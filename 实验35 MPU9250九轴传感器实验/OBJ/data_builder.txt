; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\data_builder.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\data_builder.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\data_builder.crf ..\DMP\mllite\data_builder.c]
                          THUMB

                          AREA ||i.inv_accel_was_turned_off||, CODE, READONLY, ALIGN=2

                  inv_accel_was_turned_off PROC
;;;793    */
;;;794    void inv_accel_was_turned_off()
000000  2100              MOVS     r1,#0
;;;795    {
;;;796        sensors.accel.status = 0;
000002  4801              LDR      r0,|L1.8|
000004  6741              STR      r1,[r0,#0x74]
;;;797    }
000006  4770              BX       lr
;;;798    
                          ENDP

                  |L1.8|
                          DCD      sensors

                          AREA ||i.inv_apply_calibration||, CODE, READONLY, ALIGN=1

                  inv_apply_calibration PROC
;;;430    */
;;;431    void inv_apply_calibration(struct inv_single_sensor_t *sensor, const long *bias)
000000  b53e              PUSH     {r1-r5,lr}
;;;432    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;433        long raw32[3];
;;;434    
;;;435        // Convert raw to calibrated
;;;436        raw32[0] = (long)sensor->raw[0] << 15;
000006  f9b40004          LDRSH    r0,[r4,#4]
00000a  03c0              LSLS     r0,r0,#15
00000c  9000              STR      r0,[sp,#0]
;;;437        raw32[1] = (long)sensor->raw[1] << 15;
00000e  f9b40006          LDRSH    r0,[r4,#6]
000012  03c0              LSLS     r0,r0,#15
000014  9001              STR      r0,[sp,#4]
;;;438        raw32[2] = (long)sensor->raw[2] << 15;
000016  f9b40008          LDRSH    r0,[r4,#8]
00001a  03c0              LSLS     r0,r0,#15
00001c  9002              STR      r0,[sp,#8]
;;;439    
;;;440        inv_convert_to_body_with_scale(sensor->orientation, sensor->sensitivity << 1, raw32, sensor->raw_scaled);
00001e  6a62              LDR      r2,[r4,#0x24]
000020  0051              LSLS     r1,r2,#1
000022  8822              LDRH     r2,[r4,#0]
000024  b290              UXTH     r0,r2
000026  f104030c          ADD      r3,r4,#0xc
00002a  466a              MOV      r2,sp
00002c  f7fffffe          BL       inv_convert_to_body_with_scale
;;;441    
;;;442        raw32[0] -= bias[0] >> 1;
000030  9800              LDR      r0,[sp,#0]
000032  6829              LDR      r1,[r5,#0]
000034  eba00061          SUB      r0,r0,r1,ASR #1
000038  9000              STR      r0,[sp,#0]
;;;443        raw32[1] -= bias[1] >> 1;
00003a  9801              LDR      r0,[sp,#4]
00003c  6869              LDR      r1,[r5,#4]
00003e  eba00061          SUB      r0,r0,r1,ASR #1
000042  9001              STR      r0,[sp,#4]
;;;444        raw32[2] -= bias[2] >> 1;
000044  9802              LDR      r0,[sp,#8]
000046  68a9              LDR      r1,[r5,#8]
000048  eba00061          SUB      r0,r0,r1,ASR #1
00004c  9002              STR      r0,[sp,#8]
;;;445    
;;;446        inv_convert_to_body_with_scale(sensor->orientation, sensor->sensitivity << 1, raw32, sensor->calibrated);
00004e  6a62              LDR      r2,[r4,#0x24]
000050  0051              LSLS     r1,r2,#1
000052  8822              LDRH     r2,[r4,#0]
000054  b290              UXTH     r0,r2
000056  f1040318          ADD      r3,r4,#0x18
00005a  466a              MOV      r2,sp
00005c  f7fffffe          BL       inv_convert_to_body_with_scale
;;;447    
;;;448        sensor->status |= INV_CALIBRATED;
000060  6b20              LDR      r0,[r4,#0x30]
000062  f0400020          ORR      r0,r0,#0x20
000066  6320              STR      r0,[r4,#0x30]
;;;449    }
000068  bd3e              POP      {r1-r5,pc}
;;;450    
                          ENDP


                          AREA ||i.inv_build_accel||, CODE, READONLY, ALIGN=2

                  inv_build_accel PROC
;;;631     */
;;;632    inv_error_t inv_build_accel(const long *accel, int status, inv_time_t timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;633    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;634    #ifdef INV_PLAYBACK_DBG
;;;635        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;636            int type = PLAYBACK_DBG_TYPE_ACCEL;
;;;637            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;638            fwrite(accel, sizeof(accel[0]), 3, inv_data_builder.file);
;;;639            fwrite(&timestamp, sizeof(timestamp), 1, inv_data_builder.file);
;;;640        }
;;;641    #endif
;;;642    
;;;643        if ((status & INV_CALIBRATED) == 0) {
000008  f0050020          AND      r0,r5,#0x20
00000c  b9c0              CBNZ     r0,|L3.64|
;;;644            sensors.accel.raw[0] = (short)accel[0];
00000e  8820              LDRH     r0,[r4,#0]
000010  b201              SXTH     r1,r0
000012  481b              LDR      r0,|L3.128|
000014  f8a01048          STRH     r1,[r0,#0x48]
;;;645            sensors.accel.raw[1] = (short)accel[1];
000018  88a0              LDRH     r0,[r4,#4]
00001a  b201              SXTH     r1,r0
00001c  4818              LDR      r0,|L3.128|
00001e  f8a0104a          STRH     r1,[r0,#0x4a]
;;;646            sensors.accel.raw[2] = (short)accel[2];
000022  8920              LDRH     r0,[r4,#8]
000024  b201              SXTH     r1,r0
000026  4816              LDR      r0,|L3.128|
000028  f8a0104c          STRH     r1,[r0,#0x4c]
;;;647            sensors.accel.status |= INV_RAW_DATA;
00002c  6f40              LDR      r0,[r0,#0x74]
00002e  f0400180          ORR      r1,r0,#0x80
000032  4813              LDR      r0,|L3.128|
000034  6741              STR      r1,[r0,#0x74]
;;;648            inv_apply_calibration(&sensors.accel, inv_data_builder.save.accel_bias);
000036  4913              LDR      r1,|L3.132|
000038  3044              ADDS     r0,r0,#0x44
00003a  f7fffffe          BL       inv_apply_calibration
00003e  e013              B        |L3.104|
                  |L3.64|
;;;649        } else {
;;;650            sensors.accel.calibrated[0] = accel[0];
000040  480f              LDR      r0,|L3.128|
000042  6821              LDR      r1,[r4,#0]
000044  65c1              STR      r1,[r0,#0x5c]
;;;651            sensors.accel.calibrated[1] = accel[1];
000046  6861              LDR      r1,[r4,#4]
000048  6601              STR      r1,[r0,#0x60]
;;;652            sensors.accel.calibrated[2] = accel[2];
00004a  68a1              LDR      r1,[r4,#8]
00004c  6641              STR      r1,[r0,#0x64]
;;;653            sensors.accel.status |= INV_CALIBRATED;
00004e  6f40              LDR      r0,[r0,#0x74]
000050  f0400120          ORR      r1,r0,#0x20
000054  480a              LDR      r0,|L3.128|
000056  6741              STR      r1,[r0,#0x74]
;;;654            sensors.accel.accuracy = status & 3;
000058  f0050103          AND      r1,r5,#3
00005c  6781              STR      r1,[r0,#0x78]
;;;655            inv_data_builder.save.accel_accuracy = status & 3;
00005e  f0050103          AND      r1,r5,#3
000062  4809              LDR      r0,|L3.136|
000064  f8c01134          STR      r1,[r0,#0x134]
                  |L3.104|
;;;656        }
;;;657        sensors.accel.status |= INV_NEW_DATA | INV_SENSOR_ON;
000068  4805              LDR      r0,|L3.128|
00006a  6f40              LDR      r0,[r0,#0x74]
00006c  f44071a0          ORR      r1,r0,#0x140
000070  4803              LDR      r0,|L3.128|
000072  6741              STR      r1,[r0,#0x74]
;;;658        sensors.accel.timestamp_prev = sensors.accel.timestamp;
000074  6fc1              LDR      r1,[r0,#0x7c]
000076  f8c01080          STR      r1,[r0,#0x80]
;;;659        sensors.accel.timestamp = timestamp;
00007a  67c6              STR      r6,[r0,#0x7c]
;;;660    
;;;661        return INV_SUCCESS;
00007c  2000              MOVS     r0,#0
;;;662    }
00007e  bd70              POP      {r4-r6,pc}
;;;663    
                          ENDP

                  |L3.128|
                          DCD      sensors
                  |L3.132|
                          DCD      inv_data_builder+0x114
                  |L3.136|
                          DCD      inv_data_builder

                          AREA ||i.inv_build_compass||, CODE, READONLY, ALIGN=2

                  inv_build_compass PROC
;;;701    */
;;;702    inv_error_t inv_build_compass(const long *compass, int status,
000000  b5fe              PUSH     {r1-r7,lr}
;;;703                                  inv_time_t timestamp)
;;;704    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;705    #ifdef INV_PLAYBACK_DBG
;;;706        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;707            int type = PLAYBACK_DBG_TYPE_COMPASS;
;;;708            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;709            fwrite(compass, sizeof(compass[0]), 3, inv_data_builder.file);
;;;710            fwrite(&timestamp, sizeof(timestamp), 1, inv_data_builder.file);
;;;711        }
;;;712    #endif
;;;713    
;;;714        if ((status & INV_CALIBRATED) == 0) {
000008  f0050020          AND      r0,r5,#0x20
00000c  bb08              CBNZ     r0,|L4.82|
;;;715            long data[3];
;;;716            inv_set_compass_soft_iron_input_data(compass);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       inv_set_compass_soft_iron_input_data
;;;717            inv_get_compass_soft_iron_output_data(data);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       inv_get_compass_soft_iron_output_data
;;;718            sensors.compass.raw[0] = (short)data[0];
00001a  9800              LDR      r0,[sp,#0]
00001c  b201              SXTH     r1,r0
00001e  4822              LDR      r0,|L4.168|
000020  f8a0108c          STRH     r1,[r0,#0x8c]
;;;719            sensors.compass.raw[1] = (short)data[1];
000024  9801              LDR      r0,[sp,#4]
000026  b201              SXTH     r1,r0
000028  481f              LDR      r0,|L4.168|
00002a  f8a0108e          STRH     r1,[r0,#0x8e]
;;;720            sensors.compass.raw[2] = (short)data[2];
00002e  9802              LDR      r0,[sp,#8]
000030  b201              SXTH     r1,r0
000032  481d              LDR      r0,|L4.168|
000034  f8a01090          STRH     r1,[r0,#0x90]
;;;721            inv_apply_calibration(&sensors.compass, inv_data_builder.save.compass_bias);
000038  491c              LDR      r1,|L4.172|
00003a  3088              ADDS     r0,r0,#0x88
00003c  f7fffffe          BL       inv_apply_calibration
;;;722            sensors.compass.status |= INV_RAW_DATA;
000040  4819              LDR      r0,|L4.168|
000042  f8d000b8          LDR      r0,[r0,#0xb8]
000046  f0400180          ORR      r1,r0,#0x80
00004a  4817              LDR      r0,|L4.168|
00004c  f8c010b8          STR      r1,[r0,#0xb8]
;;;723        } else {
000050  e01a              B        |L4.136|
                  |L4.82|
;;;724            sensors.compass.calibrated[0] = compass[0];
000052  4815              LDR      r0,|L4.168|
000054  6821              LDR      r1,[r4,#0]
000056  f8c010a0          STR      r1,[r0,#0xa0]
;;;725            sensors.compass.calibrated[1] = compass[1];
00005a  6861              LDR      r1,[r4,#4]
00005c  f8c010a4          STR      r1,[r0,#0xa4]
;;;726            sensors.compass.calibrated[2] = compass[2];
000060  68a1              LDR      r1,[r4,#8]
000062  f8c010a8          STR      r1,[r0,#0xa8]
;;;727            sensors.compass.status |= INV_CALIBRATED;
000066  f8d000b8          LDR      r0,[r0,#0xb8]
00006a  f0400120          ORR      r1,r0,#0x20
00006e  480e              LDR      r0,|L4.168|
000070  f8c010b8          STR      r1,[r0,#0xb8]
;;;728            sensors.compass.accuracy = status & 3;
000074  f0050103          AND      r1,r5,#3
000078  f8c010bc          STR      r1,[r0,#0xbc]
;;;729            inv_data_builder.save.compass_accuracy = status & 3;
00007c  f0050103          AND      r1,r5,#3
000080  480a              LDR      r0,|L4.172|
000082  38f4              SUBS     r0,r0,#0xf4
000084  f8c01138          STR      r1,[r0,#0x138]
                  |L4.136|
;;;730        }
;;;731        sensors.compass.timestamp_prev = sensors.compass.timestamp;
000088  4807              LDR      r0,|L4.168|
00008a  f8d010c0          LDR      r1,[r0,#0xc0]
00008e  f8c010c4          STR      r1,[r0,#0xc4]
;;;732        sensors.compass.timestamp = timestamp;
000092  f8c060c0          STR      r6,[r0,#0xc0]
;;;733        sensors.compass.status |= INV_NEW_DATA | INV_SENSOR_ON;
000096  f8d000b8          LDR      r0,[r0,#0xb8]
00009a  f44071a0          ORR      r1,r0,#0x140
00009e  4802              LDR      r0,|L4.168|
0000a0  f8c010b8          STR      r1,[r0,#0xb8]
;;;734    
;;;735        return INV_SUCCESS;
0000a4  2000              MOVS     r0,#0
;;;736    }
0000a6  bdfe              POP      {r1-r7,pc}
;;;737    
                          ENDP

                  |L4.168|
                          DCD      sensors
                  |L4.172|
                          DCD      inv_data_builder+0xf4

                          AREA ||i.inv_build_gyro||, CODE, READONLY, ALIGN=2

                  inv_build_gyro PROC
;;;670    */
;;;671    inv_error_t inv_build_gyro(const short *gyro, inv_time_t timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;672    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;673    #ifdef INV_PLAYBACK_DBG
;;;674        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;675            int type = PLAYBACK_DBG_TYPE_GYRO;
;;;676            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;677            fwrite(gyro, sizeof(gyro[0]), 3, inv_data_builder.file);
;;;678            fwrite(&timestamp, sizeof(timestamp), 1, inv_data_builder.file);
;;;679        }
;;;680    #endif
;;;681    
;;;682        memcpy(sensors.gyro.raw, gyro, 3 * sizeof(short));
000006  480a              LDR      r0,|L5.48|
000008  6821              LDR      r1,[r4,#0]
00000a  6041              STR      r1,[r0,#4]  ; sensors
00000c  88a1              LDRH     r1,[r4,#4]
00000e  8101              STRH     r1,[r0,#8]
;;;683        sensors.gyro.status |= INV_NEW_DATA | INV_RAW_DATA | INV_SENSOR_ON;
000010  6b00              LDR      r0,[r0,#0x30]  ; sensors
000012  f44070e0          ORR      r0,r0,#0x1c0
000016  4906              LDR      r1,|L5.48|
000018  6308              STR      r0,[r1,#0x30]  ; sensors
;;;684        sensors.gyro.timestamp_prev = sensors.gyro.timestamp;
00001a  4608              MOV      r0,r1
00001c  6b80              LDR      r0,[r0,#0x38]  ; sensors
00001e  63c8              STR      r0,[r1,#0x3c]  ; sensors
;;;685        sensors.gyro.timestamp = timestamp;
000020  4608              MOV      r0,r1
000022  6385              STR      r5,[r0,#0x38]  ; sensors
;;;686        inv_apply_calibration(&sensors.gyro, inv_data_builder.save.gyro_bias);
000024  4903              LDR      r1,|L5.52|
000026  f7fffffe          BL       inv_apply_calibration
;;;687    
;;;688        return INV_SUCCESS;
00002a  2000              MOVS     r0,#0
;;;689    }
00002c  bd70              POP      {r4-r6,pc}
;;;690    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      sensors
                  |L5.52|
                          DCD      inv_data_builder+0x100

                          AREA ||i.inv_build_quat||, CODE, READONLY, ALIGN=2

                  inv_build_quat PROC
;;;771    */
;;;772    inv_error_t inv_build_quat(const long *quat, int status, inv_time_t timestamp)
000000  b5f0              PUSH     {r4-r7,lr}
;;;773    {
000002  4603              MOV      r3,r0
;;;774    #ifdef INV_PLAYBACK_DBG
;;;775        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;776            int type = PLAYBACK_DBG_TYPE_QUAT;
;;;777            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;778            fwrite(quat, sizeof(quat[0]), 4, inv_data_builder.file);
;;;779            fwrite(&timestamp, sizeof(timestamp), 1, inv_data_builder.file);
;;;780        }
;;;781    #endif
;;;782        
;;;783        memcpy(sensors.quat.raw, quat, sizeof(sensors.quat.raw));
000004  480c              LDR      r0,|L6.56|
000006  e89300f0          LDM      r3,{r4-r7}
00000a  3010              ADDS     r0,r0,#0x10
00000c  c0f0              STM      r0!,{r4-r7}
;;;784        sensors.quat.timestamp = timestamp;
00000e  f5a07090          SUB      r0,r0,#0x120
000012  f8c02124          STR      r2,[r0,#0x124]
;;;785        sensors.quat.status |= INV_NEW_DATA | INV_RAW_DATA | INV_SENSOR_ON;
000016  f8d00120          LDR      r0,[r0,#0x120]
00001a  f44074e0          ORR      r4,r0,#0x1c0
00001e  4807              LDR      r0,|L6.60|
000020  f8c04120          STR      r4,[r0,#0x120]
;;;786        sensors.quat.status |= (INV_BIAS_APPLIED & status);
000024  f8d00120          LDR      r0,[r0,#0x120]
000028  f4017400          AND      r4,r1,#0x200
00002c  4320              ORRS     r0,r0,r4
00002e  4c03              LDR      r4,|L6.60|
000030  f8c40120          STR      r0,[r4,#0x120]
;;;787    
;;;788        return INV_SUCCESS;
000034  2000              MOVS     r0,#0
;;;789    }
000036  bdf0              POP      {r4-r7,pc}
;;;790    
                          ENDP

                  |L6.56|
                          DCD      sensors+0x100
                  |L6.60|
                          DCD      sensors

                          AREA ||i.inv_build_temp||, CODE, READONLY, ALIGN=2

                  inv_build_temp PROC
;;;743     */
;;;744    inv_error_t inv_build_temp(const long temp, inv_time_t timestamp)
000000  4602              MOV      r2,r0
;;;745    {
;;;746    #ifdef INV_PLAYBACK_DBG
;;;747        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;748            int type = PLAYBACK_DBG_TYPE_TEMPERATURE;
;;;749            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;750            fwrite(&temp, sizeof(temp), 1, inv_data_builder.file);
;;;751            fwrite(&timestamp, sizeof(timestamp), 1, inv_data_builder.file);
;;;752        }
;;;753    #endif
;;;754        sensors.temp.calibrated[0] = temp;
000002  4809              LDR      r0,|L7.40|
000004  f8c020e4          STR      r2,[r0,#0xe4]
;;;755        sensors.temp.status |= INV_NEW_DATA | INV_RAW_DATA | INV_SENSOR_ON;
000008  f8d000fc          LDR      r0,[r0,#0xfc]
00000c  f44073e0          ORR      r3,r0,#0x1c0
000010  4805              LDR      r0,|L7.40|
000012  f8c030fc          STR      r3,[r0,#0xfc]
;;;756        sensors.temp.timestamp_prev = sensors.temp.timestamp;
000016  f8d03104          LDR      r3,[r0,#0x104]
00001a  f8c03108          STR      r3,[r0,#0x108]
;;;757        sensors.temp.timestamp = timestamp;
00001e  f8c01104          STR      r1,[r0,#0x104]
;;;758        /* TODO: Apply scale, remove offset. */
;;;759    
;;;760        return INV_SUCCESS;
000022  2000              MOVS     r0,#0
;;;761    }
000024  4770              BX       lr
;;;762    /** quaternion data
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      sensors

                          AREA ||i.inv_compass_was_turned_off||, CODE, READONLY, ALIGN=2

                  inv_compass_was_turned_off PROC
;;;801    */
;;;802    void inv_compass_was_turned_off()
000000  2100              MOVS     r1,#0
;;;803    {
;;;804        sensors.compass.status = 0;
000002  4802              LDR      r0,|L8.12|
000004  f8c010b8          STR      r1,[r0,#0xb8]
;;;805    }
000008  4770              BX       lr
;;;806    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      sensors

                          AREA ||i.inv_db_load_func||, CODE, READONLY, ALIGN=2

                  inv_db_load_func PROC
;;;106    /** This function receives the data that was stored in non-volatile memory between power off */
;;;107    static inv_error_t inv_db_load_func(const unsigned char *data)
000000  b510              PUSH     {r4,lr}
;;;108    {
000002  4604              MOV      r4,r0
;;;109        memcpy(&inv_data_builder.save, data, sizeof(inv_data_builder.save));
000004  2248              MOVS     r2,#0x48
000006  4621              MOV      r1,r4
000008  480f              LDR      r0,|L9.72|
00000a  f7fffffe          BL       __aeabi_memcpy
;;;110        // copy in the saved accuracy in the actual sensors accuracy
;;;111        sensors.gyro.accuracy = inv_data_builder.save.gyro_accuracy;
00000e  480e              LDR      r0,|L9.72|
000010  38f4              SUBS     r0,r0,#0xf4
000012  f8d00130          LDR      r0,[r0,#0x130]
000016  490d              LDR      r1,|L9.76|
000018  6348              STR      r0,[r1,#0x34]  ; sensors
;;;112        sensors.accel.accuracy = inv_data_builder.save.accel_accuracy;
00001a  480b              LDR      r0,|L9.72|
00001c  38f4              SUBS     r0,r0,#0xf4
00001e  f8d01134          LDR      r1,[r0,#0x134]
000022  480a              LDR      r0,|L9.76|
000024  6781              STR      r1,[r0,#0x78]
;;;113        sensors.compass.accuracy = inv_data_builder.save.compass_accuracy;
000026  4808              LDR      r0,|L9.72|
000028  38f4              SUBS     r0,r0,#0xf4
00002a  f8d01138          LDR      r1,[r0,#0x138]
00002e  4807              LDR      r0,|L9.76|
000030  f8c010bc          STR      r1,[r0,#0xbc]
;;;114        // TODO
;;;115        if (sensors.compass.accuracy == 3) {
000034  f8d000bc          LDR      r0,[r0,#0xbc]
000038  2803              CMP      r0,#3
00003a  d102              BNE      |L9.66|
;;;116            inv_set_compass_bias_found(1);
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       inv_set_compass_bias_found
                  |L9.66|
;;;117        }
;;;118        return INV_SUCCESS;
000042  2000              MOVS     r0,#0
;;;119    }
000044  bd10              POP      {r4,pc}
;;;120    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      inv_data_builder+0xf4
                  |L9.76|
                          DCD      sensors

                          AREA ||i.inv_db_save_func||, CODE, READONLY, ALIGN=2

                  inv_db_save_func PROC
;;;121    /** This function returns the data to be stored in non-volatile memory between power off */
;;;122    static inv_error_t inv_db_save_func(unsigned char *data)
000000  b510              PUSH     {r4,lr}
;;;123    {
000002  4604              MOV      r4,r0
;;;124        memcpy(data, &inv_data_builder.save, sizeof(inv_data_builder.save));
000004  2248              MOVS     r2,#0x48
000006  4903              LDR      r1,|L10.20|
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __aeabi_memcpy
;;;125        return INV_SUCCESS;
00000e  2000              MOVS     r0,#0
;;;126    }
000010  bd10              POP      {r4,pc}
;;;127    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      inv_data_builder+0xf4

                          AREA ||i.inv_disable_compass_soft_iron_matrix||, CODE, READONLY, ALIGN=2

                  inv_disable_compass_soft_iron_matrix PROC
;;;1256   */
;;;1257   void inv_disable_compass_soft_iron_matrix(void)   {
000000  2100              MOVS     r1,#0
;;;1258       sensors.soft_iron.enable = 0;
000002  4802              LDR      r0,|L11.12|
000004  f8c01190          STR      r1,[r0,#0x190]
;;;1259   }
000008  4770              BX       lr
;;;1260   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      sensors

                          AREA ||i.inv_enable_compass_soft_iron_matrix||, CODE, READONLY, ALIGN=2

                  inv_enable_compass_soft_iron_matrix PROC
;;;1250   */
;;;1251   void inv_enable_compass_soft_iron_matrix(void)   {
000000  2101              MOVS     r1,#1
;;;1252       sensors.soft_iron.enable = 1;
000002  4802              LDR      r0,|L12.12|
000004  f8c01190          STR      r1,[r0,#0x190]
;;;1253   }
000008  4770              BX       lr
;;;1254   
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      sensors

                          AREA ||i.inv_execute_on_data||, CODE, READONLY, ALIGN=2

                  inv_execute_on_data PROC
;;;924    */
;;;925    inv_error_t inv_execute_on_data(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;926    {
;;;927        inv_error_t result, first_error;
;;;928        int kk;
;;;929        int mode;
;;;930    
;;;931    #ifdef INV_PLAYBACK_DBG
;;;932        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;933            int type = PLAYBACK_DBG_TYPE_EXECUTE;
;;;934            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;935        }
;;;936    #endif
;;;937        // Determine what new data we have
;;;938        mode = 0;
000004  2400              MOVS     r4,#0
;;;939        if (sensors.gyro.status & INV_NEW_DATA)
000006  4824              LDR      r0,|L13.152|
000008  f8900030          LDRB     r0,[r0,#0x30]  ; sensors
00000c  f0000040          AND      r0,r0,#0x40
000010  b108              CBZ      r0,|L13.22|
;;;940            mode |= INV_GYRO_NEW;
000012  f0440402          ORR      r4,r4,#2
                  |L13.22|
;;;941        if (sensors.accel.status & INV_NEW_DATA)
000016  4820              LDR      r0,|L13.152|
000018  f8900074          LDRB     r0,[r0,#0x74]
00001c  f0000040          AND      r0,r0,#0x40
000020  b108              CBZ      r0,|L13.38|
;;;942            mode |= INV_ACCEL_NEW;
000022  f0440401          ORR      r4,r4,#1
                  |L13.38|
;;;943        if (sensors.compass.status & INV_NEW_DATA)
000026  481c              LDR      r0,|L13.152|
000028  f89000b8          LDRB     r0,[r0,#0xb8]
00002c  f0000040          AND      r0,r0,#0x40
000030  b108              CBZ      r0,|L13.54|
;;;944            mode |= INV_MAG_NEW;
000032  f0440404          ORR      r4,r4,#4
                  |L13.54|
;;;945        if (sensors.temp.status & INV_NEW_DATA)
000036  4818              LDR      r0,|L13.152|
000038  f89000fc          LDRB     r0,[r0,#0xfc]
00003c  f0000040          AND      r0,r0,#0x40
000040  b108              CBZ      r0,|L13.70|
;;;946            mode |= INV_TEMP_NEW;
000042  f0440408          ORR      r4,r4,#8
                  |L13.70|
;;;947        if (sensors.quat.status & INV_NEW_DATA)
000046  4814              LDR      r0,|L13.152|
000048  f8900120          LDRB     r0,[r0,#0x120]
00004c  f0000040          AND      r0,r0,#0x40
000050  b108              CBZ      r0,|L13.86|
;;;948            mode |= INV_QUAT_NEW;
000052  f0440410          ORR      r4,r4,#0x10
                  |L13.86|
;;;949    
;;;950        first_error = INV_SUCCESS;
000056  2700              MOVS     r7,#0
;;;951    
;;;952        for (kk = 0; kk < inv_data_builder.num_cb; ++kk) {
000058  2500              MOVS     r5,#0
00005a  e013              B        |L13.132|
                  |L13.92|
;;;953            if (mode & inv_data_builder.process[kk].data_required) {
00005c  eb050145          ADD      r1,r5,r5,LSL #1
000060  480e              LDR      r0,|L13.156|
000062  eb000081          ADD      r0,r0,r1,LSL #2
000066  6880              LDR      r0,[r0,#8]
000068  4020              ANDS     r0,r0,r4
00006a  b150              CBZ      r0,|L13.130|
;;;954                result = inv_data_builder.process[kk].func(&sensors);
00006c  eb050245          ADD      r2,r5,r5,LSL #1
000070  480a              LDR      r0,|L13.156|
000072  f8501022          LDR      r1,[r0,r2,LSL #2]
000076  4808              LDR      r0,|L13.152|
000078  4788              BLX      r1
00007a  4606              MOV      r6,r0
;;;955                if (result && !first_error) {
00007c  b10e              CBZ      r6,|L13.130|
00007e  b907              CBNZ     r7,|L13.130|
;;;956                    first_error = result;
000080  4637              MOV      r7,r6
                  |L13.130|
000082  1c6d              ADDS     r5,r5,#1              ;952
                  |L13.132|
000084  4805              LDR      r0,|L13.156|
000086  1f00              SUBS     r0,r0,#4              ;952
000088  6800              LDR      r0,[r0,#0]            ;952  ; inv_data_builder
00008a  42a8              CMP      r0,r5                 ;952
00008c  dce6              BGT      |L13.92|
;;;957                }
;;;958            }
;;;959        }
;;;960    
;;;961        inv_set_contiguous();
00008e  f7fffffe          BL       inv_set_contiguous
;;;962    
;;;963        return first_error;
000092  4638              MOV      r0,r7
;;;964    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;965    
                          ENDP

                  |L13.152|
                          DCD      sensors
                  |L13.156|
                          DCD      inv_data_builder+0x4

                          AREA ||i.inv_get_accel_accuracy||, CODE, READONLY, ALIGN=2

                  inv_get_accel_accuracy PROC
;;;1127   */
;;;1128   int inv_get_accel_accuracy(void)
000000  4801              LDR      r0,|L14.8|
;;;1129   {
;;;1130       return sensors.accel.accuracy;
000002  6f80              LDR      r0,[r0,#0x78]
;;;1131   }
000004  4770              BX       lr
;;;1132   
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      sensors

                          AREA ||i.inv_get_accel_bias||, CODE, READONLY, ALIGN=2

                  inv_get_accel_bias PROC
;;;606    */
;;;607    void inv_get_accel_bias(long *bias, long *temp)
000000  b510              PUSH     {r4,lr}
;;;608    {
;;;609        if (bias != NULL)
000002  b130              CBZ      r0,|L15.18|
;;;610            memcpy(bias, inv_data_builder.save.accel_bias,
000004  4a06              LDR      r2,|L15.32|
000006  e9d23408          LDRD     r3,r4,[r2,#0x20]
00000a  6a92              LDR      r2,[r2,#0x28]
00000c  e9c03400          STRD     r3,r4,[r0,#0]
000010  6082              STR      r2,[r0,#8]
                  |L15.18|
;;;611                   sizeof(inv_data_builder.save.accel_bias));
;;;612        if (temp != NULL)
000012  b121              CBZ      r1,|L15.30|
;;;613            temp[0] = inv_data_builder.save.accel_temp;
000014  4a02              LDR      r2,|L15.32|
000016  3af4              SUBS     r2,r2,#0xf4
000018  f8d22120          LDR      r2,[r2,#0x120]
00001c  600a              STR      r2,[r1,#0]
                  |L15.30|
;;;614    }
00001e  bd10              POP      {r4,pc}
;;;615    
                          ENDP

                  |L15.32|
                          DCD      inv_data_builder+0xf4

                          AREA ||i.inv_get_accel_on||, CODE, READONLY, ALIGN=2

                  inv_get_accel_on PROC
;;;340    */
;;;341    int inv_get_accel_on()
000000  4802              LDR      r0,|L16.12|
;;;342    {
;;;343        return (sensors.accel.status & INV_SENSOR_ON) == INV_SENSOR_ON;
000002  f8b00074          LDRH     r0,[r0,#0x74]
000006  f3c02000          UBFX     r0,r0,#8,#1
;;;344    }
00000a  4770              BX       lr
;;;345    
                          ENDP

                  |L16.12|
                          DCD      sensors

                          AREA ||i.inv_get_accel_orient||, CODE, READONLY, ALIGN=2

                  inv_get_accel_orient PROC
;;;1138   
;;;1139   inv_error_t inv_get_accel_orient(int *orient)
000000  4601              MOV      r1,r0
;;;1140   {
;;;1141       *orient = sensors.accel.orientation;
000002  4802              LDR      r0,|L17.12|
000004  6c40              LDR      r0,[r0,#0x44]  ; sensors
000006  6008              STR      r0,[r1,#0]
;;;1142       return 0;
000008  2000              MOVS     r0,#0
;;;1143   }
00000a  4770              BX       lr
;;;1144   
                          ENDP

                  |L17.12|
                          DCD      sensors

                          AREA ||i.inv_get_accel_sample_rate_ms||, CODE, READONLY, ALIGN=2

                  inv_get_accel_sample_rate_ms PROC
;;;271    
;;;272    void inv_get_accel_sample_rate_ms(long *sample_rate_ms)
000000  4901              LDR      r1,|L18.8|
;;;273    {
;;;274    	*sample_rate_ms = sensors.accel.sample_rate_ms;
000002  6f09              LDR      r1,[r1,#0x70]
000004  6001              STR      r1,[r0,#0]
;;;275    }
000006  4770              BX       lr
;;;276    
                          ENDP

                  |L18.8|
                          DCD      sensors

                          AREA ||i.inv_get_accel_sensitivity||, CODE, READONLY, ALIGN=2

                  inv_get_accel_sensitivity PROC
;;;158    */
;;;159    long inv_get_accel_sensitivity(void)
000000  4801              LDR      r0,|L19.8|
;;;160    {
;;;161        return sensors.accel.sensitivity;
000002  6e80              LDR      r0,[r0,#0x68]
;;;162    }
000004  4770              BX       lr
;;;163    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      sensors

                          AREA ||i.inv_get_accel_set||, CODE, READONLY, ALIGN=2

                  inv_get_accel_set PROC
;;;1020   */
;;;1021   void inv_get_accel_set(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b530              PUSH     {r4,r5,lr}
;;;1022   {
;;;1023       if (data != NULL) {
000002  b130              CBZ      r0,|L20.18|
;;;1024           memcpy(data, sensors.accel.calibrated, sizeof(sensors.accel.calibrated));
000004  4b08              LDR      r3,|L20.40|
000006  e9d34517          LDRD     r4,r5,[r3,#0x5c]
00000a  6e5b              LDR      r3,[r3,#0x64]
00000c  e9c04500          STRD     r4,r5,[r0,#0]
000010  6083              STR      r3,[r0,#8]
                  |L20.18|
;;;1025       }
;;;1026       if (timestamp != NULL) {
000012  b112              CBZ      r2,|L20.26|
;;;1027           *timestamp = sensors.accel.timestamp;
000014  4b04              LDR      r3,|L20.40|
000016  6fdb              LDR      r3,[r3,#0x7c]
000018  6013              STR      r3,[r2,#0]
                  |L20.26|
;;;1028       }
;;;1029       if (accuracy != NULL) {
00001a  b121              CBZ      r1,|L20.38|
;;;1030           *accuracy = sensors.accel.accuracy;
00001c  4b02              LDR      r3,|L20.40|
00001e  f8933078          LDRB     r3,[r3,#0x78]
000022  b25b              SXTB     r3,r3
000024  700b              STRB     r3,[r1,#0]
                  |L20.38|
;;;1031       }
;;;1032   }
000026  bd30              POP      {r4,r5,pc}
;;;1033   
                          ENDP

                  |L20.40|
                          DCD      sensors

                          AREA ||i.inv_get_compass_bias||, CODE, READONLY, ALIGN=2

                  inv_get_compass_bias PROC
;;;454    */
;;;455    void inv_get_compass_bias(long *bias)
000000  b130              CBZ      r0,|L21.16|
;;;456    {
;;;457        if (bias != NULL) {
;;;458            memcpy(bias, inv_data_builder.save.compass_bias, sizeof(inv_data_builder.save.compass_bias));
000002  4904              LDR      r1,|L21.20|
000004  e9d1231d          LDRD     r2,r3,[r1,#0x74]
000008  6fc9              LDR      r1,[r1,#0x7c]  ; inv_data_builder
00000a  e9c02300          STRD     r2,r3,[r0,#0]
00000e  6081              STR      r1,[r0,#8]
                  |L21.16|
;;;459        }
;;;460    }
000010  4770              BX       lr
;;;461    
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      inv_data_builder+0x80

                          AREA ||i.inv_get_compass_disturbance||, CODE, READONLY, ALIGN=2

                  inv_get_compass_disturbance PROC
;;;480    
;;;481    int inv_get_compass_disturbance(void) {
000000  4801              LDR      r0,|L22.8|
;;;482        return inv_data_builder.compass_disturbance;
000002  f8d0013c          LDR      r0,[r0,#0x13c]  ; inv_data_builder
;;;483    }
000006  4770              BX       lr
;;;484    /** Sets the accel bias.
                          ENDP

                  |L22.8|
                          DCD      inv_data_builder

                          AREA ||i.inv_get_compass_on||, CODE, READONLY, ALIGN=2

                  inv_get_compass_on PROC
;;;324    */
;;;325    int inv_get_compass_on()
000000  4802              LDR      r0,|L23.12|
;;;326    {
;;;327        return (sensors.compass.status & INV_SENSOR_ON) == INV_SENSOR_ON;
000002  f8b000b8          LDRH     r0,[r0,#0xb8]
000006  f3c02000          UBFX     r0,r0,#8,#1
;;;328    }
00000a  4770              BX       lr
;;;329    
                          ENDP

                  |L23.12|
                          DCD      sensors

                          AREA ||i.inv_get_compass_sample_rate_ms||, CODE, READONLY, ALIGN=2

                  inv_get_compass_sample_rate_ms PROC
;;;276    
;;;277    void inv_get_compass_sample_rate_ms(long *sample_rate_ms)
000000  4902              LDR      r1,|L24.12|
;;;278    {
;;;279    	*sample_rate_ms = sensors.compass.sample_rate_ms;
000002  f8d110b4          LDR      r1,[r1,#0xb4]
000006  6001              STR      r1,[r0,#0]
;;;280    }
000008  4770              BX       lr
;;;281    
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      sensors

                          AREA ||i.inv_get_compass_sensitivity||, CODE, READONLY, ALIGN=2

                  inv_get_compass_sensitivity PROC
;;;168    */
;;;169    long inv_get_compass_sensitivity(void)
000000  4801              LDR      r0,|L25.8|
;;;170    {
;;;171        return sensors.compass.sensitivity;
000002  f8d000ac          LDR      r0,[r0,#0xac]
;;;172    }
000006  4770              BX       lr
;;;173    
                          ENDP

                  |L25.8|
                          DCD      sensors

                          AREA ||i.inv_get_compass_set||, CODE, READONLY, ALIGN=2

                  inv_get_compass_set PROC
;;;1078   */
;;;1079   void inv_get_compass_set(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b530              PUSH     {r4,r5,lr}
;;;1080   {
;;;1081       memcpy(data, sensors.compass.calibrated, sizeof(sensors.compass.calibrated));
000002  4b0e              LDR      r3,|L26.60|
000004  e9d34506          LDRD     r4,r5,[r3,#0x18]
000008  6a1b              LDR      r3,[r3,#0x20]
00000a  e9c04500          STRD     r4,r5,[r0,#0]
00000e  6083              STR      r3,[r0,#8]
;;;1082       if (timestamp != NULL) {
000010  b122              CBZ      r2,|L26.28|
;;;1083           *timestamp = sensors.compass.timestamp;
000012  4b0a              LDR      r3,|L26.60|
000014  3b88              SUBS     r3,r3,#0x88
000016  f8d330c0          LDR      r3,[r3,#0xc0]
00001a  6013              STR      r3,[r2,#0]
                  |L26.28|
;;;1084       }
;;;1085       if (accuracy != NULL) {
00001c  b161              CBZ      r1,|L26.56|
;;;1086           if (inv_data_builder.compass_disturbance)
00001e  4b08              LDR      r3,|L26.64|
000020  f8d3313c          LDR      r3,[r3,#0x13c]  ; inv_data_builder
000024  b113              CBZ      r3,|L26.44|
;;;1087               *accuracy = 0;
000026  2300              MOVS     r3,#0
000028  700b              STRB     r3,[r1,#0]
00002a  e005              B        |L26.56|
                  |L26.44|
;;;1088           else
;;;1089               *accuracy = sensors.compass.accuracy;
00002c  4b03              LDR      r3,|L26.60|
00002e  3b88              SUBS     r3,r3,#0x88
000030  f89330bc          LDRB     r3,[r3,#0xbc]
000034  b25b              SXTB     r3,r3
000036  700b              STRB     r3,[r1,#0]
                  |L26.56|
;;;1090       }
;;;1091   }
000038  bd30              POP      {r4,r5,pc}
;;;1092   
                          ENDP

00003a  0000              DCW      0x0000
                  |L26.60|
                          DCD      sensors+0x88
                  |L26.64|
                          DCD      inv_data_builder

                          AREA ||i.inv_get_compass_soft_iron_input_data||, CODE, READONLY, ALIGN=2

                  inv_get_compass_soft_iron_input_data PROC
;;;1204   */
;;;1205   void inv_get_compass_soft_iron_input_data(long *data)  {
000000  4601              MOV      r1,r0
;;;1206       int i;
;;;1207       for (i=0; i<3; i++)  {
000002  2000              MOVS     r0,#0
000004  e005              B        |L27.18|
                  |L27.6|
;;;1208           data[i] = sensors.soft_iron.raw[i];
000006  4a04              LDR      r2,|L27.24|
000008  f8522020          LDR      r2,[r2,r0,LSL #2]
00000c  f8412020          STR      r2,[r1,r0,LSL #2]
000010  1c40              ADDS     r0,r0,#1              ;1207
                  |L27.18|
000012  2803              CMP      r0,#3                 ;1207
000014  dbf7              BLT      |L27.6|
;;;1209       }
;;;1210   }
000016  4770              BX       lr
;;;1211   /** This subroutine sets the compass raw data for the soft iron transformation.
                          ENDP

                  |L27.24|
                          DCD      sensors+0x130

                          AREA ||i.inv_get_compass_soft_iron_matrix_d||, CODE, READONLY, ALIGN=2

                  inv_get_compass_soft_iron_matrix_d PROC
;;;1151   */
;;;1152   void inv_get_compass_soft_iron_matrix_d(long *matrix) {
000000  4601              MOV      r1,r0
;;;1153       int i;
;;;1154       for (i=0; i<9; i++)  {
000002  2000              MOVS     r0,#0
000004  e005              B        |L28.18|
                  |L28.6|
;;;1155           matrix[i] = sensors.soft_iron.matrix_d[i];
000006  4a04              LDR      r2,|L28.24|
000008  f8522020          LDR      r2,[r2,r0,LSL #2]
00000c  f8412020          STR      r2,[r1,r0,LSL #2]
000010  1c40              ADDS     r0,r0,#1              ;1154
                  |L28.18|
000012  2809              CMP      r0,#9                 ;1154
000014  dbf7              BLT      |L28.6|
;;;1156       }
;;;1157   }
000016  4770              BX       lr
;;;1158   
                          ENDP

                  |L28.24|
                          DCD      sensors+0x148

                          AREA ||i.inv_get_compass_soft_iron_matrix_f||, CODE, READONLY, ALIGN=2

                  inv_get_compass_soft_iron_matrix_f PROC
;;;1173   */
;;;1174   void inv_get_compass_soft_iron_matrix_f(float *matrix)  {
000000  4601              MOV      r1,r0
;;;1175       int i;
;;;1176       for (i=0; i<9; i++)  {
000002  2000              MOVS     r0,#0
000004  e009              B        |L29.26|
                  |L29.6|
;;;1177           matrix[i] = sensors.soft_iron.matrix_f[i];
000006  4a06              LDR      r2,|L29.32|
000008  eb020280          ADD      r2,r2,r0,LSL #2
00000c  ed920a00          VLDR     s0,[r2,#0]
000010  eb010280          ADD      r2,r1,r0,LSL #2
000014  ed820a00          VSTR     s0,[r2,#0]
000018  1c40              ADDS     r0,r0,#1              ;1176
                  |L29.26|
00001a  2809              CMP      r0,#9                 ;1176
00001c  dbf3              BLT      |L29.6|
;;;1178       }
;;;1179   }
00001e  4770              BX       lr
;;;1180   /** Sets the 3x3 compass transform matrix in 32 bit floating point format.
                          ENDP

                  |L29.32|
                          DCD      sensors+0x16c

                          AREA ||i.inv_get_compass_soft_iron_output_data||, CODE, READONLY, ALIGN=2

                  inv_get_compass_soft_iron_output_data PROC
;;;1195   */
;;;1196   void inv_get_compass_soft_iron_output_data(long *data) {
000000  4601              MOV      r1,r0
;;;1197       int i;
;;;1198       for (i=0; i<3; i++)  {
000002  2000              MOVS     r0,#0
000004  e005              B        |L30.18|
                  |L30.6|
;;;1199           data[i] = sensors.soft_iron.trans[i];
000006  4a04              LDR      r2,|L30.24|
000008  f8522020          LDR      r2,[r2,r0,LSL #2]
00000c  f8412020          STR      r2,[r1,r0,LSL #2]
000010  1c40              ADDS     r0,r0,#1              ;1198
                  |L30.18|
000012  2803              CMP      r0,#3                 ;1198
000014  dbf7              BLT      |L30.6|
;;;1200       }
;;;1201   }
000016  4770              BX       lr
;;;1202   /** This subroutine gets the fixed point Q30 compass data before the soft iron transformation.
                          ENDP

                  |L30.24|
                          DCD      sensors+0x13c

                          AREA ||i.inv_get_gyro||, CODE, READONLY, ALIGN=2

                  inv_get_gyro PROC
;;;1068   */
;;;1069   void inv_get_gyro(long *gyro)
000000  4b02              LDR      r3,|L31.12|
;;;1070   {
;;;1071       memcpy(gyro, sensors.gyro.calibrated, sizeof(sensors.gyro.calibrated));
000002  3318              ADDS     r3,r3,#0x18
000004  cb0e              LDM      r3,{r1-r3}
000006  e880000e          STM      r0,{r1-r3}
;;;1072   }
00000a  4770              BX       lr
;;;1073   
                          ENDP

                  |L31.12|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_accuracy||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_accuracy PROC
;;;1109   */
;;;1110   int inv_get_gyro_accuracy(void)
000000  4801              LDR      r0,|L32.8|
;;;1111   {
;;;1112       return sensors.gyro.accuracy;
000002  6b40              LDR      r0,[r0,#0x34]  ; sensors
;;;1113   }
000004  4770              BX       lr
;;;1114   
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_bias||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_bias PROC
;;;593     */
;;;594    void inv_get_gyro_bias(long *bias, long *temp)
000000  b510              PUSH     {r4,lr}
;;;595    {
;;;596        if (bias != NULL)
000002  b130              CBZ      r0,|L33.18|
;;;597            memcpy(bias, inv_data_builder.save.gyro_bias,
000004  4a06              LDR      r2,|L33.32|
000006  e9d23403          LDRD     r3,r4,[r2,#0xc]
00000a  6952              LDR      r2,[r2,#0x14]
00000c  e9c03400          STRD     r3,r4,[r0,#0]
000010  6082              STR      r2,[r0,#8]
                  |L33.18|
;;;598                   sizeof(inv_data_builder.save.gyro_bias));
;;;599        if (temp != NULL)
000012  b121              CBZ      r1,|L33.30|
;;;600            temp[0] = inv_data_builder.save.gyro_temp;
000014  4a02              LDR      r2,|L33.32|
000016  3af4              SUBS     r2,r2,#0xf4
000018  f8d2210c          LDR      r2,[r2,#0x10c]
00001c  600a              STR      r2,[r1,#0]
                  |L33.30|
;;;601    }
00001e  bd10              POP      {r4,pc}
;;;602    
                          ENDP

                  |L33.32|
                          DCD      inv_data_builder+0xf4

                          AREA ||i.inv_get_gyro_bias_tc_set||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_bias_tc_set PROC
;;;576     */
;;;577    int inv_get_gyro_bias_tc_set(void)
000000  4906              LDR      r1,|L34.28|
;;;578    {
;;;579        int flag = (inv_data_builder.save.gyro_bias_tc_set == true);
000002  f8d11110          LDR      r1,[r1,#0x110]
000006  2901              CMP      r1,#1
000008  d100              BNE      |L34.12|
00000a  e000              B        |L34.14|
                  |L34.12|
00000c  2100              MOVS     r1,#0
                  |L34.14|
00000e  4608              MOV      r0,r1
;;;580        inv_data_builder.save.gyro_bias_tc_set = false;
000010  2200              MOVS     r2,#0
000012  4902              LDR      r1,|L34.28|
000014  f8c12110          STR      r2,[r1,#0x110]
;;;581        return flag;
;;;582    }
000018  4770              BX       lr
;;;583    
                          ENDP

00001a  0000              DCW      0x0000
                  |L34.28|
                          DCD      inv_data_builder

                          AREA ||i.inv_get_gyro_on||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_on PROC
;;;332    */
;;;333    int inv_get_gyro_on()
000000  4802              LDR      r0,|L35.12|
;;;334    {
;;;335        return (sensors.gyro.status & INV_SENSOR_ON) == INV_SENSOR_ON;
000002  8e00              LDRH     r0,[r0,#0x30]  ; sensors
000004  f3c02000          UBFX     r0,r0,#8,#1
;;;336    }
000008  4770              BX       lr
;;;337    
                          ENDP

00000a  0000              DCW      0x0000
                  |L35.12|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_orient||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_orient PROC
;;;1132   
;;;1133   inv_error_t inv_get_gyro_orient(int *orient)
000000  4601              MOV      r1,r0
;;;1134   {
;;;1135       *orient = sensors.gyro.orientation;
000002  4802              LDR      r0,|L36.12|
000004  6800              LDR      r0,[r0,#0]  ; sensors
000006  6008              STR      r0,[r1,#0]
;;;1136       return 0;
000008  2000              MOVS     r0,#0
;;;1137   }
00000a  4770              BX       lr
;;;1138   
                          ENDP

                  |L36.12|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_sample_rate_ms||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_sample_rate_ms PROC
;;;266    
;;;267    void inv_get_gyro_sample_rate_ms(long *sample_rate_ms)
000000  4901              LDR      r1,|L37.8|
;;;268    {
;;;269    	*sample_rate_ms = sensors.gyro.sample_rate_ms;
000002  6ac9              LDR      r1,[r1,#0x2c]  ; sensors
000004  6001              STR      r1,[r0,#0]
;;;270    }
000006  4770              BX       lr
;;;271    
                          ENDP

                  |L37.8|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_sensitivity||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_sensitivity PROC
;;;148    */
;;;149    long inv_get_gyro_sensitivity()
000000  4801              LDR      r0,|L38.8|
;;;150    {
;;;151        return sensors.gyro.sensitivity;
000002  6a40              LDR      r0,[r0,#0x24]  ; sensors
;;;152    }
000004  4770              BX       lr
;;;153    
                          ENDP

000006  0000              DCW      0x0000
                  |L38.8|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_set||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_set PROC
;;;1038   */
;;;1039   void inv_get_gyro_set(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b530              PUSH     {r4,r5,lr}
;;;1040   {
;;;1041       memcpy(data, sensors.gyro.calibrated, sizeof(sensors.gyro.calibrated));
000002  4d08              LDR      r5,|L39.36|
000004  3518              ADDS     r5,r5,#0x18
000006  cd38              LDM      r5,{r3-r5}
000008  e8800038          STM      r0,{r3-r5}
;;;1042       if (timestamp != NULL) {
00000c  b112              CBZ      r2,|L39.20|
;;;1043           *timestamp = sensors.gyro.timestamp;
00000e  4b05              LDR      r3,|L39.36|
000010  6b9b              LDR      r3,[r3,#0x38]  ; sensors
000012  6013              STR      r3,[r2,#0]
                  |L39.20|
;;;1044       }
;;;1045       if (accuracy != NULL) {
000014  b121              CBZ      r1,|L39.32|
;;;1046           *accuracy = sensors.gyro.accuracy;
000016  4b03              LDR      r3,|L39.36|
000018  f8933034          LDRB     r3,[r3,#0x34]  ; sensors
00001c  b25b              SXTB     r3,r3
00001e  700b              STRB     r3,[r1,#0]
                  |L39.32|
;;;1047       }
;;;1048   }
000020  bd30              POP      {r4,r5,pc}
;;;1049   
                          ENDP

000022  0000              DCW      0x0000
                  |L39.36|
                          DCD      sensors

                          AREA ||i.inv_get_gyro_set_raw||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_set_raw PROC
;;;1054   */
;;;1055   void inv_get_gyro_set_raw(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b530              PUSH     {r4,r5,lr}
;;;1056   {
;;;1057       memcpy(data, sensors.gyro.raw_scaled, sizeof(sensors.gyro.raw_scaled));
000002  4d08              LDR      r5,|L40.36|
000004  350c              ADDS     r5,r5,#0xc
000006  cd38              LDM      r5,{r3-r5}
000008  e8800038          STM      r0,{r3-r5}
;;;1058       if (timestamp != NULL) {
00000c  b112              CBZ      r2,|L40.20|
;;;1059           *timestamp = sensors.gyro.timestamp;
00000e  4b05              LDR      r3,|L40.36|
000010  6b9b              LDR      r3,[r3,#0x38]  ; sensors
000012  6013              STR      r3,[r2,#0]
                  |L40.20|
;;;1060       }
;;;1061       if (accuracy != NULL) {
000014  b121              CBZ      r1,|L40.32|
;;;1062           *accuracy = sensors.gyro.accuracy;
000016  4b03              LDR      r3,|L40.36|
000018  f8933034          LDRB     r3,[r3,#0x34]  ; sensors
00001c  b25b              SXTB     r3,r3
00001e  700b              STRB     r3,[r1,#0]
                  |L40.32|
;;;1063       }
;;;1064   }
000020  bd30              POP      {r4,r5,pc}
;;;1065   
                          ENDP

000022  0000              DCW      0x0000
                  |L40.36|
                          DCD      sensors

                          AREA ||i.inv_get_last_timestamp||, CODE, READONLY, ALIGN=2

                  inv_get_last_timestamp PROC
;;;349    */
;;;350    inv_time_t inv_get_last_timestamp()
000000  2000              MOVS     r0,#0
;;;351    {
;;;352        inv_time_t timestamp = 0;
;;;353        if (sensors.accel.status & INV_SENSOR_ON) {
000002  4918              LDR      r1,|L41.100|
000004  f8b11074          LDRH     r1,[r1,#0x74]
000008  f4017180          AND      r1,r1,#0x100
00000c  b109              CBZ      r1,|L41.18|
;;;354            timestamp = sensors.accel.timestamp;
00000e  4915              LDR      r1,|L41.100|
000010  6fc8              LDR      r0,[r1,#0x7c]
                  |L41.18|
;;;355        }
;;;356        if (sensors.gyro.status & INV_SENSOR_ON) {
000012  4914              LDR      r1,|L41.100|
000014  8e09              LDRH     r1,[r1,#0x30]  ; sensors
000016  f4017180          AND      r1,r1,#0x100
00001a  b129              CBZ      r1,|L41.40|
;;;357            if (timestamp < sensors.gyro.timestamp) {
00001c  4911              LDR      r1,|L41.100|
00001e  6b89              LDR      r1,[r1,#0x38]  ; sensors
000020  4281              CMP      r1,r0
000022  d901              BLS      |L41.40|
;;;358                timestamp = sensors.gyro.timestamp;
000024  490f              LDR      r1,|L41.100|
000026  6b88              LDR      r0,[r1,#0x38]  ; sensors
                  |L41.40|
;;;359            }
;;;360        }
;;;361        if (sensors.compass.status & INV_SENSOR_ON) {
000028  490e              LDR      r1,|L41.100|
00002a  f8b110b8          LDRH     r1,[r1,#0xb8]
00002e  f4017180          AND      r1,r1,#0x100
000032  b139              CBZ      r1,|L41.68|
;;;362            if (timestamp < sensors.compass.timestamp) {
000034  490b              LDR      r1,|L41.100|
000036  f8d110c0          LDR      r1,[r1,#0xc0]
00003a  4281              CMP      r1,r0
00003c  d902              BLS      |L41.68|
;;;363                timestamp = sensors.compass.timestamp;
00003e  4909              LDR      r1,|L41.100|
000040  f8d100c0          LDR      r0,[r1,#0xc0]
                  |L41.68|
;;;364            }
;;;365        }
;;;366        if (sensors.temp.status & INV_SENSOR_ON) {
000044  4907              LDR      r1,|L41.100|
000046  f8b110fc          LDRH     r1,[r1,#0xfc]
00004a  f4017180          AND      r1,r1,#0x100
00004e  b139              CBZ      r1,|L41.96|
;;;367            if (timestamp < sensors.temp.timestamp)
000050  4904              LDR      r1,|L41.100|
000052  f8d11104          LDR      r1,[r1,#0x104]
000056  4281              CMP      r1,r0
000058  d902              BLS      |L41.96|
;;;368                timestamp = sensors.temp.timestamp;
00005a  4902              LDR      r1,|L41.100|
00005c  f8d10104          LDR      r0,[r1,#0x104]
                  |L41.96|
;;;369        }
;;;370        return timestamp;
;;;371    }
000060  4770              BX       lr
;;;372    
                          ENDP

000062  0000              DCW      0x0000
                  |L41.100|
                          DCD      sensors

                          AREA ||i.inv_get_mag_accuracy||, CODE, READONLY, ALIGN=2

                  inv_get_mag_accuracy PROC
;;;1117   */
;;;1118   int inv_get_mag_accuracy(void)
000000  4804              LDR      r0,|L42.20|
;;;1119   {
;;;1120       if (inv_data_builder.compass_disturbance)
000002  f8d0013c          LDR      r0,[r0,#0x13c]  ; inv_data_builder
000006  b108              CBZ      r0,|L42.12|
;;;1121           return 0;
000008  2000              MOVS     r0,#0
                  |L42.10|
;;;1122       return sensors.compass.accuracy;
;;;1123   }
00000a  4770              BX       lr
                  |L42.12|
00000c  4802              LDR      r0,|L42.24|
00000e  f8d000bc          LDR      r0,[r0,#0xbc]         ;1122
000012  e7fa              B        |L42.10|
;;;1124   
                          ENDP

                  |L42.20|
                          DCD      inv_data_builder
                  |L42.24|
                          DCD      sensors

                          AREA ||i.inv_get_temp_set||, CODE, READONLY, ALIGN=2

                  inv_get_temp_set PROC
;;;1097    */
;;;1098   void inv_get_temp_set(long *data, int *accuracy, inv_time_t *timestamp)
000000  4b07              LDR      r3,|L43.32|
;;;1099   {
;;;1100       data[0] = sensors.temp.calibrated[0];
000002  f8d330e4          LDR      r3,[r3,#0xe4]
000006  6003              STR      r3,[r0,#0]
;;;1101       if (timestamp)
000008  b11a              CBZ      r2,|L43.18|
;;;1102           *timestamp = sensors.temp.timestamp;
00000a  4b05              LDR      r3,|L43.32|
00000c  f8d33104          LDR      r3,[r3,#0x104]
000010  6013              STR      r3,[r2,#0]
                  |L43.18|
;;;1103       if (accuracy)
000012  b119              CBZ      r1,|L43.28|
;;;1104           *accuracy = sensors.temp.accuracy;
000014  4b02              LDR      r3,|L43.32|
000016  f8d33100          LDR      r3,[r3,#0x100]
00001a  600b              STR      r3,[r1,#0]
                  |L43.28|
;;;1105   }
00001c  4770              BX       lr
;;;1106   
                          ENDP

00001e  0000              DCW      0x0000
                  |L43.32|
                          DCD      sensors

                          AREA ||i.inv_gyro_was_turned_off||, CODE, READONLY, ALIGN=2

                  inv_gyro_was_turned_off PROC
;;;817    */
;;;818    void inv_gyro_was_turned_off()
000000  2000              MOVS     r0,#0
;;;819    {
;;;820        sensors.gyro.status = 0;
000002  4901              LDR      r1,|L44.8|
000004  6308              STR      r0,[r1,#0x30]  ; sensors
;;;821    }
000006  4770              BX       lr
;;;822    
                          ENDP

                  |L44.8|
                          DCD      sensors

                          AREA ||i.inv_init_data_builder||, CODE, READONLY, ALIGN=2

                  inv_init_data_builder PROC
;;;129    */
;;;130    inv_error_t inv_init_data_builder(void)
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132        /* TODO: Hardcode temperature scale/offset here. */
;;;133        memset(&inv_data_builder, 0, sizeof(inv_data_builder));
000002  f44f71a0          MOV      r1,#0x140
000006  4809              LDR      r0,|L45.44|
000008  f7fffffe          BL       __aeabi_memclr4
;;;134        memset(&sensors, 0, sizeof(sensors));
00000c  f44f71cc          MOV      r1,#0x198
000010  4807              LDR      r0,|L45.48|
000012  f7fffffe          BL       __aeabi_memclr4
;;;135    
;;;136        // disable the soft iron transform process
;;;137        inv_reset_compass_soft_iron_matrix();
000016  f7fffffe          BL       inv_reset_compass_soft_iron_matrix
;;;138    
;;;139        return inv_register_load_store(inv_db_load_func, inv_db_save_func,
00001a  f24d0393          MOV      r3,#0xd093
00001e  2248              MOVS     r2,#0x48
000020  4904              LDR      r1,|L45.52|
000022  4805              LDR      r0,|L45.56|
000024  f7fffffe          BL       inv_register_load_store
;;;140                                       sizeof(inv_data_builder.save),
;;;141                                       INV_DB_SAVE_KEY);
;;;142    }
000028  bd10              POP      {r4,pc}
;;;143    
                          ENDP

00002a  0000              DCW      0x0000
                  |L45.44|
                          DCD      inv_data_builder
                  |L45.48|
                          DCD      sensors
                  |L45.52|
                          DCD      inv_db_save_func
                  |L45.56|
                          DCD      inv_db_load_func

                          AREA ||i.inv_matrix_vector_mult||, CODE, READONLY, ALIGN=1

                  inv_matrix_vector_mult PROC
;;;417    
;;;418    void inv_matrix_vector_mult(const long *A, const long *x, long *y)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;419    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;420        y[0] = inv_q30_mult(A[0], x[0]) + inv_q30_mult(A[1], x[1]) + inv_q30_mult(A[2], x[2]);
00000a  6829              LDR      r1,[r5,#0]
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       inv_q30_mult
000012  4607              MOV      r7,r0
000014  6869              LDR      r1,[r5,#4]
000016  6860              LDR      r0,[r4,#4]
000018  f7fffffe          BL       inv_q30_mult
00001c  4407              ADD      r7,r7,r0
00001e  68a9              LDR      r1,[r5,#8]
000020  68a0              LDR      r0,[r4,#8]
000022  f7fffffe          BL       inv_q30_mult
000026  4438              ADD      r0,r0,r7
000028  6030              STR      r0,[r6,#0]
;;;421        y[1] = inv_q30_mult(A[3], x[0]) + inv_q30_mult(A[4], x[1]) + inv_q30_mult(A[5], x[2]);
00002a  6829              LDR      r1,[r5,#0]
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  f7fffffe          BL       inv_q30_mult
000032  4607              MOV      r7,r0
000034  6869              LDR      r1,[r5,#4]
000036  6920              LDR      r0,[r4,#0x10]
000038  f7fffffe          BL       inv_q30_mult
00003c  4407              ADD      r7,r7,r0
00003e  68a9              LDR      r1,[r5,#8]
000040  6960              LDR      r0,[r4,#0x14]
000042  f7fffffe          BL       inv_q30_mult
000046  4438              ADD      r0,r0,r7
000048  6070              STR      r0,[r6,#4]
;;;422        y[2] = inv_q30_mult(A[6], x[0]) + inv_q30_mult(A[7], x[1]) + inv_q30_mult(A[8], x[2]);
00004a  6829              LDR      r1,[r5,#0]
00004c  69a0              LDR      r0,[r4,#0x18]
00004e  f7fffffe          BL       inv_q30_mult
000052  4607              MOV      r7,r0
000054  6869              LDR      r1,[r5,#4]
000056  69e0              LDR      r0,[r4,#0x1c]
000058  f7fffffe          BL       inv_q30_mult
00005c  4407              ADD      r7,r7,r0
00005e  68a9              LDR      r1,[r5,#8]
000060  6a20              LDR      r0,[r4,#0x20]
000062  f7fffffe          BL       inv_q30_mult
000066  4438              ADD      r0,r0,r7
000068  60b0              STR      r0,[r6,#8]
;;;423    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;424    
                          ENDP


                          AREA ||i.inv_quaternion_sensor_was_turned_off||, CODE, READONLY, ALIGN=2

                  inv_quaternion_sensor_was_turned_off PROC
;;;809    */
;;;810    void inv_quaternion_sensor_was_turned_off(void)
000000  2100              MOVS     r1,#0
;;;811    {
;;;812        sensors.quat.status = 0;
000002  4802              LDR      r0,|L47.12|
000004  f8c01120          STR      r1,[r0,#0x120]
;;;813    }
000008  4770              BX       lr
;;;814    
                          ENDP

00000a  0000              DCW      0x0000
                  |L47.12|
                          DCD      sensors

                          AREA ||i.inv_register_data_cb||, CODE, READONLY, ALIGN=2

                  inv_register_data_cb PROC
;;;841    */
;;;842    inv_error_t inv_register_data_cb(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;843        inv_error_t (*func)(struct inv_sensor_cal_t *data),
;;;844        int priority, int sensor_type)
;;;845    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;846        inv_error_t result = INV_SUCCESS;
00000a  f04f0900          MOV      r9,#0
;;;847        int kk, nn;
;;;848    
;;;849        // Make sure we haven't registered this function already
;;;850        // Or used the same priority
;;;851        for (kk = 0; kk < inv_data_builder.num_cb; ++kk) {
00000e  2400              MOVS     r4,#0
000010  e012              B        |L48.56|
                  |L48.18|
;;;852            if ((inv_data_builder.process[kk].func == func) ||
000012  eb040144          ADD      r1,r4,r4,LSL #1
000016  4835              LDR      r0,|L48.236|
000018  f8500021          LDR      r0,[r0,r1,LSL #2]
00001c  42b8              CMP      r0,r7
00001e  d007              BEQ      |L48.48|
;;;853                    (inv_data_builder.process[kk].priority == priority)) {
000020  eb040144          ADD      r1,r4,r4,LSL #1
000024  4831              LDR      r0,|L48.236|
000026  eb000081          ADD      r0,r0,r1,LSL #2
00002a  6840              LDR      r0,[r0,#4]
00002c  42b0              CMP      r0,r6
00002e  d102              BNE      |L48.54|
                  |L48.48|
;;;854                return INV_ERROR_INVALID_PARAMETER;    //fixme give a warning
000030  2005              MOVS     r0,#5
                  |L48.50|
;;;855            }
;;;856        }
;;;857    
;;;858        // Make sure we have not filled up our number of allowable callbacks
;;;859        if (inv_data_builder.num_cb <= INV_MAX_DATA_CB - 1) {
;;;860            kk = 0;
;;;861            if (inv_data_builder.num_cb != 0) {
;;;862                // set kk to be where this new callback goes in the array
;;;863                while ((kk < inv_data_builder.num_cb) &&
;;;864                        (inv_data_builder.process[kk].priority < priority)) {
;;;865                    kk++;
;;;866                }
;;;867                if (kk != inv_data_builder.num_cb) {
;;;868                    // We need to move the others
;;;869                    for (nn = inv_data_builder.num_cb; nn > kk; --nn) {
;;;870                        inv_data_builder.process[nn] =
;;;871                            inv_data_builder.process[nn - 1];
;;;872                    }
;;;873                }
;;;874            }
;;;875            // Add new callback
;;;876            inv_data_builder.process[kk].func = func;
;;;877            inv_data_builder.process[kk].priority = priority;
;;;878            inv_data_builder.process[kk].data_required = sensor_type;
;;;879            inv_data_builder.num_cb++;
;;;880        } else {
;;;881            MPL_LOGE("Unable to add feature callback as too many were already registered\n");
;;;882            result = INV_ERROR_MEMORY_EXAUSTED;
;;;883        }
;;;884    
;;;885        return result;
;;;886    }
000032  e8bd87f0          POP      {r4-r10,pc}
                  |L48.54|
000036  1c64              ADDS     r4,r4,#1              ;851
                  |L48.56|
000038  482c              LDR      r0,|L48.236|
00003a  1f00              SUBS     r0,r0,#4              ;851
00003c  6800              LDR      r0,[r0,#0]            ;851  ; inv_data_builder
00003e  42a0              CMP      r0,r4                 ;851
000040  dce7              BGT      |L48.18|
000042  482a              LDR      r0,|L48.236|
000044  1f00              SUBS     r0,r0,#4              ;859
000046  6800              LDR      r0,[r0,#0]            ;859  ; inv_data_builder
000048  2813              CMP      r0,#0x13              ;859
00004a  dc45              BGT      |L48.216|
00004c  2400              MOVS     r4,#0                 ;860
00004e  4827              LDR      r0,|L48.236|
000050  1f00              SUBS     r0,r0,#4              ;861
000052  6800              LDR      r0,[r0,#0]            ;861  ; inv_data_builder
000054  b338              CBZ      r0,|L48.166|
000056  e000              B        |L48.90|
                  |L48.88|
000058  1c64              ADDS     r4,r4,#1              ;865
                  |L48.90|
00005a  4824              LDR      r0,|L48.236|
00005c  1f00              SUBS     r0,r0,#4              ;863
00005e  6800              LDR      r0,[r0,#0]            ;863  ; inv_data_builder
000060  42a0              CMP      r0,r4                 ;863
000062  dd07              BLE      |L48.116|
000064  eb040144          ADD      r1,r4,r4,LSL #1       ;864
000068  4820              LDR      r0,|L48.236|
00006a  eb000081          ADD      r0,r0,r1,LSL #2       ;864
00006e  6840              LDR      r0,[r0,#4]            ;864
000070  42b0              CMP      r0,r6                 ;864
000072  dbf1              BLT      |L48.88|
                  |L48.116|
000074  481d              LDR      r0,|L48.236|
000076  1f00              SUBS     r0,r0,#4              ;867
000078  6800              LDR      r0,[r0,#0]            ;867  ; inv_data_builder
00007a  42a0              CMP      r0,r4                 ;867
00007c  d013              BEQ      |L48.166|
00007e  481b              LDR      r0,|L48.236|
000080  1f00              SUBS     r0,r0,#4              ;869
000082  6805              LDR      r5,[r0,#0]            ;869  ; inv_data_builder
000084  e00d              B        |L48.162|
                  |L48.134|
000086  eb050145          ADD      r1,r5,r5,LSL #1       ;870
00008a  4818              LDR      r0,|L48.236|
00008c  eb000181          ADD      r1,r0,r1,LSL #2       ;870
000090  1e68              SUBS     r0,r5,#1              ;870
000092  eb000240          ADD      r2,r0,r0,LSL #1       ;870
000096  4815              LDR      r0,|L48.236|
000098  eb000382          ADD      r3,r0,r2,LSL #2       ;870
00009c  cb0d              LDM      r3,{r0,r2,r3}         ;870
00009e  c10d              STM      r1!,{r0,r2,r3}        ;870
0000a0  1e6d              SUBS     r5,r5,#1              ;869
                  |L48.162|
0000a2  42a5              CMP      r5,r4                 ;869
0000a4  dcef              BGT      |L48.134|
                  |L48.166|
0000a6  eb040144          ADD      r1,r4,r4,LSL #1       ;876
0000aa  4810              LDR      r0,|L48.236|
0000ac  f8407021          STR      r7,[r0,r1,LSL #2]     ;876
0000b0  eb040144          ADD      r1,r4,r4,LSL #1       ;877
0000b4  eb000081          ADD      r0,r0,r1,LSL #2       ;877
0000b8  6046              STR      r6,[r0,#4]            ;877
0000ba  eb040144          ADD      r1,r4,r4,LSL #1       ;878
0000be  480b              LDR      r0,|L48.236|
0000c0  eb000081          ADD      r0,r0,r1,LSL #2       ;878
0000c4  f8c08008          STR      r8,[r0,#8]            ;878
0000c8  4808              LDR      r0,|L48.236|
0000ca  1f00              SUBS     r0,r0,#4              ;879
0000cc  6800              LDR      r0,[r0,#0]            ;879  ; inv_data_builder
0000ce  1c40              ADDS     r0,r0,#1              ;879
0000d0  4906              LDR      r1,|L48.236|
0000d2  1f09              SUBS     r1,r1,#4              ;879
0000d4  6008              STR      r0,[r1,#0]            ;879  ; inv_data_builder
0000d6  e006              B        |L48.230|
                  |L48.216|
0000d8  4a05              LDR      r2,|L48.240|
0000da  a106              ADR      r1,|L48.244|
0000dc  2006              MOVS     r0,#6                 ;881
0000de  f7fffffe          BL       _MLPrintLog
0000e2  f04f0906          MOV      r9,#6                 ;882
                  |L48.230|
0000e6  4648              MOV      r0,r9                 ;885
0000e8  e7a3              B        |L48.50|
;;;887    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L48.236|
                          DCD      inv_data_builder+0x4
                  |L48.240|
                          DCD      ||.conststring||
                  |L48.244|
0000f4  4d504c00          DCB      "MPL",0

                          AREA ||i.inv_reset_compass_soft_iron_matrix||, CODE, READONLY, ALIGN=2

                  inv_reset_compass_soft_iron_matrix PROC
;;;1230   */
;;;1231   void inv_reset_compass_soft_iron_matrix(void)  {
000000  b510              PUSH     {r4,lr}
;;;1232       int i;
;;;1233       for (i=0; i<9; i++) {
000002  2400              MOVS     r4,#0
000004  e007              B        |L49.22|
                  |L49.6|
;;;1234           sensors.soft_iron.matrix_f[i] = 0.0f;
000006  ed9f0a12          VLDR     s0,|L49.80|
00000a  4812              LDR      r0,|L49.84|
00000c  eb000084          ADD      r0,r0,r4,LSL #2
000010  ed800a00          VSTR     s0,[r0,#0]
000014  1c64              ADDS     r4,r4,#1              ;1233
                  |L49.22|
000016  2c09              CMP      r4,#9                 ;1233
000018  dbf5              BLT      |L49.6|
;;;1235       }
;;;1236   
;;;1237       memset(&sensors.soft_iron.matrix_d,0,sizeof(sensors.soft_iron.matrix_d));
00001a  2124              MOVS     r1,#0x24
00001c  480d              LDR      r0,|L49.84|
00001e  3824              SUBS     r0,r0,#0x24
000020  f7fffffe          BL       __aeabi_memclr4
;;;1238   
;;;1239       for (i=0; i<3; i++)  {
000024  2400              MOVS     r4,#0
000026  e00e              B        |L49.70|
                  |L49.40|
;;;1240           // set the floating point matrix
;;;1241           sensors.soft_iron.matrix_f[i*4] = 1.0;
000028  eeb70a00          VMOV.F32 s0,#1.00000000
00002c  4809              LDR      r0,|L49.84|
00002e  eb001004          ADD      r0,r0,r4,LSL #4
000032  ed800a00          VSTR     s0,[r0,#0]
;;;1242           // set the fixed point matrix
;;;1243           sensors.soft_iron.matrix_d[i*4] = ROT_MATRIX_SCALE_LONG;
000036  f04f4180          MOV      r1,#0x40000000
00003a  00a2              LSLS     r2,r4,#2
00003c  4805              LDR      r0,|L49.84|
00003e  3824              SUBS     r0,r0,#0x24
000040  f8401022          STR      r1,[r0,r2,LSL #2]
000044  1c64              ADDS     r4,r4,#1              ;1239
                  |L49.70|
000046  2c03              CMP      r4,#3                 ;1239
000048  dbee              BLT      |L49.40|
;;;1244       }
;;;1245   
;;;1246       inv_disable_compass_soft_iron_matrix();
00004a  f7fffffe          BL       inv_disable_compass_soft_iron_matrix
;;;1247   }
00004e  bd10              POP      {r4,pc}
;;;1248   
                          ENDP

                  |L49.80|
000050  00000000          DCFS     0x00000000 ; 0
                  |L49.84|
                          DCD      sensors+0x16c

                          AREA ||i.inv_set_accel_accuracy||, CODE, READONLY, ALIGN=2

                  inv_set_accel_accuracy PROC
;;;503    */
;;;504    void inv_set_accel_accuracy(int accuracy)
000000  b510              PUSH     {r4,lr}
;;;505    {
000002  4604              MOV      r4,r0
;;;506        sensors.accel.accuracy = accuracy;
000004  4805              LDR      r0,|L50.28|
000006  6784              STR      r4,[r0,#0x78]
;;;507        inv_data_builder.save.accel_accuracy = accuracy;
000008  4805              LDR      r0,|L50.32|
00000a  f8c04134          STR      r4,[r0,#0x134]
;;;508        inv_set_message(INV_MSG_NEW_AB_EVENT, INV_MSG_NEW_AB_EVENT, 0);
00000e  2200              MOVS     r2,#0
000010  2110              MOVS     r1,#0x10
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       inv_set_message
;;;509    }
000018  bd10              POP      {r4,pc}
;;;510    
                          ENDP

00001a  0000              DCW      0x0000
                  |L50.28|
                          DCD      sensors
                  |L50.32|
                          DCD      inv_data_builder

                          AREA ||i.inv_set_accel_bandwidth||, CODE, READONLY, ALIGN=2

                  inv_set_accel_bandwidth PROC
;;;308    */
;;;309    void inv_set_accel_bandwidth(int bandwidth_hz)
000000  4901              LDR      r1,|L51.8|
;;;310    {
;;;311        sensors.accel.bandwidth = bandwidth_hz;
000002  f8c10084          STR      r0,[r1,#0x84]
;;;312    }
000006  4770              BX       lr
;;;313    
                          ENDP

                  |L51.8|
                          DCD      sensors

                          AREA ||i.inv_set_accel_bias||, CODE, READONLY, ALIGN=2

                  inv_set_accel_bias PROC
;;;487    */
;;;488    void inv_set_accel_bias(const long *bias, int accuracy)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;490        if (bias) {
000006  b17c              CBZ      r4,|L52.40|
;;;491            if (memcmp(inv_data_builder.save.accel_bias, bias, sizeof(inv_data_builder.save.accel_bias))) {
000008  220c              MOVS     r2,#0xc
00000a  4621              MOV      r1,r4
00000c  480c              LDR      r0,|L52.64|
00000e  f7fffffe          BL       memcmp
000012  b148              CBZ      r0,|L52.40|
;;;492                memcpy(inv_data_builder.save.accel_bias, bias, sizeof(inv_data_builder.save.accel_bias));
000014  480a              LDR      r0,|L52.64|
000016  3820              SUBS     r0,r0,#0x20
000018  e894000e          LDM      r4,{r1-r3}
00001c  3020              ADDS     r0,r0,#0x20
00001e  c00e              STM      r0!,{r1-r3}
;;;493                inv_apply_calibration(&sensors.accel, inv_data_builder.save.accel_bias);
000020  4907              LDR      r1,|L52.64|
000022  4808              LDR      r0,|L52.68|
000024  f7fffffe          BL       inv_apply_calibration
                  |L52.40|
;;;494            }
;;;495        }
;;;496        sensors.accel.accuracy = accuracy;
000028  4806              LDR      r0,|L52.68|
00002a  3844              SUBS     r0,r0,#0x44
00002c  6785              STR      r5,[r0,#0x78]
;;;497        inv_data_builder.save.accel_accuracy = accuracy;
00002e  4806              LDR      r0,|L52.72|
000030  f8c05134          STR      r5,[r0,#0x134]
;;;498        inv_set_message(INV_MSG_NEW_AB_EVENT, INV_MSG_NEW_AB_EVENT, 0);
000034  2200              MOVS     r2,#0
000036  2110              MOVS     r1,#0x10
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       inv_set_message
;;;499    }
00003e  bd70              POP      {r4-r6,pc}
;;;500    
                          ENDP

                  |L52.64|
                          DCD      inv_data_builder+0x114
                  |L52.68|
                          DCD      sensors+0x44
                  |L52.72|
                          DCD      inv_data_builder

                          AREA ||i.inv_set_accel_bias_mask||, CODE, READONLY, ALIGN=2

                  inv_set_accel_bias_mask PROC
;;;515    */
;;;516    void inv_set_accel_bias_mask(const long *bias, int accuracy, int mask)
000000  b570              PUSH     {r4-r6,lr}
;;;517    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;518        if (bias) {
000008  b1c4              CBZ      r4,|L53.60|
;;;519            if (mask & 1){
00000a  f0050001          AND      r0,r5,#1
00000e  b118              CBZ      r0,|L53.24|
;;;520                inv_data_builder.save.accel_bias[0] = bias[0];
000010  4810              LDR      r0,|L53.84|
000012  6821              LDR      r1,[r4,#0]
000014  f8c01114          STR      r1,[r0,#0x114]
                  |L53.24|
;;;521            }
;;;522            if (mask & 2){
000018  f0050002          AND      r0,r5,#2
00001c  b118              CBZ      r0,|L53.38|
;;;523                inv_data_builder.save.accel_bias[1] = bias[1];
00001e  480d              LDR      r0,|L53.84|
000020  6861              LDR      r1,[r4,#4]
000022  f8c01118          STR      r1,[r0,#0x118]
                  |L53.38|
;;;524            }
;;;525            if (mask & 4){
000026  f0050004          AND      r0,r5,#4
00002a  b118              CBZ      r0,|L53.52|
;;;526                inv_data_builder.save.accel_bias[2] = bias[2];
00002c  4809              LDR      r0,|L53.84|
00002e  68a1              LDR      r1,[r4,#8]
000030  f8c0111c          STR      r1,[r0,#0x11c]
                  |L53.52|
;;;527            }
;;;528    
;;;529            inv_apply_calibration(&sensors.accel, inv_data_builder.save.accel_bias);
000034  4908              LDR      r1,|L53.88|
000036  4809              LDR      r0,|L53.92|
000038  f7fffffe          BL       inv_apply_calibration
                  |L53.60|
;;;530        }
;;;531        sensors.accel.accuracy = accuracy;
00003c  4807              LDR      r0,|L53.92|
00003e  3844              SUBS     r0,r0,#0x44
000040  6786              STR      r6,[r0,#0x78]
;;;532        inv_data_builder.save.accel_accuracy = accuracy;
000042  4804              LDR      r0,|L53.84|
000044  f8c06134          STR      r6,[r0,#0x134]
;;;533        inv_set_message(INV_MSG_NEW_AB_EVENT, INV_MSG_NEW_AB_EVENT, 0);
000048  2200              MOVS     r2,#0
00004a  2110              MOVS     r1,#0x10
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       inv_set_message
;;;534    }
000052  bd70              POP      {r4-r6,pc}
;;;535    
                          ENDP

                  |L53.84|
                          DCD      inv_data_builder
                  |L53.88|
                          DCD      inv_data_builder+0x114
                  |L53.92|
                          DCD      sensors+0x44

                          AREA ||i.inv_set_accel_orientation_and_scale||, CODE, READONLY, ALIGN=2

                  inv_set_accel_orientation_and_scale PROC
;;;381    */
;;;382    void inv_set_accel_orientation_and_scale(int orientation, long sensitivity)
000000  b510              PUSH     {r4,lr}
;;;383    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;384    #ifdef INV_PLAYBACK_DBG
;;;385        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;386            int type = PLAYBACK_DBG_TYPE_A_ORIENT;
;;;387            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;388            fwrite(&orientation, sizeof(orientation), 1, inv_data_builder.file);
;;;389            fwrite(&sensitivity, sizeof(sensitivity), 1, inv_data_builder.file);
;;;390        }
;;;391    #endif
;;;392        set_sensor_orientation_and_scale(&sensors.accel, orientation,
000006  4622              MOV      r2,r4
000008  4619              MOV      r1,r3
00000a  4802              LDR      r0,|L54.20|
00000c  f7fffffe          BL       set_sensor_orientation_and_scale
;;;393                                         sensitivity);
;;;394    }
000010  bd10              POP      {r4,pc}
;;;395    
                          ENDP

000012  0000              DCW      0x0000
                  |L54.20|
                          DCD      sensors+0x44

                          AREA ||i.inv_set_accel_sample_rate||, CODE, READONLY, ALIGN=2

                  inv_set_accel_sample_rate PROC
;;;231    */
;;;232    void inv_set_accel_sample_rate(long sample_rate_us)
000000  4908              LDR      r1,|L55.36|
;;;233    {
;;;234    #ifdef INV_PLAYBACK_DBG
;;;235        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;236            int type = PLAYBACK_DBG_TYPE_A_SAMPLE_RATE;
;;;237            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;238            fwrite(&sample_rate_us, sizeof(sample_rate_us), 1, inv_data_builder.file);
;;;239        }
;;;240    #endif
;;;241        sensors.accel.sample_rate_us = sample_rate_us;
000002  66c8              STR      r0,[r1,#0x6c]
;;;242        sensors.accel.sample_rate_ms = sample_rate_us / 1000;
000004  f44f717a          MOV      r1,#0x3e8
000008  fb90f2f1          SDIV     r2,r0,r1
00000c  4905              LDR      r1,|L55.36|
00000e  670a              STR      r2,[r1,#0x70]
;;;243        if (sensors.accel.bandwidth == 0) {
000010  f8d11084          LDR      r1,[r1,#0x84]
000014  b929              CBNZ     r1,|L55.34|
;;;244            sensors.accel.bandwidth = (int)(1000000L / sample_rate_us);
000016  4904              LDR      r1,|L55.40|
000018  fb91f2f0          SDIV     r2,r1,r0
00001c  4901              LDR      r1,|L55.36|
00001e  f8c12084          STR      r2,[r1,#0x84]
                  |L55.34|
;;;245        }
;;;246    }
000022  4770              BX       lr
;;;247    
                          ENDP

                  |L55.36|
                          DCD      sensors
                  |L55.40|
                          DCD      0x000f4240

                          AREA ||i.inv_set_compass_bandwidth||, CODE, READONLY, ALIGN=2

                  inv_set_compass_bandwidth PROC
;;;316    */
;;;317    void inv_set_compass_bandwidth(int bandwidth_hz)
000000  4901              LDR      r1,|L56.8|
;;;318    {
;;;319        sensors.compass.bandwidth = bandwidth_hz;
000002  f8c100c8          STR      r0,[r1,#0xc8]
;;;320    }
000006  4770              BX       lr
;;;321    
                          ENDP

                  |L56.8|
                          DCD      sensors

                          AREA ||i.inv_set_compass_bias||, CODE, READONLY, ALIGN=2

                  inv_set_compass_bias PROC
;;;461    
;;;462    void inv_set_compass_bias(const long *bias, int accuracy)
000000  b570              PUSH     {r4-r6,lr}
;;;463    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;464        if (memcmp(inv_data_builder.save.compass_bias, bias, sizeof(inv_data_builder.save.compass_bias))) {
000006  220c              MOVS     r2,#0xc
000008  4621              MOV      r1,r4
00000a  480e              LDR      r0,|L57.68|
00000c  f7fffffe          BL       memcmp
000010  b148              CBZ      r0,|L57.38|
;;;465            memcpy(inv_data_builder.save.compass_bias, bias, sizeof(inv_data_builder.save.compass_bias));
000012  480c              LDR      r0,|L57.68|
000014  3874              SUBS     r0,r0,#0x74
000016  e894000e          LDM      r4,{r1-r3}
00001a  3074              ADDS     r0,r0,#0x74
00001c  c00e              STM      r0!,{r1-r3}
;;;466            inv_apply_calibration(&sensors.compass, inv_data_builder.save.compass_bias);
00001e  4909              LDR      r1,|L57.68|
000020  4809              LDR      r0,|L57.72|
000022  f7fffffe          BL       inv_apply_calibration
                  |L57.38|
;;;467        }
;;;468        sensors.compass.accuracy = accuracy;
000026  4808              LDR      r0,|L57.72|
000028  3888              SUBS     r0,r0,#0x88
00002a  f8c050bc          STR      r5,[r0,#0xbc]
;;;469        inv_data_builder.save.compass_accuracy = accuracy;
00002e  4805              LDR      r0,|L57.68|
000030  38f4              SUBS     r0,r0,#0xf4
000032  f8c05138          STR      r5,[r0,#0x138]
;;;470        inv_set_message(INV_MSG_NEW_CB_EVENT, INV_MSG_NEW_CB_EVENT, 0);
000036  2200              MOVS     r2,#0
000038  2108              MOVS     r1,#8
00003a  4608              MOV      r0,r1
00003c  f7fffffe          BL       inv_set_message
;;;471    }
000040  bd70              POP      {r4-r6,pc}
;;;472    
                          ENDP

000042  0000              DCW      0x0000
                  |L57.68|
                          DCD      inv_data_builder+0xf4
                  |L57.72|
                          DCD      sensors+0x88

                          AREA ||i.inv_set_compass_disturbance||, CODE, READONLY, ALIGN=2

                  inv_set_compass_disturbance PROC
;;;475    */
;;;476    void inv_set_compass_disturbance(int dist)
000000  4901              LDR      r1,|L58.8|
;;;477    {
;;;478        inv_data_builder.compass_disturbance = dist;
000002  f8c1013c          STR      r0,[r1,#0x13c]  ; inv_data_builder
;;;479    }
000006  4770              BX       lr
;;;480    
                          ENDP

                  |L58.8|
                          DCD      inv_data_builder

                          AREA ||i.inv_set_compass_orientation_and_scale||, CODE, READONLY, ALIGN=2

                  inv_set_compass_orientation_and_scale PROC
;;;404    */
;;;405    void inv_set_compass_orientation_and_scale(int orientation, long sensitivity)
000000  b510              PUSH     {r4,lr}
;;;406    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;407    #ifdef INV_PLAYBACK_DBG
;;;408        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;409            int type = PLAYBACK_DBG_TYPE_C_ORIENT;
;;;410            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;411            fwrite(&orientation, sizeof(orientation), 1, inv_data_builder.file);
;;;412            fwrite(&sensitivity, sizeof(sensitivity), 1, inv_data_builder.file);
;;;413        }
;;;414    #endif
;;;415        set_sensor_orientation_and_scale(&sensors.compass, orientation, sensitivity);
000006  4622              MOV      r2,r4
000008  4619              MOV      r1,r3
00000a  4802              LDR      r0,|L59.20|
00000c  f7fffffe          BL       set_sensor_orientation_and_scale
;;;416    }
000010  bd10              POP      {r4,pc}
;;;417    
                          ENDP

000012  0000              DCW      0x0000
                  |L59.20|
                          DCD      sensors+0x88

                          AREA ||i.inv_set_compass_sample_rate||, CODE, READONLY, ALIGN=2

                  inv_set_compass_sample_rate PROC
;;;250    */
;;;251    void inv_set_compass_sample_rate(long sample_rate_us)
000000  4909              LDR      r1,|L60.40|
;;;252    {
;;;253    #ifdef INV_PLAYBACK_DBG
;;;254        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;255            int type = PLAYBACK_DBG_TYPE_C_SAMPLE_RATE;
;;;256            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;257            fwrite(&sample_rate_us, sizeof(sample_rate_us), 1, inv_data_builder.file);
;;;258        }
;;;259    #endif
;;;260        sensors.compass.sample_rate_us = sample_rate_us;
000002  f8c100b0          STR      r0,[r1,#0xb0]
;;;261        sensors.compass.sample_rate_ms = sample_rate_us / 1000;
000006  f44f717a          MOV      r1,#0x3e8
00000a  fb90f2f1          SDIV     r2,r0,r1
00000e  4906              LDR      r1,|L60.40|
000010  f8c120b4          STR      r2,[r1,#0xb4]
;;;262        if (sensors.compass.bandwidth == 0) {
000014  f8d110c8          LDR      r1,[r1,#0xc8]
000018  b929              CBNZ     r1,|L60.38|
;;;263            sensors.compass.bandwidth = (int)(1000000L / sample_rate_us);
00001a  4904              LDR      r1,|L60.44|
00001c  fb91f2f0          SDIV     r2,r1,r0
000020  4901              LDR      r1,|L60.40|
000022  f8c120c8          STR      r2,[r1,#0xc8]
                  |L60.38|
;;;264        }
;;;265    }
000026  4770              BX       lr
;;;266    
                          ENDP

                  |L60.40|
                          DCD      sensors
                  |L60.44|
                          DCD      0x000f4240

                          AREA ||i.inv_set_compass_soft_iron_input_data||, CODE, READONLY, ALIGN=2

                  inv_set_compass_soft_iron_input_data PROC
;;;1213   */
;;;1214   void inv_set_compass_soft_iron_input_data(const long *data)  {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1215       int i;
;;;1216       for (i=0; i<3; i++)  {
000004  2400              MOVS     r4,#0
000006  e005              B        |L61.20|
                  |L61.8|
;;;1217           sensors.soft_iron.raw[i] = data[i];
000008  f8551024          LDR      r1,[r5,r4,LSL #2]
00000c  480f              LDR      r0,|L61.76|
00000e  f8401024          STR      r1,[r0,r4,LSL #2]
000012  1c64              ADDS     r4,r4,#1              ;1216
                  |L61.20|
000014  2c03              CMP      r4,#3                 ;1216
000016  dbf7              BLT      |L61.8|
;;;1218       }
;;;1219       if (sensors.soft_iron.enable == 1)  {
000018  480d              LDR      r0,|L61.80|
00001a  f8d00190          LDR      r0,[r0,#0x190]
00001e  2801              CMP      r0,#1
000020  d107              BNE      |L61.50|
;;;1220           mlMatrixVectorMult(sensors.soft_iron.matrix_d, data, sensors.soft_iron.trans);
000022  4a0a              LDR      r2,|L61.76|
000024  320c              ADDS     r2,r2,#0xc
000026  4629              MOV      r1,r5
000028  f102000c          ADD      r0,r2,#0xc
00002c  f7fffffe          BL       mlMatrixVectorMult
000030  e00a              B        |L61.72|
                  |L61.50|
;;;1221       } else {
;;;1222           for (i=0; i<3; i++)  {
000032  2400              MOVS     r4,#0
000034  e006              B        |L61.68|
                  |L61.54|
;;;1223               sensors.soft_iron.trans[i] = data[i];
000036  f8551024          LDR      r1,[r5,r4,LSL #2]
00003a  4804              LDR      r0,|L61.76|
00003c  300c              ADDS     r0,r0,#0xc
00003e  f8401024          STR      r1,[r0,r4,LSL #2]
000042  1c64              ADDS     r4,r4,#1              ;1222
                  |L61.68|
000044  2c03              CMP      r4,#3                 ;1222
000046  dbf6              BLT      |L61.54|
                  |L61.72|
;;;1224           }
;;;1225       }
;;;1226   }
000048  bd70              POP      {r4-r6,pc}
;;;1227   
                          ENDP

00004a  0000              DCW      0x0000
                  |L61.76|
                          DCD      sensors+0x130
                  |L61.80|
                          DCD      sensors

                          AREA ||i.inv_set_compass_soft_iron_matrix_d||, CODE, READONLY, ALIGN=2

                  inv_set_compass_soft_iron_matrix_d PROC
;;;1161   */
;;;1162   void inv_set_compass_soft_iron_matrix_d(long *matrix)  {
000000  4601              MOV      r1,r0
;;;1163       int i;
;;;1164       for (i=0; i<9; i++)  {
000002  2000              MOVS     r0,#0
000004  e015              B        |L62.50|
                  |L62.6|
;;;1165           // set the floating point matrix
;;;1166           sensors.soft_iron.matrix_d[i] = matrix[i];
000006  f8513020          LDR      r3,[r1,r0,LSL #2]
00000a  4a0b              LDR      r2,|L62.56|
00000c  f8423020          STR      r3,[r2,r0,LSL #2]
;;;1167           // convert to Q30 format
;;;1168           sensors.soft_iron.matrix_f[i] = inv_q30_to_float(matrix[i]);
000010  f8512020          LDR      r2,[r1,r0,LSL #2]
000014  ee002a10          VMOV     s0,r2
000018  eef80ac0          VCVT.F32.S32 s1,s0
00001c  ed9f1a07          VLDR     s2,|L62.60|
000020  ee800a81          VDIV.F32 s0,s1,s2
000024  4a04              LDR      r2,|L62.56|
000026  3224              ADDS     r2,r2,#0x24
000028  eb020280          ADD      r2,r2,r0,LSL #2
00002c  ed820a00          VSTR     s0,[r2,#0]
000030  1c40              ADDS     r0,r0,#1              ;1164
                  |L62.50|
000032  2809              CMP      r0,#9                 ;1164
000034  dbe7              BLT      |L62.6|
;;;1169       }
;;;1170   }
000036  4770              BX       lr
;;;1171   /** Gets the 3x3 compass transform matrix in 32 bit floating point format.
                          ENDP

                  |L62.56|
                          DCD      sensors+0x148
                  |L62.60|
00003c  4e800000          DCFS     0x4e800000 ; 1073741824

                          AREA ||i.inv_set_compass_soft_iron_matrix_f||, CODE, READONLY, ALIGN=2

                  inv_set_compass_soft_iron_matrix_f PROC
;;;1182   */
;;;1183   void inv_set_compass_soft_iron_matrix_f(float *matrix)   {
000000  4601              MOV      r1,r0
;;;1184       int i;
;;;1185       for (i=0; i<9; i++)  {
000002  2000              MOVS     r0,#0
000004  e019              B        |L63.58|
                  |L63.6|
;;;1186           // set the floating point matrix
;;;1187           sensors.soft_iron.matrix_f[i] = matrix[i];
000006  eb010280          ADD      r2,r1,r0,LSL #2
00000a  ed920a00          VLDR     s0,[r2,#0]
00000e  4a0c              LDR      r2,|L63.64|
000010  eb020280          ADD      r2,r2,r0,LSL #2
000014  ed820a00          VSTR     s0,[r2,#0]
;;;1188           // convert to Q30 format
;;;1189           sensors.soft_iron.matrix_d[i] = (long )(matrix[i]*ROT_MATRIX_SCALE_LONG);
000018  eb010280          ADD      r2,r1,r0,LSL #2
00001c  ed920a00          VLDR     s0,[r2,#0]
000020  eddf0a08          VLDR     s1,|L63.68|
000024  ee200a20          VMUL.F32 s0,s0,s1
000028  eebd0ac0          VCVT.S32.F32 s0,s0
00002c  ee103a10          VMOV     r3,s0
000030  4a03              LDR      r2,|L63.64|
000032  3a24              SUBS     r2,r2,#0x24
000034  f8423020          STR      r3,[r2,r0,LSL #2]
000038  1c40              ADDS     r0,r0,#1              ;1185
                  |L63.58|
00003a  2809              CMP      r0,#9                 ;1185
00003c  dbe3              BLT      |L63.6|
;;;1190       }
;;;1191   }
00003e  4770              BX       lr
;;;1192   
                          ENDP

                  |L63.64|
                          DCD      sensors+0x16c
                  |L63.68|
000044  4e800000          DCFS     0x4e800000 ; 1073741824

                          AREA ||i.inv_set_contiguous||, CODE, READONLY, ALIGN=2

                  inv_set_contiguous PROC
;;;968    */
;;;969    static void inv_set_contiguous(void)
000000  2000              MOVS     r0,#0
;;;970    {
;;;971        inv_time_t current_time = 0;
;;;972        if (sensors.gyro.status & INV_NEW_DATA) {
000002  4946              LDR      r1,|L64.284|
000004  f8911030          LDRB     r1,[r1,#0x30]  ; sensors
000008  f0010140          AND      r1,r1,#0x40
00000c  b139              CBZ      r1,|L64.30|
;;;973            sensors.gyro.status |= INV_CONTIGUOUS;
00000e  4943              LDR      r1,|L64.284|
000010  6b09              LDR      r1,[r1,#0x30]  ; sensors
000012  f0410110          ORR      r1,r1,#0x10
000016  4a41              LDR      r2,|L64.284|
000018  6311              STR      r1,[r2,#0x30]  ; sensors
;;;974            current_time = sensors.gyro.timestamp;
00001a  4611              MOV      r1,r2
00001c  6b88              LDR      r0,[r1,#0x38]  ; sensors
                  |L64.30|
;;;975        }
;;;976        if (sensors.accel.status & INV_NEW_DATA) {
00001e  493f              LDR      r1,|L64.284|
000020  f8911074          LDRB     r1,[r1,#0x74]
000024  f0010140          AND      r1,r1,#0x40
000028  b169              CBZ      r1,|L64.70|
;;;977            sensors.accel.status |= INV_CONTIGUOUS;
00002a  493c              LDR      r1,|L64.284|
00002c  6f49              LDR      r1,[r1,#0x74]
00002e  f0410210          ORR      r2,r1,#0x10
000032  493a              LDR      r1,|L64.284|
000034  674a              STR      r2,[r1,#0x74]
;;;978            current_time = MAX(current_time, sensors.accel.timestamp);
000036  6fc9              LDR      r1,[r1,#0x7c]
000038  4281              CMP      r1,r0
00003a  d201              BCS      |L64.64|
00003c  4601              MOV      r1,r0
00003e  e001              B        |L64.68|
                  |L64.64|
000040  4936              LDR      r1,|L64.284|
000042  6fc9              LDR      r1,[r1,#0x7c]
                  |L64.68|
000044  4608              MOV      r0,r1
                  |L64.70|
;;;979        }
;;;980        if (sensors.compass.status & INV_NEW_DATA) {
000046  4935              LDR      r1,|L64.284|
000048  f89110b8          LDRB     r1,[r1,#0xb8]
00004c  f0010140          AND      r1,r1,#0x40
000050  b189              CBZ      r1,|L64.118|
;;;981            sensors.compass.status |= INV_CONTIGUOUS;
000052  4932              LDR      r1,|L64.284|
000054  f8d110b8          LDR      r1,[r1,#0xb8]
000058  f0410210          ORR      r2,r1,#0x10
00005c  492f              LDR      r1,|L64.284|
00005e  f8c120b8          STR      r2,[r1,#0xb8]
;;;982            current_time = MAX(current_time, sensors.compass.timestamp);
000062  f8d110c0          LDR      r1,[r1,#0xc0]
000066  4281              CMP      r1,r0
000068  d201              BCS      |L64.110|
00006a  4601              MOV      r1,r0
00006c  e002              B        |L64.116|
                  |L64.110|
00006e  492b              LDR      r1,|L64.284|
000070  f8d110c0          LDR      r1,[r1,#0xc0]
                  |L64.116|
000074  4608              MOV      r0,r1
                  |L64.118|
;;;983        }
;;;984        if (sensors.temp.status & INV_NEW_DATA) {
000076  4929              LDR      r1,|L64.284|
000078  f89110fc          LDRB     r1,[r1,#0xfc]
00007c  f0010140          AND      r1,r1,#0x40
000080  b189              CBZ      r1,|L64.166|
;;;985            sensors.temp.status |= INV_CONTIGUOUS;
000082  4926              LDR      r1,|L64.284|
000084  f8d110fc          LDR      r1,[r1,#0xfc]
000088  f0410210          ORR      r2,r1,#0x10
00008c  4923              LDR      r1,|L64.284|
00008e  f8c120fc          STR      r2,[r1,#0xfc]
;;;986            current_time = MAX(current_time, sensors.temp.timestamp);
000092  f8d11104          LDR      r1,[r1,#0x104]
000096  4281              CMP      r1,r0
000098  d201              BCS      |L64.158|
00009a  4601              MOV      r1,r0
00009c  e002              B        |L64.164|
                  |L64.158|
00009e  491f              LDR      r1,|L64.284|
0000a0  f8d11104          LDR      r1,[r1,#0x104]
                  |L64.164|
0000a4  4608              MOV      r0,r1
                  |L64.166|
;;;987        }
;;;988        if (sensors.quat.status & INV_NEW_DATA) {
0000a6  491d              LDR      r1,|L64.284|
0000a8  f8911120          LDRB     r1,[r1,#0x120]
0000ac  f0010140          AND      r1,r1,#0x40
0000b0  b189              CBZ      r1,|L64.214|
;;;989            sensors.quat.status |= INV_CONTIGUOUS;
0000b2  491a              LDR      r1,|L64.284|
0000b4  f8d11120          LDR      r1,[r1,#0x120]
0000b8  f0410210          ORR      r2,r1,#0x10
0000bc  4917              LDR      r1,|L64.284|
0000be  f8c12120          STR      r2,[r1,#0x120]
;;;990            current_time = MAX(current_time, sensors.quat.timestamp);
0000c2  f8d11124          LDR      r1,[r1,#0x124]
0000c6  4281              CMP      r1,r0
0000c8  d201              BCS      |L64.206|
0000ca  4601              MOV      r1,r0
0000cc  e002              B        |L64.212|
                  |L64.206|
0000ce  4913              LDR      r1,|L64.284|
0000d0  f8d11124          LDR      r1,[r1,#0x124]
                  |L64.212|
0000d4  4608              MOV      r0,r1
                  |L64.214|
;;;991        }
;;;992    
;;;993    #if 0
;;;994        /* See if sensors are still on. These should be turned off by inv_*_was_turned_off()
;;;995         * type functions. This is just in case that breaks down. We make sure
;;;996         * all the data is within 2 seconds of the newest piece of data*/
;;;997        if (inv_delta_time_ms(current_time, sensors.gyro.timestamp) >= 2000)
;;;998            inv_gyro_was_turned_off();
;;;999        if (inv_delta_time_ms(current_time, sensors.accel.timestamp) >= 2000)
;;;1000           inv_accel_was_turned_off();
;;;1001       if (inv_delta_time_ms(current_time, sensors.compass.timestamp) >= 2000)
;;;1002           inv_compass_was_turned_off();
;;;1003       /* TODO: Temperature might not need to be read this quickly. */
;;;1004       if (inv_delta_time_ms(current_time, sensors.temp.timestamp) >= 2000)
;;;1005           inv_temperature_was_turned_off();
;;;1006   #endif
;;;1007   
;;;1008       /* clear bits */
;;;1009       sensors.gyro.status &= ~INV_NEW_DATA;
0000d6  4911              LDR      r1,|L64.284|
0000d8  6b09              LDR      r1,[r1,#0x30]  ; sensors
0000da  f0210140          BIC      r1,r1,#0x40
0000de  4a0f              LDR      r2,|L64.284|
0000e0  6311              STR      r1,[r2,#0x30]  ; sensors
;;;1010       sensors.accel.status &= ~INV_NEW_DATA;
0000e2  4611              MOV      r1,r2
0000e4  6f49              LDR      r1,[r1,#0x74]
0000e6  f0210240          BIC      r2,r1,#0x40
0000ea  490c              LDR      r1,|L64.284|
0000ec  674a              STR      r2,[r1,#0x74]
;;;1011       sensors.compass.status &= ~INV_NEW_DATA;
0000ee  f8d110b8          LDR      r1,[r1,#0xb8]
0000f2  f0210240          BIC      r2,r1,#0x40
0000f6  4909              LDR      r1,|L64.284|
0000f8  f8c120b8          STR      r2,[r1,#0xb8]
;;;1012       sensors.temp.status &= ~INV_NEW_DATA;
0000fc  f8d110fc          LDR      r1,[r1,#0xfc]
000100  f0210240          BIC      r2,r1,#0x40
000104  4905              LDR      r1,|L64.284|
000106  f8c120fc          STR      r2,[r1,#0xfc]
;;;1013       sensors.quat.status &= ~INV_NEW_DATA;
00010a  f8d11120          LDR      r1,[r1,#0x120]
00010e  f0210240          BIC      r2,r1,#0x40
000112  4902              LDR      r1,|L64.284|
000114  f8c12120          STR      r2,[r1,#0x120]
;;;1014   }
000118  4770              BX       lr
;;;1015   
                          ENDP

00011a  0000              DCW      0x0000
                  |L64.284|
                          DCD      sensors

                          AREA ||i.inv_set_gyro_bandwidth||, CODE, READONLY, ALIGN=2

                  inv_set_gyro_bandwidth PROC
;;;300    */
;;;301    void inv_set_gyro_bandwidth(int bandwidth_hz)
000000  4901              LDR      r1,|L65.8|
;;;302    {
;;;303        sensors.gyro.bandwidth = bandwidth_hz;
000002  6408              STR      r0,[r1,#0x40]  ; sensors
;;;304    }
000004  4770              BX       lr
;;;305    
                          ENDP

000006  0000              DCW      0x0000
                  |L65.8|
                          DCD      sensors

                          AREA ||i.inv_set_gyro_bias||, CODE, READONLY, ALIGN=2

                  inv_set_gyro_bias PROC
;;;541    */
;;;542    void inv_set_gyro_bias(const long *bias, int accuracy)
000000  b570              PUSH     {r4-r6,lr}
;;;543    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;544        if (bias != NULL) {
000006  b17c              CBZ      r4,|L66.40|
;;;545            if (memcmp(inv_data_builder.save.gyro_bias, bias, sizeof(inv_data_builder.save.gyro_bias))) {
000008  220c              MOVS     r2,#0xc
00000a  4621              MOV      r1,r4
00000c  4816              LDR      r0,|L66.104|
00000e  f7fffffe          BL       memcmp
000012  b148              CBZ      r0,|L66.40|
;;;546                memcpy(inv_data_builder.save.gyro_bias, bias, sizeof(inv_data_builder.save.gyro_bias));
000014  4814              LDR      r0,|L66.104|
000016  380c              SUBS     r0,r0,#0xc
000018  e894000e          LDM      r4,{r1-r3}
00001c  300c              ADDS     r0,r0,#0xc
00001e  c00e              STM      r0!,{r1-r3}
;;;547                inv_apply_calibration(&sensors.gyro, inv_data_builder.save.gyro_bias);
000020  4911              LDR      r1,|L66.104|
000022  4812              LDR      r0,|L66.108|
000024  f7fffffe          BL       inv_apply_calibration
                  |L66.40|
;;;548            }
;;;549        }
;;;550        sensors.gyro.accuracy = accuracy;
000028  4810              LDR      r0,|L66.108|
00002a  6345              STR      r5,[r0,#0x34]  ; sensors
;;;551        inv_data_builder.save.gyro_accuracy = accuracy;
00002c  4810              LDR      r0,|L66.112|
00002e  f8c05130          STR      r5,[r0,#0x130]
;;;552    
;;;553        /* TODO: What should we do if there's no temperature data? */
;;;554        if (sensors.temp.calibrated[0])
000032  480e              LDR      r0,|L66.108|
000034  f8d000e4          LDR      r0,[r0,#0xe4]
000038  b130              CBZ      r0,|L66.72|
;;;555            inv_data_builder.save.gyro_temp = sensors.temp.calibrated[0];
00003a  480c              LDR      r0,|L66.108|
00003c  f8d010e4          LDR      r1,[r0,#0xe4]
000040  480b              LDR      r0,|L66.112|
000042  f8c0110c          STR      r1,[r0,#0x10c]
000046  e004              B        |L66.82|
                  |L66.72|
;;;556        else
;;;557            /* Set to 27 deg C for now until we've got a better solution. */
;;;558            inv_data_builder.save.gyro_temp = 1769472L;
000048  f44f11d8          MOV      r1,#0x1b0000
00004c  4808              LDR      r0,|L66.112|
00004e  f8c0110c          STR      r1,[r0,#0x10c]
                  |L66.82|
;;;559        inv_set_message(INV_MSG_NEW_GB_EVENT, INV_MSG_NEW_GB_EVENT, 0);
000052  2200              MOVS     r2,#0
000054  2104              MOVS     r1,#4
000056  4608              MOV      r0,r1
000058  f7fffffe          BL       inv_set_message
;;;560    
;;;561        /* TODO: this flag works around the synchronization problem seen with using
;;;562           the user-exposed message layer to signal the temperature compensation
;;;563           module that gyro biases were set.
;;;564           A better, cleaner method is certainly needed. */
;;;565        inv_data_builder.save.gyro_bias_tc_set = true;
00005c  2101              MOVS     r1,#1
00005e  4804              LDR      r0,|L66.112|
000060  f8c01110          STR      r1,[r0,#0x110]
;;;566    }
000064  bd70              POP      {r4-r6,pc}
;;;567    
                          ENDP

000066  0000              DCW      0x0000
                  |L66.104|
                          DCD      inv_data_builder+0x100
                  |L66.108|
                          DCD      sensors
                  |L66.112|
                          DCD      inv_data_builder

                          AREA ||i.inv_set_gyro_orientation_and_scale||, CODE, READONLY, ALIGN=2

                  inv_set_gyro_orientation_and_scale PROC
;;;195    */
;;;196    void inv_set_gyro_orientation_and_scale(int orientation, long sensitivity)
000000  b510              PUSH     {r4,lr}
;;;197    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;198    #ifdef INV_PLAYBACK_DBG
;;;199        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;200            int type = PLAYBACK_DBG_TYPE_G_ORIENT;
;;;201            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;202            fwrite(&orientation, sizeof(orientation), 1, inv_data_builder.file);
;;;203            fwrite(&sensitivity, sizeof(sensitivity), 1, inv_data_builder.file);
;;;204        }
;;;205    #endif
;;;206        set_sensor_orientation_and_scale(&sensors.gyro, orientation,
000006  4622              MOV      r2,r4
000008  4619              MOV      r1,r3
00000a  4802              LDR      r0,|L67.20|
00000c  f7fffffe          BL       set_sensor_orientation_and_scale
;;;207                                         sensitivity);
;;;208    }
000010  bd10              POP      {r4,pc}
;;;209    
                          ENDP

000012  0000              DCW      0x0000
                  |L67.20|
                          DCD      sensors

                          AREA ||i.inv_set_gyro_sample_rate||, CODE, READONLY, ALIGN=2

                  inv_set_gyro_sample_rate PROC
;;;212    */
;;;213    void inv_set_gyro_sample_rate(long sample_rate_us)
000000  4907              LDR      r1,|L68.32|
;;;214    {
;;;215    #ifdef INV_PLAYBACK_DBG
;;;216        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;217            int type = PLAYBACK_DBG_TYPE_G_SAMPLE_RATE;
;;;218            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;219            fwrite(&sample_rate_us, sizeof(sample_rate_us), 1, inv_data_builder.file);
;;;220        }
;;;221    #endif
;;;222        sensors.gyro.sample_rate_us = sample_rate_us;
000002  6288              STR      r0,[r1,#0x28]  ; sensors
;;;223        sensors.gyro.sample_rate_ms = sample_rate_us / 1000;
000004  f44f717a          MOV      r1,#0x3e8
000008  fb90f1f1          SDIV     r1,r0,r1
00000c  4a04              LDR      r2,|L68.32|
00000e  62d1              STR      r1,[r2,#0x2c]  ; sensors
;;;224        if (sensors.gyro.bandwidth == 0) {
000010  4611              MOV      r1,r2
000012  6c09              LDR      r1,[r1,#0x40]  ; sensors
000014  b919              CBNZ     r1,|L68.30|
;;;225            sensors.gyro.bandwidth = (int)(1000000L / sample_rate_us);
000016  4903              LDR      r1,|L68.36|
000018  fb91f1f0          SDIV     r1,r1,r0
00001c  6411              STR      r1,[r2,#0x40]  ; sensors
                  |L68.30|
;;;226        }
;;;227    }
00001e  4770              BX       lr
;;;228    
                          ENDP

                  |L68.32|
                          DCD      sensors
                  |L68.36|
                          DCD      0x000f4240

                          AREA ||i.inv_set_quat_sample_rate||, CODE, READONLY, ALIGN=2

                  inv_set_quat_sample_rate PROC
;;;284    */
;;;285    void inv_set_quat_sample_rate(long sample_rate_us)
000000  4905              LDR      r1,|L69.24|
;;;286    {
;;;287    #ifdef INV_PLAYBACK_DBG
;;;288        if (inv_data_builder.debug_mode == RD_RECORD) {
;;;289            int type = PLAYBACK_DBG_TYPE_Q_SAMPLE_RATE;
;;;290            fwrite(&type, sizeof(type), 1, inv_data_builder.file);
;;;291            fwrite(&sample_rate_us, sizeof(sample_rate_us), 1, inv_data_builder.file);
;;;292        }
;;;293    #endif
;;;294        sensors.quat.sample_rate_us = sample_rate_us;
000002  f8c10128          STR      r0,[r1,#0x128]
;;;295        sensors.quat.sample_rate_ms = sample_rate_us / 1000;
000006  f44f717a          MOV      r1,#0x3e8
00000a  fb90f2f1          SDIV     r2,r0,r1
00000e  4902              LDR      r1,|L69.24|
000010  f8c1212c          STR      r2,[r1,#0x12c]
;;;296    }
000014  4770              BX       lr
;;;297    
                          ENDP

000016  0000              DCW      0x0000
                  |L69.24|
                          DCD      sensors

                          AREA ||i.inv_temperature_was_turned_off||, CODE, READONLY, ALIGN=2

                  inv_temperature_was_turned_off PROC
;;;825     */
;;;826    void inv_temperature_was_turned_off()
000000  2100              MOVS     r1,#0
;;;827    {
;;;828        sensors.temp.status = 0;
000002  4802              LDR      r0,|L70.12|
000004  f8c010fc          STR      r1,[r0,#0xfc]
;;;829    }
000008  4770              BX       lr
;;;830    
                          ENDP

00000a  0000              DCW      0x0000
                  |L70.12|
                          DCD      sensors

                          AREA ||i.inv_unregister_data_cb||, CODE, READONLY, ALIGN=2

                  inv_unregister_data_cb PROC
;;;898    */
;;;899    inv_error_t inv_unregister_data_cb(
000000  b570              PUSH     {r4-r6,lr}
;;;900        inv_error_t (*func)(struct inv_sensor_cal_t *data))
;;;901    {
000002  4603              MOV      r3,r0
;;;902        int kk, nn;
;;;903    
;;;904        for (kk = 0; kk < inv_data_builder.num_cb; ++kk) {
000004  2200              MOVS     r2,#0
000006  e024              B        |L71.82|
                  |L71.8|
;;;905            if (inv_data_builder.process[kk].func == func) {
000008  eb020442          ADD      r4,r2,r2,LSL #1
00000c  4814              LDR      r0,|L71.96|
00000e  f8500024          LDR      r0,[r0,r4,LSL #2]
000012  4298              CMP      r0,r3
000014  d11c              BNE      |L71.80|
;;;906                // Delete this callback
;;;907                for (nn = kk + 1; nn < inv_data_builder.num_cb; ++nn) {
000016  1c51              ADDS     r1,r2,#1
000018  e00c              B        |L71.52|
                  |L71.26|
;;;908                    inv_data_builder.process[nn - 1] =
00001a  1e48              SUBS     r0,r1,#1
00001c  eb000440          ADD      r4,r0,r0,LSL #1
000020  480f              LDR      r0,|L71.96|
000022  eb000484          ADD      r4,r0,r4,LSL #2
000026  eb010541          ADD      r5,r1,r1,LSL #1
00002a  eb000685          ADD      r6,r0,r5,LSL #2
00002e  ce61              LDM      r6,{r0,r5,r6}
000030  c461              STM      r4!,{r0,r5,r6}
000032  1c49              ADDS     r1,r1,#1              ;907
                  |L71.52|
000034  480a              LDR      r0,|L71.96|
000036  1f00              SUBS     r0,r0,#4              ;907
000038  6800              LDR      r0,[r0,#0]            ;907  ; inv_data_builder
00003a  4288              CMP      r0,r1                 ;907
00003c  dced              BGT      |L71.26|
;;;909                        inv_data_builder.process[nn];
;;;910                }
;;;911                inv_data_builder.num_cb--;
00003e  4808              LDR      r0,|L71.96|
000040  1f00              SUBS     r0,r0,#4
000042  6800              LDR      r0,[r0,#0]  ; inv_data_builder
000044  1e40              SUBS     r0,r0,#1
000046  4c06              LDR      r4,|L71.96|
000048  1f24              SUBS     r4,r4,#4
00004a  6020              STR      r0,[r4,#0]  ; inv_data_builder
;;;912                return INV_SUCCESS;
00004c  2000              MOVS     r0,#0
                  |L71.78|
;;;913            }
;;;914        }
;;;915    
;;;916        return INV_SUCCESS;    // We did not find the callback
;;;917    }
00004e  bd70              POP      {r4-r6,pc}
                  |L71.80|
000050  1c52              ADDS     r2,r2,#1              ;904
                  |L71.82|
000052  4803              LDR      r0,|L71.96|
000054  1f00              SUBS     r0,r0,#4              ;904
000056  6800              LDR      r0,[r0,#0]            ;904  ; inv_data_builder
000058  4290              CMP      r0,r2                 ;904
00005a  dcd5              BGT      |L71.8|
00005c  2000              MOVS     r0,#0                 ;916
00005e  e7f6              B        |L71.78|
;;;918    
                          ENDP

                  |L71.96|
                          DCD      inv_data_builder+0x4

                          AREA ||i.set_sensor_orientation_and_scale||, CODE, READONLY, ALIGN=1

                  set_sensor_orientation_and_scale PROC
;;;179    */
;;;180    void set_sensor_orientation_and_scale(struct inv_single_sensor_t *sensor,
000000  6242              STR      r2,[r0,#0x24]
;;;181                                     int orientation, long sensitivity)
;;;182    {
;;;183        sensor->sensitivity = sensitivity;
;;;184        sensor->orientation = orientation;
000002  6001              STR      r1,[r0,#0]
;;;185    }
000004  4770              BX       lr
;;;186    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inv_data_builder
                          %        320
                  sensors
                          %        408

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  556e6162          DCB      "Unable to add feature callback as too many were already"
000004  6c652074
000008  6f206164
00000c  64206665
000010  61747572
000014  65206361
000018  6c6c6261
00001c  636b2061
000020  7320746f
000024  6f206d61
000028  6e792077
00002c  65726520
000030  616c7265
000034  616479  
000037  20726567          DCB      " registered\n",0
00003b  69737465
00003f  7265640a
000043  00      
