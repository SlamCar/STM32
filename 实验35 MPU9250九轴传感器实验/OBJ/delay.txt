; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\delay.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\delay.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;91     //systick中断服务函数,使用OS时用到
;;;92     void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;93     {	
;;;94         HAL_IncTick();
000002  f7fffffe          BL       HAL_IncTick
;;;95     	if(delay_osrunning==1)					//OS开始跑了,才执行正常的调度处理
000006  4805              LDR      r0,|L1.28|
000008  7800              LDRB     r0,[r0,#0]  ; OSRunning
00000a  2801              CMP      r0,#1
00000c  d105              BNE      |L1.26|
;;;96     	{
;;;97     		OSIntEnter();						//进入中断
00000e  f7fffffe          BL       OSIntEnter
;;;98     		OSTimeTick();       				//调用ucos的时钟服务程序               
000012  f7fffffe          BL       OSTimeTick
;;;99     		OSIntExit();       	 				//触发任务切换软中断
000016  f7fffffe          BL       OSIntExit
                  |L1.26|
;;;100    	}
;;;101    }
00001a  bd10              POP      {r4,pc}
;;;102    #endif
                          ENDP

                  |L1.28|
                          DCD      OSRunning

                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;107    //SYSCLK:系统时钟频率
;;;108    void delay_init(u8 SYSCLK)
000000  b570              PUSH     {r4-r6,lr}
;;;109    {
000002  4604              MOV      r4,r0
;;;110    #if SYSTEM_SUPPORT_OS 						//如果需要支持OS.
;;;111    	u32 reload;
;;;112    #endif
;;;113        HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);//SysTick频率为HCLK
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       HAL_SYSTICK_CLKSourceConfig
;;;114    	fac_us=SYSCLK;						    //不论是否使用OS,fac_us都需要使用
00000a  4810              LDR      r0,|L2.76|
00000c  6004              STR      r4,[r0,#0]  ; fac_us
;;;115    #if SYSTEM_SUPPORT_OS 						//如果需要支持OS.
;;;116    	reload=SYSCLK;					        //每秒钟的计数次数 单位为K	   
00000e  4625              MOV      r5,r4
;;;117    	reload*=1000000/delay_ostickspersec;	//根据delay_ostickspersec设定溢出时间
000010  480f              LDR      r0,|L2.80|
000012  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000014  490f              LDR      r1,|L2.84|
000016  fbb1f0f0          UDIV     r0,r1,r0
00001a  4345              MULS     r5,r0,r5
;;;118    											//reload为24位寄存器,最大值:16777216,在216M下,约合77.7ms左右	
;;;119    	fac_ms=1000/delay_ostickspersec;		//代表OS可以延时的最少单位	   
00001c  480c              LDR      r0,|L2.80|
00001e  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000020  f44f717a          MOV      r1,#0x3e8
000024  fbb1f0f0          UDIV     r0,r1,r0
000028  490b              LDR      r1,|L2.88|
00002a  8008              STRH     r0,[r1,#0]
;;;120    	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;//开启SYSTICK中断
00002c  f04f20e0          MOV      r0,#0xe000e000
000030  6900              LDR      r0,[r0,#0x10]
000032  f0400002          ORR      r0,r0,#2
000036  f04f21e0          MOV      r1,#0xe000e000
00003a  6108              STR      r0,[r1,#0x10]
;;;121    	SysTick->LOAD=reload; 					//每1/OS_TICKS_PER_SEC秒中断一次	
00003c  4608              MOV      r0,r1
00003e  6145              STR      r5,[r0,#0x14]
;;;122    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk; //开启SYSTICK
000040  6900              LDR      r0,[r0,#0x10]
000042  f0400001          ORR      r0,r0,#1
000046  6108              STR      r0,[r1,#0x10]
;;;123    #endif 
;;;124    }								    
000048  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      fac_us
                  |L2.80|
                          DCD      OSCfg_TickRate_Hz
                  |L2.84|
                          DCD      0x000f4240
                  |L2.88|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;153    //nms:0~65535
;;;154    void delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;155    {	
000002  4604              MOV      r4,r0
;;;156    	if(delay_osrunning&&delay_osintnesting==0)//如果OS已经在跑了,并且不是在中断里面(中断里面不能任务调度)	    
000004  480f              LDR      r0,|L3.68|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  b1a0              CBZ      r0,|L3.52|
00000a  480f              LDR      r0,|L3.72|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b988              CBNZ     r0,|L3.52|
;;;157    	{		 
;;;158    		if(nms>=fac_ms)						//延时的时间大于OS的最少时间周期 
000010  480e              LDR      r0,|L3.76|
000012  8800              LDRH     r0,[r0,#0]  ; fac_ms
000014  4284              CMP      r4,r0
000016  db06              BLT      |L3.38|
;;;159    		{ 
;;;160       			delay_ostimedly(nms/fac_ms);	//OS延时
000018  480c              LDR      r0,|L3.76|
00001a  8800              LDRH     r0,[r0,#0]  ; fac_ms
00001c  fb94f5f0          SDIV     r5,r4,r0
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       delay_ostimedly
                  |L3.38|
;;;161    		}
;;;162    		nms%=fac_ms;						//OS已经无法提供这么小的延时了,采用普通方式延时    
000026  4809              LDR      r0,|L3.76|
000028  8800              LDRH     r0,[r0,#0]  ; fac_ms
00002a  fb94f1f0          SDIV     r1,r4,r0
00002e  fb004011          MLS      r0,r0,r1,r4
000032  b284              UXTH     r4,r0
                  |L3.52|
;;;163    	}
;;;164    	delay_us((u32)(nms*1000));				//普通方式延时
000034  f44f717a          MOV      r1,#0x3e8
000038  fb04f001          MUL      r0,r4,r1
00003c  f7fffffe          BL       delay_us
;;;165    }
000040  bd70              POP      {r4-r6,pc}
;;;166    #else  //不用ucos时
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      OSRunning
                  |L3.72|
                          DCD      OSIntNestingCtr
                  |L3.76|
                          DCD      fac_ms

                          AREA ||i.delay_osschedlock||, CODE, READONLY, ALIGN=1

                  delay_osschedlock PROC
;;;57     //us级延时时,关闭任务调度(防止打断us级延迟)
;;;58     void delay_osschedlock(void)
000000  b508              PUSH     {r3,lr}
;;;59     {
;;;60     #ifdef CPU_CFG_CRITICAL_METHOD   			//使用UCOSIII
;;;61     	OS_ERR err; 
;;;62     	OSSchedLock(&err);						//UCOSIII的方式,禁止调度，防止打断us延时
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       OSSchedLock
;;;63     #else										//否则UCOSII
;;;64     	OSSchedLock();							//UCOSII的方式,禁止调度，防止打断us延时
;;;65     #endif
;;;66     }
000008  bd08              POP      {r3,pc}
;;;67     
                          ENDP


                          AREA ||i.delay_osschedunlock||, CODE, READONLY, ALIGN=1

                  delay_osschedunlock PROC
;;;68     //us级延时时,恢复任务调度
;;;69     void delay_osschedunlock(void)
000000  b508              PUSH     {r3,lr}
;;;70     {	
;;;71     #ifdef CPU_CFG_CRITICAL_METHOD   			//使用UCOSIII
;;;72     	OS_ERR err; 
;;;73     	OSSchedUnlock(&err);					//UCOSIII的方式,恢复调度
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       OSSchedUnlock
;;;74     #else										//否则UCOSII
;;;75     	OSSchedUnlock();						//UCOSII的方式,恢复调度
;;;76     #endif
;;;77     }
000008  bd08              POP      {r3,pc}
;;;78     
                          ENDP


                          AREA ||i.delay_ostimedly||, CODE, READONLY, ALIGN=1

                  delay_ostimedly PROC
;;;80     //ticks:延时的节拍数
;;;81     void delay_ostimedly(u32 ticks)
000000  b538              PUSH     {r3-r5,lr}
;;;82     {
000002  4604              MOV      r4,r0
;;;83     #ifdef CPU_CFG_CRITICAL_METHOD
;;;84     	OS_ERR err; 
;;;85     	OSTimeDly(ticks,OS_OPT_TIME_PERIODIC,&err);//UCOSIII延时采用周期模式
000004  466a              MOV      r2,sp
000006  2108              MOVS     r1,#8
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       OSTimeDly
;;;86     #else
;;;87     	OSTimeDly(ticks);						//UCOSII延时
;;;88     #endif 
;;;89     }
00000e  bd38              POP      {r3-r5,pc}
;;;90      
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;129    //nus:0~204522252(最大值即2^32/fac_us@fac_us=21)	    								   
;;;130    void delay_us(u32 nus)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;131    {		
000004  4607              MOV      r7,r0
;;;132    	u32 ticks;
;;;133    	u32 told,tnow,tcnt=0;
000006  2600              MOVS     r6,#0
;;;134    	u32 reload=SysTick->LOAD;				//LOAD的值	    	 
000008  f04f20e0          MOV      r0,#0xe000e000
00000c  f8d09014          LDR      r9,[r0,#0x14]
;;;135    	ticks=nus*fac_us; 						//需要的节拍数 
000010  4810              LDR      r0,|L7.84|
000012  6800              LDR      r0,[r0,#0]  ; fac_us
000014  fb07f800          MUL      r8,r7,r0
;;;136    	delay_osschedlock();					//阻止OS调度，防止打断us延时
000018  f7fffffe          BL       delay_osschedlock
;;;137    	told=SysTick->VAL;        				//刚进入时的计数器值
00001c  f04f20e0          MOV      r0,#0xe000e000
000020  6985              LDR      r5,[r0,#0x18]
;;;138    	while(1)
000022  e011              B        |L7.72|
                  |L7.36|
;;;139    	{
;;;140    		tnow=SysTick->VAL;	
000024  f04f20e0          MOV      r0,#0xe000e000
000028  6984              LDR      r4,[r0,#0x18]
;;;141    		if(tnow!=told)
00002a  42ac              CMP      r4,r5
00002c  d00c              BEQ      |L7.72|
;;;142    		{	    
;;;143    			if(tnow<told)tcnt+=told-tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
00002e  42ac              CMP      r4,r5
000030  d202              BCS      |L7.56|
000032  1b28              SUBS     r0,r5,r4
000034  4406              ADD      r6,r6,r0
000036  e003              B        |L7.64|
                  |L7.56|
;;;144    			else tcnt+=reload-tnow+told;	    
000038  eba90004          SUB      r0,r9,r4
00003c  4428              ADD      r0,r0,r5
00003e  4406              ADD      r6,r6,r0
                  |L7.64|
;;;145    			told=tnow;
000040  4625              MOV      r5,r4
;;;146    			if(tcnt>=ticks)break;			//时间超过/等于要延迟的时间,则退出.
000042  4546              CMP      r6,r8
000044  d300              BCC      |L7.72|
000046  e000              B        |L7.74|
                  |L7.72|
000048  e7ec              B        |L7.36|
                  |L7.74|
00004a  bf00              NOP      
;;;147    		}  
;;;148    	};
;;;149    	delay_osschedunlock();					//恢复OS调度											    
00004c  f7fffffe          BL       delay_osschedunlock
;;;150    }  
000050  e8bd87f0          POP      {r4-r10,pc}
;;;151    //延时nms
                          ENDP

                  |L7.84|
                          DCD      fac_us

                          AREA ||.data||, DATA, ALIGN=2

                  fac_us
                          DCD      0x00000000
                  fac_ms
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\SYSTEM\\delay\\delay.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_8c8ced7d____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___7_delay_c_8c8ced7d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_8c8ced7d____REVSH|
#line 402
|__asm___7_delay_c_8c8ced7d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_delay_c_8c8ced7d____RRX|
#line 587
|__asm___7_delay_c_8c8ced7d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
