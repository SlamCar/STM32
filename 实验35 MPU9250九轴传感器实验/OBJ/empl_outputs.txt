; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\empl_outputs.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\empl_outputs.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\empl_outputs.crf ..\DMP\eMPL-hal\eMPL_outputs.c]
                          THUMB

                          AREA ||i.inv_disable_eMPL_outputs||, CODE, READONLY, ALIGN=2

                  inv_disable_eMPL_outputs PROC
;;;313     */
;;;314    inv_error_t inv_disable_eMPL_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;315    {
;;;316        inv_stop_eMPL_outputs();
000002  f7fffffe          BL       inv_stop_eMPL_outputs
;;;317        return inv_unregister_mpl_start_notification(inv_start_eMPL_outputs);
000006  4802              LDR      r0,|L1.16|
000008  f7fffffe          BL       inv_unregister_mpl_start_notification
;;;318    }
00000c  bd10              POP      {r4,pc}
;;;319    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      inv_start_eMPL_outputs

                          AREA ||i.inv_enable_eMPL_outputs||, CODE, READONLY, ALIGN=2

                  inv_enable_eMPL_outputs PROC
;;;301     */
;;;302    inv_error_t inv_enable_eMPL_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;303    {
;;;304        inv_error_t result;
;;;305        result = inv_init_eMPL_outputs();
000002  f7fffffe          BL       inv_init_eMPL_outputs
000006  4604              MOV      r4,r0
;;;306        if (result)
000008  b10c              CBZ      r4,|L2.14|
;;;307            return result;
00000a  4620              MOV      r0,r4
                  |L2.12|
;;;308        return inv_register_mpl_start_notification(inv_start_eMPL_outputs);
;;;309    }
00000c  bd10              POP      {r4,pc}
                  |L2.14|
00000e  4802              LDR      r0,|L2.24|
000010  f7fffffe          BL       inv_register_mpl_start_notification
000014  e7fa              B        |L2.12|
;;;310    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      inv_start_eMPL_outputs

                          AREA ||i.inv_generate_eMPL_outputs||, CODE, READONLY, ALIGN=2

                  inv_generate_eMPL_outputs PROC
;;;229    
;;;230    static inv_error_t inv_generate_eMPL_outputs
000000  b570              PUSH     {r4-r6,lr}
;;;231        (struct inv_sensor_cal_t *sensor_cal)
;;;232    {
000002  4604              MOV      r4,r0
;;;233        int use_sensor;
;;;234        long sr = 1000;
000004  f44f757a          MOV      r5,#0x3e8
;;;235        inv_get_quaternion_set(eMPL_out.quat, &eMPL_out.quat_accuracy, &eMPL_out.nine_axis_timestamp);
000008  4a38              LDR      r2,|L3.236|
00000a  f1a20114          SUB      r1,r2,#0x14
00000e  f1a10010          SUB      r0,r1,#0x10
000012  f7fffffe          BL       inv_get_quaternion_set
;;;236        eMPL_out.gyro_status = sensor_cal->gyro.status;
000016  4935              LDR      r1,|L3.236|
000018  3924              SUBS     r1,r1,#0x24
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  6148              STR      r0,[r1,#0x14]  ; eMPL_out
;;;237        eMPL_out.accel_status = sensor_cal->accel.status;
00001e  6f60              LDR      r0,[r4,#0x74]
000020  6188              STR      r0,[r1,#0x18]  ; eMPL_out
;;;238        eMPL_out.compass_status = sensor_cal->compass.status;
000022  20b8              MOVS     r0,#0xb8
000024  5900              LDR      r0,[r0,r4]
000026  61c8              STR      r0,[r1,#0x1c]  ; eMPL_out
;;;239        
;;;240        /* Find the highest sample rate and tie sensor fusion timestamps to that one. */
;;;241        if (sensor_cal->gyro.status & INV_SENSOR_ON) {
000028  8e20              LDRH     r0,[r4,#0x30]
00002a  f4007080          AND      r0,r0,#0x100
00002e  b108              CBZ      r0,|L3.52|
;;;242            sr = sensor_cal->gyro.sample_rate_ms;
000030  6ae5              LDR      r5,[r4,#0x2c]
;;;243            use_sensor = 0;
000032  2600              MOVS     r6,#0
                  |L3.52|
;;;244        }
;;;245        if ((sensor_cal->accel.status & INV_SENSOR_ON) && (sr > sensor_cal->accel.sample_rate_ms)) {
000034  2074              MOVS     r0,#0x74
000036  5b00              LDRH     r0,[r0,r4]
000038  f4007080          AND      r0,r0,#0x100
00003c  b120              CBZ      r0,|L3.72|
00003e  6f20              LDR      r0,[r4,#0x70]
000040  42a8              CMP      r0,r5
000042  da01              BGE      |L3.72|
;;;246            sr = sensor_cal->accel.sample_rate_ms;
000044  6f25              LDR      r5,[r4,#0x70]
;;;247            use_sensor = 1;
000046  2601              MOVS     r6,#1
                  |L3.72|
;;;248        }
;;;249        if ((sensor_cal->compass.status & INV_SENSOR_ON) && (sr > sensor_cal->compass.sample_rate_ms)) {
000048  20b8              MOVS     r0,#0xb8
00004a  5b00              LDRH     r0,[r0,r4]
00004c  f4007080          AND      r0,r0,#0x100
000050  b130              CBZ      r0,|L3.96|
000052  20b4              MOVS     r0,#0xb4
000054  5900              LDR      r0,[r0,r4]
000056  42a8              CMP      r0,r5
000058  da02              BGE      |L3.96|
;;;250            sr = sensor_cal->compass.sample_rate_ms;
00005a  20b4              MOVS     r0,#0xb4
00005c  5905              LDR      r5,[r0,r4]
;;;251            use_sensor = 2;
00005e  2602              MOVS     r6,#2
                  |L3.96|
;;;252        }
;;;253        if ((sensor_cal->quat.status & INV_SENSOR_ON) && (sr > sensor_cal->quat.sample_rate_ms)) {
000060  f44f7090          MOV      r0,#0x120
000064  5b00              LDRH     r0,[r0,r4]
000066  f4007080          AND      r0,r0,#0x100
00006a  b140              CBZ      r0,|L3.126|
00006c  f44f7096          MOV      r0,#0x12c
000070  5900              LDR      r0,[r0,r4]
000072  42a8              CMP      r0,r5
000074  da03              BGE      |L3.126|
;;;254            sr = sensor_cal->quat.sample_rate_ms;
000076  f44f7096          MOV      r0,#0x12c
00007a  5905              LDR      r5,[r0,r4]
;;;255            use_sensor = 3;
00007c  2603              MOVS     r6,#3
                  |L3.126|
;;;256        }
;;;257    
;;;258        switch (use_sensor) {
00007e  b136              CBZ      r6,|L3.142|
000080  2e01              CMP      r6,#1
000082  d00e              BEQ      |L3.162|
000084  2e02              CMP      r6,#2
000086  d016              BEQ      |L3.182|
000088  2e03              CMP      r6,#3
00008a  d01f              BEQ      |L3.204|
;;;259        default:
;;;260        case 0:
00008c  bf00              NOP      
                  |L3.142|
;;;261            eMPL_out.nine_axis_status = (sensor_cal->gyro.status & INV_NEW_DATA) ? 1 : 0;
00008e  f8940030          LDRB     r0,[r4,#0x30]
000092  f3c01080          UBFX     r0,r0,#6,#1
000096  4915              LDR      r1,|L3.236|
000098  3924              SUBS     r1,r1,#0x24
00009a  6208              STR      r0,[r1,#0x20]  ; eMPL_out
;;;262            eMPL_out.nine_axis_timestamp = sensor_cal->gyro.timestamp;
00009c  6ba0              LDR      r0,[r4,#0x38]
00009e  6248              STR      r0,[r1,#0x24]  ; eMPL_out
;;;263            break;
0000a0  e021              B        |L3.230|
                  |L3.162|
;;;264        case 1:
;;;265            eMPL_out.nine_axis_status = (sensor_cal->accel.status & INV_NEW_DATA) ? 1 : 0;
0000a2  f8940074          LDRB     r0,[r4,#0x74]
0000a6  f3c01080          UBFX     r0,r0,#6,#1
0000aa  4910              LDR      r1,|L3.236|
0000ac  3924              SUBS     r1,r1,#0x24
0000ae  6208              STR      r0,[r1,#0x20]  ; eMPL_out
;;;266            eMPL_out.nine_axis_timestamp = sensor_cal->accel.timestamp;
0000b0  6fe0              LDR      r0,[r4,#0x7c]
0000b2  6248              STR      r0,[r1,#0x24]  ; eMPL_out
;;;267            break;
0000b4  e017              B        |L3.230|
                  |L3.182|
;;;268        case 2:
;;;269            eMPL_out.nine_axis_status = (sensor_cal->compass.status & INV_NEW_DATA) ? 1 : 0;
0000b6  f89400b8          LDRB     r0,[r4,#0xb8]
0000ba  f3c01080          UBFX     r0,r0,#6,#1
0000be  490b              LDR      r1,|L3.236|
0000c0  3924              SUBS     r1,r1,#0x24
0000c2  6208              STR      r0,[r1,#0x20]  ; eMPL_out
;;;270            eMPL_out.nine_axis_timestamp = sensor_cal->compass.timestamp;
0000c4  20c0              MOVS     r0,#0xc0
0000c6  5900              LDR      r0,[r0,r4]
0000c8  6248              STR      r0,[r1,#0x24]  ; eMPL_out
;;;271            break;
0000ca  e00c              B        |L3.230|
                  |L3.204|
;;;272        case 3:
;;;273            eMPL_out.nine_axis_status = (sensor_cal->quat.status & INV_NEW_DATA) ? 1 : 0;
0000cc  f44f7090          MOV      r0,#0x120
0000d0  5d00              LDRB     r0,[r0,r4]
0000d2  f3c01080          UBFX     r0,r0,#6,#1
0000d6  4905              LDR      r1,|L3.236|
0000d8  3924              SUBS     r1,r1,#0x24
0000da  6208              STR      r0,[r1,#0x20]  ; eMPL_out
;;;274            eMPL_out.nine_axis_timestamp = sensor_cal->quat.timestamp;
0000dc  f44f7092          MOV      r0,#0x124
0000e0  5900              LDR      r0,[r0,r4]
0000e2  6248              STR      r0,[r1,#0x24]  ; eMPL_out
;;;275            break;
0000e4  bf00              NOP      
                  |L3.230|
0000e6  bf00              NOP                            ;263
;;;276        }
;;;277        
;;;278        
;;;279        return INV_SUCCESS;
0000e8  2000              MOVS     r0,#0
;;;280    }
0000ea  bd70              POP      {r4-r6,pc}
;;;281    
                          ENDP

                  |L3.236|
                          DCD      eMPL_out+0x24

                          AREA ||i.inv_get_sensor_type_accel||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_accel PROC
;;;45      */
;;;46     int inv_get_sensor_type_accel(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;48         inv_get_accel_set(data, accuracy, timestamp);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       inv_get_accel_set
;;;49         if (eMPL_out.accel_status & INV_NEW_DATA)
000012  4804              LDR      r0,|L4.36|
000014  7e00              LDRB     r0,[r0,#0x18]  ; eMPL_out
000016  f0000040          AND      r0,r0,#0x40
00001a  b108              CBZ      r0,|L4.32|
;;;50             return 1;
00001c  2001              MOVS     r0,#1
                  |L4.30|
;;;51         else
;;;52             return 0;
;;;53     }
00001e  bd70              POP      {r4-r6,pc}
                  |L4.32|
000020  2000              MOVS     r0,#0                 ;52
000022  e7fc              B        |L4.30|
;;;54     
                          ENDP

                  |L4.36|
                          DCD      eMPL_out

                          AREA ||i.inv_get_sensor_type_compass||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_compass PROC
;;;79      */
;;;80     int inv_get_sensor_type_compass(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;81     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;82         inv_get_compass_set(data, accuracy, timestamp);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       inv_get_compass_set
;;;83         if (eMPL_out.compass_status & INV_NEW_DATA)
000012  4804              LDR      r0,|L5.36|
000014  7f00              LDRB     r0,[r0,#0x1c]  ; eMPL_out
000016  f0000040          AND      r0,r0,#0x40
00001a  b108              CBZ      r0,|L5.32|
;;;84             return 1;
00001c  2001              MOVS     r0,#1
                  |L5.30|
;;;85         else
;;;86             return 0;
;;;87     }
00001e  bd70              POP      {r4-r6,pc}
                  |L5.32|
000020  2000              MOVS     r0,#0                 ;86
000022  e7fc              B        |L5.30|
;;;88     
                          ENDP

                  |L5.36|
                          DCD      eMPL_out

                          AREA ||i.inv_get_sensor_type_euler||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_euler PROC
;;;150     */
;;;151    int inv_get_sensor_type_euler(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;152    {
000004  ed2d8b04          VPUSH    {d8-d9}
000008  b089              SUB      sp,sp,#0x24
00000a  4605              MOV      r5,r0
00000c  460f              MOV      r7,r1
00000e  4690              MOV      r8,r2
;;;153        long t1, t2, t3;
;;;154        long q00, q01, q02, q03, q11, q12, q13, q22, q23, q33;
;;;155        float values[3];
;;;156    
;;;157        q00 = inv_q29_mult(eMPL_out.quat[0], eMPL_out.quat[0]);
000010  4a8e              LDR      r2,|L6.588|
000012  6811              LDR      r1,[r2,#0]  ; eMPL_out
000014  6810              LDR      r0,[r2,#0]  ; eMPL_out
000016  f7fffffe          BL       inv_q29_mult
00001a  4606              MOV      r6,r0
;;;158        q01 = inv_q29_mult(eMPL_out.quat[0], eMPL_out.quat[1]);
00001c  4a8b              LDR      r2,|L6.588|
00001e  6851              LDR      r1,[r2,#4]  ; eMPL_out
000020  6810              LDR      r0,[r2,#0]  ; eMPL_out
000022  f7fffffe          BL       inv_q29_mult
000026  9008              STR      r0,[sp,#0x20]
;;;159        q02 = inv_q29_mult(eMPL_out.quat[0], eMPL_out.quat[2]);
000028  4a88              LDR      r2,|L6.588|
00002a  6891              LDR      r1,[r2,#8]  ; eMPL_out
00002c  6810              LDR      r0,[r2,#0]  ; eMPL_out
00002e  f7fffffe          BL       inv_q29_mult
000032  4681              MOV      r9,r0
;;;160        q03 = inv_q29_mult(eMPL_out.quat[0], eMPL_out.quat[3]);
000034  4a85              LDR      r2,|L6.588|
000036  68d1              LDR      r1,[r2,#0xc]  ; eMPL_out
000038  6810              LDR      r0,[r2,#0]  ; eMPL_out
00003a  f7fffffe          BL       inv_q29_mult
00003e  4682              MOV      r10,r0
;;;161        q11 = inv_q29_mult(eMPL_out.quat[1], eMPL_out.quat[1]);
000040  4a82              LDR      r2,|L6.588|
000042  6851              LDR      r1,[r2,#4]  ; eMPL_out
000044  6850              LDR      r0,[r2,#4]  ; eMPL_out
000046  f7fffffe          BL       inv_q29_mult
00004a  9007              STR      r0,[sp,#0x1c]
;;;162        q12 = inv_q29_mult(eMPL_out.quat[1], eMPL_out.quat[2]);
00004c  4a7f              LDR      r2,|L6.588|
00004e  6891              LDR      r1,[r2,#8]  ; eMPL_out
000050  6850              LDR      r0,[r2,#4]  ; eMPL_out
000052  f7fffffe          BL       inv_q29_mult
000056  4683              MOV      r11,r0
;;;163        q13 = inv_q29_mult(eMPL_out.quat[1], eMPL_out.quat[3]);
000058  4a7c              LDR      r2,|L6.588|
00005a  68d1              LDR      r1,[r2,#0xc]  ; eMPL_out
00005c  6850              LDR      r0,[r2,#4]  ; eMPL_out
00005e  f7fffffe          BL       inv_q29_mult
000062  9006              STR      r0,[sp,#0x18]
;;;164        q22 = inv_q29_mult(eMPL_out.quat[2], eMPL_out.quat[2]);
000064  4a79              LDR      r2,|L6.588|
000066  6891              LDR      r1,[r2,#8]  ; eMPL_out
000068  6890              LDR      r0,[r2,#8]  ; eMPL_out
00006a  f7fffffe          BL       inv_q29_mult
00006e  9005              STR      r0,[sp,#0x14]
;;;165        q23 = inv_q29_mult(eMPL_out.quat[2], eMPL_out.quat[3]);
000070  4a76              LDR      r2,|L6.588|
000072  68d1              LDR      r1,[r2,#0xc]  ; eMPL_out
000074  6890              LDR      r0,[r2,#8]  ; eMPL_out
000076  f7fffffe          BL       inv_q29_mult
00007a  9004              STR      r0,[sp,#0x10]
;;;166        q33 = inv_q29_mult(eMPL_out.quat[3], eMPL_out.quat[3]);
00007c  4a73              LDR      r2,|L6.588|
00007e  68d1              LDR      r1,[r2,#0xc]  ; eMPL_out
000080  68d0              LDR      r0,[r2,#0xc]  ; eMPL_out
000082  f7fffffe          BL       inv_q29_mult
000086  9003              STR      r0,[sp,#0xc]
;;;167    
;;;168        /* X component of the Ybody axis in World frame */
;;;169        t1 = q12 - q03;
000088  ebab000a          SUB      r0,r11,r10
00008c  ee080a10          VMOV     s16,r0
;;;170    
;;;171        /* Y component of the Ybody axis in World frame */
;;;172        t2 = q22 + q00 - (1L << 30);
000090  9805              LDR      r0,[sp,#0x14]
000092  4430              ADD      r0,r0,r6
000094  f1a04480          SUB      r4,r0,#0x40000000
;;;173        values[2] = -atan2f((float) t1, (float) t2) * 180.f / (float) M_PI;
000098  ee004a10          VMOV     s0,r4
00009c  eef80ac0          VCVT.F32.S32 s1,s0
0000a0  eeb80ac8          VCVT.F32.S32 s0,s16
0000a4  f7fffffe          BL       __hardfp_atan2f
0000a8  eeb10a40          VNEG.F32 s0,s0
0000ac  eddf0a68          VLDR     s1,|L6.592|
0000b0  ee200a20          VMUL.F32 s0,s0,s1
0000b4  eddf0a67          VLDR     s1,|L6.596|
0000b8  ee801a20          VDIV.F32 s2,s0,s1
0000bc  ed8d1a02          VSTR     s2,[sp,#8]
;;;174    
;;;175        /* Z component of the Ybody axis in World frame */
;;;176        t3 = q23 + q01;
0000c0  9908              LDR      r1,[sp,#0x20]
0000c2  9804              LDR      r0,[sp,#0x10]
0000c4  4408              ADD      r0,r0,r1
0000c6  ee080a90          VMOV     s17,r0
;;;177        values[0] =
0000ca  eef80ac8          VCVT.F32.S32 s1,s16
0000ce  ee201aa0          VMUL.F32 s2,s1,s1
0000d2  ee004a90          VMOV     s1,r4
0000d6  eef81ae0          VCVT.F32.S32 s3,s1
0000da  ee004a90          VMOV     s1,r4
0000de  eef80ae0          VCVT.F32.S32 s1,s1
0000e2  ee011aa0          VMLA.F32 s2,s3,s1
0000e6  eeb00a41          VMOV.F32 s0,s2
0000ea  f7fffffe          BL       __hardfp_sqrtf
0000ee  eeb09a40          VMOV.F32 s18,s0
0000f2  eef00a49          VMOV.F32 s1,s18
0000f6  eeb80ae8          VCVT.F32.S32 s0,s17
0000fa  f7fffffe          BL       __hardfp_atan2f
0000fe  eddf0a54          VLDR     s1,|L6.592|
000102  ee200a20          VMUL.F32 s0,s0,s1
000106  eddf0a53          VLDR     s1,|L6.596|
00010a  ee801a20          VDIV.F32 s2,s0,s1
00010e  ed8d1a00          VSTR     s2,[sp,#0]
;;;178            atan2f((float) t3,
;;;179                    sqrtf((float) t1 * t1 +
;;;180                          (float) t2 * t2)) * 180.f / (float) M_PI;
;;;181        /* Z component of the Zbody axis in World frame */
;;;182        t2 = q33 + q00 - (1L << 30);
000112  9803              LDR      r0,[sp,#0xc]
000114  4430              ADD      r0,r0,r6
000116  f1a04480          SUB      r4,r0,#0x40000000
;;;183        if (t2 < 0) {
00011a  2c00              CMP      r4,#0
00011c  da17              BGE      |L6.334|
;;;184            if (values[0] >= 0)
00011e  ed9d0a00          VLDR     s0,[sp,#0]
000122  eeb50ac0          VCMPE.F32 s0,#0.0
000126  eef1fa10          VMRS     APSR_nzcv,FPSCR
00012a  db08              BLT      |L6.318|
;;;185                values[0] = 180.f - values[0];
00012c  ed9d0a00          VLDR     s0,[sp,#0]
000130  eddf0a47          VLDR     s1,|L6.592|
000134  ee300ac0          VSUB.F32 s0,s1,s0
000138  ed8d0a00          VSTR     s0,[sp,#0]
00013c  e007              B        |L6.334|
                  |L6.318|
;;;186            else
;;;187                values[0] = -180.f - values[0];
00013e  ed9d0a00          VLDR     s0,[sp,#0]
000142  eddf0a45          VLDR     s1,|L6.600|
000146  ee300ac0          VSUB.F32 s0,s1,s0
00014a  ed8d0a00          VSTR     s0,[sp,#0]
                  |L6.334|
;;;188        }
;;;189    
;;;190        /* X component of the Xbody axis in World frame */
;;;191        t1 = q11 + q00 - (1L << 30);
00014e  9807              LDR      r0,[sp,#0x1c]
000150  4430              ADD      r0,r0,r6
000152  f1a04080          SUB      r0,r0,#0x40000000
000156  ee080a10          VMOV     s16,r0
;;;192        /* Y component of the Xbody axis in World frame */
;;;193        t2 = q12 + q03;
00015a  eb0b040a          ADD      r4,r11,r10
;;;194        /* Z component of the Xbody axis in World frame */
;;;195        t3 = q13 - q02;
00015e  9806              LDR      r0,[sp,#0x18]
000160  eba00009          SUB      r0,r0,r9
000164  ee080a90          VMOV     s17,r0
;;;196    
;;;197        values[1] =
000168  9806              LDR      r0,[sp,#0x18]
00016a  eba00009          SUB      r0,r0,r9
00016e  ee010a10          VMOV     s2,r0
000172  eeb81ac1          VCVT.F32.S32 s2,s2
000176  eef00a41          VMOV.F32 s1,s2
00017a  9803              LDR      r0,[sp,#0xc]
00017c  4430              ADD      r0,r0,r6
00017e  f1a04080          SUB      r0,r0,#0x40000000
000182  ee010a10          VMOV     s2,r0
000186  eeb81ac1          VCVT.F32.S32 s2,s2
00018a  eeb00a41          VMOV.F32 s0,s2
00018e  f7fffffe          BL       __hardfp_atan2f
000192  eddf0a2f          VLDR     s1,|L6.592|
000196  ee200a20          VMUL.F32 s0,s0,s1
00019a  ed9f1a2e          VLDR     s2,|L6.596|
00019e  eec00a01          VDIV.F32 s1,s0,s2
0001a2  ed9f0a2e          VLDR     s0,|L6.604|
0001a6  ee300ac0          VSUB.F32 s0,s1,s0
0001aa  ed8d0a01          VSTR     s0,[sp,#4]
;;;198            (atan2f((float)(q33 + q00 - (1L << 30)), (float)(q13 - q02)) *
;;;199              180.f / (float) M_PI - 90);
;;;200        if (values[1] >= 90)
0001ae  ed9d0a01          VLDR     s0,[sp,#4]
0001b2  eddf0a2a          VLDR     s1,|L6.604|
0001b6  eeb40ae0          VCMPE.F32 s0,s1
0001ba  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001be  db07              BLT      |L6.464|
;;;201            values[1] = 180 - values[1];
0001c0  ed9d0a01          VLDR     s0,[sp,#4]
0001c4  eddf0a22          VLDR     s1,|L6.592|
0001c8  ee300ac0          VSUB.F32 s0,s1,s0
0001cc  ed8d0a01          VSTR     s0,[sp,#4]
                  |L6.464|
;;;202    
;;;203        if (values[1] < -90)
0001d0  ed9d0a01          VLDR     s0,[sp,#4]
0001d4  eddf0a22          VLDR     s1,|L6.608|
0001d8  eeb40ae0          VCMPE.F32 s0,s1
0001dc  eef1fa10          VMRS     APSR_nzcv,FPSCR
0001e0  d207              BCS      |L6.498|
;;;204            values[1] = -180 - values[1];
0001e2  ed9d0a01          VLDR     s0,[sp,#4]
0001e6  eddf0a1c          VLDR     s1,|L6.600|
0001ea  ee300ac0          VSUB.F32 s0,s1,s0
0001ee  ed8d0a01          VSTR     s0,[sp,#4]
                  |L6.498|
;;;205        data[0] = (long)(values[0] * 65536.f);
0001f2  ed9d0a00          VLDR     s0,[sp,#0]
0001f6  eddf0a1b          VLDR     s1,|L6.612|
0001fa  ee200a20          VMUL.F32 s0,s0,s1
0001fe  eebd0ac0          VCVT.S32.F32 s0,s0
000202  ed850a00          VSTR     s0,[r5,#0]
;;;206        data[1] = (long)(values[1] * 65536.f);
000206  ed9d0a01          VLDR     s0,[sp,#4]
00020a  eddf0a16          VLDR     s1,|L6.612|
00020e  ee200a20          VMUL.F32 s0,s0,s1
000212  eebd0ac0          VCVT.S32.F32 s0,s0
000216  ed850a01          VSTR     s0,[r5,#4]
;;;207        data[2] = (long)(values[2] * 65536.f);
00021a  ed9d0a02          VLDR     s0,[sp,#8]
00021e  eddf0a11          VLDR     s1,|L6.612|
000222  ee200a20          VMUL.F32 s0,s0,s1
000226  eebd0ac0          VCVT.S32.F32 s0,s0
00022a  ed850a02          VSTR     s0,[r5,#8]
;;;208    
;;;209        accuracy[0] = eMPL_out.quat_accuracy;
00022e  4807              LDR      r0,|L6.588|
000230  7c00              LDRB     r0,[r0,#0x10]  ; eMPL_out
000232  b240              SXTB     r0,r0
000234  7038              STRB     r0,[r7,#0]
;;;210        timestamp[0] = eMPL_out.nine_axis_timestamp;
000236  4805              LDR      r0,|L6.588|
000238  6a40              LDR      r0,[r0,#0x24]  ; eMPL_out
00023a  f8c80000          STR      r0,[r8,#0]
;;;211        return eMPL_out.nine_axis_status;
00023e  4803              LDR      r0,|L6.588|
000240  6a00              LDR      r0,[r0,#0x20]  ; eMPL_out
;;;212    }
000242  b009              ADD      sp,sp,#0x24
000244  ecbd8b04          VPOP     {d8-d9}
000248  e8bd8ff0          POP      {r4-r11,pc}
;;;213    
                          ENDP

                  |L6.588|
                          DCD      eMPL_out
                  |L6.592|
000250  43340000          DCFS     0x43340000 ; 180
                  |L6.596|
000254  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L6.600|
000258  c3340000          DCFS     0xc3340000 ; -180
                  |L6.604|
00025c  42b40000          DCFS     0x42b40000 ; 90
                  |L6.608|
000260  c2b40000          DCFS     0xc2b40000 ; -90
                  |L6.612|
000264  47800000          DCFS     0x47800000 ; 65536

                          AREA ||i.inv_get_sensor_type_gyro||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_gyro PROC
;;;62      */
;;;63     int inv_get_sensor_type_gyro(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;65         inv_get_gyro_set(data, accuracy, timestamp);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       inv_get_gyro_set
;;;66         if (eMPL_out.gyro_status & INV_NEW_DATA)
000012  4804              LDR      r0,|L7.36|
000014  7d00              LDRB     r0,[r0,#0x14]  ; eMPL_out
000016  f0000040          AND      r0,r0,#0x40
00001a  b108              CBZ      r0,|L7.32|
;;;67             return 1;
00001c  2001              MOVS     r0,#1
                  |L7.30|
;;;68         else
;;;69             return 0;
;;;70     }
00001e  bd70              POP      {r4-r6,pc}
                  |L7.32|
000020  2000              MOVS     r0,#0                 ;69
000022  e7fc              B        |L7.30|
;;;71     
                          ENDP

                  |L7.36|
                          DCD      eMPL_out

                          AREA ||i.inv_get_sensor_type_heading||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_heading PROC
;;;113     */
;;;114    int inv_get_sensor_type_heading(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;115    {
000004  ed2d8b04          VPUSH    {d8-d9}
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
00000c  4616              MOV      r6,r2
;;;116        long t1, t2, q00, q03, q12, q22;
;;;117        float fdata;
;;;118    
;;;119        q00 = inv_q29_mult(eMPL_out.quat[0], eMPL_out.quat[0]);
00000e  4a29              LDR      r2,|L8.180|
000010  6811              LDR      r1,[r2,#0]  ; eMPL_out
000012  6810              LDR      r0,[r2,#0]  ; eMPL_out
000014  f7fffffe          BL       inv_q29_mult
000018  4607              MOV      r7,r0
;;;120        q03 = inv_q29_mult(eMPL_out.quat[0], eMPL_out.quat[3]);
00001a  4a26              LDR      r2,|L8.180|
00001c  68d1              LDR      r1,[r2,#0xc]  ; eMPL_out
00001e  6810              LDR      r0,[r2,#0]  ; eMPL_out
000020  f7fffffe          BL       inv_q29_mult
000024  4680              MOV      r8,r0
;;;121        q12 = inv_q29_mult(eMPL_out.quat[1], eMPL_out.quat[2]);
000026  4a23              LDR      r2,|L8.180|
000028  6891              LDR      r1,[r2,#8]  ; eMPL_out
00002a  6850              LDR      r0,[r2,#4]  ; eMPL_out
00002c  f7fffffe          BL       inv_q29_mult
000030  4681              MOV      r9,r0
;;;122        q22 = inv_q29_mult(eMPL_out.quat[2], eMPL_out.quat[2]);
000032  4a20              LDR      r2,|L8.180|
000034  6891              LDR      r1,[r2,#8]  ; eMPL_out
000036  6890              LDR      r0,[r2,#8]  ; eMPL_out
000038  f7fffffe          BL       inv_q29_mult
00003c  4682              MOV      r10,r0
;;;123    
;;;124        /* X component of the Ybody axis in World frame */
;;;125        t1 = q12 - q03;
00003e  eba90008          SUB      r0,r9,r8
000042  ee080a90          VMOV     s17,r0
;;;126    
;;;127        /* Y component of the Ybody axis in World frame */
;;;128        t2 = q22 + q00 - (1L << 30);
000046  eb0a0007          ADD      r0,r10,r7
00004a  f1a04080          SUB      r0,r0,#0x40000000
00004e  ee090a10          VMOV     s18,r0
;;;129        fdata = atan2f((float) t1, (float) t2) * 180.f / (float) M_PI;
000052  eef80ac9          VCVT.F32.S32 s1,s18
000056  eeb80ae8          VCVT.F32.S32 s0,s17
00005a  f7fffffe          BL       __hardfp_atan2f
00005e  eddf0a16          VLDR     s1,|L8.184|
000062  ee200a20          VMUL.F32 s0,s0,s1
000066  eddf0a15          VLDR     s1,|L8.188|
00006a  ee801a20          VDIV.F32 s2,s0,s1
00006e  eeb08a41          VMOV.F32 s16,s2
;;;130        if (fdata < 0.f)
000072  eeb58ac0          VCMPE.F32 s16,#0.0
000076  eef1fa10          VMRS     APSR_nzcv,FPSCR
00007a  d205              BCS      |L8.136|
;;;131            fdata += 360.f;
00007c  ed9f0a10          VLDR     s0,|L8.192|
000080  ee380a00          VADD.F32 s0,s16,s0
000084  eeb08a40          VMOV.F32 s16,s0
                  |L8.136|
;;;132        data[0] = (long)(fdata * 65536.f);
000088  ed9f0a0e          VLDR     s0,|L8.196|
00008c  ee280a00          VMUL.F32 s0,s16,s0
000090  eebd0ac0          VCVT.S32.F32 s0,s0
000094  ed840a00          VSTR     s0,[r4,#0]
;;;133    
;;;134        accuracy[0] = eMPL_out.quat_accuracy;
000098  4806              LDR      r0,|L8.180|
00009a  7c00              LDRB     r0,[r0,#0x10]  ; eMPL_out
00009c  b240              SXTB     r0,r0
00009e  7028              STRB     r0,[r5,#0]
;;;135        timestamp[0] = eMPL_out.nine_axis_timestamp;
0000a0  4804              LDR      r0,|L8.180|
0000a2  6a40              LDR      r0,[r0,#0x24]  ; eMPL_out
0000a4  6030              STR      r0,[r6,#0]
;;;136        return eMPL_out.nine_axis_status;
0000a6  4803              LDR      r0,|L8.180|
0000a8  6a00              LDR      r0,[r0,#0x20]  ; eMPL_out
;;;137    }
0000aa  ecbd8b04          VPOP     {d8-d9}
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;138    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L8.180|
                          DCD      eMPL_out
                  |L8.184|
0000b8  43340000          DCFS     0x43340000 ; 180
                  |L8.188|
0000bc  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732
                  |L8.192|
0000c0  43b40000          DCFS     0x43b40000 ; 360
                  |L8.196|
0000c4  47800000          DCFS     0x47800000 ; 65536

                          AREA ||i.inv_get_sensor_type_quat||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_quat PROC
;;;97      */
;;;98     int inv_get_sensor_type_quat(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;99     {
000002  4603              MOV      r3,r0
;;;100        memcpy(data, eMPL_out.quat, sizeof(eMPL_out.quat));
000004  4e06              LDR      r6,|L9.32|
000006  ce71              LDM      r6,{r0,r4-r6}
000008  e8830071          STM      r3,{r0,r4-r6}
;;;101        accuracy[0] = eMPL_out.quat_accuracy;
00000c  4804              LDR      r0,|L9.32|
00000e  7c00              LDRB     r0,[r0,#0x10]  ; eMPL_out
000010  b240              SXTB     r0,r0
000012  7008              STRB     r0,[r1,#0]
;;;102        timestamp[0] = eMPL_out.nine_axis_timestamp;
000014  4802              LDR      r0,|L9.32|
000016  6a40              LDR      r0,[r0,#0x24]  ; eMPL_out
000018  6010              STR      r0,[r2,#0]
;;;103        return eMPL_out.nine_axis_status;
00001a  4801              LDR      r0,|L9.32|
00001c  6a00              LDR      r0,[r0,#0x20]  ; eMPL_out
;;;104    }
00001e  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP

                  |L9.32|
                          DCD      eMPL_out

                          AREA ||i.inv_get_sensor_type_rot_mat||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_rot_mat PROC
;;;221     */
;;;222    int inv_get_sensor_type_rot_mat(long *data, int8_t *accuracy, inv_time_t *timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;224        inv_quaternion_to_rotation(eMPL_out.quat, data);
000008  4621              MOV      r1,r4
00000a  4806              LDR      r0,|L10.36|
00000c  f7fffffe          BL       inv_quaternion_to_rotation
;;;225        accuracy[0] = eMPL_out.quat_accuracy;
000010  4804              LDR      r0,|L10.36|
000012  7c00              LDRB     r0,[r0,#0x10]  ; eMPL_out
000014  b240              SXTB     r0,r0
000016  7030              STRB     r0,[r6,#0]
;;;226        timestamp[0] = eMPL_out.nine_axis_timestamp;
000018  4802              LDR      r0,|L10.36|
00001a  6a40              LDR      r0,[r0,#0x24]  ; eMPL_out
00001c  6028              STR      r0,[r5,#0]
;;;227        return eMPL_out.nine_axis_status;
00001e  4801              LDR      r0,|L10.36|
000020  6a00              LDR      r0,[r0,#0x20]  ; eMPL_out
;;;228    }
000022  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

                  |L10.36|
                          DCD      eMPL_out

                          AREA ||i.inv_init_eMPL_outputs||, CODE, READONLY, ALIGN=2

                  inv_init_eMPL_outputs PROC
;;;292    
;;;293    static inv_error_t inv_init_eMPL_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;294    {
;;;295        memset(&eMPL_out, 0, sizeof(eMPL_out));
000002  2128              MOVS     r1,#0x28
000004  4802              LDR      r0,|L11.16|
000006  f7fffffe          BL       __aeabi_memclr4
;;;296        return INV_SUCCESS;
00000a  2000              MOVS     r0,#0
;;;297    }
00000c  bd10              POP      {r4,pc}
;;;298    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      eMPL_out

                          AREA ||i.inv_start_eMPL_outputs||, CODE, READONLY, ALIGN=2

                  inv_start_eMPL_outputs PROC
;;;281    
;;;282    static inv_error_t inv_start_eMPL_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;283    {
;;;284        return inv_register_data_cb(inv_generate_eMPL_outputs,
000002  2207              MOVS     r2,#7
000004  f44f7161          MOV      r1,#0x384
000008  4801              LDR      r0,|L12.16|
00000a  f7fffffe          BL       inv_register_data_cb
;;;285            INV_PRIORITY_HAL_OUTPUTS, INV_GYRO_NEW | INV_ACCEL_NEW | INV_MAG_NEW);
;;;286    }
00000e  bd10              POP      {r4,pc}
;;;287    
                          ENDP

                  |L12.16|
                          DCD      inv_generate_eMPL_outputs

                          AREA ||i.inv_stop_eMPL_outputs||, CODE, READONLY, ALIGN=2

                  inv_stop_eMPL_outputs PROC
;;;287    
;;;288    static inv_error_t inv_stop_eMPL_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;289    {
;;;290        return inv_unregister_data_cb(inv_generate_eMPL_outputs);
000002  4802              LDR      r0,|L13.12|
000004  f7fffffe          BL       inv_unregister_data_cb
;;;291    }
000008  bd10              POP      {r4,pc}
;;;292    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      inv_generate_eMPL_outputs

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  eMPL_out
                          %        40
