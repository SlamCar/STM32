; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\hal_outputs.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\hal_outputs.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\hal_outputs.crf ..\DMP\mllite\hal_outputs.c]
                          THUMB

                          AREA ||i.google_orientation||, CODE, READONLY, ALIGN=2

                  google_orientation PROC
;;;267    
;;;268    static void google_orientation(float *g)
000000  b510              PUSH     {r4,lr}
;;;269    {
000002  ed2d8b02          VPUSH    {d8}
000006  b08a              SUB      sp,sp,#0x28
000008  4604              MOV      r4,r0
;;;270        float rad2deg = (float)(180.0 / M_PI);
00000a  ed9f0a22          VLDR     s0,|L1.148|
00000e  eeb08a40          VMOV.F32 s16,s0
;;;271        float R[3][3];
;;;272    
;;;273        inv_get_rotation(R);
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       inv_get_rotation
;;;274    
;;;275        g[0] = atan2f(-R[1][0], R[0][0]) * rad2deg;
000018  ed9d1a01          VLDR     s2,[sp,#4]
00001c  eef00a41          VMOV.F32 s1,s2
000020  ed9d1a04          VLDR     s2,[sp,#0x10]
000024  eeb11a41          VNEG.F32 s2,s2
000028  eeb00a41          VMOV.F32 s0,s2
00002c  f7fffffe          BL       __hardfp_atan2f
000030  ee200a08          VMUL.F32 s0,s0,s16
000034  ed840a00          VSTR     s0,[r4,#0]
;;;276        g[1] = atan2f(-R[2][1], R[2][2]) * rad2deg;
000038  ed9d1a09          VLDR     s2,[sp,#0x24]
00003c  eef00a41          VMOV.F32 s1,s2
000040  ed9d1a08          VLDR     s2,[sp,#0x20]
000044  eeb11a41          VNEG.F32 s2,s2
000048  eeb00a41          VMOV.F32 s0,s2
00004c  f7fffffe          BL       __hardfp_atan2f
000050  ee200a08          VMUL.F32 s0,s0,s16
000054  ed840a01          VSTR     s0,[r4,#4]
;;;277        g[2] = asinf ( R[2][0])          * rad2deg;
000058  eddd0a07          VLDR     s1,[sp,#0x1c]
00005c  eeb00a60          VMOV.F32 s0,s1
000060  f7fffffe          BL       __hardfp_asinf
000064  ee200a08          VMUL.F32 s0,s0,s16
000068  ed840a02          VSTR     s0,[r4,#8]
;;;278        if (g[0] < 0)
00006c  ed940a00          VLDR     s0,[r4,#0]
000070  eeb50ac0          VCMPE.F32 s0,#0.0
000074  eef1fa10          VMRS     APSR_nzcv,FPSCR
000078  d207              BCS      |L1.138|
;;;279            g[0] += 360;
00007a  ed940a00          VLDR     s0,[r4,#0]
00007e  eddf0a06          VLDR     s1,|L1.152|
000082  ee300a20          VADD.F32 s0,s0,s1
000086  ed840a00          VSTR     s0,[r4,#0]
                  |L1.138|
;;;280    }
00008a  b00a              ADD      sp,sp,#0x28
00008c  ecbd8b02          VPOP     {d8}
000090  bd10              POP      {r4,pc}
;;;281    
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
000094  42652ee1          DCFS     0x42652ee1 ; 57.295780181884766
                  |L1.152|
000098  43b40000          DCFS     0x43b40000 ; 360

                          AREA ||i.inv_disable_hal_outputs||, CODE, READONLY, ALIGN=2

                  inv_disable_hal_outputs PROC
;;;474    */
;;;475    inv_error_t inv_disable_hal_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;476    {
;;;477        inv_error_t result;
;;;478    
;;;479        inv_stop_hal_outputs(); // Ignore error if we have already stopped this
000002  f7fffffe          BL       inv_stop_hal_outputs
;;;480        result = inv_unregister_mpl_start_notification(inv_start_hal_outputs);
000006  4803              LDR      r0,|L2.20|
000008  f7fffffe          BL       inv_unregister_mpl_start_notification
00000c  4604              MOV      r4,r0
;;;481        return result;
00000e  4620              MOV      r0,r4
;;;482    }
000010  bd10              POP      {r4,pc}
;;;483    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      inv_start_hal_outputs

                          AREA ||i.inv_enable_hal_outputs||, CODE, READONLY, ALIGN=2

                  inv_enable_hal_outputs PROC
;;;460    */
;;;461    inv_error_t inv_enable_hal_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;462    {
;;;463        inv_error_t result;
;;;464    
;;;465    	// don't need to check the result for inv_init_hal_outputs
;;;466    	// since it's always INV_SUCCESS
;;;467    	inv_init_hal_outputs();
000002  f7fffffe          BL       inv_init_hal_outputs
;;;468    
;;;469        result = inv_register_mpl_start_notification(inv_start_hal_outputs);
000006  4803              LDR      r0,|L3.20|
000008  f7fffffe          BL       inv_register_mpl_start_notification
00000c  4604              MOV      r4,r0
;;;470        return result;
00000e  4620              MOV      r0,r4
;;;471    }
000010  bd10              POP      {r4,pc}
;;;472    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      inv_start_hal_outputs

                          AREA ||i.inv_generate_hal_outputs||, CODE, READONLY, ALIGN=2

                  inv_generate_hal_outputs PROC
;;;319    */
;;;320    inv_error_t inv_generate_hal_outputs(struct inv_sensor_cal_t *sensor_cal)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;321    {
000004  4604              MOV      r4,r0
;;;322        int use_sensor = 0;
000006  2700              MOVS     r7,#0
;;;323        long sr = 1000;
000008  f44f767a          MOV      r6,#0x3e8
;;;324        long compass[3];
;;;325        int8_t accuracy;
;;;326        int i;
;;;327        (void) sensor_cal;
;;;328    
;;;329        inv_get_quaternion_set(hal_out.nav_quat, &hal_out.accuracy_quat,
00000c  4a7c              LDR      r2,|L4.512|
00000e  1f11              SUBS     r1,r2,#4
000010  f1010010          ADD      r0,r1,#0x10
000014  f7fffffe          BL       inv_get_quaternion_set
;;;330                               &hal_out.nav_timestamp);
;;;331        hal_out.gyro_status = sensor_cal->gyro.status;
000018  4979              LDR      r1,|L4.512|
00001a  3908              SUBS     r1,r1,#8
00001c  6b20              LDR      r0,[r4,#0x30]
00001e  6248              STR      r0,[r1,#0x24]  ; hal_out
;;;332        hal_out.accel_status = sensor_cal->accel.status;
000020  6f60              LDR      r0,[r4,#0x74]
000022  6288              STR      r0,[r1,#0x28]  ; hal_out
;;;333        hal_out.compass_status = sensor_cal->compass.status;
000024  20b8              MOVS     r0,#0xb8
000026  5900              LDR      r0,[r0,r4]
000028  62c8              STR      r0,[r1,#0x2c]  ; hal_out
;;;334    
;;;335        // Find the highest sample rate and tie generating 9-axis to that one.
;;;336        if (sensor_cal->gyro.status & INV_SENSOR_ON) {
00002a  8e20              LDRH     r0,[r4,#0x30]
00002c  f4007080          AND      r0,r0,#0x100
000030  b108              CBZ      r0,|L4.54|
;;;337            sr = sensor_cal->gyro.sample_rate_ms;
000032  6ae6              LDR      r6,[r4,#0x2c]
;;;338            use_sensor = 0;
000034  bf00              NOP      
                  |L4.54|
;;;339        }
;;;340        if ((sensor_cal->accel.status & INV_SENSOR_ON) && (sr > sensor_cal->accel.sample_rate_ms)) {
000036  2074              MOVS     r0,#0x74
000038  5b00              LDRH     r0,[r0,r4]
00003a  f4007080          AND      r0,r0,#0x100
00003e  b120              CBZ      r0,|L4.74|
000040  6f20              LDR      r0,[r4,#0x70]
000042  42b0              CMP      r0,r6
000044  da01              BGE      |L4.74|
;;;341            sr = sensor_cal->accel.sample_rate_ms;
000046  6f26              LDR      r6,[r4,#0x70]
;;;342            use_sensor = 1;
000048  2701              MOVS     r7,#1
                  |L4.74|
;;;343        }
;;;344        if ((sensor_cal->compass.status & INV_SENSOR_ON) && (sr > sensor_cal->compass.sample_rate_ms)) {
00004a  20b8              MOVS     r0,#0xb8
00004c  5b00              LDRH     r0,[r0,r4]
00004e  f4007080          AND      r0,r0,#0x100
000052  b130              CBZ      r0,|L4.98|
000054  20b4              MOVS     r0,#0xb4
000056  5900              LDR      r0,[r0,r4]
000058  42b0              CMP      r0,r6
00005a  da02              BGE      |L4.98|
;;;345            sr = sensor_cal->compass.sample_rate_ms;
00005c  20b4              MOVS     r0,#0xb4
00005e  5906              LDR      r6,[r0,r4]
;;;346            use_sensor = 2;
000060  2702              MOVS     r7,#2
                  |L4.98|
;;;347        }
;;;348        if ((sensor_cal->quat.status & INV_SENSOR_ON) && (sr > sensor_cal->quat.sample_rate_ms)) {
000062  f44f7090          MOV      r0,#0x120
000066  5b00              LDRH     r0,[r0,r4]
000068  f4007080          AND      r0,r0,#0x100
00006c  b140              CBZ      r0,|L4.128|
00006e  f44f7096          MOV      r0,#0x12c
000072  5900              LDR      r0,[r0,r4]
000074  42b0              CMP      r0,r6
000076  da03              BGE      |L4.128|
;;;349            sr = sensor_cal->quat.sample_rate_ms;
000078  f44f7096          MOV      r0,#0x12c
00007c  5906              LDR      r6,[r0,r4]
;;;350            use_sensor = 3;
00007e  2703              MOVS     r7,#3
                  |L4.128|
;;;351        }
;;;352    
;;;353        // Only output 9-axis if all 9 sensors are on.
;;;354        if (sensor_cal->quat.status & INV_SENSOR_ON) {
000080  f44f7090          MOV      r0,#0x120
000084  5b00              LDRH     r0,[r0,r4]
000086  f4007080          AND      r0,r0,#0x100
00008a  b150              CBZ      r0,|L4.162|
;;;355            // If quaternion sensor is on, gyros are not required as quaternion already has that part
;;;356            if ((sensor_cal->accel.status & sensor_cal->compass.status & INV_SENSOR_ON) == 0) {
00008c  2074              MOVS     r0,#0x74
00008e  5b00              LDRH     r0,[r0,r4]
000090  21b8              MOVS     r1,#0xb8
000092  5b09              LDRH     r1,[r1,r4]
000094  4008              ANDS     r0,r0,r1
000096  f4007080          AND      r0,r0,#0x100
00009a  b970              CBNZ     r0,|L4.186|
;;;357                use_sensor = -1;
00009c  f04f37ff          MOV      r7,#0xffffffff
0000a0  e00b              B        |L4.186|
                  |L4.162|
;;;358            }
;;;359        } else {
;;;360            if ((sensor_cal->gyro.status & sensor_cal->accel.status & sensor_cal->compass.status & INV_SENSOR_ON) == 0) {
0000a2  8e20              LDRH     r0,[r4,#0x30]
0000a4  2174              MOVS     r1,#0x74
0000a6  5b09              LDRH     r1,[r1,r4]
0000a8  4008              ANDS     r0,r0,r1
0000aa  21b8              MOVS     r1,#0xb8
0000ac  5b09              LDRH     r1,[r1,r4]
0000ae  4008              ANDS     r0,r0,r1
0000b0  f4007080          AND      r0,r0,#0x100
0000b4  b908              CBNZ     r0,|L4.186|
;;;361                use_sensor = -1;
0000b6  f04f37ff          MOV      r7,#0xffffffff
                  |L4.186|
;;;362            }
;;;363        }
;;;364    
;;;365        switch (use_sensor) {
0000ba  b137              CBZ      r7,|L4.202|
0000bc  2f01              CMP      r7,#1
0000be  d00e              BEQ      |L4.222|
0000c0  2f02              CMP      r7,#2
0000c2  d016              BEQ      |L4.242|
0000c4  2f03              CMP      r7,#3
0000c6  d12c              BNE      |L4.290|
0000c8  e01e              B        |L4.264|
                  |L4.202|
;;;366        case 0:
;;;367            hal_out.nine_axis_status = (sensor_cal->gyro.status & INV_NEW_DATA) ? 1 : 0;
0000ca  f8940030          LDRB     r0,[r4,#0x30]
0000ce  f3c01080          UBFX     r0,r0,#6,#1
0000d2  494b              LDR      r1,|L4.512|
0000d4  3908              SUBS     r1,r1,#8
0000d6  6308              STR      r0,[r1,#0x30]  ; hal_out
;;;368            hal_out.nav_timestamp = sensor_cal->gyro.timestamp;
0000d8  6ba0              LDR      r0,[r4,#0x38]
0000da  6088              STR      r0,[r1,#8]  ; hal_out
;;;369            break;
0000dc  e026              B        |L4.300|
                  |L4.222|
;;;370        case 1:
;;;371            hal_out.nine_axis_status = (sensor_cal->accel.status & INV_NEW_DATA) ? 1 : 0;
0000de  f8940074          LDRB     r0,[r4,#0x74]
0000e2  f3c01080          UBFX     r0,r0,#6,#1
0000e6  4946              LDR      r1,|L4.512|
0000e8  3908              SUBS     r1,r1,#8
0000ea  6308              STR      r0,[r1,#0x30]  ; hal_out
;;;372            hal_out.nav_timestamp = sensor_cal->accel.timestamp;
0000ec  6fe0              LDR      r0,[r4,#0x7c]
0000ee  6088              STR      r0,[r1,#8]  ; hal_out
;;;373            break;
0000f0  e01c              B        |L4.300|
                  |L4.242|
;;;374        case 2:
;;;375            hal_out.nine_axis_status = (sensor_cal->compass.status & INV_NEW_DATA) ? 1 : 0;
0000f2  f89400b8          LDRB     r0,[r4,#0xb8]
0000f6  f3c01080          UBFX     r0,r0,#6,#1
0000fa  4941              LDR      r1,|L4.512|
0000fc  3908              SUBS     r1,r1,#8
0000fe  6308              STR      r0,[r1,#0x30]  ; hal_out
;;;376            hal_out.nav_timestamp = sensor_cal->compass.timestamp;
000100  20c0              MOVS     r0,#0xc0
000102  5900              LDR      r0,[r0,r4]
000104  6088              STR      r0,[r1,#8]  ; hal_out
;;;377            break;
000106  e011              B        |L4.300|
                  |L4.264|
;;;378        case 3:
;;;379            hal_out.nine_axis_status = (sensor_cal->quat.status & INV_NEW_DATA) ? 1 : 0;
000108  f44f7090          MOV      r0,#0x120
00010c  5d00              LDRB     r0,[r0,r4]
00010e  f3c01080          UBFX     r0,r0,#6,#1
000112  493b              LDR      r1,|L4.512|
000114  3908              SUBS     r1,r1,#8
000116  6308              STR      r0,[r1,#0x30]  ; hal_out
;;;380            hal_out.nav_timestamp = sensor_cal->quat.timestamp;
000118  f44f7092          MOV      r0,#0x124
00011c  5900              LDR      r0,[r0,r4]
00011e  6088              STR      r0,[r1,#8]  ; hal_out
;;;381            break;
000120  e004              B        |L4.300|
                  |L4.290|
;;;382        default:
;;;383            hal_out.nine_axis_status = 0; // Don't output quaternion related info
000122  2000              MOVS     r0,#0
000124  4936              LDR      r1,|L4.512|
000126  3908              SUBS     r1,r1,#8
000128  6308              STR      r0,[r1,#0x30]  ; hal_out
;;;384            break;
00012a  bf00              NOP      
                  |L4.300|
00012c  bf00              NOP                            ;369
;;;385        }
;;;386    
;;;387        /* Converts fixed point to uT. Fixed point has 1 uT = 2^16.
;;;388         * So this is: 1 / 2^16*/
;;;389        #define COMPASS_CONVERSION 1.52587890625e-005f
;;;390    
;;;391        inv_get_compass_set(compass, &accuracy, &(hal_out.mag_timestamp) );
00012e  4a34              LDR      r2,|L4.512|
000130  3208              ADDS     r2,r2,#8
000132  4669              MOV      r1,sp
000134  a801              ADD      r0,sp,#4
000136  f7fffffe          BL       inv_get_compass_set
;;;392        hal_out.accuracy_mag = (int ) accuracy;
00013a  f99d0000          LDRSB    r0,[sp,#0]
00013e  4930              LDR      r1,|L4.512|
000140  3908              SUBS     r1,r1,#8
000142  6008              STR      r0,[r1,#0]  ; hal_out
;;;393    
;;;394        for (i=0; i<3; i++) {
000144  2500              MOVS     r5,#0
000146  e054              B        |L4.498|
                  |L4.328|
;;;395            if ((sensor_cal->compass.status & (INV_NEW_DATA | INV_CONTIGUOUS)) ==
000148  f89400b8          LDRB     r0,[r4,#0xb8]
00014c  f0000050          AND      r0,r0,#0x50
000150  2840              CMP      r0,#0x40
000152  d112              BNE      |L4.378|
;;;396                                                                 INV_NEW_DATA )  {
;;;397                // set the state variables to match output with input
;;;398                inv_calc_state_to_match_output(&hal_out.lp_filter[i], (float ) compass[i]);
000154  a901              ADD      r1,sp,#4
000156  f8511025          LDR      r1,[r1,r5,LSL #2]
00015a  ee001a90          VMOV     s1,r1
00015e  eef80ae0          VCVT.F32.S32 s1,s1
000162  eeb00a60          VMOV.F32 s0,s1
000166  eb050145          ADD      r1,r5,r5,LSL #1
00016a  eb0102c5          ADD      r2,r1,r5,LSL #3
00016e  4924              LDR      r1,|L4.512|
000170  312c              ADDS     r1,r1,#0x2c
000172  eb010082          ADD      r0,r1,r2,LSL #2
000176  f7fffffe          BL       inv_calc_state_to_match_output
                  |L4.378|
;;;399            }
;;;400    
;;;401            if ((sensor_cal->compass.status & (INV_NEW_DATA | INV_RAW_DATA)) ==
00017a  f89400b8          LDRB     r0,[r4,#0xb8]
00017e  f00000c0          AND      r0,r0,#0xc0
000182  28c0              CMP      r0,#0xc0
000184  d11d              BNE      |L4.450|
;;;402                                             (INV_NEW_DATA | INV_RAW_DATA)   )  {
;;;403    
;;;404                hal_out.compass_float[i] = inv_biquad_filter_process(&hal_out.lp_filter[i],
000186  a901              ADD      r1,sp,#4
000188  f8511025          LDR      r1,[r1,r5,LSL #2]
00018c  ee001a90          VMOV     s1,r1
000190  eef80ae0          VCVT.F32.S32 s1,s1
000194  eeb00a60          VMOV.F32 s0,s1
000198  eb050145          ADD      r1,r5,r5,LSL #1
00019c  eb0102c5          ADD      r2,r1,r5,LSL #3
0001a0  4917              LDR      r1,|L4.512|
0001a2  312c              ADDS     r1,r1,#0x2c
0001a4  eb010082          ADD      r0,r1,r2,LSL #2
0001a8  f7fffffe          BL       inv_biquad_filter_process
0001ac  eddf0a15          VLDR     s1,|L4.516|
0001b0  ee200a20          VMUL.F32 s0,s0,s1
0001b4  4812              LDR      r0,|L4.512|
0001b6  30b0              ADDS     r0,r0,#0xb0
0001b8  eb000085          ADD      r0,r0,r5,LSL #2
0001bc  ed800a00          VSTR     s0,[r0,#0]
0001c0  e016              B        |L4.496|
                  |L4.450|
;;;405                                               (float ) compass[i]) * COMPASS_CONVERSION;
;;;406    
;;;407            } else if ((sensor_cal->compass.status & INV_NEW_DATA) == INV_NEW_DATA )  {
0001c2  f89400b8          LDRB     r0,[r4,#0xb8]
0001c6  f0000040          AND      r0,r0,#0x40
0001ca  2840              CMP      r0,#0x40
0001cc  d110              BNE      |L4.496|
;;;408                hal_out.compass_float[i] = (float ) compass[i] * COMPASS_CONVERSION;
0001ce  a801              ADD      r0,sp,#4
0001d0  f8500025          LDR      r0,[r0,r5,LSL #2]
0001d4  ee000a10          VMOV     s0,r0
0001d8  eeb80ac0          VCVT.F32.S32 s0,s0
0001dc  eddf0a09          VLDR     s1,|L4.516|
0001e0  ee200a20          VMUL.F32 s0,s0,s1
0001e4  4806              LDR      r0,|L4.512|
0001e6  30b0              ADDS     r0,r0,#0xb0
0001e8  eb000085          ADD      r0,r0,r5,LSL #2
0001ec  ed800a00          VSTR     s0,[r0,#0]
                  |L4.496|
0001f0  1c6d              ADDS     r5,r5,#1              ;394
                  |L4.498|
0001f2  2d03              CMP      r5,#3                 ;394
0001f4  dba8              BLT      |L4.328|
;;;409            }
;;;410    
;;;411        }
;;;412        return INV_SUCCESS;
0001f6  2000              MOVS     r0,#0
;;;413    }
0001f8  b004              ADD      sp,sp,#0x10
0001fa  e8bd81f0          POP      {r4-r8,pc}
;;;414    
                          ENDP

0001fe  0000              DCW      0x0000
                  |L4.512|
                          DCD      hal_out+0x8
                  |L4.516|
000204  37800000          DCFS     0x37800000 ; 1.52587890625e-05

                          AREA ||i.inv_get_rotation||, CODE, READONLY, ALIGN=2

                  inv_get_rotation PROC
;;;250    
;;;251    static void inv_get_rotation(float r[3][3])
000000  b510              PUSH     {r4,lr}
;;;252    {
000002  ed2d8b02          VPUSH    {d8}
000006  b08a              SUB      sp,sp,#0x28
000008  4604              MOV      r4,r0
;;;253        long rot[9];
;;;254        float conv = 1.f / (1L<<30);
00000a  ed9f0a2a          VLDR     s0,|L5.180|
00000e  eeb08a40          VMOV.F32 s16,s0
;;;255    
;;;256        inv_quaternion_to_rotation(hal_out.nav_quat, rot);
000012  a901              ADD      r1,sp,#4
000014  4828              LDR      r0,|L5.184|
000016  f7fffffe          BL       inv_quaternion_to_rotation
;;;257        r[0][0] = rot[0]*conv;
00001a  ed9d0a01          VLDR     s0,[sp,#4]
00001e  eeb80ac0          VCVT.F32.S32 s0,s0
000022  ee200a08          VMUL.F32 s0,s0,s16
000026  ed840a00          VSTR     s0,[r4,#0]
;;;258        r[0][1] = rot[1]*conv;
00002a  ed9d0a02          VLDR     s0,[sp,#8]
00002e  eeb80ac0          VCVT.F32.S32 s0,s0
000032  ee200a08          VMUL.F32 s0,s0,s16
000036  ed840a01          VSTR     s0,[r4,#4]
;;;259        r[0][2] = rot[2]*conv;
00003a  ed9d0a03          VLDR     s0,[sp,#0xc]
00003e  eeb80ac0          VCVT.F32.S32 s0,s0
000042  ee200a08          VMUL.F32 s0,s0,s16
000046  ed840a02          VSTR     s0,[r4,#8]
;;;260        r[1][0] = rot[3]*conv;
00004a  ed9d0a04          VLDR     s0,[sp,#0x10]
00004e  eeb80ac0          VCVT.F32.S32 s0,s0
000052  ee200a08          VMUL.F32 s0,s0,s16
000056  ed840a03          VSTR     s0,[r4,#0xc]
;;;261        r[1][1] = rot[4]*conv;
00005a  ed9d0a05          VLDR     s0,[sp,#0x14]
00005e  eeb80ac0          VCVT.F32.S32 s0,s0
000062  ee200a08          VMUL.F32 s0,s0,s16
000066  ed840a04          VSTR     s0,[r4,#0x10]
;;;262        r[1][2] = rot[5]*conv;
00006a  ed9d0a06          VLDR     s0,[sp,#0x18]
00006e  eeb80ac0          VCVT.F32.S32 s0,s0
000072  ee200a08          VMUL.F32 s0,s0,s16
000076  ed840a05          VSTR     s0,[r4,#0x14]
;;;263        r[2][0] = rot[6]*conv;
00007a  ed9d0a07          VLDR     s0,[sp,#0x1c]
00007e  eeb80ac0          VCVT.F32.S32 s0,s0
000082  ee200a08          VMUL.F32 s0,s0,s16
000086  ed840a06          VSTR     s0,[r4,#0x18]
;;;264        r[2][1] = rot[7]*conv;
00008a  ed9d0a08          VLDR     s0,[sp,#0x20]
00008e  eeb80ac0          VCVT.F32.S32 s0,s0
000092  ee200a08          VMUL.F32 s0,s0,s16
000096  ed840a07          VSTR     s0,[r4,#0x1c]
;;;265        r[2][2] = rot[8]*conv;
00009a  ed9d0a09          VLDR     s0,[sp,#0x24]
00009e  eeb80ac0          VCVT.F32.S32 s0,s0
0000a2  ee200a08          VMUL.F32 s0,s0,s16
0000a6  ed840a08          VSTR     s0,[r4,#0x20]
;;;266    }
0000aa  b00a              ADD      sp,sp,#0x28
0000ac  ecbd8b02          VPOP     {d8}
0000b0  bd10              POP      {r4,pc}
;;;267    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L5.180|
0000b4  30800000          DCFS     0x30800000 ; 9.3132257461547852e-10
                  |L5.184|
                          DCD      hal_out+0x14

                          AREA ||i.inv_get_sensor_type_accelerometer||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_accelerometer PROC
;;;56     */
;;;57     int inv_get_sensor_type_accelerometer(float *values, int8_t *accuracy,
000000  b5fe              PUSH     {r1-r7,lr}
;;;58                                            inv_time_t * timestamp)
;;;59     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;60         int status;
;;;61         /* Converts fixed point to m/s^2. Fixed point has 1g = 2^16.
;;;62          * So this 9.80665 / 2^16 */
;;;63     #define ACCEL_CONVERSION 0.000149637603759766f
;;;64         long accel[3];
;;;65         inv_get_accel_set(accel, accuracy, timestamp);
000008  463a              MOV      r2,r7
00000a  4631              MOV      r1,r6
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       inv_get_accel_set
;;;66         values[0] = accel[0] * ACCEL_CONVERSION;
000012  ed9d0a00          VLDR     s0,[sp,#0]
000016  eeb80ac0          VCVT.F32.S32 s0,s0
00001a  eddf0a12          VLDR     s1,|L6.100|
00001e  ee200a20          VMUL.F32 s0,s0,s1
000022  ed840a00          VSTR     s0,[r4,#0]
;;;67         values[1] = accel[1] * ACCEL_CONVERSION;
000026  ed9d0a01          VLDR     s0,[sp,#4]
00002a  eeb80ac0          VCVT.F32.S32 s0,s0
00002e  eddf0a0d          VLDR     s1,|L6.100|
000032  ee200a20          VMUL.F32 s0,s0,s1
000036  ed840a01          VSTR     s0,[r4,#4]
;;;68         values[2] = accel[2] * ACCEL_CONVERSION;
00003a  ed9d0a02          VLDR     s0,[sp,#8]
00003e  eeb80ac0          VCVT.F32.S32 s0,s0
000042  eddf0a08          VLDR     s1,|L6.100|
000046  ee200a20          VMUL.F32 s0,s0,s1
00004a  ed840a02          VSTR     s0,[r4,#8]
;;;69         if (hal_out.accel_status & INV_NEW_DATA)
00004e  4806              LDR      r0,|L6.104|
000050  f8900028          LDRB     r0,[r0,#0x28]  ; hal_out
000054  f0000040          AND      r0,r0,#0x40
000058  b108              CBZ      r0,|L6.94|
;;;70             status = 1;
00005a  2501              MOVS     r5,#1
00005c  e000              B        |L6.96|
                  |L6.94|
;;;71         else
;;;72             status = 0;
00005e  2500              MOVS     r5,#0
                  |L6.96|
;;;73         return status;
000060  4628              MOV      r0,r5
;;;74     }
000062  bdfe              POP      {r1-r7,pc}
;;;75     
                          ENDP

                  |L6.100|
000064  391ce80a          DCFS     0x391ce80a ; 0.00014963760622777045
                  |L6.104|
                          DCD      hal_out

                          AREA ||i.inv_get_sensor_type_gravity||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_gravity PROC
;;;107    */
;;;108    int inv_get_sensor_type_gravity(float *values, int8_t *accuracy,
000000  b5fe              PUSH     {r1-r7,lr}
;;;109                                     inv_time_t * timestamp)
;;;110    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;111        long gravity[3];
;;;112    
;;;113        *accuracy = (int8_t) hal_out.accuracy_quat;
000008  4817              LDR      r0,|L7.104|
00000a  7900              LDRB     r0,[r0,#4]  ; hal_out
00000c  b240              SXTB     r0,r0
00000e  7028              STRB     r0,[r5,#0]
;;;114        *timestamp = hal_out.nav_timestamp;
000010  4815              LDR      r0,|L7.104|
000012  6880              LDR      r0,[r0,#8]  ; hal_out
000014  6030              STR      r0,[r6,#0]
;;;115        inv_get_gravity(gravity);
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       inv_get_gravity
;;;116        values[0] = (gravity[0] >> 14) * ACCEL_CONVERSION;
00001c  9800              LDR      r0,[sp,#0]
00001e  1380              ASRS     r0,r0,#14
000020  ee000a10          VMOV     s0,r0
000024  eeb80ac0          VCVT.F32.S32 s0,s0
000028  eddf0a10          VLDR     s1,|L7.108|
00002c  ee200a20          VMUL.F32 s0,s0,s1
000030  ed840a00          VSTR     s0,[r4,#0]
;;;117        values[1] = (gravity[1] >> 14) * ACCEL_CONVERSION;
000034  9801              LDR      r0,[sp,#4]
000036  1380              ASRS     r0,r0,#14
000038  ee000a10          VMOV     s0,r0
00003c  eeb80ac0          VCVT.F32.S32 s0,s0
000040  eddf0a0a          VLDR     s1,|L7.108|
000044  ee200a20          VMUL.F32 s0,s0,s1
000048  ed840a01          VSTR     s0,[r4,#4]
;;;118        values[2] = (gravity[2] >> 14) * ACCEL_CONVERSION;
00004c  9802              LDR      r0,[sp,#8]
00004e  1380              ASRS     r0,r0,#14
000050  ee000a10          VMOV     s0,r0
000054  eeb80ac0          VCVT.F32.S32 s0,s0
000058  eddf0a04          VLDR     s1,|L7.108|
00005c  ee200a20          VMUL.F32 s0,s0,s1
000060  ed840a02          VSTR     s0,[r4,#8]
;;;119    
;;;120        return 1;
000064  2001              MOVS     r0,#1
;;;121    }
000066  bdfe              POP      {r1-r7,pc}
;;;122    
                          ENDP

                  |L7.104|
                          DCD      hal_out
                  |L7.108|
00006c  391ce80a          DCFS     0x391ce80a ; 0.00014963760622777045

                          AREA ||i.inv_get_sensor_type_gyroscope||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_gyroscope PROC
;;;133    */
;;;134    int inv_get_sensor_type_gyroscope(float *values, int8_t *accuracy,
000000  b5fe              PUSH     {r1-r7,lr}
;;;135                                       inv_time_t * timestamp)
;;;136    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;137        long gyro[3];
;;;138        int status;
;;;139    
;;;140        inv_get_gyro_set(gyro, accuracy, timestamp);
000008  463a              MOV      r2,r7
00000a  4631              MOV      r1,r6
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       inv_get_gyro_set
;;;141        values[0] = gyro[0] * GYRO_CONVERSION;
000012  ed9d0a00          VLDR     s0,[sp,#0]
000016  eeb80ac0          VCVT.F32.S32 s0,s0
00001a  eddf0a12          VLDR     s1,|L8.100|
00001e  ee200a20          VMUL.F32 s0,s0,s1
000022  ed840a00          VSTR     s0,[r4,#0]
;;;142        values[1] = gyro[1] * GYRO_CONVERSION;
000026  ed9d0a01          VLDR     s0,[sp,#4]
00002a  eeb80ac0          VCVT.F32.S32 s0,s0
00002e  eddf0a0d          VLDR     s1,|L8.100|
000032  ee200a20          VMUL.F32 s0,s0,s1
000036  ed840a01          VSTR     s0,[r4,#4]
;;;143        values[2] = gyro[2] * GYRO_CONVERSION;
00003a  ed9d0a02          VLDR     s0,[sp,#8]
00003e  eeb80ac0          VCVT.F32.S32 s0,s0
000042  eddf0a08          VLDR     s1,|L8.100|
000046  ee200a20          VMUL.F32 s0,s0,s1
00004a  ed840a02          VSTR     s0,[r4,#8]
;;;144        if (hal_out.gyro_status & INV_NEW_DATA)
00004e  4806              LDR      r0,|L8.104|
000050  f8900024          LDRB     r0,[r0,#0x24]  ; hal_out
000054  f0000040          AND      r0,r0,#0x40
000058  b108              CBZ      r0,|L8.94|
;;;145            status = 1;
00005a  2501              MOVS     r5,#1
00005c  e000              B        |L8.96|
                  |L8.94|
;;;146        else
;;;147            status = 0;
00005e  2500              MOVS     r5,#0
                  |L8.96|
;;;148        return status;
000060  4628              MOV      r0,r5
;;;149    }
000062  bdfe              POP      {r1-r7,pc}
;;;150    
                          ENDP

                  |L8.100|
000064  348efa35          DCFS     0x348efa35 ; 2.6631610694494157e-07
                  |L8.104|
                          DCD      hal_out

                          AREA ||i.inv_get_sensor_type_gyroscope_raw||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_gyroscope_raw PROC
;;;157    */
;;;158    int inv_get_sensor_type_gyroscope_raw(float *values, int8_t *accuracy,
000000  b5fe              PUSH     {r1-r7,lr}
;;;159                                       inv_time_t * timestamp)
;;;160    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;161        long gyro[3];
;;;162        int status;
;;;163    
;;;164        inv_get_gyro_set_raw(gyro, accuracy, timestamp);
000008  463a              MOV      r2,r7
00000a  4631              MOV      r1,r6
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       inv_get_gyro_set_raw
;;;165        values[0] = gyro[0] * GYRO_CONVERSION;
000012  ed9d0a00          VLDR     s0,[sp,#0]
000016  eeb80ac0          VCVT.F32.S32 s0,s0
00001a  eddf0a12          VLDR     s1,|L9.100|
00001e  ee200a20          VMUL.F32 s0,s0,s1
000022  ed840a00          VSTR     s0,[r4,#0]
;;;166        values[1] = gyro[1] * GYRO_CONVERSION;
000026  ed9d0a01          VLDR     s0,[sp,#4]
00002a  eeb80ac0          VCVT.F32.S32 s0,s0
00002e  eddf0a0d          VLDR     s1,|L9.100|
000032  ee200a20          VMUL.F32 s0,s0,s1
000036  ed840a01          VSTR     s0,[r4,#4]
;;;167        values[2] = gyro[2] * GYRO_CONVERSION;
00003a  ed9d0a02          VLDR     s0,[sp,#8]
00003e  eeb80ac0          VCVT.F32.S32 s0,s0
000042  eddf0a08          VLDR     s1,|L9.100|
000046  ee200a20          VMUL.F32 s0,s0,s1
00004a  ed840a02          VSTR     s0,[r4,#8]
;;;168        if (hal_out.gyro_status & INV_NEW_DATA)
00004e  4806              LDR      r0,|L9.104|
000050  f8900024          LDRB     r0,[r0,#0x24]  ; hal_out
000054  f0000040          AND      r0,r0,#0x40
000058  b108              CBZ      r0,|L9.94|
;;;169            status = 1;
00005a  2501              MOVS     r5,#1
00005c  e000              B        |L9.96|
                  |L9.94|
;;;170        else
;;;171            status = 0;
00005e  2500              MOVS     r5,#0
                  |L9.96|
;;;172        return status;
000060  4628              MOV      r0,r5
;;;173    }
000062  bdfe              POP      {r1-r7,pc}
;;;174    
                          ENDP

                  |L9.100|
000064  348efa35          DCFS     0x348efa35 ; 2.6631610694494157e-07
                  |L9.104|
                          DCD      hal_out

                          AREA ||i.inv_get_sensor_type_linear_acceleration||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_linear_acceleration PROC
;;;83     */
;;;84     int inv_get_sensor_type_linear_acceleration(float *values, int8_t *accuracy,
000000  b570              PUSH     {r4-r6,lr}
;;;85             inv_time_t * timestamp)
;;;86     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;87         long gravity[3], accel[3];
;;;88     
;;;89         inv_get_accel_set(accel, accuracy, timestamp);
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       inv_get_accel_set
;;;90         inv_get_gravity(gravity);
000014  a803              ADD      r0,sp,#0xc
000016  f7fffffe          BL       inv_get_gravity
;;;91         accel[0] -= gravity[0] >> 14;
00001a  9903              LDR      r1,[sp,#0xc]
00001c  9800              LDR      r0,[sp,#0]
00001e  eba030a1          SUB      r0,r0,r1,ASR #14
000022  9000              STR      r0,[sp,#0]
;;;92         accel[1] -= gravity[1] >> 14;
000024  9904              LDR      r1,[sp,#0x10]
000026  9801              LDR      r0,[sp,#4]
000028  eba030a1          SUB      r0,r0,r1,ASR #14
00002c  9001              STR      r0,[sp,#4]
;;;93         accel[2] -= gravity[2] >> 14;
00002e  9905              LDR      r1,[sp,#0x14]
000030  9802              LDR      r0,[sp,#8]
000032  eba030a1          SUB      r0,r0,r1,ASR #14
000036  9002              STR      r0,[sp,#8]
;;;94         values[0] = accel[0] * ACCEL_CONVERSION;
000038  ed9d0a00          VLDR     s0,[sp,#0]
00003c  eeb80ac0          VCVT.F32.S32 s0,s0
000040  eddf0a0e          VLDR     s1,|L10.124|
000044  ee200a20          VMUL.F32 s0,s0,s1
000048  ed840a00          VSTR     s0,[r4,#0]
;;;95         values[1] = accel[1] * ACCEL_CONVERSION;
00004c  ed9d0a01          VLDR     s0,[sp,#4]
000050  eeb80ac0          VCVT.F32.S32 s0,s0
000054  eddf0a09          VLDR     s1,|L10.124|
000058  ee200a20          VMUL.F32 s0,s0,s1
00005c  ed840a01          VSTR     s0,[r4,#4]
;;;96         values[2] = accel[2] * ACCEL_CONVERSION;
000060  ed9d0a02          VLDR     s0,[sp,#8]
000064  eeb80ac0          VCVT.F32.S32 s0,s0
000068  eddf0a04          VLDR     s1,|L10.124|
00006c  ee200a20          VMUL.F32 s0,s0,s1
000070  ed840a02          VSTR     s0,[r4,#8]
;;;97     
;;;98         return 1;
000074  2001              MOVS     r0,#1
;;;99     }
000076  b006              ADD      sp,sp,#0x18
000078  bd70              POP      {r4-r6,pc}
;;;100    
                          ENDP

00007a  0000              DCW      0x0000
                  |L10.124|
00007c  391ce80a          DCFS     0x391ce80a ; 0.00014963760622777045

                          AREA ||i.inv_get_sensor_type_magnetic_field||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_magnetic_field PROC
;;;227    */
;;;228    int inv_get_sensor_type_magnetic_field(float *values, int8_t *accuracy,
000000  b570              PUSH     {r4-r6,lr}
;;;229                                            inv_time_t * timestamp)
;;;230    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;231        int status;
;;;232        /* Converts fixed point to uT. Fixed point has 1 uT = 2^16.
;;;233         * So this is: 1 / 2^16*/
;;;234    //#define COMPASS_CONVERSION 1.52587890625e-005f
;;;235        int i;
;;;236    
;;;237        *timestamp = hal_out.mag_timestamp;
000006  4d11              LDR      r5,|L11.76|
000008  692d              LDR      r5,[r5,#0x10]  ; hal_out
00000a  6015              STR      r5,[r2,#0]
;;;238        *accuracy = (int8_t) hal_out.accuracy_mag;
00000c  4d0f              LDR      r5,|L11.76|
00000e  782d              LDRB     r5,[r5,#0]  ; hal_out
000010  b26d              SXTB     r5,r5
000012  7025              STRB     r5,[r4,#0]
;;;239    
;;;240        for (i=0; i<3; i++)  {
000014  2100              MOVS     r1,#0
000016  e00a              B        |L11.46|
                  |L11.24|
;;;241            values[i] = hal_out.compass_float[i];
000018  4d0c              LDR      r5,|L11.76|
00001a  35b8              ADDS     r5,r5,#0xb8
00001c  eb050581          ADD      r5,r5,r1,LSL #2
000020  ed950a00          VLDR     s0,[r5,#0]
000024  eb030581          ADD      r5,r3,r1,LSL #2
000028  ed850a00          VSTR     s0,[r5,#0]
00002c  1c49              ADDS     r1,r1,#1              ;240
                  |L11.46|
00002e  2903              CMP      r1,#3                 ;240
000030  dbf2              BLT      |L11.24|
;;;242        }
;;;243        if (hal_out.compass_status & INV_NEW_DATA)
000032  4d06              LDR      r5,|L11.76|
000034  f895502c          LDRB     r5,[r5,#0x2c]  ; hal_out
000038  f0050540          AND      r5,r5,#0x40
00003c  b10d              CBZ      r5,|L11.66|
;;;244            status = 1;
00003e  2001              MOVS     r0,#1
000040  e000              B        |L11.68|
                  |L11.66|
;;;245        else
;;;246            status = 0;
000042  2000              MOVS     r0,#0
                  |L11.68|
;;;247        hal_out.compass_status = 0;
000044  2500              MOVS     r5,#0
000046  4e01              LDR      r6,|L11.76|
000048  62f5              STR      r5,[r6,#0x2c]  ; hal_out
;;;248        return status;
;;;249    }
00004a  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

                  |L11.76|
                          DCD      hal_out

                          AREA ||i.inv_get_sensor_type_orientation||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_orientation PROC
;;;303    */
;;;304    int inv_get_sensor_type_orientation(float *values, int8_t *accuracy,
000000  b570              PUSH     {r4-r6,lr}
;;;305                                         inv_time_t * timestamp)
;;;306    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;307        *accuracy = (int8_t) hal_out.accuracy_quat;
000008  4806              LDR      r0,|L12.36|
00000a  7900              LDRB     r0,[r0,#4]  ; hal_out
00000c  b240              SXTB     r0,r0
00000e  7020              STRB     r0,[r4,#0]
;;;308        *timestamp = hal_out.nav_timestamp;
000010  4804              LDR      r0,|L12.36|
000012  6880              LDR      r0,[r0,#8]  ; hal_out
000014  6028              STR      r0,[r5,#0]
;;;309    
;;;310        google_orientation(values);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       google_orientation
;;;311    
;;;312        return hal_out.nine_axis_status;
00001c  4801              LDR      r0,|L12.36|
00001e  6b00              LDR      r0,[r0,#0x30]  ; hal_out
;;;313    }
000020  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      hal_out

                          AREA ||i.inv_get_sensor_type_rotation_vector||, CODE, READONLY, ALIGN=2

                  inv_get_sensor_type_rotation_vector PROC
;;;198    */
;;;199    int inv_get_sensor_type_rotation_vector(float *values, int8_t *accuracy,
000000  b570              PUSH     {r4-r6,lr}
;;;200            inv_time_t * timestamp)
;;;201    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;202        *accuracy = (int8_t) hal_out.accuracy_quat;
000008  4837              LDR      r0,|L13.232|
00000a  7900              LDRB     r0,[r0,#4]  ; hal_out
00000c  b240              SXTB     r0,r0
00000e  7028              STRB     r0,[r5,#0]
;;;203        *timestamp = hal_out.nav_timestamp;
000010  4835              LDR      r0,|L13.232|
000012  6880              LDR      r0,[r0,#8]  ; hal_out
000014  6030              STR      r0,[r6,#0]
;;;204    
;;;205        if (hal_out.nav_quat[0] >= 0) {
000016  4834              LDR      r0,|L13.232|
000018  6940              LDR      r0,[r0,#0x14]  ; hal_out
00001a  2800              CMP      r0,#0
00001c  db29              BLT      |L13.114|
;;;206            values[0] = hal_out.nav_quat[1] * INV_TWO_POWER_NEG_30;
00001e  4832              LDR      r0,|L13.232|
000020  ed900a06          VLDR     s0,[r0,#0x18]
000024  eeb80ac0          VCVT.F32.S32 s0,s0
000028  eddf0a30          VLDR     s1,|L13.236|
00002c  ee200a20          VMUL.F32 s0,s0,s1
000030  ed840a00          VSTR     s0,[r4,#0]
;;;207            values[1] = hal_out.nav_quat[2] * INV_TWO_POWER_NEG_30;
000034  ed900a07          VLDR     s0,[r0,#0x1c]
000038  eeb80ac0          VCVT.F32.S32 s0,s0
00003c  eddf0a2b          VLDR     s1,|L13.236|
000040  ee200a20          VMUL.F32 s0,s0,s1
000044  ed840a01          VSTR     s0,[r4,#4]
;;;208            values[2] = hal_out.nav_quat[3] * INV_TWO_POWER_NEG_30;
000048  ed900a08          VLDR     s0,[r0,#0x20]
00004c  eeb80ac0          VCVT.F32.S32 s0,s0
000050  eddf0a26          VLDR     s1,|L13.236|
000054  ee200a20          VMUL.F32 s0,s0,s1
000058  ed840a02          VSTR     s0,[r4,#8]
;;;209            values[3] = hal_out.nav_quat[0] * INV_TWO_POWER_NEG_30;
00005c  ed900a05          VLDR     s0,[r0,#0x14]
000060  eeb80ac0          VCVT.F32.S32 s0,s0
000064  eddf0a21          VLDR     s1,|L13.236|
000068  ee200a20          VMUL.F32 s0,s0,s1
00006c  ed840a03          VSTR     s0,[r4,#0xc]
000070  e033              B        |L13.218|
                  |L13.114|
;;;210        } else {
;;;211            values[0] = -hal_out.nav_quat[1] * INV_TWO_POWER_NEG_30;
000072  481d              LDR      r0,|L13.232|
000074  6980              LDR      r0,[r0,#0x18]
000076  4240              RSBS     r0,r0,#0
000078  ee000a10          VMOV     s0,r0
00007c  eeb80ac0          VCVT.F32.S32 s0,s0
000080  eddf0a1a          VLDR     s1,|L13.236|
000084  ee200a20          VMUL.F32 s0,s0,s1
000088  ed840a00          VSTR     s0,[r4,#0]
;;;212            values[1] = -hal_out.nav_quat[2] * INV_TWO_POWER_NEG_30;
00008c  4816              LDR      r0,|L13.232|
00008e  69c0              LDR      r0,[r0,#0x1c]
000090  4240              RSBS     r0,r0,#0
000092  ee000a10          VMOV     s0,r0
000096  eeb80ac0          VCVT.F32.S32 s0,s0
00009a  eddf0a14          VLDR     s1,|L13.236|
00009e  ee200a20          VMUL.F32 s0,s0,s1
0000a2  ed840a01          VSTR     s0,[r4,#4]
;;;213            values[2] = -hal_out.nav_quat[3] * INV_TWO_POWER_NEG_30;
0000a6  4810              LDR      r0,|L13.232|
0000a8  6a00              LDR      r0,[r0,#0x20]
0000aa  4240              RSBS     r0,r0,#0
0000ac  ee000a10          VMOV     s0,r0
0000b0  eeb80ac0          VCVT.F32.S32 s0,s0
0000b4  eddf0a0d          VLDR     s1,|L13.236|
0000b8  ee200a20          VMUL.F32 s0,s0,s1
0000bc  ed840a02          VSTR     s0,[r4,#8]
;;;214            values[3] = -hal_out.nav_quat[0] * INV_TWO_POWER_NEG_30;
0000c0  4809              LDR      r0,|L13.232|
0000c2  6940              LDR      r0,[r0,#0x14]  ; hal_out
0000c4  4240              RSBS     r0,r0,#0
0000c6  ee000a10          VMOV     s0,r0
0000ca  eeb80ac0          VCVT.F32.S32 s0,s0
0000ce  eddf0a07          VLDR     s1,|L13.236|
0000d2  ee200a20          VMUL.F32 s0,s0,s1
0000d6  ed840a03          VSTR     s0,[r4,#0xc]
                  |L13.218|
;;;215        }
;;;216        values[4] = inv_get_heading_confidence_interval();
0000da  f7fffffe          BL       inv_get_heading_confidence_interval
0000de  ed840a04          VSTR     s0,[r4,#0x10]
;;;217    
;;;218        return hal_out.nine_axis_status;
0000e2  4801              LDR      r0,|L13.232|
0000e4  6b00              LDR      r0,[r0,#0x30]  ; hal_out
;;;219    }
0000e6  bd70              POP      {r4-r6,pc}
;;;220    
                          ENDP

                  |L13.232|
                          DCD      hal_out
                  |L13.236|
0000ec  30800000          DCFS     0x30800000 ; 9.3132257461547852e-10

                          AREA ||i.inv_init_hal_outputs||, CODE, READONLY, ALIGN=2

                  inv_init_hal_outputs PROC
;;;446    */
;;;447    inv_error_t inv_init_hal_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;448    {
;;;449        int i;
;;;450        memset(&hal_out, 0, sizeof(hal_out));
000002  21c4              MOVS     r1,#0xc4
000004  480a              LDR      r0,|L14.48|
000006  f7fffffe          BL       __aeabi_memclr4
;;;451        for (i=0; i<3; i++)  {
00000a  2400              MOVS     r4,#0
00000c  e00b              B        |L14.38|
                  |L14.14|
;;;452            inv_init_biquad_filter(&hal_out.lp_filter[i], compass_low_pass_filter_coeff);
00000e  eb040144          ADD      r1,r4,r4,LSL #1
000012  eb0102c4          ADD      r2,r1,r4,LSL #3
000016  4906              LDR      r1,|L14.48|
000018  3134              ADDS     r1,r1,#0x34
00001a  eb010082          ADD      r0,r1,r2,LSL #2
00001e  4905              LDR      r1,|L14.52|
000020  f7fffffe          BL       inv_init_biquad_filter
000024  1c64              ADDS     r4,r4,#1              ;451
                  |L14.38|
000026  2c03              CMP      r4,#3                 ;451
000028  dbf1              BLT      |L14.14|
;;;453        }
;;;454    
;;;455        return INV_SUCCESS;
00002a  2000              MOVS     r0,#0
;;;456    }
00002c  bd10              POP      {r4,pc}
;;;457    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      hal_out
                  |L14.52|
                          DCD      compass_low_pass_filter_coeff

                          AREA ||i.inv_start_hal_outputs||, CODE, READONLY, ALIGN=2

                  inv_start_hal_outputs PROC
;;;428    */
;;;429    inv_error_t inv_start_hal_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;430    {
;;;431        inv_error_t result;
;;;432        result =
000002  2207              MOVS     r2,#7
000004  f44f7161          MOV      r1,#0x384
000008  4802              LDR      r0,|L15.20|
00000a  f7fffffe          BL       inv_register_data_cb
00000e  4604              MOV      r4,r0
;;;433            inv_register_data_cb(inv_generate_hal_outputs,
;;;434                                 INV_PRIORITY_HAL_OUTPUTS,
;;;435                                 INV_GYRO_NEW | INV_ACCEL_NEW | INV_MAG_NEW);
;;;436        return result;
000010  4620              MOV      r0,r4
;;;437    }
000012  bd10              POP      {r4,pc}
;;;438    /* file name: lowPassFilterCoeff_1_6.c */
                          ENDP

                  |L15.20|
                          DCD      inv_generate_hal_outputs

                          AREA ||i.inv_stop_hal_outputs||, CODE, READONLY, ALIGN=2

                  inv_stop_hal_outputs PROC
;;;417     */
;;;418    inv_error_t inv_stop_hal_outputs(void)
000000  b510              PUSH     {r4,lr}
;;;419    {
;;;420        inv_error_t result;
;;;421        result = inv_unregister_data_cb(inv_generate_hal_outputs);
000002  4803              LDR      r0,|L16.16|
000004  f7fffffe          BL       inv_unregister_data_cb
000008  4604              MOV      r4,r0
;;;422        return result;
00000a  4620              MOV      r0,r4
;;;423    }
00000c  bd10              POP      {r4,pc}
;;;424    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      inv_generate_hal_outputs

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  hal_out
                          %        196

                          AREA ||.data||, DATA, ALIGN=2

                  compass_low_pass_filter_coeff
000000  40000000          DCFS     0x40000000 ; 2
000004  3f800000          DCFS     0x3f800000 ; 1
000008  bfa3caff          DCFS     0xbfa3caff ; -1.2796324491500854
00000c  3ef486f9          DCFS     0x3ef486f9 ; 0.47759225964546204
000010  3d4ab5fb          DCFS     0x3d4ab5fb ; 0.049489956349134445
