; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\ml_math_func.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\ml_math_func.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\ml_math_func.crf ..\DMP\mllite\ml_math_func.c]
                          THUMB

                          AREA ||i.inv_angle_diff||, CODE, READONLY, ALIGN=2

                  inv_angle_diff PROC
;;;581     */
;;;582    float inv_angle_diff(float ang1, float ang2)
000000  b500              PUSH     {lr}
;;;583    {
000002  eeb04a40          VMOV.F32 s8,s0
000006  eef03a60          VMOV.F32 s7,s1
;;;584        float d;
;;;585        ang1 = inv_wrap_angle(ang1);
00000a  eeb00a44          VMOV.F32 s0,s8
00000e  f7fffffe          BL       inv_wrap_angle
000012  eeb04a40          VMOV.F32 s8,s0
;;;586        ang2 = inv_wrap_angle(ang2);
000016  eeb00a63          VMOV.F32 s0,s7
00001a  f7fffffe          BL       inv_wrap_angle
00001e  eef03a40          VMOV.F32 s7,s0
;;;587        d = ang1 - ang2;
000022  ee340a63          VSUB.F32 s0,s8,s7
000026  eeb03a40          VMOV.F32 s6,s0
;;;588        if ((double)d > M_PI)
00002a  eeb70ac3          VCVT.F64.F32 d0,s6
00002e  ed9f1b0f          VLDR     d1,|L1.108|
000032  eeb40bc1          VCMPE.F64 d0,d1
000036  eef1fa10          VMRS     APSR_nzcv,FPSCR
00003a  dd06              BLE      |L1.74|
;;;589            d -= 2 * (float)M_PI;
00003c  ed9f0a0d          VLDR     s0,|L1.116|
000040  ee330a40          VSUB.F32 s0,s6,s0
000044  eeb03a40          VMOV.F32 s6,s0
000048  e00c              B        |L1.100|
                  |L1.74|
;;;590        else if (d < -(float)M_PI)
00004a  ed9f0a0b          VLDR     s0,|L1.120|
00004e  eeb43ac0          VCMPE.F32 s6,s0
000052  eef1fa10          VMRS     APSR_nzcv,FPSCR
000056  d205              BCS      |L1.100|
;;;591            d += 2 * (float)M_PI;
000058  ed9f0a06          VLDR     s0,|L1.116|
00005c  ee330a00          VADD.F32 s0,s6,s0
000060  eeb03a40          VMOV.F32 s6,s0
                  |L1.100|
;;;592        return d;
000064  eeb00a43          VMOV.F32 s0,s6
;;;593    }
000068  bd00              POP      {pc}
;;;594    
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
00006c  54442d11          DCFD     0x400921fb54442d11 ; 3.14159265358979
000070  400921fb
                  |L1.116|
000074  40c90fdb          DCFS     0x40c90fdb ; 6.2831854820251465
                  |L1.120|
000078  c0490fdb          DCFS     0xc0490fdb ; -3.1415927410125732

                          AREA ||i.inv_big8_to_int16||, CODE, READONLY, ALIGN=1

                  inv_big8_to_int16 PROC
;;;470    /** Converts a big endian byte stream into a 16-bit integer (short) */
;;;471    short inv_big8_to_int16(const unsigned char *big8)
000000  4601              MOV      r1,r0
;;;472    {
;;;473        short x;
;;;474        x = ((short)big8[0] << 8) | ((short)big8[1]);
000002  784a              LDRB     r2,[r1,#1]
000004  780b              LDRB     r3,[r1,#0]
000006  ea422203          ORR      r2,r2,r3,LSL #8
00000a  b210              SXTH     r0,r2
;;;475        return x;
;;;476    }
00000c  4770              BX       lr
;;;477    
                          ENDP


                          AREA ||i.inv_big8_to_int32||, CODE, READONLY, ALIGN=1

                  inv_big8_to_int32 PROC
;;;461    /** Converts a big endian byte stream into a 32-bit long */
;;;462    long inv_big8_to_int32(const unsigned char *big8)
000000  4601              MOV      r1,r0
;;;463    {
;;;464        long x;
;;;465        x = ((long)big8[0] << 24) | ((long)big8[1] << 16) | ((long)big8[2] << 8)
000002  780a              LDRB     r2,[r1,#0]
000004  0612              LSLS     r2,r2,#24
000006  784b              LDRB     r3,[r1,#1]
000008  ea424203          ORR      r2,r2,r3,LSL #16
00000c  788b              LDRB     r3,[r1,#2]
00000e  ea422203          ORR      r2,r2,r3,LSL #8
000012  78cb              LDRB     r3,[r1,#3]
000014  ea420003          ORR      r0,r2,r3
;;;466            | ((long)big8[3]);
;;;467        return x;
;;;468    }
000018  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.inv_biquad_filter_process||, CODE, READONLY, ALIGN=1

                  inv_biquad_filter_process PROC
;;;732    
;;;733    float inv_biquad_filter_process(inv_biquad_filter_t *pFilter, float input)  {
000000  eef00a40          VMOV.F32 s1,s0
;;;734        float stateZero;
;;;735    
;;;736        pFilter->input = input;
000004  edc00a09          VSTR     s1,[r0,#0x24]
;;;737        // calculate the new state;
;;;738        stateZero = pFilter->input - pFilter->c[2]*pFilter->state[0]
000008  ed900a09          VLDR     s0,[r0,#0x24]
00000c  edd01a06          VLDR     s3,[r0,#0x18]
000010  ed902a00          VLDR     s4,[r0,#0]
000014  ee010ac2          VMLS.F32 s0,s3,s4
000018  edd01a07          VLDR     s3,[r0,#0x1c]
00001c  ed902a01          VLDR     s4,[r0,#4]
000020  ee010ac2          VMLS.F32 s0,s3,s4
000024  eeb01a40          VMOV.F32 s2,s0
;;;739                                   - pFilter->c[3]*pFilter->state[1];
;;;740    
;;;741        pFilter->output = stateZero + pFilter->c[0]*pFilter->state[0]
000028  edd01a04          VLDR     s3,[r0,#0x10]
00002c  ed902a00          VLDR     s4,[r0,#0]
000030  eeb00a41          VMOV.F32 s0,s2
000034  ee010a82          VMLA.F32 s0,s3,s4
000038  edd01a05          VLDR     s3,[r0,#0x14]
00003c  ed902a01          VLDR     s4,[r0,#4]
000040  ee010a82          VMLA.F32 s0,s3,s4
000044  ed800a0a          VSTR     s0,[r0,#0x28]
;;;742                                    + pFilter->c[1]*pFilter->state[1];
;;;743    
;;;744        // update the output and state
;;;745        pFilter->output = pFilter->output * pFilter->c[4];
000048  ed900a0a          VLDR     s0,[r0,#0x28]
00004c  edd01a08          VLDR     s3,[r0,#0x20]
000050  ee200a21          VMUL.F32 s0,s0,s3
000054  ed800a0a          VSTR     s0,[r0,#0x28]
;;;746        pFilter->state[1] = pFilter->state[0];
000058  ed900a00          VLDR     s0,[r0,#0]
00005c  ed800a01          VSTR     s0,[r0,#4]
;;;747        pFilter->state[0] = stateZero;
000060  ed801a00          VSTR     s2,[r0,#0]
;;;748        return pFilter->output;
000064  ed900a0a          VLDR     s0,[r0,#0x28]
;;;749    }
000068  4770              BX       lr
;;;750    
                          ENDP


                          AREA ||i.inv_calc_state_to_match_output||, CODE, READONLY, ALIGN=1

                  inv_calc_state_to_match_output PROC
;;;724    
;;;725    void inv_calc_state_to_match_output(inv_biquad_filter_t *pFilter, float input)
000000  ed800a09          VSTR     s0,[r0,#0x24]
;;;726    {
;;;727        pFilter->input = input;
;;;728        pFilter->output = input;
000004  ed800a0a          VSTR     s0,[r0,#0x28]
;;;729        pFilter->state[0] = input / (1 + pFilter->c[2] + pFilter->c[3]);
000008  edd00a06          VLDR     s1,[r0,#0x18]
00000c  eeb71a00          VMOV.F32 s2,#1.00000000
000010  ee700a81          VADD.F32 s1,s1,s2
000014  ed901a07          VLDR     s2,[r0,#0x1c]
000018  ee700a81          VADD.F32 s1,s1,s2
00001c  ee801a20          VDIV.F32 s2,s0,s1
000020  ed801a00          VSTR     s2,[r0,#0]
;;;730        pFilter->state[1] = pFilter->state[0];
000024  edd00a00          VLDR     s1,[r0,#0]
000028  edc00a01          VSTR     s1,[r0,#4]
;;;731    }
00002c  4770              BX       lr
;;;732    
                          ENDP


                          AREA ||i.inv_checksum||, CODE, READONLY, ALIGN=1

                  inv_checksum PROC
;;;595    /** bernstein hash, derived from public domain source */
;;;596    uint32_t inv_checksum(const unsigned char *str, int len)
000000  b530              PUSH     {r4,r5,lr}
;;;597    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;598        uint32_t hash = 5381;
000006  f2415005          MOV      r0,#0x1505
;;;599        int i, c;
;;;600    
;;;601        for (i = 0; i < len; i++) {
00000a  2100              MOVS     r1,#0
00000c  e004              B        |L6.24|
                  |L6.14|
;;;602            c = *(str + i);
00000e  5c54              LDRB     r4,[r2,r1]
;;;603            hash = ((hash << 5) + hash) + c;	/* hash * 33 + c */
000010  eb001540          ADD      r5,r0,r0,LSL #5
000014  1928              ADDS     r0,r5,r4
000016  1c49              ADDS     r1,r1,#1              ;601
                  |L6.24|
000018  4299              CMP      r1,r3                 ;601
00001a  dbf8              BLT      |L6.14|
;;;604        }
;;;605    
;;;606        return hash;
;;;607    }
00001c  bd30              POP      {r4,r5,pc}
;;;608    
                          ENDP


                          AREA ||i.inv_compass_angle||, CODE, READONLY, ALIGN=2

                  inv_compass_angle PROC
;;;92      */
;;;93     float inv_compass_angle(const long *compass, const long *grav, const long *quat)
000000  b5f0              PUSH     {r4-r7,lr}
;;;94     {
000002  ed2d8b04          VPUSH    {d8-d9}
000006  b091              SUB      sp,sp,#0x44
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
00000c  4616              MOV      r6,r2
;;;95         long cgcross[4], q1[4], q2[4], qi[4];
;;;96         float angW;
;;;97     
;;;98         // Compass cross Gravity
;;;99         cgcross[0] = 0L;
00000e  2000              MOVS     r0,#0
000010  900d              STR      r0,[sp,#0x34]
;;;100        cgcross[1] = inv_q30_mult(compass[1], grav[2]) - inv_q30_mult(compass[2], grav[1]);
000012  68a9              LDR      r1,[r5,#8]
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       inv_q30_mult
00001a  4607              MOV      r7,r0
00001c  6869              LDR      r1,[r5,#4]
00001e  68a0              LDR      r0,[r4,#8]
000020  f7fffffe          BL       inv_q30_mult
000024  1a38              SUBS     r0,r7,r0
000026  900e              STR      r0,[sp,#0x38]
;;;101        cgcross[2] = inv_q30_mult(compass[2], grav[0]) - inv_q30_mult(compass[0], grav[2]);
000028  6829              LDR      r1,[r5,#0]
00002a  68a0              LDR      r0,[r4,#8]
00002c  f7fffffe          BL       inv_q30_mult
000030  4607              MOV      r7,r0
000032  68a9              LDR      r1,[r5,#8]
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       inv_q30_mult
00003a  1a38              SUBS     r0,r7,r0
00003c  900f              STR      r0,[sp,#0x3c]
;;;102        cgcross[3] = inv_q30_mult(compass[0], grav[1]) - inv_q30_mult(compass[1], grav[0]);
00003e  6869              LDR      r1,[r5,#4]
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       inv_q30_mult
000046  4607              MOV      r7,r0
000048  6829              LDR      r1,[r5,#0]
00004a  6860              LDR      r0,[r4,#4]
00004c  f7fffffe          BL       inv_q30_mult
000050  1a38              SUBS     r0,r7,r0
000052  9010              STR      r0,[sp,#0x40]
;;;103    
;;;104        // Now convert cross product into world frame
;;;105        inv_q_mult(quat, cgcross, q1);
000054  aa09              ADD      r2,sp,#0x24
000056  a90d              ADD      r1,sp,#0x34
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       inv_q_mult
;;;106        inv_q_invert(quat, qi);
00005e  a901              ADD      r1,sp,#4
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       inv_q_invert
;;;107        inv_q_mult(q1, qi, q2);
000066  aa05              ADD      r2,sp,#0x14
000068  a901              ADD      r1,sp,#4
00006a  a809              ADD      r0,sp,#0x24
00006c  f7fffffe          BL       inv_q_mult
;;;108    
;;;109        // Protect against atan2 of 0,0
;;;110        if ((q2[2] == 0L) && (q2[1] == 0L))
000070  9807              LDR      r0,[sp,#0x1c]
000072  b938              CBNZ     r0,|L7.132|
000074  9806              LDR      r0,[sp,#0x18]
000076  b928              CBNZ     r0,|L7.132|
;;;111            return 0.f;
000078  ed9f0a0c          VLDR     s0,|L7.172|
                  |L7.124|
;;;112    
;;;113        // This is the unfiltered heading correction
;;;114        angW = -atan2f(inv_q30_to_float(q2[2]), inv_q30_to_float(q2[1]));
;;;115        return angW;
;;;116    }
00007c  b011              ADD      sp,sp,#0x44
00007e  ecbd8b04          VPOP     {d8-d9}
000082  bdf0              POP      {r4-r7,pc}
                  |L7.132|
000084  9806              LDR      r0,[sp,#0x18]         ;114
000086  f7fffffe          BL       inv_q30_to_float
00008a  eef08a40          VMOV.F32 s17,s0                ;114
00008e  9807              LDR      r0,[sp,#0x1c]         ;114
000090  f7fffffe          BL       inv_q30_to_float
000094  eeb09a40          VMOV.F32 s18,s0                ;114
000098  eef00a68          VMOV.F32 s1,s17                ;114
00009c  f7fffffe          BL       __hardfp_atan2f
0000a0  eeb18a40          VNEG.F32 s16,s0                ;114
0000a4  eeb00a48          VMOV.F32 s0,s16                ;115
0000a8  e7e8              B        |L7.124|
;;;117    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L7.172|
0000ac  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.inv_convert_to_body||, CODE, READONLY, ALIGN=1

                  inv_convert_to_body PROC
;;;666    */
;;;667    void inv_convert_to_body(unsigned short orientation, const long *input, long *output)
000000  b510              PUSH     {r4,lr}
;;;668    {
;;;669        output[0] = input[orientation      & 0x03] * SIGNSET(orientation & 0x004);
000002  f0000303          AND      r3,r0,#3
000006  f8513023          LDR      r3,[r1,r3,LSL #2]
00000a  f0000404          AND      r4,r0,#4
00000e  b114              CBZ      r4,|L8.22|
000010  f04f34ff          MOV      r4,#0xffffffff
000014  e000              B        |L8.24|
                  |L8.22|
000016  2401              MOVS     r4,#1
                  |L8.24|
000018  4363              MULS     r3,r4,r3
00001a  6013              STR      r3,[r2,#0]
;;;670        output[1] = input[(orientation>>3) & 0x03] * SIGNSET(orientation & 0x020);
00001c  f3c003c1          UBFX     r3,r0,#3,#2
000020  f8513023          LDR      r3,[r1,r3,LSL #2]
000024  f0000420          AND      r4,r0,#0x20
000028  b114              CBZ      r4,|L8.48|
00002a  f04f34ff          MOV      r4,#0xffffffff
00002e  e000              B        |L8.50|
                  |L8.48|
000030  2401              MOVS     r4,#1
                  |L8.50|
000032  4363              MULS     r3,r4,r3
000034  6053              STR      r3,[r2,#4]
;;;671        output[2] = input[(orientation>>6) & 0x03] * SIGNSET(orientation & 0x100);
000036  f3c01381          UBFX     r3,r0,#6,#2
00003a  f8513023          LDR      r3,[r1,r3,LSL #2]
00003e  f4007480          AND      r4,r0,#0x100
000042  b114              CBZ      r4,|L8.74|
000044  f04f34ff          MOV      r4,#0xffffffff
000048  e000              B        |L8.76|
                  |L8.74|
00004a  2401              MOVS     r4,#1
                  |L8.76|
00004c  4363              MULS     r3,r4,r3
00004e  6093              STR      r3,[r2,#8]
;;;672    }
000050  bd10              POP      {r4,pc}
;;;673    
                          ENDP


                          AREA ||i.inv_convert_to_body_with_scale||, CODE, READONLY, ALIGN=1

                  inv_convert_to_body_with_scale PROC
;;;693    */
;;;694    void inv_convert_to_body_with_scale(unsigned short orientation, long sensitivity, const long *input, long *output)
000000  b5f0              PUSH     {r4-r7,lr}
;;;695    {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;696        output[0] = inv_q30_mult(input[orientation & 0x03] *
00000a  f0040103          AND      r1,r4,#3
00000e  f8551021          LDR      r1,[r5,r1,LSL #2]
000012  f0040204          AND      r2,r4,#4
000016  b112              CBZ      r2,|L9.30|
;;;697                                 SIGNSET(orientation & 0x004), sensitivity);
000018  f04f32ff          MOV      r2,#0xffffffff
00001c  e000              B        |L9.32|
                  |L9.30|
00001e  2201              MOVS     r2,#1
                  |L9.32|
000020  fb01f002          MUL      r0,r1,r2
000024  4639              MOV      r1,r7
000026  f7fffffe          BL       inv_q30_mult
00002a  6030              STR      r0,[r6,#0]
;;;698        output[1] = inv_q30_mult(input[(orientation>>3) & 0x03] *
00002c  f3c401c1          UBFX     r1,r4,#3,#2
000030  f8551021          LDR      r1,[r5,r1,LSL #2]
000034  f0040220          AND      r2,r4,#0x20
000038  b112              CBZ      r2,|L9.64|
;;;699                                 SIGNSET(orientation & 0x020), sensitivity);
00003a  f04f32ff          MOV      r2,#0xffffffff
00003e  e000              B        |L9.66|
                  |L9.64|
000040  2201              MOVS     r2,#1
                  |L9.66|
000042  fb01f002          MUL      r0,r1,r2
000046  4639              MOV      r1,r7
000048  f7fffffe          BL       inv_q30_mult
00004c  6070              STR      r0,[r6,#4]
;;;700        output[2] = inv_q30_mult(input[(orientation>>6) & 0x03] *
00004e  f3c41181          UBFX     r1,r4,#6,#2
000052  f8551021          LDR      r1,[r5,r1,LSL #2]
000056  f4047280          AND      r2,r4,#0x100
00005a  b112              CBZ      r2,|L9.98|
;;;701                                 SIGNSET(orientation & 0x100), sensitivity);
00005c  f04f32ff          MOV      r2,#0xffffffff
000060  e000              B        |L9.100|
                  |L9.98|
000062  2201              MOVS     r2,#1
                  |L9.100|
000064  fb01f002          MUL      r0,r1,r2
000068  4639              MOV      r1,r7
00006a  f7fffffe          BL       inv_q30_mult
00006e  60b0              STR      r0,[r6,#8]
;;;702    }
000070  bdf0              POP      {r4-r7,pc}
;;;703    
                          ENDP


                          AREA ||i.inv_convert_to_chip||, CODE, READONLY, ALIGN=1

                  inv_convert_to_chip PROC
;;;678    */
;;;679    void inv_convert_to_chip(unsigned short orientation, const long *input, long *output)
000000  b510              PUSH     {r4,lr}
;;;680    {
;;;681        output[orientation & 0x03]      = input[0] * SIGNSET(orientation & 0x004);
000002  f0000404          AND      r4,r0,#4
000006  680b              LDR      r3,[r1,#0]
000008  b114              CBZ      r4,|L10.16|
00000a  f04f34ff          MOV      r4,#0xffffffff
00000e  e000              B        |L10.18|
                  |L10.16|
000010  2401              MOVS     r4,#1
                  |L10.18|
000012  4363              MULS     r3,r4,r3
000014  f0000403          AND      r4,r0,#3
000018  f8423024          STR      r3,[r2,r4,LSL #2]
;;;682        output[(orientation>>3) & 0x03] = input[1] * SIGNSET(orientation & 0x020);
00001c  f0000420          AND      r4,r0,#0x20
000020  684b              LDR      r3,[r1,#4]
000022  b114              CBZ      r4,|L10.42|
000024  f04f34ff          MOV      r4,#0xffffffff
000028  e000              B        |L10.44|
                  |L10.42|
00002a  2401              MOVS     r4,#1
                  |L10.44|
00002c  4363              MULS     r3,r4,r3
00002e  f3c004c1          UBFX     r4,r0,#3,#2
000032  f8423024          STR      r3,[r2,r4,LSL #2]
;;;683        output[(orientation>>6) & 0x03] = input[2] * SIGNSET(orientation & 0x100);
000036  f4007480          AND      r4,r0,#0x100
00003a  688b              LDR      r3,[r1,#8]
00003c  b114              CBZ      r4,|L10.68|
00003e  f04f34ff          MOV      r4,#0xffffffff
000042  e000              B        |L10.70|
                  |L10.68|
000044  2401              MOVS     r4,#1
                  |L10.70|
000046  4363              MULS     r3,r4,r3
000048  f3c01481          UBFX     r4,r0,#6,#2
00004c  f8423024          STR      r3,[r2,r4,LSL #2]
;;;684    }
000050  bd10              POP      {r4,pc}
;;;685    
                          ENDP


                          AREA ||i.inv_cosf||, CODE, READONLY, ALIGN=2

                  inv_cosf PROC
;;;75     
;;;76     float inv_cosf(float x)
000000  eef00a40          VMOV.F32 s1,s0
;;;77     {
;;;78         int index = ((unsigned int)((x * (TABLE_SIZE>>1)) / 3.14159f) + (TABLE_SIZE>>2)) % TABLE_SIZE;
000004  ed9f0a09          VLDR     s0,|L11.44|
000008  ee200a80          VMUL.F32 s0,s1,s0
00000c  ed9f1a08          VLDR     s2,|L11.48|
000010  eec01a01          VDIV.F32 s3,s0,s2
000014  eebc0ae1          VCVT.U32.F32 s0,s3
000018  ee101a10          VMOV     r1,s0
00001c  3140              ADDS     r1,r1,#0x40
00001e  b2c8              UXTB     r0,r1
;;;79         return sin_lookup[index];
000020  4904              LDR      r1,|L11.52|
000022  eb010180          ADD      r1,r1,r0,LSL #2
000026  ed910a00          VLDR     s0,[r1,#0]
;;;80     }
00002a  4770              BX       lr
;;;81     #endif
                          ENDP

                  |L11.44|
00002c  43000000          DCFS     0x43000000 ; 128
                  |L11.48|
000030  40490fd0          DCFS     0x40490fd0 ; 3.1415901184082031
                  |L11.52|
                          DCD      sin_lookup

                          AREA ||i.inv_get_cross_product_vec||, CODE, READONLY, ALIGN=1

                  inv_get_cross_product_vec PROC
;;;750    
;;;751    void inv_get_cross_product_vec(float *cgcross, float compass[3], float grav[3])  {
000000  ed910a01          VLDR     s0,[r1,#4]
;;;752    
;;;753        cgcross[0] = (float)compass[1] * grav[2] - (float)compass[2] * grav[1];
000004  edd20a02          VLDR     s1,[r2,#8]
000008  ee200a20          VMUL.F32 s0,s0,s1
00000c  edd10a02          VLDR     s1,[r1,#8]
000010  ed921a01          VLDR     s2,[r2,#4]
000014  ee000ac1          VMLS.F32 s0,s1,s2
000018  ed800a00          VSTR     s0,[r0,#0]
;;;754        cgcross[1] = (float)compass[2] * grav[0] - (float)compass[0] * grav[2];
00001c  ed910a02          VLDR     s0,[r1,#8]
000020  edd20a00          VLDR     s1,[r2,#0]
000024  ee200a20          VMUL.F32 s0,s0,s1
000028  edd10a00          VLDR     s1,[r1,#0]
00002c  ed921a02          VLDR     s2,[r2,#8]
000030  ee000ac1          VMLS.F32 s0,s1,s2
000034  ed800a01          VSTR     s0,[r0,#4]
;;;755        cgcross[2] = (float)compass[0] * grav[1] - (float)compass[1] * grav[0];
000038  ed910a00          VLDR     s0,[r1,#0]
00003c  edd20a01          VLDR     s1,[r2,#4]
000040  ee200a20          VMUL.F32 s0,s0,s1
000044  edd10a01          VLDR     s1,[r1,#4]
000048  ed921a00          VLDR     s2,[r2,#0]
00004c  ee000ac1          VMLS.F32 s0,s1,s2
000050  ed800a02          VSTR     s0,[r0,#8]
;;;756    }
000054  4770              BX       lr
;;;757    
                          ENDP


                          AREA ||i.inv_get_gyro_sum_of_sqr||, CODE, READONLY, ALIGN=1

                  inv_get_gyro_sum_of_sqr PROC
;;;123     */
;;;124    unsigned long inv_get_gyro_sum_of_sqr(const long *gyro)
000000  b510              PUSH     {r4,lr}
;;;125    {
000002  4603              MOV      r3,r0
;;;126        unsigned long gmag = 0;
000004  2000              MOVS     r0,#0
;;;127        long temp;
;;;128        int kk;
;;;129    
;;;130        for (kk = 0; kk < 3; ++kk) {
000006  2200              MOVS     r2,#0
000008  e005              B        |L13.22|
                  |L13.10|
;;;131            temp = gyro[kk] >> (16 - (GYRO_MAG_SQR_SHIFT / 2));
00000a  f8534022          LDR      r4,[r3,r2,LSL #2]
00000e  1361              ASRS     r1,r4,#13
;;;132            gmag += temp * temp;
000010  fb010001          MLA      r0,r1,r1,r0
000014  1c52              ADDS     r2,r2,#1              ;130
                  |L13.22|
000016  2a03              CMP      r2,#3                 ;130
000018  dbf7              BLT      |L13.10|
;;;133        }
;;;134    
;;;135        return gmag;
;;;136    }
00001a  bd10              POP      {r4,pc}
;;;137    
                          ENDP


                          AREA ||i.inv_init_biquad_filter||, CODE, READONLY, ALIGN=2

                  inv_init_biquad_filter PROC
;;;712    
;;;713    void inv_init_biquad_filter(inv_biquad_filter_t *pFilter, float *pBiquadCoeff) {
000000  460a              MOV      r2,r1
;;;714        int i;
;;;715        // initial state to zero
;;;716        pFilter->state[0] = 0;
000002  ed9f0a0c          VLDR     s0,|L14.52|
000006  ed800a00          VSTR     s0,[r0,#0]
;;;717        pFilter->state[1] = 0;
00000a  ed9f0a0a          VLDR     s0,|L14.52|
00000e  ed800a01          VSTR     s0,[r0,#4]
;;;718    
;;;719        // set up coefficients
;;;720        for (i=0; i<5; i++) {
000012  2100              MOVS     r1,#0
000014  e00a              B        |L14.44|
                  |L14.22|
;;;721            pFilter->c[i] = pBiquadCoeff[i];
000016  eb020381          ADD      r3,r2,r1,LSL #2
00001a  ed930a00          VLDR     s0,[r3,#0]
00001e  f1000310          ADD      r3,r0,#0x10
000022  eb030381          ADD      r3,r3,r1,LSL #2
000026  ed830a00          VSTR     s0,[r3,#0]
00002a  1c49              ADDS     r1,r1,#1              ;720
                  |L14.44|
00002c  2905              CMP      r1,#5                 ;720
00002e  dbf2              BLT      |L14.22|
;;;722        }
;;;723    }
000030  4770              BX       lr
;;;724    
                          ENDP

000032  0000              DCW      0x0000
                  |L14.52|
000034  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.inv_int16_to_big8||, CODE, READONLY, ALIGN=1

                  inv_int16_to_big8 PROC
;;;486    /** Converts a 16-bit short to a big endian byte stream */
;;;487    unsigned char *inv_int16_to_big8(short x, unsigned char *big8)
000000  4602              MOV      r2,r0
;;;488    {
;;;489        big8[0] = (unsigned char)((x >> 8) & 0xff);
000002  0a10              LSRS     r0,r2,#8
000004  7008              STRB     r0,[r1,#0]
;;;490        big8[1] = (unsigned char)(x & 0xff);
000006  704a              STRB     r2,[r1,#1]
;;;491        return big8;
000008  4608              MOV      r0,r1
;;;492    }
00000a  4770              BX       lr
;;;493    
                          ENDP


                          AREA ||i.inv_int32_to_big8||, CODE, READONLY, ALIGN=1

                  inv_int32_to_big8 PROC
;;;451    /** Converts a 32-bit long to a big endian byte stream */
;;;452    unsigned char *inv_int32_to_big8(long x, unsigned char *big8)
000000  4602              MOV      r2,r0
;;;453    {
;;;454        big8[0] = (unsigned char)((x >> 24) & 0xff);
000002  0e10              LSRS     r0,r2,#24
000004  7008              STRB     r0,[r1,#0]
;;;455        big8[1] = (unsigned char)((x >> 16) & 0xff);
000006  0c10              LSRS     r0,r2,#16
000008  7048              STRB     r0,[r1,#1]
;;;456        big8[2] = (unsigned char)((x >> 8) & 0xff);
00000a  0a10              LSRS     r0,r2,#8
00000c  7088              STRB     r0,[r1,#2]
;;;457        big8[3] = (unsigned char)(x & 0xff);
00000e  70ca              STRB     r2,[r1,#3]
;;;458        return big8;
000010  4608              MOV      r0,r1
;;;459    }
000012  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.inv_little8_to_int16||, CODE, READONLY, ALIGN=1

                  inv_little8_to_int16 PROC
;;;478    /** Converts a little endian byte stream into a 16-bit integer (short) */
;;;479    short inv_little8_to_int16(const unsigned char *little8)
000000  4601              MOV      r1,r0
;;;480    {
;;;481        short x;
;;;482        x = ((short)little8[1] << 8) | ((short)little8[0]);
000002  780a              LDRB     r2,[r1,#0]
000004  784b              LDRB     r3,[r1,#1]
000006  ea422203          ORR      r2,r2,r3,LSL #8
00000a  b210              SXTH     r0,r2
;;;483        return x;
;;;484    }
00000c  4770              BX       lr
;;;485    
                          ENDP


                          AREA ||i.inv_matrix_det||, CODE, READONLY, ALIGN=2

                  inv_matrix_det PROC
;;;523    
;;;524    float inv_matrix_det(float *p, int *n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;525    {
000004  ed2d8b02          VPUSH    {d8}
000008  b0a5              SUB      sp,sp,#0x94
00000a  4604              MOV      r4,r0
00000c  460e              MOV      r6,r1
;;;526        float d[6][6], sum = 0;
00000e  ed9f0a26          VLDR     s0,|L18.168|
000012  eeb08a40          VMOV.F32 s16,s0
;;;527        int i, j, m;
;;;528        m = *n;
000016  f8d68000          LDR      r8,[r6,#0]
;;;529        if (*n == 2)
00001a  6830              LDR      r0,[r6,#0]
00001c  2802              CMP      r0,#2
00001e  d110              BNE      |L18.66|
;;;530            return (*p ** (p + 7) - *(p + 1) ** (p + 6));
000020  ed940a00          VLDR     s0,[r4,#0]
000024  edd40a07          VLDR     s1,[r4,#0x1c]
000028  ee200a20          VMUL.F32 s0,s0,s1
00002c  edd40a01          VLDR     s1,[r4,#4]
000030  ed941a06          VLDR     s2,[r4,#0x18]
000034  ee000ac1          VMLS.F32 s0,s1,s2
                  |L18.56|
;;;531        for (i = 0, j = 0; j < m; j++) {
;;;532            *n = m;
;;;533            inv_matrix_det_inc(p, &d[0][0], n, i, j);
;;;534            sum =
;;;535                sum + *(p + 6 * i + j) * SIGNM(i +
;;;536                                                j) *
;;;537                inv_matrix_det(&d[0][0], n);
;;;538        }
;;;539    
;;;540        return (sum);
;;;541    }
000038  b025              ADD      sp,sp,#0x94
00003a  ecbd8b02          VPOP     {d8}
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L18.66|
000042  2700              MOVS     r7,#0                 ;531
000044  2500              MOVS     r5,#0                 ;531
000046  e029              B        |L18.156|
                  |L18.72|
000048  f8c68000          STR      r8,[r6,#0]            ;532
00004c  463b              MOV      r3,r7                 ;533
00004e  4632              MOV      r2,r6                 ;533
000050  a901              ADD      r1,sp,#4              ;533
000052  4620              MOV      r0,r4                 ;533
000054  9500              STR      r5,[sp,#0]            ;533
000056  f7fffffe          BL       inv_matrix_det_inc
00005a  4631              MOV      r1,r6                 ;534
00005c  a801              ADD      r0,sp,#4              ;534
00005e  f7fffffe          BL       inv_matrix_det
000062  eb070047          ADD      r0,r7,r7,LSL #1       ;534
000066  eb0400c0          ADD      r0,r4,r0,LSL #3       ;534
00006a  eb000085          ADD      r0,r0,r5,LSL #2       ;534
00006e  ed901a00          VLDR     s2,[r0,#0]            ;534
000072  1978              ADDS     r0,r7,r5              ;534
000074  f0000001          AND      r0,r0,#1              ;534
000078  b110              CBZ      r0,|L18.128|
00007a  f04f30ff          MOV      r0,#0xffffffff        ;535
00007e  e000              B        |L18.130|
                  |L18.128|
000080  2001              MOVS     r0,#1                 ;535
                  |L18.130|
000082  ee000a90          VMOV     s1,r0                 ;535
000086  eef80ae0          VCVT.F32.S32 s1,s1                 ;535
00008a  ee211a20          VMUL.F32 s2,s2,s1              ;535
00008e  eef00a48          VMOV.F32 s1,s16                ;535
000092  ee410a00          VMLA.F32 s1,s2,s0              ;535
000096  eeb08a60          VMOV.F32 s16,s1                ;535
00009a  1c6d              ADDS     r5,r5,#1              ;531
                  |L18.156|
00009c  4545              CMP      r5,r8                 ;531
00009e  dbd3              BLT      |L18.72|
0000a0  eeb00a48          VMOV.F32 s0,s16                ;540
0000a4  e7c8              B        |L18.56|
;;;542    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L18.168|
0000a8  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.inv_matrix_det_inc||, CODE, READONLY, ALIGN=1

                  inv_matrix_det_inc PROC
;;;493    
;;;494    void inv_matrix_det_inc(float *a, float *b, int *n, int x, int y)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;495    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  f8ddc018          LDR      r12,[sp,#0x18]
;;;496        int k, l, i, j;
;;;497        for (i = 0, k = 0; i < *n; i++, k++) {
00000c  2000              MOVS     r0,#0
00000e  2600              MOVS     r6,#0
000010  e020              B        |L19.84|
                  |L19.18|
;;;498            for (j = 0, l = 0; j < *n; j++, l++) {
000012  2100              MOVS     r1,#0
000014  2700              MOVS     r7,#0
000016  e017              B        |L19.72|
                  |L19.24|
;;;499                if (i == x)
000018  4298              CMP      r0,r3
00001a  d100              BNE      |L19.30|
;;;500                    i++;
00001c  1c40              ADDS     r0,r0,#1
                  |L19.30|
;;;501                if (j == y)
00001e  4561              CMP      r1,r12
000020  d100              BNE      |L19.36|
;;;502                    j++;
000022  1c49              ADDS     r1,r1,#1
                  |L19.36|
;;;503                *(b + 6 * k + l) = *(a + 6 * i + j);
000024  eb000840          ADD      r8,r0,r0,LSL #1
000028  eb0408c8          ADD      r8,r4,r8,LSL #3
00002c  eb080881          ADD      r8,r8,r1,LSL #2
000030  ed980a00          VLDR     s0,[r8,#0]
000034  eb060846          ADD      r8,r6,r6,LSL #1
000038  eb0508c8          ADD      r8,r5,r8,LSL #3
00003c  eb080887          ADD      r8,r8,r7,LSL #2
000040  ed880a00          VSTR     s0,[r8,#0]
000044  1c49              ADDS     r1,r1,#1              ;498
000046  1c7f              ADDS     r7,r7,#1              ;498
                  |L19.72|
000048  f8d28000          LDR      r8,[r2,#0]            ;498
00004c  4588              CMP      r8,r1                 ;498
00004e  dce3              BGT      |L19.24|
000050  1c40              ADDS     r0,r0,#1              ;497
000052  1c76              ADDS     r6,r6,#1              ;497
                  |L19.84|
000054  f8d28000          LDR      r8,[r2,#0]            ;497
000058  4580              CMP      r8,r0                 ;497
00005a  dcda              BGT      |L19.18|
;;;504            }
;;;505        }
;;;506        *n = *n - 1;
00005c  f8d28000          LDR      r8,[r2,#0]
000060  f1a80801          SUB      r8,r8,#1
000064  f8c28000          STR      r8,[r2,#0]
;;;507    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;508    
                          ENDP


                          AREA ||i.inv_matrix_det_incd||, CODE, READONLY, ALIGN=1

                  inv_matrix_det_incd PROC
;;;508    
;;;509    void inv_matrix_det_incd(double *a, double *b, int *n, int x, int y)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;510    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  f8ddc018          LDR      r12,[sp,#0x18]
;;;511        int k, l, i, j;
;;;512        for (i = 0, k = 0; i < *n; i++, k++) {
00000c  2000              MOVS     r0,#0
00000e  2600              MOVS     r6,#0
000010  e020              B        |L20.84|
                  |L20.18|
;;;513            for (j = 0, l = 0; j < *n; j++, l++) {
000012  2100              MOVS     r1,#0
000014  2700              MOVS     r7,#0
000016  e017              B        |L20.72|
                  |L20.24|
;;;514                if (i == x)
000018  4298              CMP      r0,r3
00001a  d100              BNE      |L20.30|
;;;515                    i++;
00001c  1c40              ADDS     r0,r0,#1
                  |L20.30|
;;;516                if (j == y)
00001e  4561              CMP      r1,r12
000020  d100              BNE      |L20.36|
;;;517                    j++;
000022  1c49              ADDS     r1,r1,#1
                  |L20.36|
;;;518                *(b + 6 * k + l) = *(a + 6 * i + j);
000024  eb000840          ADD      r8,r0,r0,LSL #1
000028  eb041808          ADD      r8,r4,r8,LSL #4
00002c  eb0808c1          ADD      r8,r8,r1,LSL #3
000030  ed980b00          VLDR     d0,[r8,#0]
000034  eb060846          ADD      r8,r6,r6,LSL #1
000038  eb051808          ADD      r8,r5,r8,LSL #4
00003c  eb0808c7          ADD      r8,r8,r7,LSL #3
000040  ed880b00          VSTR     d0,[r8,#0]
000044  1c49              ADDS     r1,r1,#1              ;513
000046  1c7f              ADDS     r7,r7,#1              ;513
                  |L20.72|
000048  f8d28000          LDR      r8,[r2,#0]            ;513
00004c  4588              CMP      r8,r1                 ;513
00004e  dce3              BGT      |L20.24|
000050  1c40              ADDS     r0,r0,#1              ;512
000052  1c76              ADDS     r6,r6,#1              ;512
                  |L20.84|
000054  f8d28000          LDR      r8,[r2,#0]            ;512
000058  4580              CMP      r8,r0                 ;512
00005a  dcda              BGT      |L20.18|
;;;519            }
;;;520        }
;;;521        *n = *n - 1;
00005c  f8d28000          LDR      r8,[r2,#0]
000060  f1a80801          SUB      r8,r8,#1
000064  f8c28000          STR      r8,[r2,#0]
;;;522    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;523    
                          ENDP


                          AREA ||i.inv_matrix_detd||, CODE, READONLY, ALIGN=2

                  inv_matrix_detd PROC
;;;542    
;;;543    double inv_matrix_detd(double *p, int *n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;544    {
000004  ed2d8b02          VPUSH    {d8}
000008  b0ca              SUB      sp,sp,#0x128
00000a  4604              MOV      r4,r0
00000c  460e              MOV      r6,r1
;;;545        double d[6][6], sum = 0;
00000e  ed9f0b26          VLDR     d0,|L21.168|
000012  eeb08b40          VMOV.F64 d8,d0
;;;546        int i, j, m;
;;;547        m = *n;
000016  f8d68000          LDR      r8,[r6,#0]
;;;548        if (*n == 2)
00001a  6830              LDR      r0,[r6,#0]
00001c  2802              CMP      r0,#2
00001e  d110              BNE      |L21.66|
;;;549            return (*p ** (p + 7) - *(p + 1) ** (p + 6));
000020  ed940b00          VLDR     d0,[r4,#0]
000024  ed941b0e          VLDR     d1,[r4,#0x38]
000028  ee200b01          VMUL.F64 d0,d0,d1
00002c  ed941b02          VLDR     d1,[r4,#8]
000030  ed942b0c          VLDR     d2,[r4,#0x30]
000034  ee010b42          VMLS.F64 d0,d1,d2
                  |L21.56|
;;;550        for (i = 0, j = 0; j < m; j++) {
;;;551            *n = m;
;;;552            inv_matrix_det_incd(p, &d[0][0], n, i, j);
;;;553            sum =
;;;554                sum + *(p + 6 * i + j) * SIGNM(i +
;;;555                                                j) *
;;;556                inv_matrix_detd(&d[0][0], n);
;;;557        }
;;;558    
;;;559        return (sum);
;;;560    }
000038  b04a              ADD      sp,sp,#0x128
00003a  ecbd8b02          VPOP     {d8}
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L21.66|
000042  2700              MOVS     r7,#0                 ;550
000044  2500              MOVS     r5,#0                 ;550
000046  e029              B        |L21.156|
                  |L21.72|
000048  f8c68000          STR      r8,[r6,#0]            ;551
00004c  463b              MOV      r3,r7                 ;552
00004e  4632              MOV      r2,r6                 ;552
000050  a902              ADD      r1,sp,#8              ;552
000052  4620              MOV      r0,r4                 ;552
000054  9500              STR      r5,[sp,#0]            ;552
000056  f7fffffe          BL       inv_matrix_det_incd
00005a  4631              MOV      r1,r6                 ;553
00005c  a802              ADD      r0,sp,#8              ;553
00005e  f7fffffe          BL       inv_matrix_detd
000062  eb070047          ADD      r0,r7,r7,LSL #1       ;553
000066  eb041000          ADD      r0,r4,r0,LSL #4       ;553
00006a  eb0000c5          ADD      r0,r0,r5,LSL #3       ;553
00006e  ed902b00          VLDR     d2,[r0,#0]            ;553
000072  1978              ADDS     r0,r7,r5              ;553
000074  f0000001          AND      r0,r0,#1              ;553
000078  b110              CBZ      r0,|L21.128|
00007a  f04f30ff          MOV      r0,#0xffffffff        ;554
00007e  e000              B        |L21.130|
                  |L21.128|
000080  2001              MOVS     r0,#1                 ;554
                  |L21.130|
000082  ee010a10          VMOV     s2,r0                 ;554
000086  eeb81bc1          VCVT.F64.S32 d1,s2                 ;554
00008a  ee222b01          VMUL.F64 d2,d2,d1              ;554
00008e  eeb01b48          VMOV.F64 d1,d8                 ;554
000092  ee021b00          VMLA.F64 d1,d2,d0              ;554
000096  eeb08b41          VMOV.F64 d8,d1                 ;554
00009a  1c6d              ADDS     r5,r5,#1              ;550
                  |L21.156|
00009c  4545              CMP      r5,r8                 ;550
00009e  dbd3              BLT      |L21.72|
0000a0  eeb00b48          VMOV.F64 d0,d8                 ;559
0000a4  e7c8              B        |L21.56|
;;;561    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L21.168|
0000a8  00000000          DCFD     0x0000000000000000 ; 0
0000ac  00000000

                          AREA ||i.inv_orientation_matrix_to_scalar||, CODE, READONLY, ALIGN=1

                  inv_orientation_matrix_to_scalar PROC
;;;639    */
;;;640    unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx)
000000  b570              PUSH     {r4-r6,lr}
;;;641    {
000002  4605              MOV      r5,r0
;;;642    
;;;643        unsigned short scalar;
;;;644    
;;;645        /*
;;;646           XYZ  010_001_000 Identity Matrix
;;;647           XZY  001_010_000
;;;648           YXZ  010_000_001
;;;649           YZX  000_010_001
;;;650           ZXY  001_000_010
;;;651           ZYX  000_001_010
;;;652         */
;;;653    
;;;654        scalar = inv_row_2_scale(mtx);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       inv_row_2_scale
00000a  4604              MOV      r4,r0
;;;655        scalar |= inv_row_2_scale(mtx + 3) << 3;
00000c  1ce8              ADDS     r0,r5,#3
00000e  f7fffffe          BL       inv_row_2_scale
000012  ea4400c0          ORR      r0,r4,r0,LSL #3
000016  b284              UXTH     r4,r0
;;;656        scalar |= inv_row_2_scale(mtx + 6) << 6;
000018  1da8              ADDS     r0,r5,#6
00001a  f7fffffe          BL       inv_row_2_scale
00001e  ea441080          ORR      r0,r4,r0,LSL #6
000022  b284              UXTH     r4,r0
;;;657    
;;;658    
;;;659        return scalar;
000024  4620              MOV      r0,r4
;;;660    }
000026  bd70              POP      {r4-r6,pc}
;;;661    
                          ENDP


                          AREA ||i.inv_q29_mult||, CODE, READONLY, ALIGN=1

                  inv_q29_mult PROC
;;;144    */
;;;145    long inv_q29_mult(long a, long b)
000000  b5f0              PUSH     {r4-r7,lr}
;;;146    {
000002  4602              MOV      r2,r0
;;;147    #ifdef EMPL_NO_64BIT
;;;148        long result;
;;;149        result = (long)((float)a * b / (1L << 29));
;;;150        return result;
;;;151    #else
;;;152        long long temp;
;;;153        long result;
;;;154        temp = (long long)a * b;
000004  fb823501          SMULL    r3,r5,r2,r1
000008  462c              MOV      r4,r5
;;;155        result = (long)(temp >> 29);
00000a  0f5d              LSRS     r5,r3,#29
00000c  ea4500c4          ORR      r0,r5,r4,LSL #3
;;;156        return result;
;;;157    #endif
;;;158    }
000010  bdf0              POP      {r4-r7,pc}
;;;159    
                          ENDP


                          AREA ||i.inv_q30_div||, CODE, READONLY, ALIGN=1

                  inv_q30_div PROC
;;;182    #ifndef EMPL_NO_64BIT
;;;183    long inv_q30_div(long a, long b)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;184    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;185        long long temp;
;;;186        long result;
;;;187        temp = (((long long)a) << 30) / b;
000008  17e0              ASRS     r0,r4,#31
00000a  0780              LSLS     r0,r0,#30
00000c  ea400194          ORR      r1,r0,r4,LSR #2
000010  07a7              LSLS     r7,r4,#30
000012  464a              MOV      r2,r9
000014  ea4f73e9          ASR      r3,r9,#31
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       __aeabi_ldivmod
00001e  4605              MOV      r5,r0
;;;188        result = (long)temp;
000020  46aa              MOV      r10,r5
;;;189        return result;
000022  4650              MOV      r0,r10
;;;190    }
000024  e8bd87f0          POP      {r4-r10,pc}
;;;191    #endif
                          ENDP


                          AREA ||i.inv_q30_mult||, CODE, READONLY, ALIGN=1

                  inv_q30_mult PROC
;;;166    */
;;;167    long inv_q30_mult(long a, long b)
000000  b5f0              PUSH     {r4-r7,lr}
;;;168    {
000002  4602              MOV      r2,r0
;;;169    #ifdef EMPL_NO_64BIT
;;;170        long result;
;;;171        result = (long)((float)a * b / (1L << 30));
;;;172        return result;
;;;173    #else
;;;174        long long temp;
;;;175        long result;
;;;176        temp = (long long)a * b;
000004  fb823501          SMULL    r3,r5,r2,r1
000008  462c              MOV      r4,r5
;;;177        result = (long)(temp >> 30);
00000a  0f9d              LSRS     r5,r3,#30
00000c  ea450084          ORR      r0,r5,r4,LSL #2
;;;178        return result;
;;;179    #endif
;;;180    }
000010  bdf0              POP      {r4-r7,pc}
;;;181    
                          ENDP


                          AREA ||i.inv_q30_to_double||, CODE, READONLY, ALIGN=2

                  inv_q30_to_double PROC
;;;38     
;;;39         static inline double inv_q30_to_double(long q30)
000000  ee000a10          VMOV     s0,r0
;;;40         {
;;;41             return (double) q30 / ((double)(1L << 30));
000004  eeb81bc0          VCVT.F64.S32 d1,s0
000008  ed9f2b02          VLDR     d2,|L26.20|
00000c  ee810b02          VDIV.F64 d0,d1,d2
;;;42         }
000010  4770              BX       lr
;;;43     
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
000014  00000000          DCFD     0x41d0000000000000 ; 1073741824
000018  41d00000

                          AREA ||i.inv_q30_to_float||, CODE, READONLY, ALIGN=2

                  inv_q30_to_float PROC
;;;33     
;;;34         static inline float inv_q30_to_float(long q30)
000000  ee000a10          VMOV     s0,r0
;;;35         {
;;;36             return (float) q30 / ((float)(1L << 30));
000004  eef80ac0          VCVT.F32.S32 s1,s0
000008  ed9f1a02          VLDR     s2,|L27.20|
00000c  ee800a81          VDIV.F32 s0,s1,s2
;;;37         }
000010  4770              BX       lr
;;;38     
                          ENDP

000012  0000              DCW      0x0000
                  |L27.20|
000014  4e800000          DCFS     0x4e800000 ; 1073741824

                          AREA ||i.inv_q_add||, CODE, READONLY, ALIGN=1

                  inv_q_add PROC
;;;241    */
;;;242    void inv_q_add(long *q1, long *q2, long *qSum)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244        INVENSENSE_FUNC_START;
;;;245        qSum[0] = q1[0] + q2[0];
000002  6803              LDR      r3,[r0,#0]
000004  680c              LDR      r4,[r1,#0]
000006  4423              ADD      r3,r3,r4
000008  6013              STR      r3,[r2,#0]
;;;246        qSum[1] = q1[1] + q2[1];
00000a  6843              LDR      r3,[r0,#4]
00000c  684c              LDR      r4,[r1,#4]
00000e  4423              ADD      r3,r3,r4
000010  6053              STR      r3,[r2,#4]
;;;247        qSum[2] = q1[2] + q2[2];
000012  6883              LDR      r3,[r0,#8]
000014  688c              LDR      r4,[r1,#8]
000016  4423              ADD      r3,r3,r4
000018  6093              STR      r3,[r2,#8]
;;;248        qSum[3] = q1[3] + q2[3];
00001a  68c3              LDR      r3,[r0,#0xc]
00001c  68cc              LDR      r4,[r1,#0xc]
00001e  4423              ADD      r3,r3,r4
000020  60d3              STR      r3,[r2,#0xc]
;;;249    }
000022  bd10              POP      {r4,pc}
;;;250    
                          ENDP


                          AREA ||i.inv_q_addf||, CODE, READONLY, ALIGN=1

                  inv_q_addf PROC
;;;327    
;;;328    void inv_q_addf(const float *q1, const float *q2, float *qSum)
000000  ed900a00          VLDR     s0,[r0,#0]
;;;329    {
;;;330        INVENSENSE_FUNC_START;
;;;331        qSum[0] = q1[0] + q2[0];
000004  edd10a00          VLDR     s1,[r1,#0]
000008  ee300a20          VADD.F32 s0,s0,s1
00000c  ed820a00          VSTR     s0,[r2,#0]
;;;332        qSum[1] = q1[1] + q2[1];
000010  ed900a01          VLDR     s0,[r0,#4]
000014  edd10a01          VLDR     s1,[r1,#4]
000018  ee300a20          VADD.F32 s0,s0,s1
00001c  ed820a01          VSTR     s0,[r2,#4]
;;;333        qSum[2] = q1[2] + q2[2];
000020  ed900a02          VLDR     s0,[r0,#8]
000024  edd10a02          VLDR     s1,[r1,#8]
000028  ee300a20          VADD.F32 s0,s0,s1
00002c  ed820a02          VSTR     s0,[r2,#8]
;;;334        qSum[3] = q1[3] + q2[3];
000030  ed900a03          VLDR     s0,[r0,#0xc]
000034  edd10a03          VLDR     s1,[r1,#0xc]
000038  ee300a20          VADD.F32 s0,s0,s1
00003c  ed820a03          VSTR     s0,[r2,#0xc]
;;;335    }
000040  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.inv_q_invert||, CODE, READONLY, ALIGN=1

                  inv_q_invert PROC
;;;278    
;;;279    void inv_q_invert(const long *q, long *qInverted)
000000  6802              LDR      r2,[r0,#0]
;;;280    {
;;;281        INVENSENSE_FUNC_START;
;;;282        qInverted[0] = q[0];
000002  600a              STR      r2,[r1,#0]
;;;283        qInverted[1] = -q[1];
000004  6842              LDR      r2,[r0,#4]
000006  4252              RSBS     r2,r2,#0
000008  604a              STR      r2,[r1,#4]
;;;284        qInverted[2] = -q[2];
00000a  6882              LDR      r2,[r0,#8]
00000c  4252              RSBS     r2,r2,#0
00000e  608a              STR      r2,[r1,#8]
;;;285        qInverted[3] = -q[3];
000010  68c2              LDR      r2,[r0,#0xc]
000012  4252              RSBS     r2,r2,#0
000014  60ca              STR      r2,[r1,#0xc]
;;;286    }
000016  4770              BX       lr
;;;287    
                          ENDP


                          AREA ||i.inv_q_invertf||, CODE, READONLY, ALIGN=1

                  inv_q_invertf PROC
;;;381    
;;;382    void inv_q_invertf(const float *q, float *qInverted)
000000  ed900a00          VLDR     s0,[r0,#0]
;;;383    {
;;;384        INVENSENSE_FUNC_START;
;;;385        qInverted[0] = q[0];
000004  ed810a00          VSTR     s0,[r1,#0]
;;;386        qInverted[1] = -q[1];
000008  ed900a01          VLDR     s0,[r0,#4]
00000c  eeb10a40          VNEG.F32 s0,s0
000010  ed810a01          VSTR     s0,[r1,#4]
;;;387        qInverted[2] = -q[2];
000014  ed900a02          VLDR     s0,[r0,#8]
000018  eeb10a40          VNEG.F32 s0,s0
00001c  ed810a02          VSTR     s0,[r1,#8]
;;;388        qInverted[3] = -q[3];
000020  ed900a03          VLDR     s0,[r0,#0xc]
000024  eeb10a40          VNEG.F32 s0,s0
000028  ed810a03          VSTR     s0,[r1,#0xc]
;;;389    }
00002c  4770              BX       lr
;;;390    
                          ENDP


                          AREA ||i.inv_q_mult||, CODE, READONLY, ALIGN=1

                  inv_q_mult PROC
;;;217    */
;;;218    void inv_q_mult(const long *q1, const long *q2, long *qProd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;219    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;220        INVENSENSE_FUNC_START;
;;;221        qProd[0] = inv_q30_mult(q1[0], q2[0]) - inv_q30_mult(q1[1], q2[1]) -
000008  6829              LDR      r1,[r5,#0]
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       inv_q30_mult
000010  4607              MOV      r7,r0
000012  6869              LDR      r1,[r5,#4]
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       inv_q30_mult
00001a  1a3f              SUBS     r7,r7,r0
00001c  68a9              LDR      r1,[r5,#8]
00001e  68a0              LDR      r0,[r4,#8]
000020  f7fffffe          BL       inv_q30_mult
000024  1a3f              SUBS     r7,r7,r0
000026  68e9              LDR      r1,[r5,#0xc]
000028  68e0              LDR      r0,[r4,#0xc]
00002a  f7fffffe          BL       inv_q30_mult
00002e  1a38              SUBS     r0,r7,r0
000030  6030              STR      r0,[r6,#0]
;;;222                   inv_q30_mult(q1[2], q2[2]) - inv_q30_mult(q1[3], q2[3]);
;;;223    
;;;224        qProd[1] = inv_q30_mult(q1[0], q2[1]) + inv_q30_mult(q1[1], q2[0]) +
000032  6869              LDR      r1,[r5,#4]
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       inv_q30_mult
00003a  4607              MOV      r7,r0
00003c  6829              LDR      r1,[r5,#0]
00003e  6860              LDR      r0,[r4,#4]
000040  f7fffffe          BL       inv_q30_mult
000044  4407              ADD      r7,r7,r0
000046  68e9              LDR      r1,[r5,#0xc]
000048  68a0              LDR      r0,[r4,#8]
00004a  f7fffffe          BL       inv_q30_mult
00004e  4407              ADD      r7,r7,r0
000050  68a9              LDR      r1,[r5,#8]
000052  68e0              LDR      r0,[r4,#0xc]
000054  f7fffffe          BL       inv_q30_mult
000058  1a38              SUBS     r0,r7,r0
00005a  6070              STR      r0,[r6,#4]
;;;225                   inv_q30_mult(q1[2], q2[3]) - inv_q30_mult(q1[3], q2[2]);
;;;226    
;;;227        qProd[2] = inv_q30_mult(q1[0], q2[2]) - inv_q30_mult(q1[1], q2[3]) +
00005c  68a9              LDR      r1,[r5,#8]
00005e  6820              LDR      r0,[r4,#0]
000060  f7fffffe          BL       inv_q30_mult
000064  4607              MOV      r7,r0
000066  68e9              LDR      r1,[r5,#0xc]
000068  6860              LDR      r0,[r4,#4]
00006a  f7fffffe          BL       inv_q30_mult
00006e  1a3f              SUBS     r7,r7,r0
000070  6829              LDR      r1,[r5,#0]
000072  68a0              LDR      r0,[r4,#8]
000074  f7fffffe          BL       inv_q30_mult
000078  4407              ADD      r7,r7,r0
00007a  6869              LDR      r1,[r5,#4]
00007c  68e0              LDR      r0,[r4,#0xc]
00007e  f7fffffe          BL       inv_q30_mult
000082  4438              ADD      r0,r0,r7
000084  60b0              STR      r0,[r6,#8]
;;;228                   inv_q30_mult(q1[2], q2[0]) + inv_q30_mult(q1[3], q2[1]);
;;;229    
;;;230        qProd[3] = inv_q30_mult(q1[0], q2[3]) + inv_q30_mult(q1[1], q2[2]) -
000086  68e9              LDR      r1,[r5,#0xc]
000088  6820              LDR      r0,[r4,#0]
00008a  f7fffffe          BL       inv_q30_mult
00008e  4607              MOV      r7,r0
000090  68a9              LDR      r1,[r5,#8]
000092  6860              LDR      r0,[r4,#4]
000094  f7fffffe          BL       inv_q30_mult
000098  4407              ADD      r7,r7,r0
00009a  6869              LDR      r1,[r5,#4]
00009c  68a0              LDR      r0,[r4,#8]
00009e  f7fffffe          BL       inv_q30_mult
0000a2  1a3f              SUBS     r7,r7,r0
0000a4  6829              LDR      r1,[r5,#0]
0000a6  68e0              LDR      r0,[r4,#0xc]
0000a8  f7fffffe          BL       inv_q30_mult
0000ac  4438              ADD      r0,r0,r7
0000ae  60f0              STR      r0,[r6,#0xc]
;;;231                   inv_q30_mult(q1[2], q2[1]) + inv_q30_mult(q1[3], q2[0]);
;;;232    }
0000b0  bdf0              POP      {r4-r7,pc}
;;;233    
                          ENDP


                          AREA ||i.inv_q_multf||, CODE, READONLY, ALIGN=1

                  inv_q_multf PROC
;;;314    
;;;315    void inv_q_multf(const float *q1, const float *q2, float *qProd)
000000  ed900a00          VLDR     s0,[r0,#0]
;;;316    {
;;;317        INVENSENSE_FUNC_START;
;;;318        qProd[0] =
000004  edd10a00          VLDR     s1,[r1,#0]
000008  ee200a20          VMUL.F32 s0,s0,s1
00000c  edd00a01          VLDR     s1,[r0,#4]
000010  ed911a01          VLDR     s2,[r1,#4]
000014  ee000ac1          VMLS.F32 s0,s1,s2
000018  edd00a02          VLDR     s1,[r0,#8]
00001c  ed911a02          VLDR     s2,[r1,#8]
000020  ee000ac1          VMLS.F32 s0,s1,s2
000024  edd00a03          VLDR     s1,[r0,#0xc]
000028  ed911a03          VLDR     s2,[r1,#0xc]
00002c  ee000ac1          VMLS.F32 s0,s1,s2
000030  ed820a00          VSTR     s0,[r2,#0]
;;;319            (q1[0] * q2[0] - q1[1] * q2[1] - q1[2] * q2[2] - q1[3] * q2[3]);
;;;320        qProd[1] =
000034  ed900a00          VLDR     s0,[r0,#0]
000038  edd10a01          VLDR     s1,[r1,#4]
00003c  ee200a20          VMUL.F32 s0,s0,s1
000040  edd00a01          VLDR     s1,[r0,#4]
000044  ed911a00          VLDR     s2,[r1,#0]
000048  ee000a81          VMLA.F32 s0,s1,s2
00004c  edd00a02          VLDR     s1,[r0,#8]
000050  ed911a03          VLDR     s2,[r1,#0xc]
000054  ee000a81          VMLA.F32 s0,s1,s2
000058  edd00a03          VLDR     s1,[r0,#0xc]
00005c  ed911a02          VLDR     s2,[r1,#8]
000060  ee000ac1          VMLS.F32 s0,s1,s2
000064  ed820a01          VSTR     s0,[r2,#4]
;;;321            (q1[0] * q2[1] + q1[1] * q2[0] + q1[2] * q2[3] - q1[3] * q2[2]);
;;;322        qProd[2] =
000068  ed900a00          VLDR     s0,[r0,#0]
00006c  edd10a02          VLDR     s1,[r1,#8]
000070  ee200a20          VMUL.F32 s0,s0,s1
000074  edd00a01          VLDR     s1,[r0,#4]
000078  ed911a03          VLDR     s2,[r1,#0xc]
00007c  ee000ac1          VMLS.F32 s0,s1,s2
000080  edd00a02          VLDR     s1,[r0,#8]
000084  ed911a00          VLDR     s2,[r1,#0]
000088  ee000a81          VMLA.F32 s0,s1,s2
00008c  edd00a03          VLDR     s1,[r0,#0xc]
000090  ed911a01          VLDR     s2,[r1,#4]
000094  ee000a81          VMLA.F32 s0,s1,s2
000098  ed820a02          VSTR     s0,[r2,#8]
;;;323            (q1[0] * q2[2] - q1[1] * q2[3] + q1[2] * q2[0] + q1[3] * q2[1]);
;;;324        qProd[3] =
00009c  ed900a00          VLDR     s0,[r0,#0]
0000a0  edd10a03          VLDR     s1,[r1,#0xc]
0000a4  ee200a20          VMUL.F32 s0,s0,s1
0000a8  edd00a01          VLDR     s1,[r0,#4]
0000ac  ed911a02          VLDR     s2,[r1,#8]
0000b0  ee000a81          VMLA.F32 s0,s1,s2
0000b4  edd00a02          VLDR     s1,[r0,#8]
0000b8  ed911a01          VLDR     s2,[r1,#4]
0000bc  ee000ac1          VMLS.F32 s0,s1,s2
0000c0  edd00a03          VLDR     s1,[r0,#0xc]
0000c4  ed911a00          VLDR     s2,[r1,#0]
0000c8  ee000a81          VMLA.F32 s0,s1,s2
0000cc  ed820a03          VSTR     s0,[r2,#0xc]
;;;325            (q1[0] * q2[3] + q1[1] * q2[2] - q1[2] * q2[1] + q1[3] * q2[0]);
;;;326    }
0000d0  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.inv_q_norm4||, CODE, READONLY, ALIGN=2

                  inv_q_norm4 PROC
;;;364    */
;;;365    void inv_q_norm4(float *q)
000000  b510              PUSH     {r4,lr}
;;;366    {
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
;;;367        float mag;
;;;368        mag = sqrtf(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
000008  edd40a00          VLDR     s1,[r4,#0]
00000c  ee600aa0          VMUL.F32 s1,s1,s1
000010  ed941a01          VLDR     s2,[r4,#4]
000014  edd41a01          VLDR     s3,[r4,#4]
000018  ee410a21          VMLA.F32 s1,s2,s3
00001c  ed941a02          VLDR     s2,[r4,#8]
000020  edd41a02          VLDR     s3,[r4,#8]
000024  ee410a21          VMLA.F32 s1,s2,s3
000028  ed941a03          VLDR     s2,[r4,#0xc]
00002c  edd41a03          VLDR     s3,[r4,#0xc]
000030  ee410a21          VMLA.F32 s1,s2,s3
000034  eeb00a60          VMOV.F32 s0,s1
000038  f7fffffe          BL       __hardfp_sqrtf
00003c  eeb08a40          VMOV.F32 s16,s0
;;;369        if (mag) {
000040  eeb58ac0          VCMPE.F32 s16,#0.0
000044  eef1fa10          VMRS     APSR_nzcv,FPSCR
000048  d018              BEQ      |L34.124|
;;;370            q[0] /= mag;
00004a  ed940a00          VLDR     s0,[r4,#0]
00004e  eec00a08          VDIV.F32 s1,s0,s16
000052  edc40a00          VSTR     s1,[r4,#0]
;;;371            q[1] /= mag;
000056  ed940a01          VLDR     s0,[r4,#4]
00005a  eec00a08          VDIV.F32 s1,s0,s16
00005e  edc40a01          VSTR     s1,[r4,#4]
;;;372            q[2] /= mag;
000062  ed940a02          VLDR     s0,[r4,#8]
000066  eec00a08          VDIV.F32 s1,s0,s16
00006a  edc40a02          VSTR     s1,[r4,#8]
;;;373            q[3] /= mag;
00006e  ed940a03          VLDR     s0,[r4,#0xc]
000072  eec00a08          VDIV.F32 s1,s0,s16
000076  edc40a03          VSTR     s1,[r4,#0xc]
00007a  e00f              B        |L34.156|
                  |L34.124|
;;;374        } else {
;;;375            q[0] = 1.f;
00007c  eeb70a00          VMOV.F32 s0,#1.00000000
000080  ed840a00          VSTR     s0,[r4,#0]
;;;376            q[1] = 0.f;
000084  ed9f0a07          VLDR     s0,|L34.164|
000088  ed840a01          VSTR     s0,[r4,#4]
;;;377            q[2] = 0.f;
00008c  ed9f0a05          VLDR     s0,|L34.164|
000090  ed840a02          VSTR     s0,[r4,#8]
;;;378            q[3] = 0.f;
000094  ed9f0a03          VLDR     s0,|L34.164|
000098  ed840a03          VSTR     s0,[r4,#0xc]
                  |L34.156|
;;;379        }
;;;380    }
00009c  ecbd8b02          VPOP     {d8}
0000a0  bd10              POP      {r4,pc}
;;;381    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L34.164|
0000a4  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.inv_q_normalize||, CODE, READONLY, ALIGN=1

                  inv_q_normalize PROC
;;;272    
;;;273    void inv_q_normalize(long *q)
000000  b510              PUSH     {r4,lr}
;;;274    {
000002  4604              MOV      r4,r0
;;;275        INVENSENSE_FUNC_START;
;;;276        inv_vector_normalize(q, 4);
000004  2104              MOVS     r1,#4
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       inv_vector_normalize
;;;277    }
00000c  bd10              POP      {r4,pc}
;;;278    
                          ENDP


                          AREA ||i.inv_q_normalizef||, CODE, READONLY, ALIGN=2

                  inv_q_normalizef PROC
;;;336    
;;;337    void inv_q_normalizef(float *q)
000000  ed9f1a4b          VLDR     s2,|L36.304|
;;;338    {
;;;339        INVENSENSE_FUNC_START;
;;;340        float normSF = 0;
000004  eeb00a41          VMOV.F32 s0,s2
;;;341        float xHalf = 0;
000008  ed9f1a49          VLDR     s2,|L36.304|
00000c  eef00a41          VMOV.F32 s1,s2
;;;342        normSF = (q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
000010  ed901a00          VLDR     s2,[r0,#0]
000014  ee211a01          VMUL.F32 s2,s2,s2
000018  edd01a01          VLDR     s3,[r0,#4]
00001c  ed902a01          VLDR     s4,[r0,#4]
000020  ee011a82          VMLA.F32 s2,s3,s4
000024  edd01a02          VLDR     s3,[r0,#8]
000028  ed902a02          VLDR     s4,[r0,#8]
00002c  ee011a82          VMLA.F32 s2,s3,s4
000030  edd01a03          VLDR     s3,[r0,#0xc]
000034  ed902a03          VLDR     s4,[r0,#0xc]
000038  ee011a82          VMLA.F32 s2,s3,s4
00003c  eeb00a41          VMOV.F32 s0,s2
;;;343        if (normSF < 2) {
000040  eeb01a00          VMOV.F32 s2,#2.00000000
000044  eeb40ac1          VCMPE.F32 s0,s2
000048  eef1fa10          VMRS     APSR_nzcv,FPSCR
00004c  d246              BCS      |L36.220|
;;;344            xHalf = 0.5f * normSF;
00004e  eeb61a00          VMOV.F32 s2,#0.50000000
000052  ee201a01          VMUL.F32 s2,s0,s2
000056  eef00a41          VMOV.F32 s1,s2
;;;345            normSF = normSF * (1.5f - xHalf * normSF * normSF);
00005a  ee601a80          VMUL.F32 s3,s1,s0
00005e  eeb71a08          VMOV.F32 s2,#1.50000000
000062  ee011ac0          VMLS.F32 s2,s3,s0
000066  ee211a00          VMUL.F32 s2,s2,s0
00006a  eeb00a41          VMOV.F32 s0,s2
;;;346            normSF = normSF * (1.5f - xHalf * normSF * normSF);
00006e  ee601a80          VMUL.F32 s3,s1,s0
000072  eeb71a08          VMOV.F32 s2,#1.50000000
000076  ee011ac0          VMLS.F32 s2,s3,s0
00007a  ee211a00          VMUL.F32 s2,s2,s0
00007e  eeb00a41          VMOV.F32 s0,s2
;;;347            normSF = normSF * (1.5f - xHalf * normSF * normSF);
000082  ee601a80          VMUL.F32 s3,s1,s0
000086  eeb71a08          VMOV.F32 s2,#1.50000000
00008a  ee011ac0          VMLS.F32 s2,s3,s0
00008e  ee211a00          VMUL.F32 s2,s2,s0
000092  eeb00a41          VMOV.F32 s0,s2
;;;348            normSF = normSF * (1.5f - xHalf * normSF * normSF);
000096  ee601a80          VMUL.F32 s3,s1,s0
00009a  eeb71a08          VMOV.F32 s2,#1.50000000
00009e  ee011ac0          VMLS.F32 s2,s3,s0
0000a2  ee211a00          VMUL.F32 s2,s2,s0
0000a6  eeb00a41          VMOV.F32 s0,s2
;;;349            q[0] *= normSF;
0000aa  ed901a00          VLDR     s2,[r0,#0]
0000ae  ee211a00          VMUL.F32 s2,s2,s0
0000b2  ed801a00          VSTR     s2,[r0,#0]
;;;350            q[1] *= normSF;
0000b6  ed901a01          VLDR     s2,[r0,#4]
0000ba  ee211a00          VMUL.F32 s2,s2,s0
0000be  ed801a01          VSTR     s2,[r0,#4]
;;;351            q[2] *= normSF;
0000c2  ed901a02          VLDR     s2,[r0,#8]
0000c6  ee211a00          VMUL.F32 s2,s2,s0
0000ca  ed801a02          VSTR     s2,[r0,#8]
;;;352            q[3] *= normSF;
0000ce  ed901a03          VLDR     s2,[r0,#0xc]
0000d2  ee211a00          VMUL.F32 s2,s2,s0
0000d6  ed801a03          VSTR     s2,[r0,#0xc]
0000da  e00f              B        |L36.252|
                  |L36.220|
;;;353        } else {
;;;354            q[0] = 1.0;
0000dc  eeb71a00          VMOV.F32 s2,#1.00000000
0000e0  ed801a00          VSTR     s2,[r0,#0]
;;;355            q[1] = 0.0;
0000e4  ed9f1a12          VLDR     s2,|L36.304|
0000e8  ed801a01          VSTR     s2,[r0,#4]
;;;356            q[2] = 0.0;
0000ec  ed9f1a10          VLDR     s2,|L36.304|
0000f0  ed801a02          VSTR     s2,[r0,#8]
;;;357            q[3] = 0.0;
0000f4  ed9f1a0e          VLDR     s2,|L36.304|
0000f8  ed801a03          VSTR     s2,[r0,#0xc]
                  |L36.252|
;;;358        }
;;;359        normSF = (q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);
0000fc  ed901a00          VLDR     s2,[r0,#0]
000100  ee211a01          VMUL.F32 s2,s2,s2
000104  edd01a01          VLDR     s3,[r0,#4]
000108  ed902a01          VLDR     s4,[r0,#4]
00010c  ee011a82          VMLA.F32 s2,s3,s4
000110  edd01a02          VLDR     s3,[r0,#8]
000114  ed902a02          VLDR     s4,[r0,#8]
000118  ee011a82          VMLA.F32 s2,s3,s4
00011c  edd01a03          VLDR     s3,[r0,#0xc]
000120  ed902a03          VLDR     s4,[r0,#0xc]
000124  ee011a82          VMLA.F32 s2,s3,s4
000128  eeb00a41          VMOV.F32 s0,s2
;;;360    }
00012c  4770              BX       lr
;;;361    
                          ENDP

00012e  0000              DCW      0x0000
                  |L36.304|
000130  00000000          DCFS     0x00000000 ; 0

                          AREA ||i.inv_q_rotate||, CODE, READONLY, ALIGN=1

                  inv_q_rotate PROC
;;;300    */
;;;301    void inv_q_rotate(const long *q, const long *in, long *out)
000000  b570              PUSH     {r4-r6,lr}
;;;302    {
000002  b090              SUB      sp,sp,#0x40
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;303        long q_temp1[4], q_temp2[4];
;;;304        long in4[4], out4[4];
;;;305    
;;;306        // Fixme optimize
;;;307        in4[0] = 0;
00000a  2000              MOVS     r0,#0
00000c  9004              STR      r0,[sp,#0x10]
;;;308        memcpy(&in4[1], in, 3 * sizeof(long));
00000e  e9d40201          LDRD     r0,r2,[r4,#4]
000012  6821              LDR      r1,[r4,#0]
000014  e9cd0206          STRD     r0,r2,[sp,#0x18]
000018  9105              STR      r1,[sp,#0x14]
;;;309        inv_q_mult(q, in4, q_temp1);
00001a  aa0c              ADD      r2,sp,#0x30
00001c  a904              ADD      r1,sp,#0x10
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       inv_q_mult
;;;310        inv_q_invert(q, q_temp2);
000024  a908              ADD      r1,sp,#0x20
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       inv_q_invert
;;;311        inv_q_mult(q_temp1, q_temp2, out4);
00002c  466a              MOV      r2,sp
00002e  a908              ADD      r1,sp,#0x20
000030  a80c              ADD      r0,sp,#0x30
000032  f7fffffe          BL       inv_q_mult
;;;312        memcpy(out, &out4[1], 3 * sizeof(long));
000036  a801              ADD      r0,sp,#4
000038  c807              LDM      r0,{r0-r2}
00003a  e8850007          STM      r5,{r0-r2}
;;;313    }
00003e  b010              ADD      sp,sp,#0x40
000040  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP


                          AREA ||i.inv_q_shift_mult||, CODE, READONLY, ALIGN=1

                  inv_q_shift_mult PROC
;;;201    #ifndef EMPL_NO_64BIT
;;;202    long inv_q_shift_mult(long a, long b, int shift)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;203    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;204        long result;
;;;205        result = (long)(((long long)a * b) >> shift);
00000a  fb864507          SMULL    r4,r5,r6,r7
00000e  4642              MOV      r2,r8
000010  4620              MOV      r0,r4
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       __aeabi_lasr
000018  4681              MOV      r9,r0
;;;206        return result;
00001a  4648              MOV      r0,r9
;;;207    }
00001c  e8bd87f0          POP      {r4-r10,pc}
;;;208    #endif
                          ENDP


                          AREA ||i.inv_quaternion_to_rotation||, CODE, READONLY, ALIGN=1

                  inv_quaternion_to_rotation PROC
;;;399     */
;;;400    void inv_quaternion_to_rotation(const long *quat, long *rot)
000000  b570              PUSH     {r4-r6,lr}
;;;401    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;402        rot[0] =
000006  6861              LDR      r1,[r4,#4]
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       inv_q29_mult
00000e  4606              MOV      r6,r0
000010  6821              LDR      r1,[r4,#0]
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       inv_q29_mult
000018  4430              ADD      r0,r0,r6
00001a  f1a04080          SUB      r0,r0,#0x40000000
00001e  6028              STR      r0,[r5,#0]
;;;403            inv_q29_mult(quat[1], quat[1]) + inv_q29_mult(quat[0],
;;;404                    quat[0]) -
;;;405            1073741824L;
;;;406        rot[1] =
000020  e9d40101          LDRD     r0,r1,[r4,#4]
000024  f7fffffe          BL       inv_q29_mult
000028  4606              MOV      r6,r0
00002a  6821              LDR      r1,[r4,#0]
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  f7fffffe          BL       inv_q29_mult
000032  1a30              SUBS     r0,r6,r0
000034  6068              STR      r0,[r5,#4]
;;;407            inv_q29_mult(quat[1], quat[2]) - inv_q29_mult(quat[3], quat[0]);
;;;408        rot[2] =
000036  68e1              LDR      r1,[r4,#0xc]
000038  6860              LDR      r0,[r4,#4]
00003a  f7fffffe          BL       inv_q29_mult
00003e  4606              MOV      r6,r0
000040  6821              LDR      r1,[r4,#0]
000042  68a0              LDR      r0,[r4,#8]
000044  f7fffffe          BL       inv_q29_mult
000048  4430              ADD      r0,r0,r6
00004a  60a8              STR      r0,[r5,#8]
;;;409            inv_q29_mult(quat[1], quat[3]) + inv_q29_mult(quat[2], quat[0]);
;;;410        rot[3] =
00004c  e9d40101          LDRD     r0,r1,[r4,#4]
000050  f7fffffe          BL       inv_q29_mult
000054  4606              MOV      r6,r0
000056  6821              LDR      r1,[r4,#0]
000058  68e0              LDR      r0,[r4,#0xc]
00005a  f7fffffe          BL       inv_q29_mult
00005e  4430              ADD      r0,r0,r6
000060  60e8              STR      r0,[r5,#0xc]
;;;411            inv_q29_mult(quat[1], quat[2]) + inv_q29_mult(quat[3], quat[0]);
;;;412        rot[4] =
000062  68a1              LDR      r1,[r4,#8]
000064  4608              MOV      r0,r1
000066  f7fffffe          BL       inv_q29_mult
00006a  4606              MOV      r6,r0
00006c  6821              LDR      r1,[r4,#0]
00006e  4608              MOV      r0,r1
000070  f7fffffe          BL       inv_q29_mult
000074  4430              ADD      r0,r0,r6
000076  f1a04080          SUB      r0,r0,#0x40000000
00007a  6128              STR      r0,[r5,#0x10]
;;;413            inv_q29_mult(quat[2], quat[2]) + inv_q29_mult(quat[0],
;;;414                    quat[0]) -
;;;415            1073741824L;
;;;416        rot[5] =
00007c  e9d40102          LDRD     r0,r1,[r4,#8]
000080  f7fffffe          BL       inv_q29_mult
000084  4606              MOV      r6,r0
000086  e9d41000          LDRD     r1,r0,[r4,#0]
00008a  f7fffffe          BL       inv_q29_mult
00008e  1a30              SUBS     r0,r6,r0
000090  6168              STR      r0,[r5,#0x14]
;;;417            inv_q29_mult(quat[2], quat[3]) - inv_q29_mult(quat[1], quat[0]);
;;;418        rot[6] =
000092  68e1              LDR      r1,[r4,#0xc]
000094  6860              LDR      r0,[r4,#4]
000096  f7fffffe          BL       inv_q29_mult
00009a  4606              MOV      r6,r0
00009c  6821              LDR      r1,[r4,#0]
00009e  68a0              LDR      r0,[r4,#8]
0000a0  f7fffffe          BL       inv_q29_mult
0000a4  1a30              SUBS     r0,r6,r0
0000a6  61a8              STR      r0,[r5,#0x18]
;;;419            inv_q29_mult(quat[1], quat[3]) - inv_q29_mult(quat[2], quat[0]);
;;;420        rot[7] =
0000a8  e9d40102          LDRD     r0,r1,[r4,#8]
0000ac  f7fffffe          BL       inv_q29_mult
0000b0  4606              MOV      r6,r0
0000b2  e9d41000          LDRD     r1,r0,[r4,#0]
0000b6  f7fffffe          BL       inv_q29_mult
0000ba  4430              ADD      r0,r0,r6
0000bc  61e8              STR      r0,[r5,#0x1c]
;;;421            inv_q29_mult(quat[2], quat[3]) + inv_q29_mult(quat[1], quat[0]);
;;;422        rot[8] =
0000be  68e1              LDR      r1,[r4,#0xc]
0000c0  4608              MOV      r0,r1
0000c2  f7fffffe          BL       inv_q29_mult
0000c6  4606              MOV      r6,r0
0000c8  6821              LDR      r1,[r4,#0]
0000ca  4608              MOV      r0,r1
0000cc  f7fffffe          BL       inv_q29_mult
0000d0  4430              ADD      r0,r0,r6
0000d2  f1a04080          SUB      r0,r0,#0x40000000
0000d6  6228              STR      r0,[r5,#0x20]
;;;423            inv_q29_mult(quat[3], quat[3]) + inv_q29_mult(quat[0],
;;;424                    quat[0]) -
;;;425            1073741824L;
;;;426    }
0000d8  bd70              POP      {r4-r6,pc}
;;;427    
                          ENDP


                          AREA ||i.inv_quaternion_to_rotation_vector||, CODE, READONLY, ALIGN=1

                  inv_quaternion_to_rotation_vector PROC
;;;437     */
;;;438    void inv_quaternion_to_rotation_vector(const long *quat, long *rot)
000000  6842              LDR      r2,[r0,#4]
;;;439    {
;;;440        rot[0] = quat[1];
000002  600a              STR      r2,[r1,#0]
;;;441        rot[1] = quat[2];
000004  6882              LDR      r2,[r0,#8]
000006  604a              STR      r2,[r1,#4]
;;;442        rot[2] = quat[3];
000008  68c2              LDR      r2,[r0,#0xc]
00000a  608a              STR      r2,[r1,#8]
;;;443    
;;;444        if (quat[0] < 0.0) {
00000c  ed900a00          VLDR     s0,[r0,#0]
000010  eeb80bc0          VCVT.F64.S32 d0,s0
000014  eeb50bc0          VCMPE.F64 d0,#0.0
000018  eef1fa10          VMRS     APSR_nzcv,FPSCR
00001c  d208              BCS      |L40.48|
;;;445            rot[0] = -rot[0];
00001e  680a              LDR      r2,[r1,#0]
000020  4252              RSBS     r2,r2,#0
000022  600a              STR      r2,[r1,#0]
;;;446            rot[1] = -rot[1];
000024  684a              LDR      r2,[r1,#4]
000026  4252              RSBS     r2,r2,#0
000028  604a              STR      r2,[r1,#4]
;;;447            rot[2] = -rot[2];
00002a  688a              LDR      r2,[r1,#8]
00002c  4252              RSBS     r2,r2,#0
00002e  608a              STR      r2,[r1,#8]
                  |L40.48|
;;;448        }
;;;449    }
000030  4770              BX       lr
;;;450    
                          ENDP


                          AREA ||i.inv_row_2_scale||, CODE, READONLY, ALIGN=1

                  inv_row_2_scale PROC
;;;608    
;;;609    static unsigned short inv_row_2_scale(const signed char *row)
000000  4601              MOV      r1,r0
;;;610    {
;;;611        unsigned short b;
;;;612    
;;;613        if (row[0] > 0)
000002  f9912000          LDRSB    r2,[r1,#0]
000006  2a00              CMP      r2,#0
000008  dd01              BLE      |L41.14|
;;;614            b = 0;
00000a  2000              MOVS     r0,#0
00000c  e01e              B        |L41.76|
                  |L41.14|
;;;615        else if (row[0] < 0)
00000e  f9912000          LDRSB    r2,[r1,#0]
000012  2a00              CMP      r2,#0
000014  da01              BGE      |L41.26|
;;;616            b = 4;
000016  2004              MOVS     r0,#4
000018  e018              B        |L41.76|
                  |L41.26|
;;;617        else if (row[1] > 0)
00001a  f9912001          LDRSB    r2,[r1,#1]
00001e  2a00              CMP      r2,#0
000020  dd01              BLE      |L41.38|
;;;618            b = 1;
000022  2001              MOVS     r0,#1
000024  e012              B        |L41.76|
                  |L41.38|
;;;619        else if (row[1] < 0)
000026  f9912001          LDRSB    r2,[r1,#1]
00002a  2a00              CMP      r2,#0
00002c  da01              BGE      |L41.50|
;;;620            b = 5;
00002e  2005              MOVS     r0,#5
000030  e00c              B        |L41.76|
                  |L41.50|
;;;621        else if (row[2] > 0)
000032  f9912002          LDRSB    r2,[r1,#2]
000036  2a00              CMP      r2,#0
000038  dd01              BLE      |L41.62|
;;;622            b = 2;
00003a  2002              MOVS     r0,#2
00003c  e006              B        |L41.76|
                  |L41.62|
;;;623        else if (row[2] < 0)
00003e  f9912002          LDRSB    r2,[r1,#2]
000042  2a00              CMP      r2,#0
000044  da01              BGE      |L41.74|
;;;624            b = 6;
000046  2006              MOVS     r0,#6
000048  e000              B        |L41.76|
                  |L41.74|
;;;625        else
;;;626            b = 7;		// error
00004a  2007              MOVS     r0,#7
                  |L41.76|
;;;627        return b;
;;;628    }
00004c  4770              BX       lr
;;;629    
                          ENDP


                          AREA ||i.inv_sinf||, CODE, READONLY, ALIGN=2

                  inv_sinf PROC
;;;69     
;;;70     float inv_sinf(float x)
000000  eef00a40          VMOV.F32 s1,s0
;;;71     {
;;;72         int index = (unsigned int)((x * (TABLE_SIZE>>1)) / 3.14159f) % TABLE_SIZE;
000004  ed9f0a09          VLDR     s0,|L42.44|
000008  ee200a80          VMUL.F32 s0,s1,s0
00000c  ed9f1a08          VLDR     s2,|L42.48|
000010  eec01a01          VDIV.F32 s3,s0,s2
000014  eebc0ae1          VCVT.U32.F32 s0,s3
000018  ee101a10          VMOV     r1,s0
00001c  b2c8              UXTB     r0,r1
;;;73         return sin_lookup[index];
00001e  4905              LDR      r1,|L42.52|
000020  eb010180          ADD      r1,r1,r0,LSL #2
000024  ed910a00          VLDR     s0,[r1,#0]
;;;74     }
000028  4770              BX       lr
;;;75     
                          ENDP

00002a  0000              DCW      0x0000
                  |L42.44|
00002c  43000000          DCFS     0x43000000 ; 128
                  |L42.48|
000030  40490fd0          DCFS     0x40490fd0 ; 3.1415901184082031
                  |L42.52|
                          DCD      sin_lookup

                          AREA ||i.inv_vector_norm||, CODE, READONLY, ALIGN=1

                  inv_vector_norm PROC
;;;707    */
;;;708    double inv_vector_norm(const float *x)
000000  b510              PUSH     {r4,lr}
;;;709    {
000002  4604              MOV      r4,r0
;;;710        return sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);
000004  ed941a00          VLDR     s2,[r4,#0]
000008  ee211a01          VMUL.F32 s2,s2,s2
00000c  edd41a01          VLDR     s3,[r4,#4]
000010  ed942a01          VLDR     s4,[r4,#4]
000014  ee011a82          VMLA.F32 s2,s3,s4
000018  edd41a02          VLDR     s3,[r4,#8]
00001c  ed942a02          VLDR     s4,[r4,#8]
000020  ee011a82          VMLA.F32 s2,s3,s4
000024  eeb71ac1          VCVT.F64.F32 d1,s2
000028  eeb00b41          VMOV.F64 d0,d1
00002c  f7fffffe          BL       __hardfp_sqrt
;;;711    }
000030  bd10              POP      {r4,pc}
;;;712    
                          ENDP


                          AREA ||i.inv_vector_normalize||, CODE, READONLY, ALIGN=2

                  inv_vector_normalize PROC
;;;250    
;;;251    void inv_vector_normalize(long *vec, int length)
000000  b570              PUSH     {r4-r6,lr}
;;;252    {
000002  ed2d8b04          VPUSH    {d8-d9}
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;253        INVENSENSE_FUNC_START;
;;;254        double normSF = 0;
00000a  ed9f0b25          VLDR     d0,|L44.160|
00000e  eeb08b40          VMOV.F64 d8,d0
;;;255        int ii;
;;;256        for (ii = 0; ii < length; ii++) {
000012  2400              MOVS     r4,#0
000014  e010              B        |L44.56|
                  |L44.22|
;;;257            normSF +=
000016  f8550024          LDR      r0,[r5,r4,LSL #2]
00001a  f7fffffe          BL       inv_q30_to_double
00001e  eeb09b40          VMOV.F64 d9,d0
000022  f8550024          LDR      r0,[r5,r4,LSL #2]
000026  f7fffffe          BL       inv_q30_to_double
00002a  eeb01b48          VMOV.F64 d1,d8
00002e  ee091b00          VMLA.F64 d1,d9,d0
000032  eeb08b41          VMOV.F64 d8,d1
000036  1c64              ADDS     r4,r4,#1              ;256
                  |L44.56|
000038  42b4              CMP      r4,r6                 ;256
00003a  dbec              BLT      |L44.22|
;;;258                inv_q30_to_double(vec[ii]) * inv_q30_to_double(vec[ii]);
;;;259        }
;;;260        if (normSF > 0) {
00003c  eeb58bc0          VCMPE.F64 d8,#0.0
000040  eef1fa10          VMRS     APSR_nzcv,FPSCR
000044  dd1d              BLE      |L44.130|
;;;261            normSF = 1 / sqrt(normSF);
000046  eeb00b48          VMOV.F64 d0,d8
00004a  f7fffffe          BL       __hardfp_sqrt
00004e  eeb71b00          VMOV.F64 d1,#1.00000000
000052  ee812b00          VDIV.F64 d2,d1,d0
000056  eeb08b42          VMOV.F64 d8,d2
;;;262            for (ii = 0; ii < length; ii++) {
00005a  2400              MOVS     r4,#0
00005c  e00e              B        |L44.124|
                  |L44.94|
;;;263                vec[ii] = (int)((double)vec[ii] * normSF);
00005e  f8550024          LDR      r0,[r5,r4,LSL #2]
000062  ee000a10          VMOV     s0,r0
000066  eeb80bc0          VCVT.F64.S32 d0,s0
00006a  ee200b08          VMUL.F64 d0,d0,d8
00006e  eebd0bc0          VCVT.S32.F64 s0,d0
000072  ee100a10          VMOV     r0,s0
000076  f8450024          STR      r0,[r5,r4,LSL #2]
00007a  1c64              ADDS     r4,r4,#1              ;262
                  |L44.124|
00007c  42b4              CMP      r4,r6                 ;262
00007e  dbee              BLT      |L44.94|
000080  e00a              B        |L44.152|
                  |L44.130|
;;;264            }
;;;265        } else {
;;;266            vec[0] = 1073741824L;
000082  f04f4080          MOV      r0,#0x40000000
000086  6028              STR      r0,[r5,#0]
;;;267            for (ii = 1; ii < length; ii++) {
000088  2401              MOVS     r4,#1
00008a  e003              B        |L44.148|
                  |L44.140|
;;;268                vec[ii] = 0;
00008c  2000              MOVS     r0,#0
00008e  f8450024          STR      r0,[r5,r4,LSL #2]
000092  1c64              ADDS     r4,r4,#1              ;267
                  |L44.148|
000094  42b4              CMP      r4,r6                 ;267
000096  dbf9              BLT      |L44.140|
                  |L44.152|
;;;269            }
;;;270        }
;;;271    }
000098  ecbd8b04          VPOP     {d8-d9}
00009c  bd70              POP      {r4-r6,pc}
;;;272    
                          ENDP

00009e  0000              DCW      0x0000
                  |L44.160|
0000a0  00000000          DCFD     0x0000000000000000 ; 0
0000a4  00000000

                          AREA ||i.inv_wrap_angle||, CODE, READONLY, ALIGN=2

                  inv_wrap_angle PROC
;;;565     */
;;;566    float inv_wrap_angle(float ang)
000000  eef00a40          VMOV.F32 s1,s0
;;;567    {
;;;568        if ((double)ang > M_PI)
000004  eeb71ae0          VCVT.F64.F32 d1,s1
000008  ed9f2b0d          VLDR     d2,|L45.64|
00000c  eeb41bc2          VCMPE.F64 d1,d2
000010  eef1fa10          VMRS     APSR_nzcv,FPSCR
000014  dd04              BLE      |L45.32|
;;;569            return ang - 2 * (float)M_PI;
000016  ed9f0a0c          VLDR     s0,|L45.72|
00001a  ee300ac0          VSUB.F32 s0,s1,s0
                  |L45.30|
;;;570        else if (ang <= -(float)M_PI)
;;;571            return ang + 2 * (float)M_PI;
;;;572        else
;;;573            return ang;
;;;574    }
00001e  4770              BX       lr
                  |L45.32|
000020  ed9f0a0a          VLDR     s0,|L45.76|
000024  eef40ac0          VCMPE.F32 s1,s0                 ;570
000028  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;570
00002c  d804              BHI      |L45.56|
00002e  ed9f0a06          VLDR     s0,|L45.72|
000032  ee300a80          VADD.F32 s0,s1,s0              ;571
000036  e7f2              B        |L45.30|
                  |L45.56|
000038  eeb00a60          VMOV.F32 s0,s1                 ;573
00003c  e7ef              B        |L45.30|
;;;575    
                          ENDP

00003e  0000              DCW      0x0000
                  |L45.64|
000040  54442d11          DCFD     0x400921fb54442d11 ; 3.14159265358979
000044  400921fb
                  |L45.72|
000048  40c90fdb          DCFS     0x40c90fdb ; 6.2831854820251465
                  |L45.76|
00004c  c0490fdb          DCFS     0xc0490fdb ; -3.1415927410125732

                          AREA ||i.mlMatrixVectorMult||, CODE, READONLY, ALIGN=1

                  mlMatrixVectorMult PROC
;;;757    
;;;758    void mlMatrixVectorMult(long matrix[9], const long vecIn[3], long *vecOut)  {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;759            // matrix format
;;;760            //  [ 0  3  6;
;;;761            //    1  4  7;
;;;762            //    2  5  8]
;;;763    
;;;764            // vector format:  [0  1  2]^T;
;;;765            int i, j;
;;;766            long temp;
;;;767    
;;;768            for (i=0; i<3; i++)	{
00000a  2400              MOVS     r4,#0
00000c  e013              B        |L46.54|
                  |L46.14|
;;;769                    temp = 0;
00000e  f04f0900          MOV      r9,#0
;;;770                    for (j=0; j<3; j++)  {
000012  2500              MOVS     r5,#0
000014  e00a              B        |L46.44|
                  |L46.22|
;;;771                            temp += inv_q30_mult(matrix[i+j*3], vecIn[j]);
000016  f8571025          LDR      r1,[r7,r5,LSL #2]
00001a  eb050245          ADD      r2,r5,r5,LSL #1
00001e  4422              ADD      r2,r2,r4
000020  f8560022          LDR      r0,[r6,r2,LSL #2]
000024  f7fffffe          BL       inv_q30_mult
000028  4481              ADD      r9,r9,r0
00002a  1c6d              ADDS     r5,r5,#1              ;770
                  |L46.44|
00002c  2d03              CMP      r5,#3                 ;770
00002e  dbf2              BLT      |L46.22|
;;;772                    }
;;;773                    vecOut[i] = temp;
000030  f8489024          STR      r9,[r8,r4,LSL #2]
000034  1c64              ADDS     r4,r4,#1              ;768
                  |L46.54|
000036  2c03              CMP      r4,#3                 ;768
000038  dbe9              BLT      |L46.14|
;;;774            }
;;;775    }
00003a  e8bd83f0          POP      {r4-r9,pc}
;;;776    
                          ENDP


                          AREA ||i.quaternion_to_rotation_angle||, CODE, READONLY, ALIGN=2

                  quaternion_to_rotation_angle PROC
;;;287    
;;;288    double quaternion_to_rotation_angle(const long *quat) {
000000  b510              PUSH     {r4,lr}
000002  ed2d8b02          VPUSH    {d8}
000006  4604              MOV      r4,r0
;;;289        double quat0 = (double )quat[0] / 1073741824;
000008  ed940a00          VLDR     s0,[r4,#0]
00000c  eeb80bc0          VCVT.F64.S32 d0,s0
000010  ed9f1b17          VLDR     d1,|L47.112|
000014  ee802b01          VDIV.F64 d2,d0,d1
000018  eeb08b42          VMOV.F64 d8,d2
;;;290        if (quat0 > 1.0f) {
00001c  eeb70b00          VMOV.F64 d0,#1.00000000
000020  eeb48bc0          VCMPE.F64 d8,d0
000024  eef1fa10          VMRS     APSR_nzcv,FPSCR
000028  dd04              BLE      |L47.52|
;;;291            quat0 = 1.0;
00002a  eeb70b00          VMOV.F64 d0,#1.00000000
00002e  eeb08b40          VMOV.F64 d8,d0
000032  e00a              B        |L47.74|
                  |L47.52|
;;;292        } else if (quat0 < -1.0f) {
000034  eebf0b00          VMOV.F64 d0,#-1.00000000
000038  eeb48bc0          VCMPE.F64 d8,d0
00003c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000040  d203              BCS      |L47.74|
;;;293            quat0 = -1.0;
000042  eebf0b00          VMOV.F64 d0,#-1.00000000
000046  eeb08b40          VMOV.F64 d8,d0
                  |L47.74|
;;;294        }
;;;295    
;;;296        return acos(quat0)*2*180/M_PI;
00004a  eeb00b48          VMOV.F64 d0,d8
00004e  f7fffffe          BL       __hardfp_acos
000052  eeb01b00          VMOV.F64 d1,#2.00000000
000056  ee200b01          VMUL.F64 d0,d0,d1
00005a  ed9f1b07          VLDR     d1,|L47.120|
00005e  ee201b01          VMUL.F64 d1,d0,d1
000062  ed9f2b07          VLDR     d2,|L47.128|
000066  ee810b02          VDIV.F64 d0,d1,d2
;;;297    }
00006a  ecbd8b02          VPOP     {d8}
00006e  bd10              POP      {r4,pc}
;;;298    
                          ENDP

                  |L47.112|
000070  00000000          DCFD     0x41d0000000000000 ; 1073741824
000074  41d00000
                  |L47.120|
000078  00000000          DCFD     0x4066800000000000 ; 180
00007c  40668000
                  |L47.128|
000080  54442d11          DCFD     0x400921fb54442d11 ; 3.14159265358979
000084  400921fb

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  sin_lookup
000000  00000000          DCFS     0x00000000 ; 0
000004  3cc90a35          DCFS     0x3cc90a35 ; 0.02454099990427494
000008  3d48fb87          DCFS     0x3d48fb87 ; 0.049068000167608261
00000c  3d96a93f          DCFS     0x3d96a93f ; 0.073564998805522919
000010  3dc8bd23          DCFS     0x3dc8bd23 ; 0.098016999661922455
000014  3dfab29e          DCFS     0x3dfab29e ; 0.12241099774837494
000018  3e164064          DCFS     0x3e164064 ; 0.14673000574111938
00001c  3e2f10aa          DCFS     0x3e2f10aa ; 0.17096200585365295
000020  3e47c5ac          DCFS     0x3e47c5ac ; 0.19508999586105347
000024  3e605c03          DCFS     0x3e605c03 ; 0.21910099685192108
000028  3e78cfc0          DCFS     0x3e78cfc0 ; 0.24298000335693359
00002c  3e888e9b          DCFS     0x3e888e9b ; 0.26671299338340759
000030  3e94a03c          DCFS     0x3e94a03c ; 0.29028499126434326
000034  3ea09aed          DCFS     0x3ea09aed ; 0.31368198990821838
000038  3eac7cd9          DCFS     0x3eac7cd9 ; 0.33689001202583313
00003c  3eb84428          DCFS     0x3eb84428 ; 0.35989499092102051
000040  3ec3ef07          DCFS     0x3ec3ef07 ; 0.38268300890922546
000044  3ecf7bc0          DCFS     0x3ecf7bc0 ; 0.40524101257324219
000048  3edae87d          DCFS     0x3edae87d ; 0.42755499482154846
00004c  3ee6336a          DCFS     0x3ee6336a ; 0.44961100816726685
000050  3ef15af3          DCFS     0x3ef15af3 ; 0.47139701247215271
000054  3efc5d20          DCFS     0x3efc5d20 ; 0.49289798736572266
000058  3f039c41          DCFS     0x3f039c41 ; 0.5141029953956604
00005c  3f08f5a1          DCFS     0x3f08f5a1 ; 0.53499799966812134
000060  3f0e39d6          DCFS     0x3f0e39d6 ; 0.55557000637054443
000064  3f136827          DCFS     0x3f136827 ; 0.57580798864364624
000068  3f187fbb          DCFS     0x3f187fbb ; 0.5956990122795105
00006c  3f1d7fd8          DCFS     0x3f1d7fd8 ; 0.61523199081420898
000070  3f226794          DCFS     0x3f226794 ; 0.63439297676086426
000074  3f273659          DCFS     0x3f273659 ; 0.65317302942276001
000078  3f2beb4a          DCFS     0x3f2beb4a ; 0.67155897617340088
00007c  3f3085c2          DCFS     0x3f3085c2 ; 0.68954098224639893
000080  3f3504f7          DCFS     0x3f3504f7 ; 0.70710700750350952
000084  3f396840          DCFS     0x3f396840 ; 0.72424697875976562
000088  3f3daef7          DCFS     0x3f3daef7 ; 0.74095100164413452
00008c  3f41d873          DCFS     0x3f41d873 ; 0.75720900297164917
000090  3f45e3fc          DCFS     0x3f45e3fc ; 0.7730100154876709
000094  3f49d10b          DCFS     0x3f49d10b ; 0.78834599256515503
000098  3f4d9f0a          DCFS     0x3f4d9f0a ; 0.80320799350738525
00009c  3f514d40          DCFS     0x3f514d40 ; 0.81758499145507812
0000a0  3f54db38          DCFS     0x3f54db38 ; 0.83147001266479492
0000a4  3f58485a          DCFS     0x3f58485a ; 0.84485399723052979
0000a8  3f5b9421          DCFS     0x3f5b9421 ; 0.85772901773452759
0000ac  3f5ebe06          DCFS     0x3f5ebe06 ; 0.87008702754974365
0000b0  3f61c593          DCFS     0x3f61c593 ; 0.88192099332809448
0000b4  3f64aa54          DCFS     0x3f64aa54 ; 0.89322400093078613
0000b8  3f676bd3          DCFS     0x3f676bd3 ; 0.90398901700973511
0000bc  3f6a09ab          DCFS     0x3f6a09ab ; 0.91421002149581909
0000c0  3f6c8366          DCFS     0x3f6c8366 ; 0.92387998104095459
0000c4  3f6ed8a1          DCFS     0x3f6ed8a1 ; 0.93299299478530884
0000c8  3f710907          DCFS     0x3f710907 ; 0.94154399633407593
0000cc  3f731444          DCFS     0x3f731444 ; 0.94952797889709473
0000d0  3f74fa05          DCFS     0x3f74fa05 ; 0.95693999528884888
0000d4  3f76ba06          DCFS     0x3f76ba06 ; 0.96377599239349365
0000d8  3f7853f4          DCFS     0x3f7853f4 ; 0.9700310230255127
0000dc  3f79c79b          DCFS     0x3f79c79b ; 0.97570198774337769
0000e0  3f7b14ba          DCFS     0x3f7b14ba ; 0.98078501224517822
0000e4  3f7c3b2e          DCFS     0x3f7c3b2e ; 0.98527801036834717
0000e8  3f7d3ab4          DCFS     0x3f7d3ab4 ; 0.98917698860168457
0000ec  3f7e132b          DCFS     0x3f7e132b ; 0.99247997999191284
0000f0  3f7ec472          DCFS     0x3f7ec472 ; 0.99518501758575439
0000f4  3f7f4e66          DCFS     0x3f7f4e66 ; 0.99729001522064209
0000f8  3f7fb107          DCFS     0x3f7fb107 ; 0.99879497289657593
0000fc  3f7fec46          DCFS     0x3f7fec46 ; 0.99969899654388428
000100  3f800000          DCFS     0x3f800000 ; 1
000104  3f7fec46          DCFS     0x3f7fec46 ; 0.99969899654388428
000108  3f7fb107          DCFS     0x3f7fb107 ; 0.99879497289657593
00010c  3f7f4e66          DCFS     0x3f7f4e66 ; 0.99729001522064209
000110  3f7ec472          DCFS     0x3f7ec472 ; 0.99518501758575439
000114  3f7e132b          DCFS     0x3f7e132b ; 0.99247997999191284
000118  3f7d3ab4          DCFS     0x3f7d3ab4 ; 0.98917698860168457
00011c  3f7c3b2e          DCFS     0x3f7c3b2e ; 0.98527801036834717
000120  3f7b14ba          DCFS     0x3f7b14ba ; 0.98078501224517822
000124  3f79c79b          DCFS     0x3f79c79b ; 0.97570198774337769
000128  3f7853f4          DCFS     0x3f7853f4 ; 0.9700310230255127
00012c  3f76ba06          DCFS     0x3f76ba06 ; 0.96377599239349365
000130  3f74fa05          DCFS     0x3f74fa05 ; 0.95693999528884888
000134  3f731444          DCFS     0x3f731444 ; 0.94952797889709473
000138  3f710907          DCFS     0x3f710907 ; 0.94154399633407593
00013c  3f6ed8a1          DCFS     0x3f6ed8a1 ; 0.93299299478530884
000140  3f6c8366          DCFS     0x3f6c8366 ; 0.92387998104095459
000144  3f6a09ab          DCFS     0x3f6a09ab ; 0.91421002149581909
000148  3f676bd3          DCFS     0x3f676bd3 ; 0.90398901700973511
00014c  3f64aa54          DCFS     0x3f64aa54 ; 0.89322400093078613
000150  3f61c593          DCFS     0x3f61c593 ; 0.88192099332809448
000154  3f5ebe06          DCFS     0x3f5ebe06 ; 0.87008702754974365
000158  3f5b9421          DCFS     0x3f5b9421 ; 0.85772901773452759
00015c  3f58485a          DCFS     0x3f58485a ; 0.84485399723052979
000160  3f54db38          DCFS     0x3f54db38 ; 0.83147001266479492
000164  3f514d40          DCFS     0x3f514d40 ; 0.81758499145507812
000168  3f4d9f0a          DCFS     0x3f4d9f0a ; 0.80320799350738525
00016c  3f49d10b          DCFS     0x3f49d10b ; 0.78834599256515503
000170  3f45e3fc          DCFS     0x3f45e3fc ; 0.7730100154876709
000174  3f41d873          DCFS     0x3f41d873 ; 0.75720900297164917
000178  3f3daef7          DCFS     0x3f3daef7 ; 0.74095100164413452
00017c  3f396840          DCFS     0x3f396840 ; 0.72424697875976562
000180  3f3504f7          DCFS     0x3f3504f7 ; 0.70710700750350952
000184  3f3085c2          DCFS     0x3f3085c2 ; 0.68954098224639893
000188  3f2beb4a          DCFS     0x3f2beb4a ; 0.67155897617340088
00018c  3f273659          DCFS     0x3f273659 ; 0.65317302942276001
000190  3f226794          DCFS     0x3f226794 ; 0.63439297676086426
000194  3f1d7fd8          DCFS     0x3f1d7fd8 ; 0.61523199081420898
000198  3f187fbb          DCFS     0x3f187fbb ; 0.5956990122795105
00019c  3f136827          DCFS     0x3f136827 ; 0.57580798864364624
0001a0  3f0e39d6          DCFS     0x3f0e39d6 ; 0.55557000637054443
0001a4  3f08f5a1          DCFS     0x3f08f5a1 ; 0.53499799966812134
0001a8  3f039c41          DCFS     0x3f039c41 ; 0.5141029953956604
0001ac  3efc5d20          DCFS     0x3efc5d20 ; 0.49289798736572266
0001b0  3ef15af3          DCFS     0x3ef15af3 ; 0.47139701247215271
0001b4  3ee6336a          DCFS     0x3ee6336a ; 0.44961100816726685
0001b8  3edae87d          DCFS     0x3edae87d ; 0.42755499482154846
0001bc  3ecf7bc0          DCFS     0x3ecf7bc0 ; 0.40524101257324219
0001c0  3ec3ef07          DCFS     0x3ec3ef07 ; 0.38268300890922546
0001c4  3eb84428          DCFS     0x3eb84428 ; 0.35989499092102051
0001c8  3eac7cd9          DCFS     0x3eac7cd9 ; 0.33689001202583313
0001cc  3ea09aed          DCFS     0x3ea09aed ; 0.31368198990821838
0001d0  3e94a03c          DCFS     0x3e94a03c ; 0.29028499126434326
0001d4  3e888e9b          DCFS     0x3e888e9b ; 0.26671299338340759
0001d8  3e78cfc0          DCFS     0x3e78cfc0 ; 0.24298000335693359
0001dc  3e605c03          DCFS     0x3e605c03 ; 0.21910099685192108
0001e0  3e47c5ef          DCFS     0x3e47c5ef ; 0.19509099423885345
0001e4  3e2f10aa          DCFS     0x3e2f10aa ; 0.17096200585365295
0001e8  3e1640a7          DCFS     0x3e1640a7 ; 0.14673100411891937
0001ec  3dfab29e          DCFS     0x3dfab29e ; 0.12241099774837494
0001f0  3dc8bd23          DCFS     0x3dc8bd23 ; 0.098016999661922455
0001f4  3d96a93f          DCFS     0x3d96a93f ; 0.073564998805522919
0001f8  3d48fb87          DCFS     0x3d48fb87 ; 0.049068000167608261
0001fc  3cc90a35          DCFS     0x3cc90a35 ; 0.02454099990427494
000200  00000000          DCFS     0x00000000 ; 0
000204  bcc90a35          DCFS     0xbcc90a35 ; -0.02454099990427494
000208  bd48fa7b          DCFS     0xbd48fa7b ; -0.049067001789808273
00020c  bd96a8b9          DCFS     0xbd96a8b9 ; -0.073564000427722931
000210  bdc8bd23          DCFS     0xbdc8bd23 ; -0.098016999661922455
000214  bdfab29e          DCFS     0xbdfab29e ; -0.12241099774837494
000218  be164064          DCFS     0xbe164064 ; -0.14673000574111938
00021c  be2f10aa          DCFS     0xbe2f10aa ; -0.17096200585365295
000220  be47c5ac          DCFS     0xbe47c5ac ; -0.19508999586105347
000224  be605c03          DCFS     0xbe605c03 ; -0.21910099685192108
000228  be78cfc0          DCFS     0xbe78cfc0 ; -0.24298000335693359
00022c  be888e9b          DCFS     0xbe888e9b ; -0.26671299338340759
000230  be94a01b          DCFS     0xbe94a01b ; -0.29028400778770447
000234  bea09aed          DCFS     0xbea09aed ; -0.31368198990821838
000238  beac7cd9          DCFS     0xbeac7cd9 ; -0.33689001202583313
00023c  beb84428          DCFS     0xbeb84428 ; -0.35989499092102051
000240  bec3ef07          DCFS     0xbec3ef07 ; -0.38268300890922546
000244  becf7bc0          DCFS     0xbecf7bc0 ; -0.40524101257324219
000248  bedae87d          DCFS     0xbedae87d ; -0.42755499482154846
00024c  bee6336a          DCFS     0xbee6336a ; -0.44961100816726685
000250  bef15af3          DCFS     0xbef15af3 ; -0.47139701247215271
000254  befc5d20          DCFS     0xbefc5d20 ; -0.49289798736572266
000258  bf039c41          DCFS     0xbf039c41 ; -0.5141029953956604
00025c  bf08f590          DCFS     0xbf08f590 ; -0.53499698638916016
000260  bf0e39d6          DCFS     0xbf0e39d6 ; -0.55557000637054443
000264  bf136827          DCFS     0xbf136827 ; -0.57580798864364624
000268  bf187fbb          DCFS     0xbf187fbb ; -0.5956990122795105
00026c  bf1d7fc7          DCFS     0xbf1d7fc7 ; -0.6152309775352478
000270  bf226794          DCFS     0xbf226794 ; -0.63439297676086426
000274  bf273659          DCFS     0xbf273659 ; -0.65317302942276001
000278  bf2beb4a          DCFS     0xbf2beb4a ; -0.67155897617340088
00027c  bf3085b2          DCFS     0xbf3085b2 ; -0.68954002857208252
000280  bf3504f7          DCFS     0xbf3504f7 ; -0.70710700750350952
000284  bf396840          DCFS     0xbf396840 ; -0.72424697875976562
000288  bf3daef7          DCFS     0xbf3daef7 ; -0.74095100164413452
00028c  bf41d873          DCFS     0xbf41d873 ; -0.75720900297164917
000290  bf45e3fc          DCFS     0xbf45e3fc ; -0.7730100154876709
000294  bf49d10b          DCFS     0xbf49d10b ; -0.78834599256515503
000298  bf4d9ef9          DCFS     0xbf4d9ef9 ; -0.80320698022842407
00029c  bf514d40          DCFS     0xbf514d40 ; -0.81758499145507812
0002a0  bf54db27          DCFS     0xbf54db27 ; -0.83146899938583374
0002a4  bf584849          DCFS     0xbf584849 ; -0.8448529839515686
0002a8  bf5b9421          DCFS     0xbf5b9421 ; -0.85772901773452759
0002ac  bf5ebe06          DCFS     0xbf5ebe06 ; -0.87008702754974365
0002b0  bf61c593          DCFS     0xbf61c593 ; -0.88192099332809448
0002b4  bf64aa54          DCFS     0xbf64aa54 ; -0.89322400093078613
0002b8  bf676bd3          DCFS     0xbf676bd3 ; -0.90398901700973511
0002bc  bf6a09ab          DCFS     0xbf6a09ab ; -0.91421002149581909
0002c0  bf6c8366          DCFS     0xbf6c8366 ; -0.92387998104095459
0002c4  bf6ed8a1          DCFS     0xbf6ed8a1 ; -0.93299299478530884
0002c8  bf710907          DCFS     0xbf710907 ; -0.94154399633407593
0002cc  bf731444          DCFS     0xbf731444 ; -0.94952797889709473
0002d0  bf74fa05          DCFS     0xbf74fa05 ; -0.95693999528884888
0002d4  bf76ba06          DCFS     0xbf76ba06 ; -0.96377599239349365
0002d8  bf7853f4          DCFS     0xbf7853f4 ; -0.9700310230255127
0002dc  bf79c79b          DCFS     0xbf79c79b ; -0.97570198774337769
0002e0  bf7b14ba          DCFS     0xbf7b14ba ; -0.98078501224517822
0002e4  bf7c3b2e          DCFS     0xbf7c3b2e ; -0.98527801036834717
0002e8  bf7d3aa3          DCFS     0xbf7d3aa3 ; -0.98917597532272339
0002ec  bf7e132b          DCFS     0xbf7e132b ; -0.99247997999191284
0002f0  bf7ec472          DCFS     0xbf7ec472 ; -0.99518501758575439
0002f4  bf7f4e66          DCFS     0xbf7f4e66 ; -0.99729001522064209
0002f8  bf7fb107          DCFS     0xbf7fb107 ; -0.99879497289657593
0002fc  bf7fec46          DCFS     0xbf7fec46 ; -0.99969899654388428
000300  bf800000          DCFS     0xbf800000 ; -1
000304  bf7fec46          DCFS     0xbf7fec46 ; -0.99969899654388428
000308  bf7fb107          DCFS     0xbf7fb107 ; -0.99879497289657593
00030c  bf7f4e66          DCFS     0xbf7f4e66 ; -0.99729001522064209
000310  bf7ec472          DCFS     0xbf7ec472 ; -0.99518501758575439
000314  bf7e132b          DCFS     0xbf7e132b ; -0.99247997999191284
000318  bf7d3ab4          DCFS     0xbf7d3ab4 ; -0.98917698860168457
00031c  bf7c3b2e          DCFS     0xbf7c3b2e ; -0.98527801036834717
000320  bf7b14ba          DCFS     0xbf7b14ba ; -0.98078501224517822
000324  bf79c79b          DCFS     0xbf79c79b ; -0.97570198774337769
000328  bf7853f4          DCFS     0xbf7853f4 ; -0.9700310230255127
00032c  bf76ba06          DCFS     0xbf76ba06 ; -0.96377599239349365
000330  bf74fa05          DCFS     0xbf74fa05 ; -0.95693999528884888
000334  bf731444          DCFS     0xbf731444 ; -0.94952797889709473
000338  bf710907          DCFS     0xbf710907 ; -0.94154399633407593
00033c  bf6ed8a1          DCFS     0xbf6ed8a1 ; -0.93299299478530884
000340  bf6c8366          DCFS     0xbf6c8366 ; -0.92387998104095459
000344  bf6a09ab          DCFS     0xbf6a09ab ; -0.91421002149581909
000348  bf676bd3          DCFS     0xbf676bd3 ; -0.90398901700973511
00034c  bf64aa54          DCFS     0xbf64aa54 ; -0.89322400093078613
000350  bf61c593          DCFS     0xbf61c593 ; -0.88192099332809448
000354  bf5ebe06          DCFS     0xbf5ebe06 ; -0.87008702754974365
000358  bf5b9421          DCFS     0xbf5b9421 ; -0.85772901773452759
00035c  bf58485a          DCFS     0xbf58485a ; -0.84485399723052979
000360  bf54db38          DCFS     0xbf54db38 ; -0.83147001266479492
000364  bf514d40          DCFS     0xbf514d40 ; -0.81758499145507812
000368  bf4d9f0a          DCFS     0xbf4d9f0a ; -0.80320799350738525
00036c  bf49d11c          DCFS     0xbf49d11c ; -0.78834700584411621
000370  bf45e40d          DCFS     0xbf45e40d ; -0.77301102876663208
000374  bf41d873          DCFS     0xbf41d873 ; -0.75720900297164917
000378  bf3daef7          DCFS     0xbf3daef7 ; -0.74095100164413452
00037c  bf396840          DCFS     0xbf396840 ; -0.72424697875976562
000380  bf3504f7          DCFS     0xbf3504f7 ; -0.70710700750350952
000384  bf3085c2          DCFS     0xbf3085c2 ; -0.68954098224639893
000388  bf2beb4a          DCFS     0xbf2beb4a ; -0.67155897617340088
00038c  bf273659          DCFS     0xbf273659 ; -0.65317302942276001
000390  bf2267a5          DCFS     0xbf2267a5 ; -0.63439399003982544
000394  bf1d7fd8          DCFS     0xbf1d7fd8 ; -0.61523199081420898
000398  bf187fbb          DCFS     0xbf187fbb ; -0.5956990122795105
00039c  bf136827          DCFS     0xbf136827 ; -0.57580798864364624
0003a0  bf0e39d6          DCFS     0xbf0e39d6 ; -0.55557000637054443
0003a4  bf08f5a1          DCFS     0xbf08f5a1 ; -0.53499799966812134
0003a8  bf039c41          DCFS     0xbf039c41 ; -0.5141029953956604
0003ac  befc5d20          DCFS     0xbefc5d20 ; -0.49289798736572266
0003b0  bef15af3          DCFS     0xbef15af3 ; -0.47139701247215271
0003b4  bee6338b          DCFS     0xbee6338b ; -0.44961199164390564
0003b8  bedae87d          DCFS     0xbedae87d ; -0.42755499482154846
0003bc  becf7bc0          DCFS     0xbecf7bc0 ; -0.40524101257324219
0003c0  bec3ef28          DCFS     0xbec3ef28 ; -0.38268399238586426
0003c4  beb84428          DCFS     0xbeb84428 ; -0.35989499092102051
0003c8  beac7cd9          DCFS     0xbeac7cd9 ; -0.33689001202583313
0003cc  bea09aed          DCFS     0xbea09aed ; -0.31368198990821838
0003d0  be94a03c          DCFS     0xbe94a03c ; -0.29028499126434326
0003d4  be888e9b          DCFS     0xbe888e9b ; -0.26671299338340759
0003d8  be78d003          DCFS     0xbe78d003 ; -0.24298100173473358
0003dc  be605c46          DCFS     0xbe605c46 ; -0.21910199522972107
0003e0  be47c5ef          DCFS     0xbe47c5ef ; -0.19509099423885345
0003e4  be2f10aa          DCFS     0xbe2f10aa ; -0.17096200585365295
0003e8  be1640a7          DCFS     0xbe1640a7 ; -0.14673100411891937
0003ec  bdfab29e          DCFS     0xbdfab29e ; -0.12241099774837494
0003f0  bdc8bd23          DCFS     0xbdc8bd23 ; -0.098016999661922455
0003f4  bd96a93f          DCFS     0xbd96a93f ; -0.073564998805522919
0003f8  bd48fb87          DCFS     0xbd48fb87 ; -0.049068000167608261
0003fc  bcc90c4e          DCFS     0xbcc90c4e ; -0.024542000144720078
