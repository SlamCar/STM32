; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\mpu9250.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\mpu9250.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\mpu9250.crf ..\HARDWARE\MPU9250\mpu9250.c]
                          THUMB

                          AREA ||i.MPU9250_Init||, CODE, READONLY, ALIGN=1

                  MPU9250_Init PROC
;;;30     //    其他,错误代码
;;;31     u8 MPU9250_Init(void)
000000  b510              PUSH     {r4,lr}
;;;32     {
;;;33         u8 res=0;
000002  2400              MOVS     r4,#0
;;;34         IIC_Init();     //初始化IIC总线
000004  f7fffffe          BL       IIC_Init
;;;35         MPU_Write_Byte(MPU9250_ADDR,MPU_PWR_MGMT1_REG,0X80);//复位MPU9250
000008  2280              MOVS     r2,#0x80
00000a  216b              MOVS     r1,#0x6b
00000c  2068              MOVS     r0,#0x68
00000e  f7fffffe          BL       MPU_Write_Byte
;;;36         delay_ms(100);  //延时100ms
000012  2064              MOVS     r0,#0x64
000014  f7fffffe          BL       delay_ms
;;;37         MPU_Write_Byte(MPU9250_ADDR,MPU_PWR_MGMT1_REG,0X00);//唤醒MPU9250
000018  2200              MOVS     r2,#0
00001a  216b              MOVS     r1,#0x6b
00001c  2068              MOVS     r0,#0x68
00001e  f7fffffe          BL       MPU_Write_Byte
;;;38         MPU_Set_Gyro_Fsr(3);					        	//陀螺仪传感器,±2000dps
000022  2003              MOVS     r0,#3
000024  f7fffffe          BL       MPU_Set_Gyro_Fsr
;;;39     	MPU_Set_Accel_Fsr(0);					       	 	//加速度传感器,±2g
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       MPU_Set_Accel_Fsr
;;;40         MPU_Set_Rate(50);						       	 	//设置采样率50Hz
00002e  2032              MOVS     r0,#0x32
000030  f7fffffe          BL       MPU_Set_Rate
;;;41         MPU_Write_Byte(MPU9250_ADDR,MPU_INT_EN_REG,0X00);   //关闭所有中断
000034  2200              MOVS     r2,#0
000036  2138              MOVS     r1,#0x38
000038  2068              MOVS     r0,#0x68
00003a  f7fffffe          BL       MPU_Write_Byte
;;;42     	MPU_Write_Byte(MPU9250_ADDR,MPU_USER_CTRL_REG,0X00);//I2C主模式关闭
00003e  2200              MOVS     r2,#0
000040  216a              MOVS     r1,#0x6a
000042  2068              MOVS     r0,#0x68
000044  f7fffffe          BL       MPU_Write_Byte
;;;43     	MPU_Write_Byte(MPU9250_ADDR,MPU_FIFO_EN_REG,0X00);	//关闭FIFO
000048  2200              MOVS     r2,#0
00004a  2123              MOVS     r1,#0x23
00004c  2068              MOVS     r0,#0x68
00004e  f7fffffe          BL       MPU_Write_Byte
;;;44     	MPU_Write_Byte(MPU9250_ADDR,MPU_INTBP_CFG_REG,0X82);//INT引脚低电平有效，开启bypass模式，可以直接读取磁力计
000052  2282              MOVS     r2,#0x82
000054  2137              MOVS     r1,#0x37
000056  2068              MOVS     r0,#0x68
000058  f7fffffe          BL       MPU_Write_Byte
;;;45         res=MPU_Read_Byte(MPU9250_ADDR,MPU_DEVICE_ID_REG);  //读取MPU6500的ID
00005c  2175              MOVS     r1,#0x75
00005e  2068              MOVS     r0,#0x68
000060  f7fffffe          BL       MPU_Read_Byte
000064  4604              MOV      r4,r0
;;;46         if(res==MPU6500_ID1||res==MPU6500_ID2) 				//器件ID正确
000066  2c71              CMP      r4,#0x71
000068  d001              BEQ      |L1.110|
00006a  2c73              CMP      r4,#0x73
00006c  d10d              BNE      |L1.138|
                  |L1.110|
;;;47         {
;;;48             MPU_Write_Byte(MPU9250_ADDR,MPU_PWR_MGMT1_REG,0X01);  	//设置CLKSEL,PLL X轴为参考
00006e  2201              MOVS     r2,#1
000070  216b              MOVS     r1,#0x6b
000072  2068              MOVS     r0,#0x68
000074  f7fffffe          BL       MPU_Write_Byte
;;;49             MPU_Write_Byte(MPU9250_ADDR,MPU_PWR_MGMT2_REG,0X00);  	//加速度与陀螺仪都工作
000078  2200              MOVS     r2,#0
00007a  216c              MOVS     r1,#0x6c
00007c  2068              MOVS     r0,#0x68
00007e  f7fffffe          BL       MPU_Write_Byte
;;;50     		MPU_Set_Rate(50);						       			//设置采样率为50Hz   
000082  2032              MOVS     r0,#0x32
000084  f7fffffe          BL       MPU_Set_Rate
000088  e001              B        |L1.142|
                  |L1.138|
;;;51         }else return 1;
00008a  2001              MOVS     r0,#1
                  |L1.140|
;;;52      
;;;53         res=MPU_Read_Byte(AK8963_ADDR,MAG_WIA);    			//读取AK8963 ID   
;;;54         if(res==AK8963_ID)
;;;55         {
;;;56             MPU_Write_Byte(AK8963_ADDR,MAG_CNTL2,0X01);		//复位AK8963
;;;57     		delay_ms(50);
;;;58             MPU_Write_Byte(AK8963_ADDR,MAG_CNTL1,0X11);		//设置AK8963为单次测量
;;;59         }else return 1;
;;;60     
;;;61         return 0;
;;;62     }
00008c  bd10              POP      {r4,pc}
                  |L1.142|
00008e  2100              MOVS     r1,#0                 ;53
000090  200c              MOVS     r0,#0xc               ;53
000092  f7fffffe          BL       MPU_Read_Byte
000096  4604              MOV      r4,r0                 ;53
000098  2c48              CMP      r4,#0x48              ;54
00009a  d10d              BNE      |L1.184|
00009c  2201              MOVS     r2,#1                 ;56
00009e  210b              MOVS     r1,#0xb               ;56
0000a0  200c              MOVS     r0,#0xc               ;56
0000a2  f7fffffe          BL       MPU_Write_Byte
0000a6  2032              MOVS     r0,#0x32              ;57
0000a8  f7fffffe          BL       delay_ms
0000ac  2211              MOVS     r2,#0x11              ;58
0000ae  210a              MOVS     r1,#0xa               ;58
0000b0  200c              MOVS     r0,#0xc               ;58
0000b2  f7fffffe          BL       MPU_Write_Byte
0000b6  e001              B        |L1.188|
                  |L1.184|
0000b8  2001              MOVS     r0,#1                 ;59
0000ba  e7e7              B        |L1.140|
                  |L1.188|
0000bc  2000              MOVS     r0,#0                 ;61
0000be  e7e5              B        |L1.140|
;;;63     
                          ENDP


                          AREA ||i.MPU_Get_Accelerometer||, CODE, READONLY, ALIGN=1

                  MPU_Get_Accelerometer PROC
;;;142    //    其他,错误代码
;;;143    u8 MPU_Get_Accelerometer(short *ax,short *ay,short *az)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;144    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;145        u8 buf[6],res;  
;;;146    	res=MPU_Read_Len(MPU9250_ADDR,MPU_ACCEL_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  213b              MOVS     r1,#0x3b
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;147    	if(res==0)
000018  b9bf              CBNZ     r7,|L2.74|
;;;148    	{
;;;149    		*ax=((u16)buf[0]<<8)|buf[1];  
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;150    		*ay=((u16)buf[2]<<8)|buf[3];  
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;151    		*az=((u16)buf[4]<<8)|buf[5];
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L2.74|
;;;152    	} 	
;;;153        return res;;
00004a  4638              MOV      r0,r7
;;;154    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;155    
                          ENDP


                          AREA ||i.MPU_Get_Gyroscope||, CODE, READONLY, ALIGN=1

                  MPU_Get_Gyroscope PROC
;;;126    //    其他,错误代码
;;;127    u8 MPU_Get_Gyroscope(short *gx,short *gy,short *gz)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;128    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;129        u8 buf[6],res; 
;;;130    	res=MPU_Read_Len(MPU9250_ADDR,MPU_GYRO_XOUTH_REG,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  2143              MOVS     r1,#0x43
000010  2068              MOVS     r0,#0x68
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;131    	if(res==0)
000018  b9bf              CBNZ     r7,|L3.74|
;;;132    	{
;;;133    		*gx=((u16)buf[0]<<8)|buf[1];  
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f89d1000          LDRB     r1,[sp,#0]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;134    		*gy=((u16)buf[2]<<8)|buf[3];  
00002a  f89d0003          LDRB     r0,[sp,#3]
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;135    		*gz=((u16)buf[4]<<8)|buf[5];
00003a  f89d0005          LDRB     r0,[sp,#5]
00003e  f89d1004          LDRB     r1,[sp,#4]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L3.74|
;;;136    	} 	
;;;137        return res;;
00004a  4638              MOV      r0,r7
;;;138    }
00004c  e8bd81fc          POP      {r2-r8,pc}
;;;139    //得到加速度值(原始值)
                          ENDP


                          AREA ||i.MPU_Get_Magnetometer||, CODE, READONLY, ALIGN=1

                  MPU_Get_Magnetometer PROC
;;;159    //    其他,错误代码
;;;160    u8 MPU_Get_Magnetometer(short *mx,short *my,short *mz)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;161    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;162        u8 buf[6],res;  
;;;163     	res=MPU_Read_Len(AK8963_ADDR,MAG_XOUT_L,6,buf);
00000a  466b              MOV      r3,sp
00000c  2206              MOVS     r2,#6
00000e  2103              MOVS     r1,#3
000010  200c              MOVS     r0,#0xc
000012  f7fffffe          BL       MPU_Read_Len
000016  4607              MOV      r7,r0
;;;164    	if(res==0)
000018  b9bf              CBNZ     r7,|L4.74|
;;;165    	{
;;;166    		*mx=((u16)buf[1]<<8)|buf[0];  
00001a  f89d0000          LDRB     r0,[sp,#0]
00001e  f89d1001          LDRB     r1,[sp,#1]
000022  ea402001          ORR      r0,r0,r1,LSL #8
000026  b200              SXTH     r0,r0
000028  8020              STRH     r0,[r4,#0]
;;;167    		*my=((u16)buf[3]<<8)|buf[2];  
00002a  f89d0002          LDRB     r0,[sp,#2]
00002e  f89d1003          LDRB     r1,[sp,#3]
000032  ea402001          ORR      r0,r0,r1,LSL #8
000036  b200              SXTH     r0,r0
000038  8028              STRH     r0,[r5,#0]
;;;168    		*mz=((u16)buf[5]<<8)|buf[4];
00003a  f89d0004          LDRB     r0,[sp,#4]
00003e  f89d1005          LDRB     r1,[sp,#5]
000042  ea402001          ORR      r0,r0,r1,LSL #8
000046  b200              SXTH     r0,r0
000048  8030              STRH     r0,[r6,#0]
                  |L4.74|
;;;169    	} 	 
;;;170    	MPU_Write_Byte(AK8963_ADDR,MAG_CNTL1,0X11); //AK8963每次读完以后都需要重新设置为单次测量模式
00004a  2211              MOVS     r2,#0x11
00004c  210a              MOVS     r1,#0xa
00004e  200c              MOVS     r0,#0xc
000050  f7fffffe          BL       MPU_Write_Byte
;;;171        return res;;
000054  4638              MOV      r0,r7
;;;172    }
000056  e8bd81fc          POP      {r2-r8,pc}
;;;173    
                          ENDP


                          AREA ||i.MPU_Get_Temperature||, CODE, READONLY, ALIGN=2

                  MPU_Get_Temperature PROC
;;;112    //返回值:温度值(扩大了100倍)
;;;113    short MPU_Get_Temperature(void)
000000  b500              PUSH     {lr}
;;;114    {
000002  ed2d8b02          VPUSH    {d8}
000006  b081              SUB      sp,sp,#4
;;;115        u8 buf[2]; 
;;;116        short raw;
;;;117    	float temp;
;;;118    	MPU_Read_Len(MPU9250_ADDR,MPU_TEMP_OUTH_REG,2,buf); 
000008  466b              MOV      r3,sp
00000a  2202              MOVS     r2,#2
00000c  2141              MOVS     r1,#0x41
00000e  2068              MOVS     r0,#0x68
000010  f7fffffe          BL       MPU_Read_Len
;;;119        raw=((u16)buf[0]<<8)|buf[1];  
000014  f89d0001          LDRB     r0,[sp,#1]
000018  f89d1000          LDRB     r1,[sp,#0]
00001c  ea402001          ORR      r0,r0,r1,LSL #8
000020  b200              SXTH     r0,r0
000022  ee080a10          VMOV     s16,r0
;;;120        temp=21+((double)raw)/333.87;  
000026  eeb80bc8          VCVT.F64.S32 d0,s16
00002a  ed9f2b0c          VLDR     d2,|L5.92|
00002e  ee801b02          VDIV.F64 d1,d0,d2
000032  eeb30b05          VMOV.F64 d0,#21.00000000
000036  ee310b00          VADD.F64 d0,d1,d0
00003a  eeb70bc0          VCVT.F32.F64 s0,d0
00003e  eef08a40          VMOV.F32 s17,s0
;;;121        return temp*100;;
000042  ed9f0a08          VLDR     s0,|L5.100|
000046  ee280a80          VMUL.F32 s0,s17,s0
00004a  eebd0ac0          VCVT.S32.F32 s0,s0
00004e  ee100a10          VMOV     r0,s0
000052  b200              SXTH     r0,r0
;;;122    }
000054  b001              ADD      sp,sp,#4
000056  ecbd8b02          VPOP     {d8}
00005a  bd00              POP      {pc}
;;;123    //得到陀螺仪值(原始值)
                          ENDP

                  |L5.92|
00005c  851eb852          DCFD     0x4074ddeb851eb852 ; 333.87
000060  4074ddeb
                  |L5.100|
000064  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.MPU_Read_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Read_Byte PROC
;;;267    //返回值:读到的数据
;;;268    u8 MPU_Read_Byte(u8 addr,u8 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;269    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;270        u8 res;
;;;271        IIC_Start();
000006  f7fffffe          BL       IIC_Start
;;;272        IIC_Send_Byte((addr<<1)|0); //发送器件地址+写命令
00000a  2100              MOVS     r1,#0
00000c  ea410144          ORR      r1,r1,r4,LSL #1
000010  b2c8              UXTB     r0,r1
000012  f7fffffe          BL       IIC_Send_Byte
;;;273        IIC_Wait_Ack();             //等待应答
000016  f7fffffe          BL       IIC_Wait_Ack
;;;274        IIC_Send_Byte(reg);         //写寄存器地址
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       IIC_Send_Byte
;;;275        IIC_Wait_Ack();             //等待应答
000020  f7fffffe          BL       IIC_Wait_Ack
;;;276    	IIC_Start();                
000024  f7fffffe          BL       IIC_Start
;;;277        IIC_Send_Byte((addr<<1)|1); //发送器件地址+读命令
000028  2101              MOVS     r1,#1
00002a  eb010144          ADD      r1,r1,r4,LSL #1
00002e  b2c8              UXTB     r0,r1
000030  f7fffffe          BL       IIC_Send_Byte
;;;278        IIC_Wait_Ack();             //等待应答
000034  f7fffffe          BL       IIC_Wait_Ack
;;;279        res=IIC_Read_Byte(0);		//读数据,发送nACK  
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       IIC_Read_Byte
00003e  4606              MOV      r6,r0
;;;280        IIC_Stop();                 //产生一个停止条件
000040  f7fffffe          BL       IIC_Stop
;;;281        return res;  
000044  4630              MOV      r0,r6
;;;282    }
000046  bd70              POP      {r4-r6,pc}
;;;283    
                          ENDP


                          AREA ||i.MPU_Read_Len||, CODE, READONLY, ALIGN=1

                  MPU_Read_Len PROC
;;;212    //    其他,错误代码
;;;213    u8 MPU_Read_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;214    { 
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;215        IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;216        IIC_Send_Byte((addr<<1)|0); //发送器件地址+写命令
000010  2100              MOVS     r1,#0
000012  ea410146          ORR      r1,r1,r6,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       IIC_Send_Byte
;;;217        if(IIC_Wait_Ack())          //等待应答
00001c  f7fffffe          BL       IIC_Wait_Ack
000020  b120              CBZ      r0,|L7.44|
;;;218        {
;;;219            IIC_Stop();
000022  f7fffffe          BL       IIC_Stop
;;;220            return 1;
000026  2001              MOVS     r0,#1
                  |L7.40|
;;;221        }
;;;222        IIC_Send_Byte(reg);         //写寄存器地址
;;;223        IIC_Wait_Ack();             //等待应答
;;;224    	IIC_Start();                
;;;225        IIC_Send_Byte((addr<<1)|1); //发送器件地址+读命令
;;;226        IIC_Wait_Ack();             //等待应答
;;;227        while(len)
;;;228        {
;;;229            if(len==1)*buf=IIC_Read_Byte(0);//读数据,发送nACK 
;;;230    		else *buf=IIC_Read_Byte(1);		//读数据,发送ACK  
;;;231    		len--;
;;;232    		buf++;  
;;;233        }
;;;234        IIC_Stop();                 //产生一个停止条件
;;;235        return 0;       
;;;236    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L7.44|
00002c  4638              MOV      r0,r7                 ;222
00002e  f7fffffe          BL       IIC_Send_Byte
000032  f7fffffe          BL       IIC_Wait_Ack
000036  f7fffffe          BL       IIC_Start
00003a  2101              MOVS     r1,#1                 ;225
00003c  eb010146          ADD      r1,r1,r6,LSL #1       ;225
000040  b2c8              UXTB     r0,r1                 ;225
000042  f7fffffe          BL       IIC_Send_Byte
000046  f7fffffe          BL       IIC_Wait_Ack
00004a  e00d              B        |L7.104|
                  |L7.76|
00004c  2c01              CMP      r4,#1                 ;229
00004e  d104              BNE      |L7.90|
000050  2000              MOVS     r0,#0                 ;229
000052  f7fffffe          BL       IIC_Read_Byte
000056  7028              STRB     r0,[r5,#0]            ;229
000058  e003              B        |L7.98|
                  |L7.90|
00005a  2001              MOVS     r0,#1                 ;230
00005c  f7fffffe          BL       IIC_Read_Byte
000060  7028              STRB     r0,[r5,#0]            ;230
                  |L7.98|
000062  1e60              SUBS     r0,r4,#1              ;231
000064  b2c4              UXTB     r4,r0                 ;231
000066  1c6d              ADDS     r5,r5,#1              ;232
                  |L7.104|
000068  2c00              CMP      r4,#0                 ;227
00006a  d1ef              BNE      |L7.76|
00006c  f7fffffe          BL       IIC_Stop
000070  2000              MOVS     r0,#0                 ;235
000072  e7d9              B        |L7.40|
;;;237    
                          ENDP


                          AREA ||i.MPU_Set_Accel_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Accel_Fsr PROC
;;;75     //    其他,设置失败 
;;;76     u8 MPU_Set_Accel_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;77     {
000002  4604              MOV      r4,r0
;;;78     	return MPU_Write_Byte(MPU9250_ADDR,MPU_ACCEL_CFG_REG,fsr<<3);//设置加速度传感器满量程范围  
000004  06e0              LSLS     r0,r4,#27
000006  0e02              LSRS     r2,r0,#24
000008  211c              MOVS     r1,#0x1c
00000a  2068              MOVS     r0,#0x68
00000c  f7fffffe          BL       MPU_Write_Byte
;;;79     }
000010  bd10              POP      {r4,pc}
;;;80     
                          ENDP


                          AREA ||i.MPU_Set_Gyro_Fsr||, CODE, READONLY, ALIGN=1

                  MPU_Set_Gyro_Fsr PROC
;;;67     //    其他,设置失败 
;;;68     u8 MPU_Set_Gyro_Fsr(u8 fsr)
000000  b510              PUSH     {r4,lr}
;;;69     {
000002  4604              MOV      r4,r0
;;;70     	return MPU_Write_Byte(MPU9250_ADDR,MPU_GYRO_CFG_REG,(fsr<<3)|3);//设置陀螺仪满量程范围  
000004  2003              MOVS     r0,#3
000006  eb0000c4          ADD      r0,r0,r4,LSL #3
00000a  b2c2              UXTB     r2,r0
00000c  211b              MOVS     r1,#0x1b
00000e  2068              MOVS     r0,#0x68
000010  f7fffffe          BL       MPU_Write_Byte
;;;71     }
000014  bd10              POP      {r4,pc}
;;;72     //设置MPU9250加速度传感器满量程范围
                          ENDP


                          AREA ||i.MPU_Set_LPF||, CODE, READONLY, ALIGN=1

                  MPU_Set_LPF PROC
;;;84     //    其他,设置失败 
;;;85     u8 MPU_Set_LPF(u16 lpf)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
000002  4604              MOV      r4,r0
;;;87     	u8 data=0;
000004  2500              MOVS     r5,#0
;;;88     	if(lpf>=188)data=1;
000006  2cbc              CMP      r4,#0xbc
000008  db01              BLT      |L10.14|
00000a  2501              MOVS     r5,#1
00000c  e010              B        |L10.48|
                  |L10.14|
;;;89     	else if(lpf>=98)data=2;
00000e  2c62              CMP      r4,#0x62
000010  db01              BLT      |L10.22|
000012  2502              MOVS     r5,#2
000014  e00c              B        |L10.48|
                  |L10.22|
;;;90     	else if(lpf>=42)data=3;
000016  2c2a              CMP      r4,#0x2a
000018  db01              BLT      |L10.30|
00001a  2503              MOVS     r5,#3
00001c  e008              B        |L10.48|
                  |L10.30|
;;;91     	else if(lpf>=20)data=4;
00001e  2c14              CMP      r4,#0x14
000020  db01              BLT      |L10.38|
000022  2504              MOVS     r5,#4
000024  e004              B        |L10.48|
                  |L10.38|
;;;92     	else if(lpf>=10)data=5;
000026  2c0a              CMP      r4,#0xa
000028  db01              BLT      |L10.46|
00002a  2505              MOVS     r5,#5
00002c  e000              B        |L10.48|
                  |L10.46|
;;;93     	else data=6; 
00002e  2506              MOVS     r5,#6
                  |L10.48|
;;;94     	return MPU_Write_Byte(MPU9250_ADDR,MPU_CFG_REG,data);//设置数字低通滤波器  
000030  462a              MOV      r2,r5
000032  211a              MOVS     r1,#0x1a
000034  2068              MOVS     r0,#0x68
000036  f7fffffe          BL       MPU_Write_Byte
;;;95     }
00003a  bd70              POP      {r4-r6,pc}
;;;96     
                          ENDP


                          AREA ||i.MPU_Set_Rate||, CODE, READONLY, ALIGN=1

                  MPU_Set_Rate PROC
;;;100    //    其他,设置失败 
;;;101    u8 MPU_Set_Rate(u16 rate)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  4604              MOV      r4,r0
;;;103    	u8 data;
;;;104    	if(rate>1000)rate=1000;
000004  f5b47f7a          CMP      r4,#0x3e8
000008  dd01              BLE      |L11.14|
00000a  f44f747a          MOV      r4,#0x3e8
                  |L11.14|
;;;105    	if(rate<4)rate=4;
00000e  2c04              CMP      r4,#4
000010  da00              BGE      |L11.20|
000012  2404              MOVS     r4,#4
                  |L11.20|
;;;106    	data=1000/rate-1;
000014  f44f707a          MOV      r0,#0x3e8
000018  fb90f0f4          SDIV     r0,r0,r4
00001c  1e40              SUBS     r0,r0,#1
00001e  b2c5              UXTB     r5,r0
;;;107    	data=MPU_Write_Byte(MPU9250_ADDR,MPU_SAMPLE_RATE_REG,data);	//设置数字低通滤波器
000020  462a              MOV      r2,r5
000022  2119              MOVS     r1,#0x19
000024  2068              MOVS     r0,#0x68
000026  f7fffffe          BL       MPU_Write_Byte
00002a  4605              MOV      r5,r0
;;;108     	return MPU_Set_LPF(rate/2);	//自动设置LPF为采样率的一半
00002c  4626              MOV      r6,r4
00002e  eb0471d6          ADD      r1,r4,r6,LSR #31
000032  f3c1004f          UBFX     r0,r1,#1,#16
000036  f7fffffe          BL       MPU_Set_LPF
;;;109    }
00003a  bd70              POP      {r4-r6,pc}
;;;110    
                          ENDP


                          AREA ||i.MPU_Write_Byte||, CODE, READONLY, ALIGN=1

                  MPU_Write_Byte PROC
;;;243    //    其他,错误代码
;;;244    u8 MPU_Write_Byte(u8 addr,u8 reg,u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;246        IIC_Start();
000008  f7fffffe          BL       IIC_Start
;;;247        IIC_Send_Byte((addr<<1)|0); //发送器件地址+写命令
00000c  2100              MOVS     r1,#0
00000e  ea410144          ORR      r1,r1,r4,LSL #1
000012  b2c8              UXTB     r0,r1
000014  f7fffffe          BL       IIC_Send_Byte
;;;248        if(IIC_Wait_Ack())          //等待应答
000018  f7fffffe          BL       IIC_Wait_Ack
00001c  b118              CBZ      r0,|L12.38|
;;;249        {
;;;250            IIC_Stop();
00001e  f7fffffe          BL       IIC_Stop
;;;251            return 1;
000022  2001              MOVS     r0,#1
                  |L12.36|
;;;252        }
;;;253        IIC_Send_Byte(reg);         //写寄存器地址
;;;254        IIC_Wait_Ack();             //等待应答
;;;255        IIC_Send_Byte(data);        //发送数据
;;;256        if(IIC_Wait_Ack())          //等待ACK
;;;257        {
;;;258            IIC_Stop();
;;;259            return 1;
;;;260        }
;;;261        IIC_Stop();
;;;262        return 0;
;;;263    }
000024  bd70              POP      {r4-r6,pc}
                  |L12.38|
000026  4628              MOV      r0,r5                 ;253
000028  f7fffffe          BL       IIC_Send_Byte
00002c  f7fffffe          BL       IIC_Wait_Ack
000030  4630              MOV      r0,r6                 ;255
000032  f7fffffe          BL       IIC_Send_Byte
000036  f7fffffe          BL       IIC_Wait_Ack
00003a  b118              CBZ      r0,|L12.68|
00003c  f7fffffe          BL       IIC_Stop
000040  2001              MOVS     r0,#1                 ;259
000042  e7ef              B        |L12.36|
                  |L12.68|
000044  f7fffffe          BL       IIC_Stop
000048  2000              MOVS     r0,#0                 ;262
00004a  e7eb              B        |L12.36|
;;;264    
                          ENDP


                          AREA ||i.MPU_Write_Len||, CODE, READONLY, ALIGN=1

                  MPU_Write_Len PROC
;;;180    //    其他,错误代码
;;;181    u8 MPU_Write_Len(u8 addr,u8 reg,u8 len,u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;182    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;183        u8 i;
;;;184        IIC_Start();
00000c  f7fffffe          BL       IIC_Start
;;;185        IIC_Send_Byte((addr<<1)|0); //发送器件地址+写命令
000010  2100              MOVS     r1,#0
000012  ea410145          ORR      r1,r1,r5,LSL #1
000016  b2c8              UXTB     r0,r1
000018  f7fffffe          BL       IIC_Send_Byte
;;;186        if(IIC_Wait_Ack())          //等待应答
00001c  f7fffffe          BL       IIC_Wait_Ack
000020  b120              CBZ      r0,|L13.44|
;;;187        {
;;;188            IIC_Stop();
000022  f7fffffe          BL       IIC_Stop
;;;189            return 1;
000026  2001              MOVS     r0,#1
                  |L13.40|
;;;190        }
;;;191        IIC_Send_Byte(reg);         //写寄存器地址
;;;192        IIC_Wait_Ack();             //等待应答
;;;193        for(i=0;i<len;i++)
;;;194        {
;;;195            IIC_Send_Byte(buf[i]);  //发送数据
;;;196            if(IIC_Wait_Ack())      //等待ACK
;;;197            {
;;;198                IIC_Stop();
;;;199                return 1;
;;;200            }
;;;201        }
;;;202        IIC_Stop();
;;;203        return 0;
;;;204    } 
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L13.44|
00002c  4630              MOV      r0,r6                 ;191
00002e  f7fffffe          BL       IIC_Send_Byte
000032  f7fffffe          BL       IIC_Wait_Ack
000036  2400              MOVS     r4,#0                 ;193
000038  e00c              B        |L13.84|
                  |L13.58|
00003a  f8180004          LDRB     r0,[r8,r4]            ;195
00003e  f7fffffe          BL       IIC_Send_Byte
000042  f7fffffe          BL       IIC_Wait_Ack
000046  b118              CBZ      r0,|L13.80|
000048  f7fffffe          BL       IIC_Stop
00004c  2001              MOVS     r0,#1                 ;199
00004e  e7eb              B        |L13.40|
                  |L13.80|
000050  1c60              ADDS     r0,r4,#1              ;193
000052  b2c4              UXTB     r4,r0                 ;193
                  |L13.84|
000054  42bc              CMP      r4,r7                 ;193
000056  dbf0              BLT      |L13.58|
000058  f7fffffe          BL       IIC_Stop
00005c  2000              MOVS     r0,#0                 ;203
00005e  e7e3              B        |L13.40|
;;;205    
                          ENDP


                          AREA ||i.mpu9250_run||, CODE, READONLY, ALIGN=2

                  mpu9250_run PROC
;;;294    
;;;295    void mpu9250_run(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;296    {
;;;297         key=KEY_Scan(0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       KEY_Scan
000008  49b1              LDR      r1,|L14.720|
00000a  7008              STRB     r0,[r1,#0]
;;;298    		if(key==KEY0_PRES)
00000c  4608              MOV      r0,r1
00000e  7800              LDRB     r0,[r0,#0]  ; key
000010  2801              CMP      r0,#1
000012  d11f              BNE      |L14.84|
;;;299    		{
;;;300                report=!report;
000014  48af              LDR      r0,|L14.724|
000016  7800              LDRB     r0,[r0,#0]  ; report
000018  b908              CBNZ     r0,|L14.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L14.32|
                  |L14.30|
00001e  2000              MOVS     r0,#0
                  |L14.32|
000020  49ac              LDR      r1,|L14.724|
000022  7008              STRB     r0,[r1,#0]
;;;301    			if(report)LCD_ShowString(30,170,200,16,16,"UPLOAD ON ");
000024  4608              MOV      r0,r1
000026  7800              LDRB     r0,[r0,#0]  ; report
000028  b150              CBZ      r0,|L14.64|
00002a  a0ab              ADR      r0,|L14.728|
00002c  2110              MOVS     r1,#0x10
00002e  460b              MOV      r3,r1
000030  22c8              MOVS     r2,#0xc8
000032  e9cd1000          STRD     r1,r0,[sp,#0]
000036  21aa              MOVS     r1,#0xaa
000038  201e              MOVS     r0,#0x1e
00003a  f7fffffe          BL       LCD_ShowString
00003e  e009              B        |L14.84|
                  |L14.64|
;;;302    			else LCD_ShowString(30,170,200,16,16,"UPLOAD OFF");
000040  a0a8              ADR      r0,|L14.740|
000042  2110              MOVS     r1,#0x10
000044  460b              MOV      r3,r1
000046  22c8              MOVS     r2,#0xc8
000048  e9cd1000          STRD     r1,r0,[sp,#0]
00004c  21aa              MOVS     r1,#0xaa
00004e  201e              MOVS     r0,#0x1e
000050  f7fffffe          BL       LCD_ShowString
                  |L14.84|
;;;303    		}
;;;304            if(mpu_mpl_get_data(&pitch,&roll,&yaw)==0)
000054  4aa6              LDR      r2,|L14.752|
000056  49a7              LDR      r1,|L14.756|
000058  48a7              LDR      r0,|L14.760|
00005a  f7fffffe          BL       mpu_mpl_get_data
00005e  2800              CMP      r0,#0
                  |L14.96|
000060  d172              BNE      |L14.328|
;;;305            {
;;;306    
;;;307                temp=MPU_Get_Temperature();	//得到温度值
000062  f7fffffe          BL       MPU_Get_Temperature
000066  49a5              LDR      r1,|L14.764|
000068  8008              STRH     r0,[r1,#0]
;;;308    			MPU_Get_Accelerometer(&aacx,&aacy,&aacz);	//得到加速度传感器数据
00006a  4aa5              LDR      r2,|L14.768|
00006c  49a5              LDR      r1,|L14.772|
00006e  48a6              LDR      r0,|L14.776|
000070  f7fffffe          BL       MPU_Get_Accelerometer
;;;309    			MPU_Get_Gyroscope(&gyrox,&gyroy,&gyroz);	//得到陀螺仪数据
000074  4aa5              LDR      r2,|L14.780|
000076  49a6              LDR      r1,|L14.784|
000078  48a6              LDR      r0,|L14.788|
00007a  f7fffffe          BL       MPU_Get_Gyroscope
;;;310    //  			if(report)mpu9250_send_data(aacx,aacy,aacz,gyrox,gyroy,gyroz);//发送加速度+陀螺仪原始数据
;;;311    //			if(report)usart1_report_imu((int)(roll*100),(int)(pitch*100),(int)(yaw*100),0,0);
;;;312    			if((t%10)==0)
00007e  48a6              LDR      r0,|L14.792|
000080  7800              LDRB     r0,[r0,#0]  ; t
000082  210a              MOVS     r1,#0xa
000084  fb90f2f1          SDIV     r2,r0,r1
000088  fb010012          MLS      r0,r1,r2,r0
00008c  2800              CMP      r0,#0
00008e  d1e7              BNE      |L14.96|
;;;313    			{ 
;;;314    				if(temp<0)
000090  489a              LDR      r0,|L14.764|
000092  f9b00000          LDRSH    r0,[r0,#0]  ; temp
000096  2800              CMP      r0,#0
000098  da0e              BGE      |L14.184|
;;;315    				{
;;;316    					LCD_ShowChar(30+48,200,'-',16,0);		//显示负号
00009a  2000              MOVS     r0,#0
00009c  2310              MOVS     r3,#0x10
00009e  222d              MOVS     r2,#0x2d
0000a0  21c8              MOVS     r1,#0xc8
0000a2  9000              STR      r0,[sp,#0]
0000a4  204e              MOVS     r0,#0x4e
0000a6  f7fffffe          BL       LCD_ShowChar
;;;317    					temp=-temp;		//转为正数
0000aa  4894              LDR      r0,|L14.764|
0000ac  8800              LDRH     r0,[r0,#0]  ; temp
0000ae  4240              RSBS     r0,r0,#0
0000b0  b200              SXTH     r0,r0
0000b2  4992              LDR      r1,|L14.764|
0000b4  8008              STRH     r0,[r1,#0]
0000b6  e007              B        |L14.200|
                  |L14.184|
;;;318    				}else LCD_ShowChar(30+48,200,' ',16,0);		//去掉负号 
0000b8  2000              MOVS     r0,#0
0000ba  2310              MOVS     r3,#0x10
0000bc  2220              MOVS     r2,#0x20
0000be  21c8              MOVS     r1,#0xc8
0000c0  9000              STR      r0,[sp,#0]
0000c2  204e              MOVS     r0,#0x4e
0000c4  f7fffffe          BL       LCD_ShowChar
                  |L14.200|
;;;319    				LCD_ShowNum(30+48+8,200,temp/100,3,16);		//显示整数部分	    
0000c8  488c              LDR      r0,|L14.764|
0000ca  f9b00000          LDRSH    r0,[r0,#0]  ; temp
0000ce  2164              MOVS     r1,#0x64
0000d0  fb90f4f1          SDIV     r4,r0,r1
0000d4  2010              MOVS     r0,#0x10
0000d6  2303              MOVS     r3,#3
0000d8  4622              MOV      r2,r4
0000da  21c8              MOVS     r1,#0xc8
0000dc  9000              STR      r0,[sp,#0]
0000de  2056              MOVS     r0,#0x56
0000e0  f7fffffe          BL       LCD_ShowNum
;;;320    				LCD_ShowNum(30+48+40,200,temp%10,1,16);		//显示小数部分 
0000e4  4885              LDR      r0,|L14.764|
0000e6  f9b00000          LDRSH    r0,[r0,#0]  ; temp
0000ea  210a              MOVS     r1,#0xa
0000ec  fb90f2f1          SDIV     r2,r0,r1
0000f0  fb010412          MLS      r4,r1,r2,r0
0000f4  2010              MOVS     r0,#0x10
0000f6  2301              MOVS     r3,#1
0000f8  4622              MOV      r2,r4
0000fa  21c8              MOVS     r1,#0xc8
0000fc  9000              STR      r0,[sp,#0]
0000fe  2076              MOVS     r0,#0x76
000100  f7fffffe          BL       LCD_ShowNum
;;;321    				temp=pitch*10;
000104  487c              LDR      r0,|L14.760|
000106  ed900a00          VLDR     s0,[r0,#0]
00010a  eef20a04          VMOV.F32 s1,#10.00000000
00010e  ee200a20          VMUL.F32 s0,s0,s1
000112  eebd0ac0          VCVT.S32.F32 s0,s0
000116  ee100a10          VMOV     r0,s0
00011a  b200              SXTH     r0,r0
00011c  4977              LDR      r1,|L14.764|
00011e  8008              STRH     r0,[r1,#0]
;;;322    				if(temp<0)
000120  4608              MOV      r0,r1
000122  f9b00000          LDRSH    r0,[r0,#0]  ; temp
000126  2800              CMP      r0,#0
000128  da0f              BGE      |L14.330|
;;;323    				{
;;;324    					LCD_ShowChar(30+48,220,'-',16,0);		//显示负号
00012a  2000              MOVS     r0,#0
00012c  2310              MOVS     r3,#0x10
00012e  222d              MOVS     r2,#0x2d
000130  21dc              MOVS     r1,#0xdc
000132  9000              STR      r0,[sp,#0]
000134  204e              MOVS     r0,#0x4e
000136  f7fffffe          BL       LCD_ShowChar
;;;325    					temp=-temp;		//转为正数
00013a  4870              LDR      r0,|L14.764|
00013c  8800              LDRH     r0,[r0,#0]  ; temp
00013e  4240              RSBS     r0,r0,#0
000140  b200              SXTH     r0,r0
000142  496e              LDR      r1,|L14.764|
000144  8008              STRH     r0,[r1,#0]
000146  e008              B        |L14.346|
                  |L14.328|
000148  e0bc              B        |L14.708|
                  |L14.330|
;;;326    				}else LCD_ShowChar(30+48,220,' ',16,0);		//去掉负号 
00014a  2000              MOVS     r0,#0
00014c  2310              MOVS     r3,#0x10
00014e  2220              MOVS     r2,#0x20
000150  21dc              MOVS     r1,#0xdc
000152  9000              STR      r0,[sp,#0]
000154  204e              MOVS     r0,#0x4e
000156  f7fffffe          BL       LCD_ShowChar
                  |L14.346|
;;;327    				LCD_ShowNum(30+48+8,220,temp/10,3,16);		//显示整数部分	    
00015a  4868              LDR      r0,|L14.764|
00015c  f9b00000          LDRSH    r0,[r0,#0]  ; temp
000160  210a              MOVS     r1,#0xa
000162  fb90f4f1          SDIV     r4,r0,r1
000166  2010              MOVS     r0,#0x10
000168  2303              MOVS     r3,#3
00016a  4622              MOV      r2,r4
00016c  21dc              MOVS     r1,#0xdc
00016e  9000              STR      r0,[sp,#0]
000170  2056              MOVS     r0,#0x56
000172  f7fffffe          BL       LCD_ShowNum
;;;328    				LCD_ShowNum(30+48+40,220,temp%10,1,16);		//显示小数部分 
000176  4861              LDR      r0,|L14.764|
000178  f9b00000          LDRSH    r0,[r0,#0]  ; temp
00017c  210a              MOVS     r1,#0xa
00017e  fb90f2f1          SDIV     r2,r0,r1
000182  fb010412          MLS      r4,r1,r2,r0
000186  2010              MOVS     r0,#0x10
000188  2301              MOVS     r3,#1
00018a  4622              MOV      r2,r4
00018c  21dc              MOVS     r1,#0xdc
00018e  9000              STR      r0,[sp,#0]
000190  2076              MOVS     r0,#0x76
000192  f7fffffe          BL       LCD_ShowNum
;;;329    				temp=roll*10;
000196  4857              LDR      r0,|L14.756|
000198  ed900a00          VLDR     s0,[r0,#0]
00019c  eef20a04          VMOV.F32 s1,#10.00000000
0001a0  ee200a20          VMUL.F32 s0,s0,s1
0001a4  eebd0ac0          VCVT.S32.F32 s0,s0
0001a8  ee100a10          VMOV     r0,s0
0001ac  b200              SXTH     r0,r0
0001ae  4953              LDR      r1,|L14.764|
0001b0  8008              STRH     r0,[r1,#0]
;;;330    				if(temp<0)
0001b2  4608              MOV      r0,r1
0001b4  f9b00000          LDRSH    r0,[r0,#0]  ; temp
0001b8  2800              CMP      r0,#0
0001ba  da0e              BGE      |L14.474|
;;;331    				{
;;;332    					LCD_ShowChar(30+48,240,'-',16,0);		//显示负号
0001bc  2000              MOVS     r0,#0
0001be  2310              MOVS     r3,#0x10
0001c0  222d              MOVS     r2,#0x2d
0001c2  21f0              MOVS     r1,#0xf0
0001c4  9000              STR      r0,[sp,#0]
0001c6  204e              MOVS     r0,#0x4e
0001c8  f7fffffe          BL       LCD_ShowChar
;;;333    					temp=-temp;		//转为正数
0001cc  484b              LDR      r0,|L14.764|
0001ce  8800              LDRH     r0,[r0,#0]  ; temp
0001d0  4240              RSBS     r0,r0,#0
0001d2  b200              SXTH     r0,r0
0001d4  4949              LDR      r1,|L14.764|
0001d6  8008              STRH     r0,[r1,#0]
0001d8  e007              B        |L14.490|
                  |L14.474|
;;;334    				}else LCD_ShowChar(30+48,240,' ',16,0);		//去掉负号 
0001da  2000              MOVS     r0,#0
0001dc  2310              MOVS     r3,#0x10
0001de  2220              MOVS     r2,#0x20
0001e0  21f0              MOVS     r1,#0xf0
0001e2  9000              STR      r0,[sp,#0]
0001e4  204e              MOVS     r0,#0x4e
0001e6  f7fffffe          BL       LCD_ShowChar
                  |L14.490|
;;;335    				LCD_ShowNum(30+48+8,240,temp/10,3,16);		//显示整数部分	    
0001ea  4844              LDR      r0,|L14.764|
0001ec  f9b00000          LDRSH    r0,[r0,#0]  ; temp
0001f0  210a              MOVS     r1,#0xa
0001f2  fb90f4f1          SDIV     r4,r0,r1
0001f6  2010              MOVS     r0,#0x10
0001f8  2303              MOVS     r3,#3
0001fa  4622              MOV      r2,r4
0001fc  21f0              MOVS     r1,#0xf0
0001fe  9000              STR      r0,[sp,#0]
000200  2056              MOVS     r0,#0x56
000202  f7fffffe          BL       LCD_ShowNum
;;;336    				LCD_ShowNum(30+48+40,240,temp%10,1,16);		//显示小数部分 
000206  483d              LDR      r0,|L14.764|
000208  f9b00000          LDRSH    r0,[r0,#0]  ; temp
00020c  210a              MOVS     r1,#0xa
00020e  fb90f2f1          SDIV     r2,r0,r1
000212  fb010412          MLS      r4,r1,r2,r0
000216  2010              MOVS     r0,#0x10
000218  2301              MOVS     r3,#1
00021a  4622              MOV      r2,r4
00021c  21f0              MOVS     r1,#0xf0
00021e  9000              STR      r0,[sp,#0]
000220  2076              MOVS     r0,#0x76
000222  f7fffffe          BL       LCD_ShowNum
;;;337    				temp=yaw*10;
000226  4832              LDR      r0,|L14.752|
000228  ed900a00          VLDR     s0,[r0,#0]
00022c  eef20a04          VMOV.F32 s1,#10.00000000
000230  ee200a20          VMUL.F32 s0,s0,s1
000234  eebd0ac0          VCVT.S32.F32 s0,s0
000238  ee100a10          VMOV     r0,s0
00023c  b200              SXTH     r0,r0
00023e  492f              LDR      r1,|L14.764|
000240  8008              STRH     r0,[r1,#0]
;;;338    				if(temp<0)
000242  4608              MOV      r0,r1
000244  f9b00000          LDRSH    r0,[r0,#0]  ; temp
000248  2800              CMP      r0,#0
00024a  da0f              BGE      |L14.620|
;;;339    				{
;;;340    					LCD_ShowChar(30+48,260,'-',16,0);		//显示负号
00024c  2000              MOVS     r0,#0
00024e  2310              MOVS     r3,#0x10
000250  222d              MOVS     r2,#0x2d
000252  f44f7182          MOV      r1,#0x104
000256  9000              STR      r0,[sp,#0]
000258  204e              MOVS     r0,#0x4e
00025a  f7fffffe          BL       LCD_ShowChar
;;;341    					temp=-temp;		//转为正数
00025e  4827              LDR      r0,|L14.764|
000260  8800              LDRH     r0,[r0,#0]  ; temp
000262  4240              RSBS     r0,r0,#0
000264  b200              SXTH     r0,r0
000266  4925              LDR      r1,|L14.764|
000268  8008              STRH     r0,[r1,#0]
00026a  e008              B        |L14.638|
                  |L14.620|
;;;342    				}else LCD_ShowChar(30+48,260,' ',16,0);		//去掉负号 
00026c  2000              MOVS     r0,#0
00026e  2310              MOVS     r3,#0x10
000270  2220              MOVS     r2,#0x20
000272  f44f7182          MOV      r1,#0x104
000276  9000              STR      r0,[sp,#0]
000278  204e              MOVS     r0,#0x4e
00027a  f7fffffe          BL       LCD_ShowChar
                  |L14.638|
;;;343    				LCD_ShowNum(30+48+8,260,temp/10,3,16);		//显示整数部分	    
00027e  481f              LDR      r0,|L14.764|
000280  f9b00000          LDRSH    r0,[r0,#0]  ; temp
000284  210a              MOVS     r1,#0xa
000286  fb90f4f1          SDIV     r4,r0,r1
00028a  2010              MOVS     r0,#0x10
00028c  2303              MOVS     r3,#3
00028e  4622              MOV      r2,r4
000290  f44f7182          MOV      r1,#0x104
000294  9000              STR      r0,[sp,#0]
000296  2056              MOVS     r0,#0x56
000298  f7fffffe          BL       LCD_ShowNum
;;;344    				LCD_ShowNum(30+48+40,260,temp%10,1,16);		//显示小数部分  
00029c  4817              LDR      r0,|L14.764|
00029e  f9b00000          LDRSH    r0,[r0,#0]  ; temp
0002a2  210a              MOVS     r1,#0xa
0002a4  fb90f2f1          SDIV     r2,r0,r1
0002a8  fb010412          MLS      r4,r1,r2,r0
0002ac  2010              MOVS     r0,#0x10
0002ae  2301              MOVS     r3,#1
0002b0  4622              MOV      r2,r4
0002b2  f44f7182          MOV      r1,#0x104
0002b6  9000              STR      r0,[sp,#0]
0002b8  2076              MOVS     r0,#0x76
0002ba  f7fffffe          BL       LCD_ShowNum
;;;345    				t=0;
0002be  2000              MOVS     r0,#0
0002c0  4915              LDR      r1,|L14.792|
0002c2  7008              STRB     r0,[r1,#0]
                  |L14.708|
;;;346    
;;;347    			}
;;;348    		}
;;;349            t++;
0002c4  4814              LDR      r0,|L14.792|
0002c6  7800              LDRB     r0,[r0,#0]  ; t
0002c8  1c40              ADDS     r0,r0,#1
0002ca  4913              LDR      r1,|L14.792|
0002cc  7008              STRB     r0,[r1,#0]
;;;350    
;;;351    }
0002ce  bd1c              POP      {r2-r4,pc}
;;;352    
                          ENDP

                  |L14.720|
                          DCD      key
                  |L14.724|
                          DCD      report
                  |L14.728|
0002d8  55504c4f          DCB      "UPLOAD ON ",0
0002dc  4144204f
0002e0  4e2000  
0002e3  00                DCB      0
                  |L14.740|
0002e4  55504c4f          DCB      "UPLOAD OFF",0
0002e8  4144204f
0002ec  464600  
0002ef  00                DCB      0
                  |L14.752|
                          DCD      yaw
                  |L14.756|
                          DCD      roll
                  |L14.760|
                          DCD      pitch
                  |L14.764|
                          DCD      temp
                  |L14.768|
                          DCD      aacz
                  |L14.772|
                          DCD      aacy
                  |L14.776|
                          DCD      aacx
                  |L14.780|
                          DCD      gyroz
                  |L14.784|
                          DCD      gyroy
                  |L14.788|
                          DCD      gyrox
                  |L14.792|
                          DCD      t

                          AREA ||.data||, DATA, ALIGN=2

                  key
000000  00                DCB      0x00
                  t
000001  00                DCB      0x00
                  report
000002  0100              DCB      0x01,0x00
                  pitch
                          DCD      0x00000000
                  roll
                          DCD      0x00000000
                  yaw
                          DCD      0x00000000
                  aacx
000010  0000              DCB      0x00,0x00
                  aacy
000012  0000              DCB      0x00,0x00
                  aacz
000014  0000              DCB      0x00,0x00
                  gyrox
000016  0000              DCB      0x00,0x00
                  gyroy
000018  0000              DCB      0x00,0x00
                  gyroz
00001a  0000              DCB      0x00,0x00
                  temp
00001c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\HARDWARE\\MPU9250\\mpu9250.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu9250_c_b48083c4____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___9_mpu9250_c_b48083c4____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu9250_c_b48083c4____REVSH|
#line 402
|__asm___9_mpu9250_c_b48083c4____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_mpu9250_c_b48083c4____RRX|
#line 587
|__asm___9_mpu9250_c_b48083c4____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
