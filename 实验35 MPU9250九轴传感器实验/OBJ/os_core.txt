; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\os_core.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\os_core.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\os_core.crf ..\UCOSIII\uCOS-III\Source\os_core.c]
                          THUMB

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=2

                  OSInit PROC
;;;56     
;;;57     void  OSInit (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  4604              MOV      r4,r0
;;;59         CPU_STK      *p_stk;
;;;60         CPU_STK_SIZE  size;
;;;61     
;;;62     
;;;63     
;;;64     #ifdef OS_SAFETY_CRITICAL
;;;65         if (p_err == (OS_ERR *)0) {
;;;66             OS_SAFETY_CRITICAL_EXCEPTION();
;;;67             return;
;;;68         }
;;;69     #endif
;;;70     
;;;71         OSInitHook();                                           /* Call port specific initialization code                 */
000004  f7fffffe          BL       OSInitHook
;;;72     
;;;73         OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
000008  2000              MOVS     r0,#0
00000a  493e              LDR      r1,|L1.260|
00000c  7008              STRB     r0,[r1,#0]
;;;74     
;;;75         OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
00000e  493e              LDR      r1,|L1.264|
000010  7008              STRB     r0,[r1,#0]
;;;76     
;;;77         OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
000012  493e              LDR      r1,|L1.268|
000014  7008              STRB     r0,[r1,#0]
;;;78     
;;;79         OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
000016  493e              LDR      r1,|L1.272|
000018  6008              STR      r0,[r1,#0]  ; OSTCBCurPtr
;;;80         OSTCBHighRdyPtr                 = (OS_TCB *)0;
00001a  493e              LDR      r1,|L1.276|
00001c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdyPtr
;;;81     
;;;82         OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
00001e  493e              LDR      r1,|L1.280|
000020  7008              STRB     r0,[r1,#0]
;;;83         OSPrioHighRdy                   = (OS_PRIO)0;
000022  493e              LDR      r1,|L1.284|
000024  7008              STRB     r0,[r1,#0]
;;;84         OSPrioSaved                     = (OS_PRIO)0;
000026  493e              LDR      r1,|L1.288|
000028  7008              STRB     r0,[r1,#0]
;;;85     
;;;86     #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;87         OSSchedLockTimeBegin            = (CPU_TS)0;
;;;88         OSSchedLockTimeMax              = (CPU_TS)0;
;;;89         OSSchedLockTimeMaxCur           = (CPU_TS)0;
;;;90     #endif
;;;91     
;;;92     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;93         OSSafetyCriticalStartFlag       =  DEF_FALSE;
;;;94     #endif
;;;95     
;;;96     #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;97         OSSchedRoundRobinEn             = DEF_FALSE;
;;;98         OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
;;;99     #endif
;;;100    
;;;101        if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
00002a  483e              LDR      r0,|L1.292|
00002c  6800              LDR      r0,[r0,#0]  ; OSCfg_ISRStkSize
00002e  b158              CBZ      r0,|L1.72|
;;;102            p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
000030  483d              LDR      r0,|L1.296|
000032  6805              LDR      r5,[r0,#0]  ; OSCfg_ISRStkBasePtr
;;;103            if (p_stk != (CPU_STK *)0) {
000034  b145              CBZ      r5,|L1.72|
;;;104                size  = OSCfg_ISRStkSize;
000036  483b              LDR      r0,|L1.292|
000038  6806              LDR      r6,[r0,#0]  ; OSCfg_ISRStkSize
;;;105                while (size > (CPU_STK_SIZE)0) {
00003a  e003              B        |L1.68|
                  |L1.60|
;;;106                    size--;
00003c  1e76              SUBS     r6,r6,#1
;;;107                   *p_stk = (CPU_STK)0;
00003e  2000              MOVS     r0,#0
000040  6028              STR      r0,[r5,#0]
;;;108                    p_stk++;
000042  1d2d              ADDS     r5,r5,#4
                  |L1.68|
000044  2e00              CMP      r6,#0                 ;105
000046  d1f9              BNE      |L1.60|
                  |L1.72|
;;;109                }
;;;110            }
;;;111        }
;;;112    
;;;113    #if OS_CFG_APP_HOOKS_EN > 0u
;;;114        OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
000048  2000              MOVS     r0,#0
00004a  4938              LDR      r1,|L1.300|
00004c  6008              STR      r0,[r1,#0]  ; OS_AppTaskCreateHookPtr
;;;115        OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
00004e  4938              LDR      r1,|L1.304|
000050  6008              STR      r0,[r1,#0]  ; OS_AppTaskDelHookPtr
;;;116        OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
000052  4938              LDR      r1,|L1.308|
000054  6008              STR      r0,[r1,#0]  ; OS_AppTaskReturnHookPtr
;;;117    
;;;118        OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
000056  4938              LDR      r1,|L1.312|
000058  6008              STR      r0,[r1,#0]  ; OS_AppIdleTaskHookPtr
;;;119        OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
00005a  4938              LDR      r1,|L1.316|
00005c  6008              STR      r0,[r1,#0]  ; OS_AppStatTaskHookPtr
;;;120        OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
00005e  4938              LDR      r1,|L1.320|
000060  6008              STR      r0,[r1,#0]  ; OS_AppTaskSwHookPtr
;;;121        OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
000062  4938              LDR      r1,|L1.324|
000064  6008              STR      r0,[r1,#0]  ; OS_AppTimeTickHookPtr
;;;122    #endif
;;;123    
;;;124    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;125        OSTaskRegNextAvailID    = (OS_REG_ID)0;
000066  4938              LDR      r1,|L1.328|
000068  7008              STRB     r0,[r1,#0]
;;;126    #endif
;;;127    
;;;128        OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
00006a  f7fffffe          BL       OS_PrioInit
;;;129    
;;;130        OS_RdyListInit();                                       /* Initialize the Ready List                              */
00006e  f7fffffe          BL       OS_RdyListInit
;;;131    
;;;132        
;;;133    #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
;;;134        OS_FlagInit(p_err);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       OS_FlagInit
;;;135        if (*p_err != OS_ERR_NONE) {
000078  8820              LDRH     r0,[r4,#0]
00007a  b100              CBZ      r0,|L1.126|
                  |L1.124|
;;;136            return;
;;;137        }
;;;138    #endif
;;;139    
;;;140    
;;;141    #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
;;;142        OS_MemInit(p_err);
;;;143        if (*p_err != OS_ERR_NONE) {
;;;144            return;
;;;145        }
;;;146    #endif
;;;147    
;;;148    
;;;149    #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
;;;150        OS_MsgPoolInit(p_err);
;;;151        if (*p_err != OS_ERR_NONE) {
;;;152            return;
;;;153        }
;;;154    #endif
;;;155    
;;;156    
;;;157    #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
;;;158        OS_MutexInit(p_err);
;;;159        if (*p_err != OS_ERR_NONE) {
;;;160            return;
;;;161        }
;;;162    #endif
;;;163    
;;;164    
;;;165    #if OS_CFG_Q_EN > 0u
;;;166        OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
;;;167        if (*p_err != OS_ERR_NONE) {
;;;168            return;
;;;169        }
;;;170    #endif
;;;171    
;;;172    
;;;173    #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
;;;174        OS_SemInit(p_err);
;;;175        if (*p_err != OS_ERR_NONE) {
;;;176            return;
;;;177        }
;;;178    #endif
;;;179    
;;;180    
;;;181    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;182        OS_TLS_Init(p_err);                                     /* Initialize Task Local Storage, before creating tasks   */
;;;183        if (*p_err != OS_ERR_NONE) {
;;;184            return;
;;;185        }
;;;186    #endif
;;;187    
;;;188    
;;;189        OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
;;;190        if (*p_err != OS_ERR_NONE) {
;;;191            return;
;;;192        }
;;;193    
;;;194    
;;;195    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;196        OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
;;;197        if (*p_err != OS_ERR_NONE) {
;;;198            return;
;;;199        }
;;;200    #endif
;;;201    
;;;202        
;;;203        OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
;;;204        if (*p_err != OS_ERR_NONE) {
;;;205            return;
;;;206        }
;;;207    
;;;208    
;;;209        OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
;;;210        if (*p_err != OS_ERR_NONE) {
;;;211            return;
;;;212        }
;;;213    
;;;214    
;;;215    #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
;;;216        OS_StatTaskInit(p_err);
;;;217        if (*p_err != OS_ERR_NONE) {
;;;218            return;
;;;219        }
;;;220    #endif
;;;221    
;;;222    
;;;223    #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
;;;224        OS_TmrInit(p_err);
;;;225        if (*p_err != OS_ERR_NONE) {
;;;226            return;
;;;227        }
;;;228    #endif
;;;229    
;;;230    
;;;231    #if OS_CFG_DBG_EN > 0u
;;;232        OS_Dbg_Init();
;;;233    #endif
;;;234    
;;;235    
;;;236        OSCfg_Init();
;;;237    }
00007c  bd70              POP      {r4-r6,pc}
                  |L1.126|
00007e  4620              MOV      r0,r4                 ;142
000080  f7fffffe          BL       OS_MemInit
000084  8820              LDRH     r0,[r4,#0]            ;143
000086  b100              CBZ      r0,|L1.138|
000088  e7f8              B        |L1.124|
                  |L1.138|
00008a  4620              MOV      r0,r4                 ;150
00008c  f7fffffe          BL       OS_MsgPoolInit
000090  8820              LDRH     r0,[r4,#0]            ;151
000092  b100              CBZ      r0,|L1.150|
000094  e7f2              B        |L1.124|
                  |L1.150|
000096  4620              MOV      r0,r4                 ;158
000098  f7fffffe          BL       OS_MutexInit
00009c  8820              LDRH     r0,[r4,#0]            ;159
00009e  b100              CBZ      r0,|L1.162|
0000a0  e7ec              B        |L1.124|
                  |L1.162|
0000a2  4620              MOV      r0,r4                 ;166
0000a4  f7fffffe          BL       OS_QInit
0000a8  8820              LDRH     r0,[r4,#0]            ;167
0000aa  b100              CBZ      r0,|L1.174|
0000ac  e7e6              B        |L1.124|
                  |L1.174|
0000ae  4620              MOV      r0,r4                 ;174
0000b0  f7fffffe          BL       OS_SemInit
0000b4  8820              LDRH     r0,[r4,#0]            ;175
0000b6  b100              CBZ      r0,|L1.186|
0000b8  e7e0              B        |L1.124|
                  |L1.186|
0000ba  4620              MOV      r0,r4                 ;189
0000bc  f7fffffe          BL       OS_TaskInit
0000c0  8820              LDRH     r0,[r4,#0]            ;190
0000c2  b100              CBZ      r0,|L1.198|
0000c4  e7da              B        |L1.124|
                  |L1.198|
0000c6  4620              MOV      r0,r4                 ;203
0000c8  f7fffffe          BL       OS_IdleTaskInit
0000cc  8820              LDRH     r0,[r4,#0]            ;204
0000ce  b100              CBZ      r0,|L1.210|
0000d0  e7d4              B        |L1.124|
                  |L1.210|
0000d2  4620              MOV      r0,r4                 ;209
0000d4  f7fffffe          BL       OS_TickTaskInit
0000d8  8820              LDRH     r0,[r4,#0]            ;210
0000da  b100              CBZ      r0,|L1.222|
0000dc  e7ce              B        |L1.124|
                  |L1.222|
0000de  4620              MOV      r0,r4                 ;216
0000e0  f7fffffe          BL       OS_StatTaskInit
0000e4  8820              LDRH     r0,[r4,#0]            ;217
0000e6  b100              CBZ      r0,|L1.234|
0000e8  e7c8              B        |L1.124|
                  |L1.234|
0000ea  4620              MOV      r0,r4                 ;224
0000ec  f7fffffe          BL       OS_TmrInit
0000f0  8820              LDRH     r0,[r4,#0]            ;225
0000f2  b100              CBZ      r0,|L1.246|
0000f4  e7c2              B        |L1.124|
                  |L1.246|
0000f6  f7fffffe          BL       OS_Dbg_Init
0000fa  f7fffffe          BL       OSCfg_Init
0000fe  bf00              NOP      
000100  e7bc              B        |L1.124|
;;;238    
                          ENDP

000102  0000              DCW      0x0000
                  |L1.260|
                          DCD      OSIntNestingCtr
                  |L1.264|
                          DCD      OSRunning
                  |L1.268|
                          DCD      OSSchedLockNestingCtr
                  |L1.272|
                          DCD      OSTCBCurPtr
                  |L1.276|
                          DCD      OSTCBHighRdyPtr
                  |L1.280|
                          DCD      OSPrioCur
                  |L1.284|
                          DCD      OSPrioHighRdy
                  |L1.288|
                          DCD      OSPrioSaved
                  |L1.292|
                          DCD      OSCfg_ISRStkSize
                  |L1.296|
                          DCD      OSCfg_ISRStkBasePtr
                  |L1.300|
                          DCD      OS_AppTaskCreateHookPtr
                  |L1.304|
                          DCD      OS_AppTaskDelHookPtr
                  |L1.308|
                          DCD      OS_AppTaskReturnHookPtr
                  |L1.312|
                          DCD      OS_AppIdleTaskHookPtr
                  |L1.316|
                          DCD      OS_AppStatTaskHookPtr
                  |L1.320|
                          DCD      OS_AppTaskSwHookPtr
                  |L1.324|
                          DCD      OS_AppTimeTickHookPtr
                  |L1.328|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;267    
;;;268    void  OSIntEnter (void)
000000  4808              LDR      r0,|L2.36|
;;;269    {
;;;270        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d000              BEQ      |L2.10|
                  |L2.8|
;;;271            return;                                             /* No                                                     */
;;;272        }
;;;273    
;;;274        if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
;;;275            return;                                             /* Yes                                                    */
;;;276        }
;;;277    
;;;278        OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
;;;279    }
000008  4770              BX       lr
                  |L2.10|
00000a  4807              LDR      r0,|L2.40|
00000c  7800              LDRB     r0,[r0,#0]            ;274  ; OSIntNestingCtr
00000e  28fa              CMP      r0,#0xfa              ;274
000010  db00              BLT      |L2.20|
000012  e7f9              B        |L2.8|
                  |L2.20|
000014  4804              LDR      r0,|L2.40|
000016  7800              LDRB     r0,[r0,#0]            ;278  ; OSIntNestingCtr
000018  1c40              ADDS     r0,r0,#1              ;278
00001a  4903              LDR      r1,|L2.40|
00001c  7008              STRB     r0,[r1,#0]            ;278
00001e  bf00              NOP      
000020  e7f2              B        |L2.8|
;;;280    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      OSRunning
                  |L2.40|
                          DCD      OSIntNestingCtr

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;301    
;;;302    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;303    {
;;;304        CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;305    
;;;306    
;;;307    
;;;308        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
000004  482d              LDR      r0,|L3.188|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d000              BEQ      |L3.14|
                  |L3.12|
;;;309            return;                                             /* No                                                     */
;;;310        }
;;;311    
;;;312        CPU_INT_DIS();
;;;313        if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
;;;314            CPU_INT_EN();
;;;315            return;
;;;316        }
;;;317        OSIntNestingCtr--;
;;;318        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
;;;319            CPU_INT_EN();                                       /* Yes                                                    */
;;;320            return;
;;;321        }
;;;322    
;;;323        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
;;;324            CPU_INT_EN();                                       /* Yes                                                    */
;;;325            return;
;;;326        }
;;;327    
;;;328        OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
;;;329        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
;;;330        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
;;;331            CPU_INT_EN();                                       /* Yes                                                    */
;;;332            return;
;;;333        }
;;;334    
;;;335    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;336        OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
;;;337    #endif
;;;338        OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
;;;339    
;;;340    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;341        OS_TLS_TaskSw();
;;;342    #endif
;;;343    
;;;344        OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
;;;345    
;;;346        CPU_INT_EN();
;;;347    }
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  bf00              NOP                            ;312
000010  f7fffffe          BL       CPU_SR_Save
000014  4604              MOV      r4,r0                 ;312
000016  bf00              NOP                            ;312
000018  4829              LDR      r0,|L3.192|
00001a  7800              LDRB     r0,[r0,#0]            ;313  ; OSIntNestingCtr
00001c  b928              CBNZ     r0,|L3.42|
00001e  bf00              NOP                            ;314
000020  4620              MOV      r0,r4                 ;314
000022  f7fffffe          BL       CPU_SR_Restore
000026  bf00              NOP                            ;314
000028  e7f0              B        |L3.12|
                  |L3.42|
00002a  4825              LDR      r0,|L3.192|
00002c  7800              LDRB     r0,[r0,#0]            ;317  ; OSIntNestingCtr
00002e  1e40              SUBS     r0,r0,#1              ;317
000030  4923              LDR      r1,|L3.192|
000032  7008              STRB     r0,[r1,#0]            ;317
000034  4608              MOV      r0,r1                 ;318
000036  7800              LDRB     r0,[r0,#0]            ;318  ; OSIntNestingCtr
000038  2800              CMP      r0,#0                 ;318
00003a  dd05              BLE      |L3.72|
00003c  bf00              NOP                            ;319
00003e  4620              MOV      r0,r4                 ;319
000040  f7fffffe          BL       CPU_SR_Restore
000044  bf00              NOP                            ;319
000046  e7e1              B        |L3.12|
                  |L3.72|
000048  481e              LDR      r0,|L3.196|
00004a  7800              LDRB     r0,[r0,#0]            ;323  ; OSSchedLockNestingCtr
00004c  2800              CMP      r0,#0                 ;323
00004e  dd05              BLE      |L3.92|
000050  bf00              NOP                            ;324
000052  4620              MOV      r0,r4                 ;324
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;324
00005a  e7d7              B        |L3.12|
                  |L3.92|
00005c  f7fffffe          BL       OS_PrioGetHighest
000060  4919              LDR      r1,|L3.200|
000062  7008              STRB     r0,[r1,#0]            ;328
000064  4608              MOV      r0,r1                 ;329
000066  7800              LDRB     r0,[r0,#0]            ;329  ; OSPrioHighRdy
000068  eb000040          ADD      r0,r0,r0,LSL #1       ;329
00006c  4917              LDR      r1,|L3.204|
00006e  f8510020          LDR      r0,[r1,r0,LSL #2]     ;329
000072  4917              LDR      r1,|L3.208|
000074  6008              STR      r0,[r1,#0]            ;329  ; OSTCBHighRdyPtr
000076  4608              MOV      r0,r1                 ;330
000078  6800              LDR      r0,[r0,#0]            ;330  ; OSTCBHighRdyPtr
00007a  4916              LDR      r1,|L3.212|
00007c  6809              LDR      r1,[r1,#0]            ;330  ; OSTCBCurPtr
00007e  4288              CMP      r0,r1                 ;330
000080  d105              BNE      |L3.142|
000082  bf00              NOP                            ;331
000084  4620              MOV      r0,r4                 ;331
000086  f7fffffe          BL       CPU_SR_Restore
00008a  bf00              NOP                            ;331
00008c  e7be              B        |L3.12|
                  |L3.142|
00008e  4810              LDR      r0,|L3.208|
000090  6800              LDR      r0,[r0,#0]            ;336  ; OSTCBHighRdyPtr
000092  f8d0008c          LDR      r0,[r0,#0x8c]         ;336
000096  1c40              ADDS     r0,r0,#1              ;336
000098  490d              LDR      r1,|L3.208|
00009a  6809              LDR      r1,[r1,#0]            ;336  ; OSTCBHighRdyPtr
00009c  f8c1008c          STR      r0,[r1,#0x8c]         ;336
0000a0  480d              LDR      r0,|L3.216|
0000a2  6800              LDR      r0,[r0,#0]            ;338  ; OSTaskCtxSwCtr
0000a4  1c40              ADDS     r0,r0,#1              ;338
0000a6  490c              LDR      r1,|L3.216|
0000a8  6008              STR      r0,[r1,#0]            ;338  ; OSTaskCtxSwCtr
0000aa  f7fffffe          BL       OSIntCtxSw
0000ae  bf00              NOP                            ;346
0000b0  4620              MOV      r0,r4                 ;346
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP                            ;346
0000b8  bf00              NOP      
0000ba  e7a7              B        |L3.12|
;;;348    
                          ENDP

                  |L3.188|
                          DCD      OSRunning
                  |L3.192|
                          DCD      OSIntNestingCtr
                  |L3.196|
                          DCD      OSSchedLockNestingCtr
                  |L3.200|
                          DCD      OSPrioHighRdy
                  |L3.204|
                          DCD      OSRdyList
                  |L3.208|
                          DCD      OSTCBHighRdyPtr
                  |L3.212|
                          DCD      OSTCBCurPtr
                  |L3.216|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OSSched||, CODE, READONLY, ALIGN=2

                  OSSched PROC
;;;389    
;;;390    void  OSSched (void)
000000  b510              PUSH     {r4,lr}
;;;391    {
;;;392        CPU_SR_ALLOC();
000002  2400              MOVS     r4,#0
;;;393    
;;;394    
;;;395    
;;;396        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
000004  4820              LDR      r0,|L4.136|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  2800              CMP      r0,#0
00000a  dd00              BLE      |L4.14|
                  |L4.12|
;;;397            return;                                             /* Yes ... only schedule when no nested ISRs              */
;;;398        }
;;;399    
;;;400        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
;;;401            return;                                             /* Yes                                                    */
;;;402        }
;;;403    
;;;404        CPU_INT_DIS();
;;;405        OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
;;;406        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
;;;407        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
;;;408            CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
;;;409            return;
;;;410        }
;;;411    
;;;412    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;413        OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
;;;414    #endif
;;;415        OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
;;;416    
;;;417    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;418        OS_TLS_TaskSw();
;;;419    #endif
;;;420    
;;;421        OS_TASK_SW();                                           /* Perform a task level context switch                    */
;;;422        CPU_INT_EN();
;;;423    
;;;424    #ifdef OS_TASK_SW_SYNC
;;;425        OS_TASK_SW_SYNC();
;;;426    #endif
;;;427    }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  481f              LDR      r0,|L4.140|
000010  7800              LDRB     r0,[r0,#0]            ;400  ; OSSchedLockNestingCtr
000012  2800              CMP      r0,#0                 ;400
000014  dd00              BLE      |L4.24|
000016  e7f9              B        |L4.12|
                  |L4.24|
000018  bf00              NOP                            ;404
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4604              MOV      r4,r0                 ;404
000020  bf00              NOP                            ;404
000022  f7fffffe          BL       OS_PrioGetHighest
000026  491a              LDR      r1,|L4.144|
000028  7008              STRB     r0,[r1,#0]            ;405
00002a  4608              MOV      r0,r1                 ;406
00002c  7800              LDRB     r0,[r0,#0]            ;406  ; OSPrioHighRdy
00002e  eb000040          ADD      r0,r0,r0,LSL #1       ;406
000032  4918              LDR      r1,|L4.148|
000034  f8510020          LDR      r0,[r1,r0,LSL #2]     ;406
000038  4917              LDR      r1,|L4.152|
00003a  6008              STR      r0,[r1,#0]            ;406  ; OSTCBHighRdyPtr
00003c  4608              MOV      r0,r1                 ;407
00003e  6800              LDR      r0,[r0,#0]            ;407  ; OSTCBHighRdyPtr
000040  4916              LDR      r1,|L4.156|
000042  6809              LDR      r1,[r1,#0]            ;407  ; OSTCBCurPtr
000044  4288              CMP      r0,r1                 ;407
000046  d105              BNE      |L4.84|
000048  bf00              NOP                            ;408
00004a  4620              MOV      r0,r4                 ;408
00004c  f7fffffe          BL       CPU_SR_Restore
000050  bf00              NOP                            ;408
000052  e7db              B        |L4.12|
                  |L4.84|
000054  4810              LDR      r0,|L4.152|
000056  6800              LDR      r0,[r0,#0]            ;413  ; OSTCBHighRdyPtr
000058  f8d0008c          LDR      r0,[r0,#0x8c]         ;413
00005c  1c40              ADDS     r0,r0,#1              ;413
00005e  490e              LDR      r1,|L4.152|
000060  6809              LDR      r1,[r1,#0]            ;413  ; OSTCBHighRdyPtr
000062  f8c1008c          STR      r0,[r1,#0x8c]         ;413
000066  480e              LDR      r0,|L4.160|
000068  6800              LDR      r0,[r0,#0]            ;415  ; OSTaskCtxSwCtr
00006a  1c40              ADDS     r0,r0,#1              ;415
00006c  490c              LDR      r1,|L4.160|
00006e  6008              STR      r0,[r1,#0]            ;415  ; OSTaskCtxSwCtr
000070  f7fffffe          BL       OSCtxSw
000074  bf00              NOP                            ;422
000076  4620              MOV      r0,r4                 ;422
000078  f7fffffe          BL       CPU_SR_Restore
00007c  bf00              NOP                            ;422
00007e  f3bf8f6f          ISB                            ;425
000082  bf00              NOP      
000084  e7c2              B        |L4.12|
;;;428    
                          ENDP

000086  0000              DCW      0x0000
                  |L4.136|
                          DCD      OSIntNestingCtr
                  |L4.140|
                          DCD      OSSchedLockNestingCtr
                  |L4.144|
                          DCD      OSPrioHighRdy
                  |L4.148|
                          DCD      OSRdyList
                  |L4.152|
                          DCD      OSTCBHighRdyPtr
                  |L4.156|
                          DCD      OSTCBCurPtr
                  |L4.160|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;450    
;;;451    void  OSSchedLock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
000002  4604              MOV      r4,r0
;;;453        CPU_SR_ALLOC();
000004  2500              MOVS     r5,#0
;;;454    
;;;455    
;;;456    
;;;457    #ifdef OS_SAFETY_CRITICAL
;;;458        if (p_err == (OS_ERR *)0) {
;;;459            OS_SAFETY_CRITICAL_EXCEPTION();
;;;460            return;
;;;461        }
;;;462    #endif
;;;463    
;;;464    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;465        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;466           *p_err = OS_ERR_SCHED_LOCK_ISR;
;;;467            return;
;;;468        }
;;;469    #endif
;;;470    
;;;471        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
000006  4815              LDR      r0,|L5.92|
000008  7800              LDRB     r0,[r0,#0]  ; OSRunning
00000a  2801              CMP      r0,#1
00000c  d003              BEQ      |L5.22|
;;;472           *p_err = OS_ERR_OS_NOT_RUNNING;
00000e  f6456089          MOV      r0,#0x5e89
000012  8020              STRH     r0,[r4,#0]
                  |L5.20|
;;;473            return;
;;;474        }
;;;475    
;;;476        if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
;;;477           *p_err = OS_ERR_LOCK_NESTING_OVF;
;;;478            return;
;;;479        }
;;;480    
;;;481        CPU_CRITICAL_ENTER();
;;;482        OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
;;;483    #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;484        OS_SchedLockTimeMeasStart();
;;;485    #endif
;;;486        CPU_CRITICAL_EXIT();
;;;487       *p_err = OS_ERR_NONE;
;;;488    }
000014  bd70              POP      {r4-r6,pc}
                  |L5.22|
000016  4812              LDR      r0,|L5.96|
000018  7800              LDRB     r0,[r0,#0]            ;476  ; OSSchedLockNestingCtr
00001a  28fa              CMP      r0,#0xfa              ;476
00001c  db03              BLT      |L5.38|
00001e  f2452009          MOV      r0,#0x5209            ;477
000022  8020              STRH     r0,[r4,#0]            ;477
000024  e7f6              B        |L5.20|
                  |L5.38|
000026  bf00              NOP                            ;481
000028  bf00              NOP                            ;481
00002a  f7fffffe          BL       CPU_SR_Save
00002e  4605              MOV      r5,r0                 ;481
000030  bf00              NOP                            ;481
000032  f7fffffe          BL       CPU_IntDisMeasStart
000036  bf00              NOP                            ;481
000038  4809              LDR      r0,|L5.96|
00003a  7800              LDRB     r0,[r0,#0]            ;482  ; OSSchedLockNestingCtr
00003c  1c40              ADDS     r0,r0,#1              ;482
00003e  4908              LDR      r1,|L5.96|
000040  7008              STRB     r0,[r1,#0]            ;482
000042  bf00              NOP                            ;486
000044  f7fffffe          BL       CPU_IntDisMeasStop
000048  bf00              NOP                            ;486
00004a  4628              MOV      r0,r5                 ;486
00004c  f7fffffe          BL       CPU_SR_Restore
000050  bf00              NOP                            ;486
000052  bf00              NOP                            ;486
000054  2000              MOVS     r0,#0                 ;487
000056  8020              STRH     r0,[r4,#0]            ;487
000058  bf00              NOP      
00005a  e7db              B        |L5.20|
;;;489    
                          ENDP

                  |L5.92|
                          DCD      OSRunning
                  |L5.96|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;511    
;;;512    void  OSSchedUnlock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
000002  4604              MOV      r4,r0
;;;514        CPU_SR_ALLOC();
000004  2500              MOVS     r5,#0
;;;515    
;;;516    
;;;517    
;;;518    #ifdef OS_SAFETY_CRITICAL
;;;519        if (p_err == (OS_ERR *)0) {
;;;520            OS_SAFETY_CRITICAL_EXCEPTION();
;;;521            return;
;;;522        }
;;;523    #endif
;;;524    
;;;525    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;526        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;527           *p_err = OS_ERR_SCHED_UNLOCK_ISR;
;;;528            return;
;;;529        }
;;;530    #endif
;;;531    
;;;532        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
000006  481e              LDR      r0,|L6.128|
000008  7800              LDRB     r0,[r0,#0]  ; OSRunning
00000a  2801              CMP      r0,#1
00000c  d003              BEQ      |L6.22|
;;;533           *p_err = OS_ERR_OS_NOT_RUNNING;
00000e  f6456089          MOV      r0,#0x5e89
000012  8020              STRH     r0,[r4,#0]
                  |L6.20|
;;;534            return;
;;;535        }
;;;536    
;;;537        if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
;;;538           *p_err = OS_ERR_SCHED_NOT_LOCKED;
;;;539            return;
;;;540        }
;;;541    
;;;542        CPU_CRITICAL_ENTER();
;;;543        OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
;;;544        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
;;;545            CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
;;;546           *p_err = OS_ERR_SCHED_LOCKED;
;;;547            return;
;;;548        }
;;;549    
;;;550    #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;551        OS_SchedLockTimeMeasStop();
;;;552    #endif
;;;553    
;;;554        CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
;;;555        OSSched();                                              /* Run the scheduler                                      */
;;;556       *p_err = OS_ERR_NONE;
;;;557    }
000014  bd70              POP      {r4-r6,pc}
                  |L6.22|
000016  481b              LDR      r0,|L6.132|
000018  7800              LDRB     r0,[r0,#0]            ;537  ; OSSchedLockNestingCtr
00001a  b918              CBNZ     r0,|L6.36|
00001c  f6465064          MOV      r0,#0x6d64            ;538
000020  8020              STRH     r0,[r4,#0]            ;538
000022  e7f7              B        |L6.20|
                  |L6.36|
000024  bf00              NOP                            ;542
000026  bf00              NOP                            ;542
000028  f7fffffe          BL       CPU_SR_Save
00002c  4605              MOV      r5,r0                 ;542
00002e  bf00              NOP                            ;542
000030  f7fffffe          BL       CPU_IntDisMeasStart
000034  bf00              NOP                            ;542
000036  4813              LDR      r0,|L6.132|
000038  7800              LDRB     r0,[r0,#0]            ;543  ; OSSchedLockNestingCtr
00003a  1e40              SUBS     r0,r0,#1              ;543
00003c  4911              LDR      r1,|L6.132|
00003e  7008              STRB     r0,[r1,#0]            ;543
000040  4608              MOV      r0,r1                 ;544
000042  7800              LDRB     r0,[r0,#0]            ;544  ; OSSchedLockNestingCtr
000044  2800              CMP      r0,#0                 ;544
000046  dd0c              BLE      |L6.98|
000048  bf00              NOP                            ;545
00004a  f7fffffe          BL       CPU_IntDisMeasStop
00004e  bf00              NOP                            ;545
000050  4628              MOV      r0,r5                 ;545
000052  f7fffffe          BL       CPU_SR_Restore
000056  bf00              NOP                            ;545
000058  bf00              NOP                            ;545
00005a  f6465063          MOV      r0,#0x6d63            ;546
00005e  8020              STRH     r0,[r4,#0]            ;546
000060  e7d8              B        |L6.20|
                  |L6.98|
000062  bf00              NOP                            ;554
000064  f7fffffe          BL       CPU_IntDisMeasStop
000068  bf00              NOP                            ;554
00006a  4628              MOV      r0,r5                 ;554
00006c  f7fffffe          BL       CPU_SR_Restore
000070  bf00              NOP                            ;554
000072  bf00              NOP                            ;554
000074  f7fffffe          BL       OSSched
000078  2000              MOVS     r0,#0                 ;556
00007a  8020              STRH     r0,[r4,#0]            ;556
00007c  bf00              NOP      
00007e  e7c9              B        |L6.20|
;;;558    
                          ENDP

                  |L6.128|
                          DCD      OSRunning
                  |L6.132|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;712    
;;;713    void  OSStart (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;714    {
000002  4604              MOV      r4,r0
;;;715    #ifdef OS_SAFETY_CRITICAL
;;;716        if (p_err == (OS_ERR *)0) {
;;;717            OS_SAFETY_CRITICAL_EXCEPTION();
;;;718            return;
;;;719        }
;;;720    #endif
;;;721    
;;;722        if (OSRunning == OS_STATE_OS_STOPPED) {
000004  4812              LDR      r0,|L7.80|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  b9e8              CBNZ     r0,|L7.70|
;;;723            OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
00000a  f7fffffe          BL       OS_PrioGetHighest
00000e  4911              LDR      r1,|L7.84|
000010  7008              STRB     r0,[r1,#0]
;;;724            OSPrioCur       = OSPrioHighRdy;
000012  4608              MOV      r0,r1
000014  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000016  4910              LDR      r1,|L7.88|
000018  7008              STRB     r0,[r1,#0]
;;;725            OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
00001a  480e              LDR      r0,|L7.84|
00001c  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00001e  eb000040          ADD      r0,r0,r0,LSL #1
000022  490e              LDR      r1,|L7.92|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  490d              LDR      r1,|L7.96|
00002a  6008              STR      r0,[r1,#0]  ; OSTCBHighRdyPtr
;;;726            OSTCBCurPtr     = OSTCBHighRdyPtr;
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdyPtr
000030  490c              LDR      r1,|L7.100|
000032  6008              STR      r0,[r1,#0]  ; OSTCBCurPtr
;;;727            OSRunning       = OS_STATE_OS_RUNNING;
000034  2001              MOVS     r0,#1
000036  4906              LDR      r1,|L7.80|
000038  7008              STRB     r0,[r1,#0]
;;;728            OSStartHighRdy();                                   /* Execute target specific code to start task             */
00003a  f7fffffe          BL       OSStartHighRdy
;;;729           *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
00003e  f6432099          MOV      r0,#0x3a99
000042  8020              STRH     r0,[r4,#0]
000044  e002              B        |L7.76|
                  |L7.70|
;;;730        } else {
;;;731           *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
000046  f645608a          MOV      r0,#0x5e8a
00004a  8020              STRH     r0,[r4,#0]
                  |L7.76|
;;;732        }
;;;733    }
00004c  bd10              POP      {r4,pc}
;;;734    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      OSRunning
                  |L7.84|
                          DCD      OSPrioHighRdy
                  |L7.88|
                          DCD      OSPrioCur
                  |L7.92|
                          DCD      OSRdyList
                  |L7.96|
                          DCD      OSTCBHighRdyPtr
                  |L7.100|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;751    
;;;752    CPU_INT16U  OSVersion (OS_ERR  *p_err)
000000  4601              MOV      r1,r0
;;;753    {
;;;754    #ifdef OS_SAFETY_CRITICAL
;;;755        if (p_err == (OS_ERR *)0) {
;;;756            OS_SAFETY_CRITICAL_EXCEPTION();
;;;757            return ((CPU_INT16U)0u);
;;;758        }
;;;759    #endif
;;;760    
;;;761       *p_err = OS_ERR_NONE;
000002  2000              MOVS     r0,#0
000004  8008              STRH     r0,[r1,#0]
;;;762        return (OS_VERSION);
000006  f24760c5          MOV      r0,#0x76c5
;;;763    }
00000a  4770              BX       lr
;;;764    
                          ENDP


                          AREA ||i.OS_IdleTask||, CODE, READONLY, ALIGN=2

                  OS_IdleTask PROC
;;;787    
;;;788    void  OS_IdleTask (void  *p_arg)
000000  2400              MOVS     r4,#0
;;;789    {
;;;790        CPU_SR_ALLOC();
;;;791    
;;;792    
;;;793    
;;;794        (void)&p_arg;                                           /* Prevent compiler warning for not using 'p_arg'         */
;;;795    
;;;796        while (DEF_ON) {
000002  e01d              B        |L9.64|
                  |L9.4|
;;;797            CPU_CRITICAL_ENTER();
000004  bf00              NOP      
000006  bf00              NOP      
000008  f7fffffe          BL       CPU_SR_Save
00000c  4604              MOV      r4,r0
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_IntDisMeasStart
000014  bf00              NOP      
;;;798            OSIdleTaskCtr++;
000016  480b              LDR      r0,|L9.68|
000018  6800              LDR      r0,[r0,#0]  ; OSIdleTaskCtr
00001a  1c40              ADDS     r0,r0,#1
00001c  4909              LDR      r1,|L9.68|
00001e  6008              STR      r0,[r1,#0]  ; OSIdleTaskCtr
;;;799    #if OS_CFG_STAT_TASK_EN > 0u
;;;800            OSStatTaskCtr++;
000020  4809              LDR      r0,|L9.72|
000022  6800              LDR      r0,[r0,#0]  ; OSStatTaskCtr
000024  1c40              ADDS     r0,r0,#1
000026  4908              LDR      r1,|L9.72|
000028  6008              STR      r0,[r1,#0]  ; OSStatTaskCtr
;;;801    #endif
;;;802            CPU_CRITICAL_EXIT();
00002a  bf00              NOP      
00002c  f7fffffe          BL       CPU_IntDisMeasStop
000030  bf00              NOP      
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       CPU_SR_Restore
000038  bf00              NOP      
00003a  bf00              NOP      
;;;803    
;;;804            OSIdleTaskHook();                                   /* Call user definable HOOK                               */
00003c  f7fffffe          BL       OSIdleTaskHook
                  |L9.64|
000040  e7e0              B        |L9.4|
;;;805        }
;;;806    }
;;;807    
                          ENDP

000042  0000              DCW      0x0000
                  |L9.68|
                          DCD      OSIdleTaskCtr
                  |L9.72|
                          DCD      OSStatTaskCtr

                          AREA ||i.OS_IdleTaskInit||, CODE, READONLY, ALIGN=2

                  OS_IdleTaskInit PROC
;;;822    
;;;823    void  OS_IdleTaskInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;824    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;825    #ifdef OS_SAFETY_CRITICAL
;;;826        if (p_err == (OS_ERR *)0) {
;;;827            OS_SAFETY_CRITICAL_EXCEPTION();
;;;828            return;
;;;829        }
;;;830    #endif
;;;831    
;;;832        OSIdleTaskCtr = (OS_IDLE_CTR)0;
000006  2000              MOVS     r0,#0
000008  490e              LDR      r1,|L10.68|
00000a  6008              STR      r0,[r1,#0]  ; OSIdleTaskCtr
;;;833                                                                /* ---------------- CREATE THE IDLE TASK ---------------- */
;;;834        OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
00000c  200b              MOVS     r0,#0xb
00000e  2100              MOVS     r1,#0
000010  9105              STR      r1,[sp,#0x14]
000012  e9cd0407          STRD     r0,r4,[sp,#0x1c]
000016  9106              STR      r1,[sp,#0x18]
000018  4608              MOV      r0,r1
00001a  490b              LDR      r1,|L10.72|
00001c  6809              LDR      r1,[r1,#0]  ; OSCfg_IdleTaskStkSize
00001e  4a0b              LDR      r2,|L10.76|
000020  6812              LDR      r2,[r2,#0]  ; OSCfg_IdleTaskStkLimit
000022  4b0b              LDR      r3,|L10.80|
000024  681b              LDR      r3,[r3,#0]  ; OSCfg_IdleTaskStkBasePtr
000026  e9cd3201          STRD     r3,r2,[sp,#4]
00002a  e9cd1003          STRD     r1,r0,[sp,#0xc]
00002e  203f              MOVS     r0,#0x3f
000030  2300              MOVS     r3,#0
000032  4a08              LDR      r2,|L10.84|
000034  a108              ADR      r1,|L10.88|
000036  9000              STR      r0,[sp,#0]
000038  480c              LDR      r0,|L10.108|
00003a  f7fffffe          BL       OSTaskCreate
;;;835                     (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
;;;836                     (OS_TASK_PTR)OS_IdleTask,
;;;837                     (void       *)0,
;;;838                     (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
;;;839                     (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
;;;840                     (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
;;;841                     (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
;;;842                     (OS_MSG_QTY  )0u,
;;;843                     (OS_TICK     )0u,
;;;844                     (void       *)0,
;;;845                     (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;846                     (OS_ERR     *)p_err);
;;;847    }
00003e  b00a              ADD      sp,sp,#0x28
000040  bd10              POP      {r4,pc}
;;;848    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      OSIdleTaskCtr
                  |L10.72|
                          DCD      OSCfg_IdleTaskStkSize
                  |L10.76|
                          DCD      OSCfg_IdleTaskStkLimit
                  |L10.80|
                          DCD      OSCfg_IdleTaskStkBasePtr
                  |L10.84|
                          DCD      OS_IdleTask
                  |L10.88|
000058  75432f4f          DCB      "uC/OS-III Idle Task",0
00005c  532d4949
000060  49204964
000064  6c652054
000068  61736b00
                  |L10.108|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_Pend||, CODE, READONLY, ALIGN=2

                  OS_Pend PROC
;;;879    
;;;880    void  OS_Pend (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;881                   OS_PEND_OBJ   *p_obj,
;;;882                   OS_STATE       pending_on,
;;;883                   OS_TICK        timeout)
;;;884    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;885        OS_PEND_LIST  *p_pend_list;
;;;886    
;;;887    
;;;888    
;;;889        OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
00000c  4815              LDR      r0,|L11.100|
00000e  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000010  f8806034          STRB     r6,[r0,#0x34]
;;;890        OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
000014  2000              MOVS     r0,#0
000016  4913              LDR      r1,|L11.100|
000018  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00001a  f8810035          STRB     r0,[r1,#0x35]
;;;891    
;;;892        OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
00001e  4639              MOV      r1,r7
000020  4810              LDR      r0,|L11.100|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000024  f7fffffe          BL       OS_TaskBlock
;;;893                     timeout);
;;;894    
;;;895        if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
000028  b16c              CBZ      r4,|L11.70|
;;;896            p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
00002a  f1040808          ADD      r8,r4,#8
;;;897            p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
00002e  60ec              STR      r4,[r5,#0xc]
;;;898            OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
000030  2201              MOVS     r2,#1
000032  4629              MOV      r1,r5
000034  480b              LDR      r0,|L11.100|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000038  f7fffffe          BL       OS_PendDataInit
;;;899                            (OS_PEND_DATA *)p_pend_data,
;;;900                            (OS_OBJ_QTY    )1);
;;;901            OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
00003c  4629              MOV      r1,r5
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       OS_PendListInsertPrio
000044  e007              B        |L11.86|
                  |L11.70|
;;;902                                  p_pend_data);
;;;903        } else {
;;;904            OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
000046  2000              MOVS     r0,#0
000048  4906              LDR      r1,|L11.100|
00004a  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00004c  f8a10046          STRH     r0,[r1,#0x46]
;;;905            OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
000050  4904              LDR      r1,|L11.100|
000052  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000054  6308              STR      r0,[r1,#0x30]
                  |L11.86|
;;;906        }
;;;907    #if OS_CFG_DBG_EN > 0u
;;;908        OS_PendDbgNameAdd(p_obj,
000056  4803              LDR      r0,|L11.100|
000058  6801              LDR      r1,[r0,#0]  ; OSTCBCurPtr
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       OS_PendDbgNameAdd
;;;909                          OSTCBCurPtr);
;;;910    #endif
;;;911    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;912    
                          ENDP

                  |L11.100|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_PendAbort||, CODE, READONLY, ALIGN=1

                  OS_PendAbort PROC
;;;933    
;;;934    void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;935                        OS_TCB       *p_tcb,
;;;936                        CPU_TS        ts)
;;;937    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
;;;938        switch (p_tcb->TaskState) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  2808              CMP      r0,#8
00000e  d252              BCS      |L12.182|
000010  e8dff000          TBB      [pc,r0]
000014  04050809          DCB      0x04,0x05,0x08,0x09
000018  06072e2f          DCB      0x06,0x07,0x2e,0x2f
;;;939            case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
;;;940            case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
00001c  bf00              NOP      
;;;941            case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
00001e  bf00              NOP      
;;;942            case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
000020  bf00              NOP      
;;;943                 break;
000022  e049              B        |L12.184|
;;;944    
;;;945            case OS_TASK_STATE_PEND:
;;;946            case OS_TASK_STATE_PEND_TIMEOUT:
000024  bf00              NOP      
;;;947                 if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000026  f8940034          LDRB     r0,[r4,#0x34]
00002a  2803              CMP      r0,#3
00002c  d104              BNE      |L12.56|
;;;948                     OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
00002e  4632              MOV      r2,r6
000030  4621              MOV      r1,r4
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       OS_PendAbort1
                  |L12.56|
;;;949                                   p_tcb,
;;;950                                   ts);
;;;951                 }
;;;952    #if (OS_MSG_EN > 0u)
;;;953                 p_tcb->MsgPtr     = (void      *)0;
000038  2000              MOVS     r0,#0
00003a  65a0              STR      r0,[r4,#0x58]
;;;954                 p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
00003c  f8a4005c          STRH     r0,[r4,#0x5c]
;;;955    #endif
;;;956                 p_tcb->TS         = ts;
000040  64a6              STR      r6,[r4,#0x48]
;;;957                 if (p_obj != (OS_PEND_OBJ *)0) {
000042  b115              CBZ      r5,|L12.74|
;;;958                     OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       OS_PendListRemove
                  |L12.74|
;;;959                 }
;;;960                 if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
00004a  f8940036          LDRB     r0,[r4,#0x36]
00004e  2803              CMP      r0,#3
000050  d102              BNE      |L12.88|
;;;961                     OS_TickListRemove(p_tcb);                       /* Remove from tick list                             */
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       OS_TickListRemove
                  |L12.88|
;;;962                 }
;;;963                 OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                 */
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       OS_RdyListInsert
;;;964                 p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
00005e  2000              MOVS     r0,#0
000060  3434              ADDS     r4,r4,#0x34
000062  70a0              STRB     r0,[r4,#2]
;;;965                 p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
000064  2001              MOVS     r0,#1
000066  7060              STRB     r0,[r4,#1]
;;;966                 p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
000068  2000              MOVS     r0,#0
00006a  f8040934          STRB     r0,[r4],#-0x34
;;;967                 break;
00006e  e023              B        |L12.184|
;;;968    
;;;969            case OS_TASK_STATE_PEND_SUSPENDED:
;;;970            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000070  bf00              NOP      
;;;971                 if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000072  f8940034          LDRB     r0,[r4,#0x34]
000076  2803              CMP      r0,#3
000078  d104              BNE      |L12.132|
;;;972                     OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
00007a  4632              MOV      r2,r6
00007c  4621              MOV      r1,r4
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       OS_PendAbort1
                  |L12.132|
;;;973                                   p_tcb,
;;;974                                   ts);
;;;975                 }
;;;976    #if (OS_MSG_EN > 0u)
;;;977                 p_tcb->MsgPtr     = (void      *)0;
000084  2000              MOVS     r0,#0
000086  65a0              STR      r0,[r4,#0x58]
;;;978                 p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
000088  f8a4005c          STRH     r0,[r4,#0x5c]
;;;979    #endif
;;;980                 p_tcb->TS         = ts;
00008c  64a6              STR      r6,[r4,#0x48]
;;;981                 if (p_obj != (OS_PEND_OBJ *)0) {
00008e  b115              CBZ      r5,|L12.150|
;;;982                     OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       OS_PendListRemove
                  |L12.150|
;;;983                 }
;;;984                 if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
000096  f8940036          LDRB     r0,[r4,#0x36]
00009a  2807              CMP      r0,#7
00009c  d102              BNE      |L12.164|
;;;985                     OS_TickListRemove(p_tcb);                       /* Cancel the timeout                                */
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       OS_TickListRemove
                  |L12.164|
;;;986                 }
;;;987                 p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
0000a4  2004              MOVS     r0,#4
0000a6  3434              ADDS     r4,r4,#0x34
0000a8  70a0              STRB     r0,[r4,#2]
;;;988                 p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
0000aa  2001              MOVS     r0,#1
0000ac  7060              STRB     r0,[r4,#1]
;;;989                 p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
0000ae  2000              MOVS     r0,#0
0000b0  f8040934          STRB     r0,[r4],#-0x34
;;;990                 break;
0000b4  e000              B        |L12.184|
                  |L12.182|
;;;991    
;;;992            default:
;;;993                 break;
0000b6  bf00              NOP      
                  |L12.184|
0000b8  bf00              NOP                            ;943
;;;994        }
;;;995    }
0000ba  bd70              POP      {r4-r6,pc}
;;;996    
                          ENDP


                          AREA ||i.OS_PendAbort1||, CODE, READONLY, ALIGN=1

                  OS_PendAbort1 PROC
;;;1044   
;;;1045   void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1046                        OS_TCB       *p_tcb,
;;;1047                        CPU_TS        ts)
;;;1048   {
000002  4603              MOV      r3,r0
;;;1049       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1050       OS_PEND_DATA   *p_pend_data;
;;;1051   
;;;1052   
;;;1053   
;;;1054       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000004  6b08              LDR      r0,[r1,#0x30]
;;;1055       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000006  f8b14046          LDRH     r4,[r1,#0x46]
;;;1056   
;;;1057       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
00000a  e008              B        |L13.30|
                  |L13.12|
;;;1058           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
00000c  68c5              LDR      r5,[r0,#0xc]
00000e  429d              CMP      r5,r3
000010  d102              BNE      |L13.24|
;;;1059               p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
000012  6103              STR      r3,[r0,#0x10]
;;;1060               p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
000014  61c2              STR      r2,[r0,#0x1c]
;;;1061               break;
000016  e004              B        |L13.34|
                  |L13.24|
;;;1062           }
;;;1063           p_pend_data++;
000018  3020              ADDS     r0,r0,#0x20
;;;1064           n_pend_list--;
00001a  1e65              SUBS     r5,r4,#1
00001c  b2ac              UXTH     r4,r5
                  |L13.30|
00001e  2c00              CMP      r4,#0                 ;1057
000020  dcf4              BGT      |L13.12|
                  |L13.34|
000022  bf00              NOP                            ;1061
;;;1065       }
;;;1066   }
000024  bd30              POP      {r4,r5,pc}
;;;1067   
                          ENDP


                          AREA ||i.OS_PendDataInit||, CODE, READONLY, ALIGN=1

                  OS_PendDataInit PROC
;;;1109   
;;;1110   void  OS_PendDataInit (OS_TCB        *p_tcb,
000000  b510              PUSH     {r4,lr}
;;;1111                          OS_PEND_DATA  *p_pend_data_tbl,
;;;1112                          OS_OBJ_QTY     tbl_size)
;;;1113   {
;;;1114       OS_OBJ_QTY  i;
;;;1115   
;;;1116   
;;;1117   
;;;1118       p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
000002  f8a02046          STRH     r2,[r0,#0x46]
;;;1119       p_tcb->PendDataTblPtr     = p_pend_data_tbl;
000006  6301              STR      r1,[r0,#0x30]
;;;1120   
;;;1121       for (i = 0u; i < tbl_size; i++) {
000008  2300              MOVS     r3,#0
00000a  e00a              B        |L14.34|
                  |L14.12|
;;;1122           p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
00000c  2400              MOVS     r4,#0
00000e  604c              STR      r4,[r1,#4]
;;;1123           p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
000010  600c              STR      r4,[r1,#0]
;;;1124           p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
000012  610c              STR      r4,[r1,#0x10]
;;;1125           p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
000014  614c              STR      r4,[r1,#0x14]
;;;1126           p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
000016  830c              STRH     r4,[r1,#0x18]
;;;1127           p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
000018  61cc              STR      r4,[r1,#0x1c]
;;;1128           p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
00001a  6088              STR      r0,[r1,#8]
;;;1129           p_pend_data_tbl++;
00001c  3120              ADDS     r1,r1,#0x20
00001e  1c5c              ADDS     r4,r3,#1              ;1121
000020  b2a3              UXTH     r3,r4                 ;1121
                  |L14.34|
000022  4293              CMP      r3,r2                 ;1121
000024  dbf2              BLT      |L14.12|
;;;1130       }
;;;1131   }
000026  bd10              POP      {r4,pc}
;;;1132   
                          ENDP


                          AREA ||i.OS_PendDbgNameAdd||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameAdd PROC
;;;1152   #if OS_CFG_DBG_EN > 0u
;;;1153   void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1154                            OS_TCB       *p_tcb)
;;;1155   {
;;;1156       OS_PEND_LIST  *p_pend_list;
;;;1157       OS_PEND_DATA  *p_pend_data;
;;;1158       OS_TCB        *p_tcb1;
;;;1159   
;;;1160   
;;;1161       if (p_obj != (OS_PEND_OBJ *)0) {
000002  b148              CBZ      r0,|L15.24|
;;;1162           p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
000004  6845              LDR      r5,[r0,#4]
000006  f8c150bc          STR      r5,[r1,#0xbc]
;;;1163           p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
00000a  f1000408          ADD      r4,r0,#8
;;;1164           p_pend_data       =  p_pend_list->HeadPtr;
00000e  6822              LDR      r2,[r4,#0]
;;;1165           p_tcb1            =  p_pend_data->TCBPtr;
000010  6893              LDR      r3,[r2,#8]
;;;1166           p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
000012  6a1d              LDR      r5,[r3,#0x20]
000014  61c5              STR      r5,[r0,#0x1c]
000016  e013              B        |L15.64|
                  |L15.24|
;;;1167       } else {
;;;1168           switch (p_tcb->PendOn) {
000018  f8915034          LDRB     r5,[r1,#0x34]
00001c  2d02              CMP      r5,#2
00001e  d002              BEQ      |L15.38|
000020  2d07              CMP      r5,#7
000022  d108              BNE      |L15.54|
000024  e003              B        |L15.46|
                  |L15.38|
;;;1169               case OS_TASK_PEND_ON_TASK_Q:
;;;1170                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
000026  a507              ADR      r5,|L15.68|
000028  f8c150bc          STR      r5,[r1,#0xbc]
;;;1171                    break;
00002c  e007              B        |L15.62|
                  |L15.46|
;;;1172   
;;;1173               case OS_TASK_PEND_ON_TASK_SEM:
;;;1174                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
00002e  a507              ADR      r5,|L15.76|
000030  f8c150bc          STR      r5,[r1,#0xbc]
;;;1175                    break;
000034  e003              B        |L15.62|
                  |L15.54|
;;;1176   
;;;1177               default:
;;;1178                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
000036  a508              ADR      r5,|L15.88|
000038  f8c150bc          STR      r5,[r1,#0xbc]
;;;1179                    break;
00003c  bf00              NOP      
                  |L15.62|
00003e  bf00              NOP                            ;1171
                  |L15.64|
;;;1180           }
;;;1181       }
;;;1182   }
000040  bd30              POP      {r4,r5,pc}
;;;1183   
                          ENDP

000042  0000              DCW      0x0000
                  |L15.68|
000044  5461736b          DCB      "Task Q",0
000048  205100  
00004b  00                DCB      0
                  |L15.76|
00004c  5461736b          DCB      "Task Sem",0
000050  2053656d
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L15.88|
000058  2000              DCB      " ",0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.OS_PendDbgNameRemove||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameRemove PROC
;;;1185   
;;;1186   void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1187                               OS_TCB       *p_tcb)
;;;1188   {
;;;1189       OS_PEND_LIST  *p_pend_list;
;;;1190       OS_PEND_DATA  *p_pend_data;
;;;1191       OS_TCB        *p_tcb1;
;;;1192   
;;;1193   
;;;1194       p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
000002  a507              ADR      r5,|L16.32|
000004  f8c150bc          STR      r5,[r1,#0xbc]
;;;1195       p_pend_list       = &p_obj->PendList;
000008  f1000408          ADD      r4,r0,#8
;;;1196       p_pend_data       =  p_pend_list->HeadPtr;
00000c  6822              LDR      r2,[r4,#0]
;;;1197       if (p_pend_data  != (OS_PEND_DATA *)0) {
00000e  b11a              CBZ      r2,|L16.24|
;;;1198           p_tcb1            = p_pend_data->TCBPtr;
000010  6893              LDR      r3,[r2,#8]
;;;1199           p_obj->DbgNamePtr = p_tcb1->NamePtr;
000012  6a1d              LDR      r5,[r3,#0x20]
000014  61c5              STR      r5,[r0,#0x1c]
000016  e001              B        |L16.28|
                  |L16.24|
;;;1200       } else {
;;;1201           p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
000018  a501              ADR      r5,|L16.32|
00001a  61c5              STR      r5,[r0,#0x1c]
                  |L16.28|
;;;1202       }
;;;1203   }
00001c  bd30              POP      {r4,r5,pc}
;;;1204   #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L16.32|
000020  2000              DCB      " ",0
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.OS_PendListChangePrio||, CODE, READONLY, ALIGN=1

                  OS_PendListChangePrio PROC
;;;1285   
;;;1286   void  OS_PendListChangePrio (OS_TCB   *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1287   {
000004  4604              MOV      r4,r0
;;;1288       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1289       OS_PEND_DATA   *p_pend_data;
;;;1290       OS_PEND_LIST   *p_pend_list;
;;;1291       OS_PEND_OBJ    *p_obj;
;;;1292   
;;;1293   
;;;1294       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
000006  6b25              LDR      r5,[r4,#0x30]
;;;1295       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
000008  f8b47046          LDRH     r7,[r4,#0x46]
;;;1296   
;;;1297       while (n_pend_list > 0u) {
00000c  e011              B        |L17.50|
                  |L17.14|
;;;1298           p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
00000e  f8d5800c          LDR      r8,[r5,#0xc]
;;;1299           p_pend_list = &p_obj->PendList;
000012  f1080608          ADD      r6,r8,#8
;;;1300           if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
000016  8930              LDRH     r0,[r6,#8]
000018  2801              CMP      r0,#1
00001a  d907              BLS      |L17.44|
;;;1301               OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       OS_PendListRemove1
;;;1302                                  p_pend_data);
;;;1303               OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
000024  4629              MOV      r1,r5
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       OS_PendListInsertPrio
                  |L17.44|
;;;1304                                     p_pend_data);
;;;1305           }
;;;1306           p_pend_data++;                                              /* Point to next wait list                        */
00002c  3520              ADDS     r5,r5,#0x20
;;;1307           n_pend_list--;
00002e  1e78              SUBS     r0,r7,#1
000030  b287              UXTH     r7,r0
                  |L17.50|
000032  2f00              CMP      r7,#0                 ;1297
000034  d1eb              BNE      |L17.14|
;;;1308       }
;;;1309   }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;1310   
                          ENDP


                          AREA ||i.OS_PendListInit||, CODE, READONLY, ALIGN=1

                  OS_PendListInit PROC
;;;1326   
;;;1327   void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
000000  2100              MOVS     r1,#0
;;;1328   {
;;;1329       p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
000002  6001              STR      r1,[r0,#0]
;;;1330       p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
000004  6041              STR      r1,[r0,#4]
;;;1331       p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
000006  8101              STRH     r1,[r0,#8]
;;;1332   }
000008  4770              BX       lr
;;;1333   
                          ENDP


                          AREA ||i.OS_PendListInsertHead||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertHead PROC
;;;1380   
;;;1381   void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
000000  8903              LDRH     r3,[r0,#8]
;;;1382                                OS_PEND_DATA  *p_pend_data)
;;;1383   {
;;;1384       OS_PEND_DATA  *p_pend_data_next;
;;;1385   
;;;1386   
;;;1387   
;;;1388       p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
000002  1c5b              ADDS     r3,r3,#1
000004  8103              STRH     r3,[r0,#8]
;;;1389       p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
000006  6803              LDR      r3,[r0,#0]
000008  604b              STR      r3,[r1,#4]
;;;1390       p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
00000a  2300              MOVS     r3,#0
00000c  600b              STR      r3,[r1,#0]
;;;1391       p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
00000e  6802              LDR      r2,[r0,#0]
;;;1392       if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
000010  b102              CBZ      r2,|L19.20|
;;;1393           p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
000012  6011              STR      r1,[r2,#0]
                  |L19.20|
;;;1394       }
;;;1395       p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
000014  6001              STR      r1,[r0,#0]
;;;1396       if (p_pend_list->NbrEntries == 1u) {
000016  8903              LDRH     r3,[r0,#8]
000018  2b01              CMP      r3,#1
00001a  d100              BNE      |L19.30|
;;;1397           p_pend_list->TailPtr = p_pend_data;
00001c  6041              STR      r1,[r0,#4]
                  |L19.30|
;;;1398       }
;;;1399   }
00001e  4770              BX       lr
;;;1400   
                          ENDP


                          AREA ||i.OS_PendListInsertPrio||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertPrio PROC
;;;1468   
;;;1469   void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1470                                OS_PEND_DATA  *p_pend_data)
;;;1471   {
;;;1472       OS_PRIO        prio;
;;;1473       OS_TCB        *p_tcb;
;;;1474       OS_TCB        *p_tcb_next;
;;;1475       OS_PEND_DATA  *p_pend_data_prev;
;;;1476       OS_PEND_DATA  *p_pend_data_next;
;;;1477   
;;;1478   
;;;1479   
;;;1480       p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
000002  688e              LDR      r6,[r1,#8]
;;;1481       prio  = p_tcb->Prio;
000004  f8965037          LDRB     r5,[r6,#0x37]
;;;1482       if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
000008  8907              LDRH     r7,[r0,#8]
00000a  b93f              CBNZ     r7,|L20.28|
;;;1483           p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
00000c  2701              MOVS     r7,#1
00000e  8107              STRH     r7,[r0,#8]
;;;1484           p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
000010  2700              MOVS     r7,#0
000012  604f              STR      r7,[r1,#4]
;;;1485           p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
000014  600f              STR      r7,[r1,#0]
;;;1486           p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
000016  6001              STR      r1,[r0,#0]
;;;1487           p_pend_list->TailPtr    = p_pend_data;
000018  6041              STR      r1,[r0,#4]
00001a  e023              B        |L20.100|
                  |L20.28|
;;;1488       } else {
;;;1489           p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
00001c  8907              LDRH     r7,[r0,#8]
00001e  1c7f              ADDS     r7,r7,#1
000020  8107              STRH     r7,[r0,#8]
;;;1490           p_pend_data_next = p_pend_list->HeadPtr;
000022  6802              LDR      r2,[r0,#0]
;;;1491           while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
000024  e006              B        |L20.52|
                  |L20.38|
;;;1492               p_tcb_next   = p_pend_data_next->TCBPtr;
000026  6894              LDR      r4,[r2,#8]
;;;1493               if (prio < p_tcb_next->Prio) {
000028  f8947037          LDRB     r7,[r4,#0x37]
00002c  42af              CMP      r7,r5
00002e  dd00              BLE      |L20.50|
;;;1494                   break;                                                /*         Found! ... insert BEFORE current     */
000030  e002              B        |L20.56|
                  |L20.50|
;;;1495               } else {
;;;1496                   p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
000032  6852              LDR      r2,[r2,#4]
                  |L20.52|
000034  2a00              CMP      r2,#0                 ;1491
000036  d1f6              BNE      |L20.38|
                  |L20.56|
000038  bf00              NOP                            ;1494
;;;1497               }
;;;1498           }
;;;1499           if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
00003a  b932              CBNZ     r2,|L20.74|
;;;1500               p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
00003c  2700              MOVS     r7,#0
00003e  604f              STR      r7,[r1,#4]
;;;1501               p_pend_data_prev          = p_pend_list->TailPtr;
000040  6843              LDR      r3,[r0,#4]
;;;1502               p_pend_data->PrevPtr      = p_pend_data_prev;
000042  600b              STR      r3,[r1,#0]
;;;1503               p_pend_data_prev->NextPtr = p_pend_data;
000044  6059              STR      r1,[r3,#4]
;;;1504               p_pend_list->TailPtr      = p_pend_data;
000046  6041              STR      r1,[r0,#4]
000048  e00c              B        |L20.100|
                  |L20.74|
;;;1505           } else {
;;;1506               if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
00004a  6817              LDR      r7,[r2,#0]
00004c  b92f              CBNZ     r7,|L20.90|
;;;1507                   p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
00004e  6011              STR      r1,[r2,#0]
;;;1508                   p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
000050  2700              MOVS     r7,#0
000052  600f              STR      r7,[r1,#0]
;;;1509                   p_pend_data->NextPtr       = p_pend_data_next;
000054  604a              STR      r2,[r1,#4]
;;;1510                   p_pend_list->HeadPtr       = p_pend_data;
000056  6001              STR      r1,[r0,#0]
000058  e004              B        |L20.100|
                  |L20.90|
;;;1511               } else {
;;;1512                   p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
00005a  6813              LDR      r3,[r2,#0]
;;;1513                   p_pend_data->PrevPtr       = p_pend_data_prev;
00005c  600b              STR      r3,[r1,#0]
;;;1514                   p_pend_data->NextPtr       = p_pend_data_next;
00005e  604a              STR      r2,[r1,#4]
;;;1515                   p_pend_data_prev->NextPtr  = p_pend_data;
000060  6059              STR      r1,[r3,#4]
;;;1516                   p_pend_data_next->PrevPtr  = p_pend_data;
000062  6011              STR      r1,[r2,#0]
                  |L20.100|
;;;1517               }
;;;1518           }
;;;1519       }
;;;1520   }
000064  bdf0              POP      {r4-r7,pc}
;;;1521   
                          ENDP


                          AREA ||i.OS_PendListRemove||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove PROC
;;;1571   
;;;1572   void  OS_PendListRemove (OS_TCB  *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1573   {
000004  4604              MOV      r4,r0
;;;1574       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1575       OS_PEND_DATA   *p_pend_data;
;;;1576       OS_PEND_LIST   *p_pend_list;
;;;1577       OS_PEND_OBJ    *p_obj;
;;;1578   
;;;1579   
;;;1580   
;;;1581       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000006  6b25              LDR      r5,[r4,#0x30]
;;;1582       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000008  f8b46046          LDRH     r6,[r4,#0x46]
;;;1583   
;;;1584       while (n_pend_list > (OS_OBJ_QTY)0) {
00000c  e00a              B        |L21.36|
                  |L21.14|
;;;1585           p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
00000e  f8d5800c          LDR      r8,[r5,#0xc]
;;;1586           p_pend_list = &p_obj->PendList;
000012  f1080708          ADD      r7,r8,#8
;;;1587           OS_PendListRemove1(p_pend_list,
000016  4629              MOV      r1,r5
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       OS_PendListRemove1
;;;1588                              p_pend_data);
;;;1589           p_pend_data++;
00001e  3520              ADDS     r5,r5,#0x20
;;;1590           n_pend_list--;
000020  1e70              SUBS     r0,r6,#1
000022  b286              UXTH     r6,r0
                  |L21.36|
000024  2e00              CMP      r6,#0                 ;1584
000026  dcf2              BGT      |L21.14|
;;;1591       }
;;;1592       p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
000028  2000              MOVS     r0,#0
00002a  f8a40046          STRH     r0,[r4,#0x46]
;;;1593       p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
00002e  6320              STR      r0,[r4,#0x30]
;;;1594   }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;1595   
                          ENDP


                          AREA ||i.OS_PendListRemove1||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove1 PROC
;;;1646   
;;;1647   void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
000000  b510              PUSH     {r4,lr}
;;;1648                             OS_PEND_DATA  *p_pend_data)
;;;1649   {
;;;1650       OS_PEND_DATA  *p_prev;
;;;1651       OS_PEND_DATA  *p_next;
;;;1652   
;;;1653   
;;;1654   
;;;1655       if (p_pend_list->NbrEntries == 1u) {
000002  8904              LDRH     r4,[r0,#8]
000004  2c01              CMP      r4,#1
000006  d103              BNE      |L22.16|
;;;1656           p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
000008  2400              MOVS     r4,#0
00000a  6004              STR      r4,[r0,#0]
;;;1657           p_pend_list->TailPtr = (OS_PEND_DATA *)0;
00000c  6044              STR      r4,[r0,#4]
00000e  e011              B        |L22.52|
                  |L22.16|
;;;1658   
;;;1659       } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
000010  680c              LDR      r4,[r1,#0]
000012  b924              CBNZ     r4,|L22.30|
;;;1660           p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
000014  684a              LDR      r2,[r1,#4]
;;;1661           p_next->PrevPtr      = (OS_PEND_DATA *)0;
000016  2400              MOVS     r4,#0
000018  6014              STR      r4,[r2,#0]
;;;1662           p_pend_list->HeadPtr = p_next;
00001a  6002              STR      r2,[r0,#0]
00001c  e00a              B        |L22.52|
                  |L22.30|
;;;1663   
;;;1664       } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
00001e  684c              LDR      r4,[r1,#4]
000020  b924              CBNZ     r4,|L22.44|
;;;1665           p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
000022  680b              LDR      r3,[r1,#0]
;;;1666           p_prev->NextPtr      = (OS_PEND_DATA *)0;
000024  2400              MOVS     r4,#0
000026  605c              STR      r4,[r3,#4]
;;;1667           p_pend_list->TailPtr = p_prev;
000028  6043              STR      r3,[r0,#4]
00002a  e003              B        |L22.52|
                  |L22.44|
;;;1668   
;;;1669       } else {
;;;1670           p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
00002c  680b              LDR      r3,[r1,#0]
;;;1671           p_next               = p_pend_data->NextPtr;
00002e  684a              LDR      r2,[r1,#4]
;;;1672           p_prev->NextPtr      = p_next;
000030  605a              STR      r2,[r3,#4]
;;;1673           p_next->PrevPtr      = p_prev;
000032  6013              STR      r3,[r2,#0]
                  |L22.52|
;;;1674       }
;;;1675       p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
000034  8904              LDRH     r4,[r0,#8]
000036  1e64              SUBS     r4,r4,#1
000038  8104              STRH     r4,[r0,#8]
;;;1676       p_pend_data->NextPtr = (OS_PEND_DATA *)0;
00003a  2400              MOVS     r4,#0
00003c  604c              STR      r4,[r1,#4]
;;;1677       p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
00003e  600c              STR      r4,[r1,#0]
;;;1678   }
000040  bd10              POP      {r4,pc}
;;;1679   
                          ENDP


                          AREA ||i.OS_PendObjDel||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel PROC
;;;1700   
;;;1701   void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;1702                        OS_TCB       *p_tcb,
;;;1703                        CPU_TS        ts)
;;;1704   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1705       switch (p_tcb->TaskState) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  2808              CMP      r0,#8
00000e  d250              BCS      |L23.178|
000010  e8dff000          TBB      [pc,r0]
000014  04050809          DCB      0x04,0x05,0x08,0x09
000018  06072d2e          DCB      0x06,0x07,0x2d,0x2e
;;;1706           case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
;;;1707           case OS_TASK_STATE_DLY:
00001c  bf00              NOP      
;;;1708           case OS_TASK_STATE_SUSPENDED:
00001e  bf00              NOP      
;;;1709           case OS_TASK_STATE_DLY_SUSPENDED:
000020  bf00              NOP      
;;;1710                break;
000022  e047              B        |L23.180|
;;;1711   
;;;1712           case OS_TASK_STATE_PEND:
;;;1713           case OS_TASK_STATE_PEND_TIMEOUT:
000024  bf00              NOP      
;;;1714                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000026  f8940034          LDRB     r0,[r4,#0x34]
00002a  2803              CMP      r0,#3
00002c  d104              BNE      |L23.56|
;;;1715                    OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
00002e  462a              MOV      r2,r5
000030  4621              MOV      r1,r4
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       OS_PendObjDel1
                  |L23.56|
;;;1716                                   p_tcb,
;;;1717                                   ts);
;;;1718                }
;;;1719   #if (OS_MSG_EN > 0u)
;;;1720                p_tcb->MsgPtr     = (void *)0;
000038  2000              MOVS     r0,#0
00003a  65a0              STR      r0,[r4,#0x58]
;;;1721                p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
00003c  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1722   #endif
;;;1723                p_tcb->TS         = ts;
000040  64a5              STR      r5,[r4,#0x48]
;;;1724                OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       OS_PendListRemove
;;;1725                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
000048  f8940036          LDRB     r0,[r4,#0x36]
00004c  2803              CMP      r0,#3
00004e  d102              BNE      |L23.86|
;;;1726                    OS_TickListRemove(p_tcb);                       /* Remove from tick list                             */
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       OS_TickListRemove
                  |L23.86|
;;;1727                }
;;;1728                OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                 */
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       OS_RdyListInsert
;;;1729                p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
00005c  2000              MOVS     r0,#0
00005e  3434              ADDS     r4,r4,#0x34
000060  70a0              STRB     r0,[r4,#2]
;;;1730                p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
000062  2002              MOVS     r0,#2
000064  7060              STRB     r0,[r4,#1]
;;;1731                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
000066  2000              MOVS     r0,#0
000068  f8040934          STRB     r0,[r4],#-0x34
;;;1732                break;
00006c  e022              B        |L23.180|
;;;1733   
;;;1734           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1735           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00006e  bf00              NOP      
;;;1736                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000070  f8940034          LDRB     r0,[r4,#0x34]
000074  2803              CMP      r0,#3
000076  d104              BNE      |L23.130|
;;;1737                    OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
000078  462a              MOV      r2,r5
00007a  4621              MOV      r1,r4
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       OS_PendObjDel1
                  |L23.130|
;;;1738                                   p_tcb,
;;;1739                                   ts);
;;;1740                }
;;;1741   #if (OS_MSG_EN > 0u)
;;;1742                p_tcb->MsgPtr     = (void      *)0;
000082  2000              MOVS     r0,#0
000084  65a0              STR      r0,[r4,#0x58]
;;;1743                p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
000086  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1744   #endif
;;;1745                p_tcb->TS         = ts;
00008a  64a5              STR      r5,[r4,#0x48]
;;;1746                OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       OS_PendListRemove
;;;1747                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
000092  f8940036          LDRB     r0,[r4,#0x36]
000096  2807              CMP      r0,#7
000098  d102              BNE      |L23.160|
;;;1748                    OS_TickListRemove(p_tcb);                       /* Cancel the timeout                                */
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       OS_TickListRemove
                  |L23.160|
;;;1749                }
;;;1750                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
0000a0  2004              MOVS     r0,#4
0000a2  3434              ADDS     r4,r4,#0x34
0000a4  70a0              STRB     r0,[r4,#2]
;;;1751                p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
0000a6  2002              MOVS     r0,#2
0000a8  7060              STRB     r0,[r4,#1]
;;;1752                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
0000aa  2000              MOVS     r0,#0
0000ac  f8040934          STRB     r0,[r4],#-0x34
;;;1753                break;
0000b0  e000              B        |L23.180|
                  |L23.178|
;;;1754   
;;;1755           default:
;;;1756                break;
0000b2  bf00              NOP      
                  |L23.180|
0000b4  bf00              NOP                            ;1710
;;;1757       }
;;;1758   }
0000b6  bd70              POP      {r4-r6,pc}
;;;1759   
                          ENDP


                          AREA ||i.OS_PendObjDel1||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel1 PROC
;;;1807   
;;;1808   void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
000000  b530              PUSH     {r4,r5,lr}
;;;1809                         OS_TCB       *p_tcb,
;;;1810                         CPU_TS        ts)
;;;1811   {
000002  4603              MOV      r3,r0
;;;1812       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1813       OS_PEND_DATA   *p_pend_data;
;;;1814   
;;;1815   
;;;1816   
;;;1817       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000004  6b08              LDR      r0,[r1,#0x30]
;;;1818       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000006  f8b14046          LDRH     r4,[r1,#0x46]
;;;1819   
;;;1820       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
00000a  e008              B        |L24.30|
                  |L24.12|
;;;1821           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
00000c  68c5              LDR      r5,[r0,#0xc]
00000e  429d              CMP      r5,r3
000010  d102              BNE      |L24.24|
;;;1822               p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
000012  6103              STR      r3,[r0,#0x10]
;;;1823               p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
000014  61c2              STR      r2,[r0,#0x1c]
;;;1824               break;
000016  e004              B        |L24.34|
                  |L24.24|
;;;1825           }
;;;1826           p_pend_data++;
000018  3020              ADDS     r0,r0,#0x20
;;;1827           n_pend_list--;
00001a  1e65              SUBS     r5,r4,#1
00001c  b2ac              UXTH     r4,r5
                  |L24.30|
00001e  2c00              CMP      r4,#0                 ;1820
000020  dcf4              BGT      |L24.12|
                  |L24.34|
000022  bf00              NOP                            ;1824
;;;1828       }
;;;1829   }
000024  bd30              POP      {r4,r5,pc}
;;;1830   
                          ENDP


                          AREA ||i.OS_Post||, CODE, READONLY, ALIGN=1

                  OS_Post PROC
;;;1856   
;;;1857   void  OS_Post (OS_PEND_OBJ  *p_obj,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1858                  OS_TCB       *p_tcb,
;;;1859                  void         *p_void,
;;;1860                  OS_MSG_SIZE   msg_size,
;;;1861                  CPU_TS        ts)
;;;1862   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;1863       switch (p_tcb->TaskState) {
00000e  f8940036          LDRB     r0,[r4,#0x36]
000012  2808              CMP      r0,#8
000014  d25b              BCS      |L25.206|
000016  e8dff000          TBB      [pc,r0]
00001a  0405              DCB      0x04,0x05
00001c  08090607          DCB      0x08,0x09,0x06,0x07
000020  3233              DCB      0x32,0x33
;;;1864           case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
;;;1865           case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
000022  bf00              NOP      
;;;1866           case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
000024  bf00              NOP      
;;;1867           case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
000026  bf00              NOP      
;;;1868                break;
000028  e052              B        |L25.208|
;;;1869   
;;;1870           case OS_TASK_STATE_PEND:
;;;1871           case OS_TASK_STATE_PEND_TIMEOUT:
00002a  bf00              NOP      
;;;1872                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
00002c  f8940034          LDRB     r0,[r4,#0x34]
000030  2803              CMP      r0,#3
000032  d107              BNE      |L25.68|
;;;1873                    OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
000034  4643              MOV      r3,r8
000036  463a              MOV      r2,r7
000038  4621              MOV      r1,r4
00003a  4630              MOV      r0,r6
00003c  9500              STR      r5,[sp,#0]
00003e  f7fffffe          BL       OS_Post1
000042  e003              B        |L25.76|
                  |L25.68|
;;;1874                             p_tcb,
;;;1875                             p_void,
;;;1876                             msg_size,
;;;1877                             ts);
;;;1878                } else {
;;;1879   #if (OS_MSG_EN > 0u)
;;;1880                    p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
000044  65a7              STR      r7,[r4,#0x58]
;;;1881                    p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
000046  f8a4805c          STRH     r8,[r4,#0x5c]
;;;1882   #endif
;;;1883                    p_tcb->TS      = ts;
00004a  64a5              STR      r5,[r4,#0x48]
                  |L25.76|
;;;1884                }
;;;1885                if (p_obj != (OS_PEND_OBJ *)0) {
00004c  b136              CBZ      r6,|L25.92|
;;;1886                    OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       OS_PendListRemove
;;;1887   #if OS_CFG_DBG_EN > 0u
;;;1888                    OS_PendDbgNameRemove(p_obj,
000054  4621              MOV      r1,r4
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       OS_PendDbgNameRemove
                  |L25.92|
;;;1889                                         p_tcb);
;;;1890   #endif
;;;1891                }
;;;1892                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
00005c  f8940036          LDRB     r0,[r4,#0x36]
000060  2803              CMP      r0,#3
000062  d102              BNE      |L25.106|
;;;1893                    OS_TickListRemove(p_tcb);                       /* Remove from tick list                             */
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       OS_TickListRemove
                  |L25.106|
;;;1894                }
;;;1895                OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                 */
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       OS_RdyListInsert
;;;1896                p_tcb->TaskState  = OS_TASK_STATE_RDY;
000070  2000              MOVS     r0,#0
000072  3434              ADDS     r4,r4,#0x34
000074  70a0              STRB     r0,[r4,#2]
;;;1897                p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
000076  7060              STRB     r0,[r4,#1]
;;;1898                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
000078  f8040934          STRB     r0,[r4],#-0x34
;;;1899                break;
00007c  e028              B        |L25.208|
;;;1900   
;;;1901           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1902           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00007e  bf00              NOP      
;;;1903                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000080  f8940034          LDRB     r0,[r4,#0x34]
000084  2803              CMP      r0,#3
000086  d107              BNE      |L25.152|
;;;1904                    OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
000088  4643              MOV      r3,r8
00008a  463a              MOV      r2,r7
00008c  4621              MOV      r1,r4
00008e  4630              MOV      r0,r6
000090  9500              STR      r5,[sp,#0]
000092  f7fffffe          BL       OS_Post1
000096  e003              B        |L25.160|
                  |L25.152|
;;;1905                             p_tcb,
;;;1906                             p_void,
;;;1907                             msg_size,
;;;1908                             ts);
;;;1909                } else {
;;;1910   #if (OS_MSG_EN > 0u)
;;;1911                    p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
000098  65a7              STR      r7,[r4,#0x58]
;;;1912                    p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
00009a  f8a4805c          STRH     r8,[r4,#0x5c]
;;;1913   #endif
;;;1914                    p_tcb->TS      = ts;
00009e  64a5              STR      r5,[r4,#0x48]
                  |L25.160|
;;;1915                }
;;;1916                if (p_obj != (OS_PEND_OBJ *)0) {
0000a0  b136              CBZ      r6,|L25.176|
;;;1917                    OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       OS_PendListRemove
;;;1918   #if OS_CFG_DBG_EN > 0u
;;;1919                    OS_PendDbgNameRemove(p_obj,
0000a8  4621              MOV      r1,r4
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       OS_PendDbgNameRemove
                  |L25.176|
;;;1920                                         p_tcb);
;;;1921   #endif
;;;1922                }
;;;1923                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
0000b0  f8940036          LDRB     r0,[r4,#0x36]
0000b4  2807              CMP      r0,#7
0000b6  d102              BNE      |L25.190|
;;;1924                    OS_TickListRemove(p_tcb);                       /* Cancel any timeout                                */
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       OS_TickListRemove
                  |L25.190|
;;;1925                }
;;;1926                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
0000be  2004              MOVS     r0,#4
0000c0  3434              ADDS     r4,r4,#0x34
0000c2  70a0              STRB     r0,[r4,#2]
;;;1927                p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
0000c4  2000              MOVS     r0,#0
0000c6  7060              STRB     r0,[r4,#1]
;;;1928                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
0000c8  f8040934          STRB     r0,[r4],#-0x34
;;;1929                break;
0000cc  e000              B        |L25.208|
                  |L25.206|
;;;1930   
;;;1931           default:
;;;1932                break;
0000ce  bf00              NOP      
                  |L25.208|
0000d0  bf00              NOP                            ;1868
;;;1933       }
;;;1934   }
0000d2  e8bd83f8          POP      {r3-r9,pc}
;;;1935   
                          ENDP


                          AREA ||i.OS_Post1||, CODE, READONLY, ALIGN=1

                  OS_Post1 PROC
;;;1987   
;;;1988   void  OS_Post1 (OS_PEND_OBJ  *p_obj,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1989                   OS_TCB       *p_tcb,
;;;1990                   void         *p_void,
;;;1991                   OS_MSG_SIZE   msg_size,
;;;1992                   CPU_TS        ts)
;;;1993   {
000002  4604              MOV      r4,r0
000004  9e05              LDR      r6,[sp,#0x14]
;;;1994       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1995       OS_PEND_DATA   *p_pend_data;
;;;1996   
;;;1997   
;;;1998   
;;;1999       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
000006  6b08              LDR      r0,[r1,#0x30]
;;;2000       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000008  f8b15046          LDRH     r5,[r1,#0x46]
;;;2001   
;;;2002       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
00000c  e00a              B        |L26.36|
                  |L26.14|
;;;2003           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
00000e  68c7              LDR      r7,[r0,#0xc]
000010  42a7              CMP      r7,r4
000012  d104              BNE      |L26.30|
;;;2004               p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
000014  6104              STR      r4,[r0,#0x10]
;;;2005               p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
000016  6142              STR      r2,[r0,#0x14]
;;;2006               p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
000018  8303              STRH     r3,[r0,#0x18]
;;;2007               p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
00001a  61c6              STR      r6,[r0,#0x1c]
;;;2008               break;
00001c  e004              B        |L26.40|
                  |L26.30|
;;;2009           }
;;;2010           p_pend_data++;
00001e  3020              ADDS     r0,r0,#0x20
;;;2011           n_pend_list--;
000020  1e6f              SUBS     r7,r5,#1
000022  b2bd              UXTH     r5,r7
                  |L26.36|
000024  2d00              CMP      r5,#0                 ;2002
000026  dcf2              BGT      |L26.14|
                  |L26.40|
000028  bf00              NOP                            ;2008
;;;2012       }
;;;2013   }
00002a  bdf0              POP      {r4-r7,pc}
;;;2014   
                          ENDP


                          AREA ||i.OS_RdyListInit||, CODE, READONLY, ALIGN=2

                  OS_RdyListInit PROC
;;;2057   
;;;2058   void  OS_RdyListInit (void)
000000  2100              MOVS     r1,#0
;;;2059   {
;;;2060       OS_PRIO       i;
;;;2061       OS_RDY_LIST  *p_rdy_list;
;;;2062   
;;;2063   
;;;2064   
;;;2065       for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
000002  e00a              B        |L27.26|
                  |L27.4|
;;;2066           p_rdy_list = &OSRdyList[i];
000004  eb010241          ADD      r2,r1,r1,LSL #1
000008  4b05              LDR      r3,|L27.32|
00000a  eb030082          ADD      r0,r3,r2,LSL #2
;;;2067           p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
00000e  2200              MOVS     r2,#0
000010  8102              STRH     r2,[r0,#8]
;;;2068           p_rdy_list->HeadPtr    = (OS_TCB   *)0;
000012  6002              STR      r2,[r0,#0]
;;;2069           p_rdy_list->TailPtr    = (OS_TCB   *)0;
000014  6042              STR      r2,[r0,#4]
000016  1c4a              ADDS     r2,r1,#1              ;2065
000018  b2d1              UXTB     r1,r2                 ;2065
                  |L27.26|
00001a  2940              CMP      r1,#0x40              ;2065
00001c  d3f2              BCC      |L27.4|
;;;2070       }
;;;2071   }
00001e  4770              BX       lr
;;;2072   
                          ENDP

                  |L27.32|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsert||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsert PROC
;;;2091   
;;;2092   void  OS_RdyListInsert (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2093   {
000002  4604              MOV      r4,r0
;;;2094       OS_PrioInsert(p_tcb->Prio);
000004  f8940037          LDRB     r0,[r4,#0x37]
000008  f7fffffe          BL       OS_PrioInsert
;;;2095       if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
00000c  f8940037          LDRB     r0,[r4,#0x37]
000010  4905              LDR      r1,|L28.40|
000012  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000014  4288              CMP      r0,r1
000016  d103              BNE      |L28.32|
;;;2096           OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       OS_RdyListInsertTail
00001e  e002              B        |L28.38|
                  |L28.32|
;;;2097       } else {
;;;2098           OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       OS_RdyListInsertHead
                  |L28.38|
;;;2099       }
;;;2100   
;;;2101   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;2102           TRACE_OS_TASK_READY(p_tcb);                         /* Record the event.                                      */
;;;2103   #endif
;;;2104   }
000026  bd10              POP      {r4,pc}
;;;2105   
                          ENDP

                  |L28.40|
                          DCD      OSPrioCur

                          AREA ||i.OS_RdyListInsertHead||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertHead PROC
;;;2162   
;;;2163   void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2164   {
;;;2165       OS_RDY_LIST  *p_rdy_list;
;;;2166       OS_TCB       *p_tcb2;
;;;2167   
;;;2168   
;;;2169   
;;;2170       p_rdy_list = &OSRdyList[p_tcb->Prio];
000002  f8903037          LDRB     r3,[r0,#0x37]
000006  eb030343          ADD      r3,r3,r3,LSL #1
00000a  4c0c              LDR      r4,|L29.60|
00000c  eb040183          ADD      r1,r4,r3,LSL #2
;;;2171       if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
000010  890b              LDRH     r3,[r1,#8]
000012  b93b              CBNZ     r3,|L29.36|
;;;2172           p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
000014  2301              MOVS     r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2173           p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
000018  2300              MOVS     r3,#0
00001a  60c3              STR      r3,[r0,#0xc]
;;;2174           p_tcb->PrevPtr         =  (OS_TCB   *)0;
00001c  6103              STR      r3,[r0,#0x10]
;;;2175           p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
00001e  6008              STR      r0,[r1,#0]
;;;2176           p_rdy_list->TailPtr    =  p_tcb;
000020  6048              STR      r0,[r1,#4]
000022  e009              B        |L29.56|
                  |L29.36|
;;;2177       } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
;;;2178           p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
000024  890b              LDRH     r3,[r1,#8]
000026  1c5b              ADDS     r3,r3,#1
000028  810b              STRH     r3,[r1,#8]
;;;2179           p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
00002a  680b              LDR      r3,[r1,#0]
00002c  60c3              STR      r3,[r0,#0xc]
;;;2180           p_tcb->PrevPtr         = (OS_TCB    *)0;
00002e  2300              MOVS     r3,#0
000030  6103              STR      r3,[r0,#0x10]
;;;2181           p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
000032  680a              LDR      r2,[r1,#0]
;;;2182           p_tcb2->PrevPtr        = p_tcb;
000034  6110              STR      r0,[r2,#0x10]
;;;2183           p_rdy_list->HeadPtr    = p_tcb;
000036  6008              STR      r0,[r1,#0]
                  |L29.56|
;;;2184       }
;;;2185   }
000038  bd10              POP      {r4,pc}
;;;2186   
                          ENDP

00003a  0000              DCW      0x0000
                  |L29.60|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsertTail||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertTail PROC
;;;2243   
;;;2244   void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2245   {
;;;2246       OS_RDY_LIST  *p_rdy_list;
;;;2247       OS_TCB       *p_tcb2;
;;;2248   
;;;2249   
;;;2250   
;;;2251       p_rdy_list = &OSRdyList[p_tcb->Prio];
000002  f8903037          LDRB     r3,[r0,#0x37]
000006  eb030343          ADD      r3,r3,r3,LSL #1
00000a  4c0b              LDR      r4,|L30.56|
00000c  eb040183          ADD      r1,r4,r3,LSL #2
;;;2252       if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
000010  890b              LDRH     r3,[r1,#8]
000012  b93b              CBNZ     r3,|L30.36|
;;;2253           p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
000014  2301              MOVS     r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2254           p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
000018  2300              MOVS     r3,#0
00001a  60c3              STR      r3,[r0,#0xc]
;;;2255           p_tcb->PrevPtr          = (OS_TCB   *)0;
00001c  6103              STR      r3,[r0,#0x10]
;;;2256           p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
00001e  6008              STR      r0,[r1,#0]
;;;2257           p_rdy_list->TailPtr     = p_tcb;
000020  6048              STR      r0,[r1,#4]
000022  e008              B        |L30.54|
                  |L30.36|
;;;2258       } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
;;;2259           p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
000024  890b              LDRH     r3,[r1,#8]
000026  1c5b              ADDS     r3,r3,#1
000028  810b              STRH     r3,[r1,#8]
;;;2260           p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
00002a  2300              MOVS     r3,#0
00002c  60c3              STR      r3,[r0,#0xc]
;;;2261           p_tcb2                  = p_rdy_list->TailPtr;
00002e  684a              LDR      r2,[r1,#4]
;;;2262           p_tcb->PrevPtr          = p_tcb2;
000030  6102              STR      r2,[r0,#0x10]
;;;2263           p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
000032  60d0              STR      r0,[r2,#0xc]
;;;2264           p_rdy_list->TailPtr     = p_tcb;
000034  6048              STR      r0,[r1,#4]
                  |L30.54|
;;;2265       }
;;;2266   }
000036  bd10              POP      {r4,pc}
;;;2267   
                          ENDP

                  |L30.56|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListMoveHeadToTail||, CODE, READONLY, ALIGN=1

                  OS_RdyListMoveHeadToTail PROC
;;;2320   
;;;2321   void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
000000  b510              PUSH     {r4,lr}
;;;2322   {
000002  4601              MOV      r1,r0
;;;2323       OS_TCB  *p_tcb1;
;;;2324       OS_TCB  *p_tcb2;
;;;2325       OS_TCB  *p_tcb3;
;;;2326   
;;;2327   
;;;2328   
;;;2329       switch (p_rdy_list->NbrEntries) {
000004  890c              LDRH     r4,[r1,#8]
000006  b124              CBZ      r4,|L31.18|
000008  2c01              CMP      r4,#1
00000a  d003              BEQ      |L31.20|
00000c  2c02              CMP      r4,#2
00000e  d10c              BNE      |L31.42|
000010  e001              B        |L31.22|
                  |L31.18|
;;;2330           case 0:
;;;2331           case 1:
000012  bf00              NOP      
                  |L31.20|
;;;2332                break;
000014  e014              B        |L31.64|
                  |L31.22|
;;;2333   
;;;2334           case 2:                                             /* SWAP the TCBs                                          */
;;;2335                p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
000016  6808              LDR      r0,[r1,#0]
;;;2336                p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
000018  684a              LDR      r2,[r1,#4]
;;;2337                p_tcb1->PrevPtr     = p_tcb2;
00001a  6102              STR      r2,[r0,#0x10]
;;;2338                p_tcb1->NextPtr     = (OS_TCB *)0;
00001c  2400              MOVS     r4,#0
00001e  60c4              STR      r4,[r0,#0xc]
;;;2339                p_tcb2->PrevPtr     = (OS_TCB *)0;
000020  6114              STR      r4,[r2,#0x10]
;;;2340                p_tcb2->NextPtr     = p_tcb1;
000022  60d0              STR      r0,[r2,#0xc]
;;;2341                p_rdy_list->HeadPtr = p_tcb2;
000024  600a              STR      r2,[r1,#0]
;;;2342                p_rdy_list->TailPtr = p_tcb1;
000026  6048              STR      r0,[r1,#4]
;;;2343                break;
000028  e00a              B        |L31.64|
                  |L31.42|
;;;2344   
;;;2345           default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
;;;2346                p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
00002a  6808              LDR      r0,[r1,#0]
;;;2347                p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
00002c  684a              LDR      r2,[r1,#4]
;;;2348                p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
00002e  68c3              LDR      r3,[r0,#0xc]
;;;2349                p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
000030  2400              MOVS     r4,#0
000032  611c              STR      r4,[r3,#0x10]
;;;2350                p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
000034  60c4              STR      r4,[r0,#0xc]
;;;2351                p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
000036  6102              STR      r2,[r0,#0x10]
;;;2352                p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
000038  60d0              STR      r0,[r2,#0xc]
;;;2353                p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
00003a  600b              STR      r3,[r1,#0]
;;;2354                p_rdy_list->TailPtr = p_tcb1;
00003c  6048              STR      r0,[r1,#4]
;;;2355                break;
00003e  bf00              NOP      
                  |L31.64|
000040  bf00              NOP                            ;2332
;;;2356       }
;;;2357   }
000042  bd10              POP      {r4,pc}
;;;2358   
                          ENDP


                          AREA ||i.OS_RdyListRemove||, CODE, READONLY, ALIGN=2

                  OS_RdyListRemove PROC
;;;2407   
;;;2408   void  OS_RdyListRemove (OS_TCB  *p_tcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2409   {
000004  4605              MOV      r5,r0
;;;2410       OS_RDY_LIST  *p_rdy_list;
;;;2411       OS_TCB       *p_tcb1;
;;;2412       OS_TCB       *p_tcb2;
;;;2413   
;;;2414   
;;;2415   
;;;2416       p_rdy_list = &OSRdyList[p_tcb->Prio];
000006  f8950037          LDRB     r0,[r5,#0x37]
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  4912              LDR      r1,|L32.88|
000010  eb010480          ADD      r4,r1,r0,LSL #2
;;;2417       p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
000014  692f              LDR      r7,[r5,#0x10]
;;;2418       p_tcb2     = p_tcb->NextPtr;
000016  68ee              LDR      r6,[r5,#0xc]
;;;2419       if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
000018  b987              CBNZ     r7,|L32.60|
;;;2420           if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
00001a  b946              CBNZ     r6,|L32.46|
;;;2421               p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
00001c  2000              MOVS     r0,#0
00001e  8120              STRH     r0,[r4,#8]
;;;2422               p_rdy_list->HeadPtr    = (OS_TCB   *)0;
000020  6020              STR      r0,[r4,#0]
;;;2423               p_rdy_list->TailPtr    = (OS_TCB   *)0;
000022  6060              STR      r0,[r4,#4]
;;;2424               OS_PrioRemove(p_tcb->Prio);
000024  f8950037          LDRB     r0,[r5,#0x37]
000028  f7fffffe          BL       OS_PrioRemove
00002c  e00e              B        |L32.76|
                  |L32.46|
;;;2425           } else {
;;;2426               p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
00002e  8920              LDRH     r0,[r4,#8]
000030  1e40              SUBS     r0,r0,#1
000032  8120              STRH     r0,[r4,#8]
;;;2427               p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
000034  2000              MOVS     r0,#0
000036  6130              STR      r0,[r6,#0x10]
;;;2428               p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
000038  6026              STR      r6,[r4,#0]
00003a  e007              B        |L32.76|
                  |L32.60|
;;;2429           }
;;;2430       } else {
;;;2431           p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
00003c  8920              LDRH     r0,[r4,#8]
00003e  1e40              SUBS     r0,r0,#1
000040  8120              STRH     r0,[r4,#8]
;;;2432           p_tcb1->NextPtr = p_tcb2;
000042  60fe              STR      r6,[r7,#0xc]
;;;2433           if (p_tcb2 == (OS_TCB *)0) {
000044  b90e              CBNZ     r6,|L32.74|
;;;2434               p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
000046  6067              STR      r7,[r4,#4]
000048  e000              B        |L32.76|
                  |L32.74|
;;;2435           } else {
;;;2436               p_tcb2->PrevPtr     = p_tcb1;
00004a  6137              STR      r7,[r6,#0x10]
                  |L32.76|
;;;2437           }
;;;2438       }
;;;2439       p_tcb->PrevPtr = (OS_TCB *)0;
00004c  2000              MOVS     r0,#0
00004e  6128              STR      r0,[r5,#0x10]
;;;2440       p_tcb->NextPtr = (OS_TCB *)0;
000050  60e8              STR      r0,[r5,#0xc]
;;;2441   
;;;2442   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;2443       TRACE_OS_TASK_SUSPEND(p_tcb);                           /* Record the event.                                      */
;;;2444   #endif
;;;2445   }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;2446   
                          ENDP

000056  0000              DCW      0x0000
                  |L32.88|
                          DCD      OSRdyList

                          AREA ||i.OS_TaskBlock||, CODE, READONLY, ALIGN=2

                  OS_TaskBlock PROC
;;;2623   
;;;2624   void  OS_TaskBlock (OS_TCB   *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2625                       OS_TICK   timeout)
;;;2626   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2627       if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
000006  b145              CBZ      r5,|L33.26|
;;;2628           OS_TickListInsert(&OSTickListTimeout, p_tcb, timeout);
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  4806              LDR      r0,|L33.40|
00000e  f7fffffe          BL       OS_TickListInsert
;;;2629           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
000012  2003              MOVS     r0,#3
000014  f8840036          STRB     r0,[r4,#0x36]
000018  e002              B        |L33.32|
                  |L33.26|
;;;2630       } else {
;;;2631           p_tcb->TaskState = OS_TASK_STATE_PEND;
00001a  2002              MOVS     r0,#2
00001c  f8840036          STRB     r0,[r4,#0x36]
                  |L33.32|
;;;2632       }
;;;2633       OS_RdyListRemove(p_tcb);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       OS_RdyListRemove
;;;2634   }
000026  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L33.40|
                          DCD      OSTickListTimeout
