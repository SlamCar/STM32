; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\os_flag.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\os_flag.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\os_flag.crf ..\UCOSIII\uCOS-III\Source\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;70     
;;;71     void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;72                         CPU_CHAR     *p_name,
;;;73                         OS_FLAGS      flags,
;;;74                         OS_ERR       *p_err)
;;;75     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;76         CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;77     
;;;78     
;;;79     
;;;80     #ifdef OS_SAFETY_CRITICAL
;;;81         if (p_err == (OS_ERR *)0) {
;;;82             OS_SAFETY_CRITICAL_EXCEPTION();
;;;83             return;
;;;84         }
;;;85     #endif
;;;86     
;;;87     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;88         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;89            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;90             return;
;;;91         }
;;;92     #endif
;;;93     
;;;94     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;95         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;96            *p_err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE from an ISR                           */
;;;97             return;
;;;98         }
;;;99     #endif
;;;100    
;;;101    #if OS_CFG_ARG_CHK_EN > 0u
;;;102        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
;;;103           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;104            return;
;;;105        }
;;;106    #endif
;;;107    
;;;108        OS_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4680              MOV      r8,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;109    #if OS_OBJ_TYPE_REQ > 0u
;;;110        p_grp->Type    = OS_OBJ_TYPE_FLAG;                      /* Set to event flag group type                           */
000022  480f              LDR      r0,|L1.96|
000024  6020              STR      r0,[r4,#0]
;;;111    #endif
;;;112    #if OS_CFG_DBG_EN > 0u
;;;113        p_grp->NamePtr = p_name;
000026  6065              STR      r5,[r4,#4]
;;;114    #else
;;;115        (void)&p_name;
;;;116    #endif
;;;117        p_grp->Flags   = flags;                                 /* Set to desired initial value                           */
000028  6226              STR      r6,[r4,#0x20]
;;;118        p_grp->TS      = (CPU_TS)0;
00002a  2000              MOVS     r0,#0
00002c  6260              STR      r0,[r4,#0x24]
;;;119        OS_PendListInit(&p_grp->PendList);
00002e  f1040008          ADD      r0,r4,#8
000032  f7fffffe          BL       OS_PendListInit
;;;120    
;;;121    #if OS_CFG_DBG_EN > 0u
;;;122        OS_FlagDbgListAdd(p_grp);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_FlagDbgListAdd
;;;123    #endif
;;;124        OSFlagQty++;
00003c  4809              LDR      r0,|L1.100|
00003e  8800              LDRH     r0,[r0,#0]  ; OSFlagQty
000040  1c40              ADDS     r0,r0,#1
000042  4908              LDR      r1,|L1.100|
000044  8008              STRH     r0,[r1,#0]
;;;125    
;;;126    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;127        TRACE_OS_FLAG_CREATE(p_grp, p_name);                    /* Record the event.                                      */
;;;128    #endif
;;;129        
;;;130        OS_CRITICAL_EXIT_NO_SCHED();
000046  bf00              NOP      
000048  f7fffffe          BL       CPU_IntDisMeasStop
00004c  bf00              NOP      
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       CPU_SR_Restore
000054  bf00              NOP      
000056  bf00              NOP      
;;;131       *p_err = OS_ERR_NONE;
000058  2000              MOVS     r0,#0
00005a  8038              STRH     r0,[r7,#0]
;;;132    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;133    
                          ENDP

                  |L1.96|
                          DCD      0x47414c46
                  |L1.100|
                          DCD      OSFlagQty

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;333    
;;;334    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;335                          OS_FLAGS      flags,
;;;336                          OS_TICK       timeout,
;;;337                          OS_OPT        opt,
;;;338                          CPU_TS       *p_ts,
;;;339                          OS_ERR       *p_err)
;;;340    {
000004  b08b              SUB      sp,sp,#0x2c
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  4699              MOV      r9,r3
00000c  e9dd5418          LDRD     r5,r4,[sp,#0x60]
;;;341        CPU_BOOLEAN   consume;
;;;342        OS_FLAGS      flags_rdy;
;;;343        OS_OPT        mode;
;;;344        OS_PEND_DATA  pend_data;
;;;345        CPU_SR_ALLOC();
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;346    
;;;347    
;;;348    
;;;349    #ifdef OS_SAFETY_CRITICAL
;;;350        if (p_err == (OS_ERR *)0) {
;;;351    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;352            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;353    #endif
;;;354            OS_SAFETY_CRITICAL_EXCEPTION();
;;;355            return ((OS_FLAGS)0);
;;;356        }
;;;357    #endif
;;;358    
;;;359    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;360        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;361    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;362            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;363    #endif
;;;364           *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                             */
;;;365            return ((OS_FLAGS)0);
;;;366        }
;;;367    #endif
;;;368    
;;;369    #if OS_CFG_ARG_CHK_EN > 0u
;;;370        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
;;;371    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;372            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;373    #endif
;;;374           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;375            return ((OS_FLAGS)0);
;;;376        }
;;;377        switch (opt) {                                          /* Validate 'opt'                                         */
;;;378            case OS_OPT_PEND_FLAG_CLR_ALL:
;;;379            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;380            case OS_OPT_PEND_FLAG_SET_ALL:
;;;381            case OS_OPT_PEND_FLAG_SET_ANY:
;;;382            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;383            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;384            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;385            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;386            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;387            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;388            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;389            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;390            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;391            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;392            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;393            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;394                 break;
;;;395    
;;;396            default:
;;;397    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;398                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;399    #endif
;;;400                *p_err = OS_ERR_OPT_INVALID;
;;;401                 return ((OS_OBJ_QTY)0);
;;;402        }
;;;403    #endif
;;;404    
;;;405    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;406        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate that we are pointing at an event flag         */
000014  49b9              LDR      r1,|L2.764|
000016  6830              LDR      r0,[r6,#0]
000018  4288              CMP      r0,r1
00001a  d006              BEQ      |L2.42|
;;;407    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;408            TRACE_OS_FLAG_PEND_FAILED(p_grp);                   /* Record the event.                                      */
;;;409    #endif
;;;410           *p_err = OS_ERR_OBJ_TYPE;
00001c  f64550c4          MOV      r0,#0x5dc4
000020  8020              STRH     r0,[r4,#0]
;;;411            return ((OS_FLAGS)0);
000022  2000              MOVS     r0,#0
                  |L2.36|
;;;412        }
;;;413    #endif
;;;414    
;;;415        if ((opt & OS_OPT_PEND_FLAG_CONSUME) != (OS_OPT)0) {    /* See if we need to consume the flags                    */
;;;416            consume = DEF_TRUE;
;;;417        } else {
;;;418            consume = DEF_FALSE;
;;;419        }
;;;420    
;;;421        if (p_ts != (CPU_TS *)0) {
;;;422           *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
;;;423        }
;;;424    
;;;425        mode = opt & OS_OPT_PEND_FLAG_MASK;
;;;426        CPU_CRITICAL_ENTER();
;;;427        switch (mode) {
;;;428            case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
;;;429                 flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
;;;430                 if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
;;;431                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;432                         p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
;;;433                     }
;;;434                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;435                     if (p_ts != (CPU_TS *)0) {
;;;436                        *p_ts  = p_grp->TS;
;;;437                     }
;;;438                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;439    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;440                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;441    #endif
;;;442                    *p_err = OS_ERR_NONE;
;;;443                     return (flags_rdy);
;;;444                 } else {                                       /* Block task until events occur or timeout               */
;;;445                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;446                         CPU_CRITICAL_EXIT();
;;;447    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;448                         TRACE_OS_FLAG_PEND_FAILED(p_grp);      /* Record the event.                                      */
;;;449    #endif
;;;450                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;451                         return ((OS_FLAGS)0);
;;;452                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;453                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;454                             CPU_CRITICAL_EXIT();
;;;455    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;456                             TRACE_OS_FLAG_PEND_FAILED(p_grp);  /* Record the event.                                      */
;;;457    #endif
;;;458                            *p_err = OS_ERR_SCHED_LOCKED;       /* ... can't PEND when locked                             */
;;;459                             return ((OS_FLAGS)0);
;;;460                         }
;;;461                     }
;;;462                                                                /* Lock the scheduler/re-enable interrupts                */
;;;463                     OS_CRITICAL_ENTER_CPU_EXIT();              
;;;464                     OS_FlagBlock(&pend_data,
;;;465                                  p_grp,
;;;466                                  flags,
;;;467                                  opt,
;;;468                                  timeout);
;;;469                     OS_CRITICAL_EXIT_NO_SCHED();
;;;470                 }
;;;471                 break;
;;;472    
;;;473            case OS_OPT_PEND_FLAG_SET_ANY:
;;;474                 flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
;;;475                 if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
;;;476                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;477                         p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
;;;478                     }
;;;479                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;480                     if (p_ts != (CPU_TS *)0) {
;;;481                        *p_ts  = p_grp->TS;
;;;482                     }
;;;483                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;484    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;485                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;486    #endif
;;;487                    *p_err = OS_ERR_NONE;
;;;488                     return (flags_rdy);
;;;489                 } else {                                       /* Block task until events occur or timeout               */
;;;490                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;491                         CPU_CRITICAL_EXIT();
;;;492                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;493                         return ((OS_FLAGS)0);
;;;494                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;495                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;496                             CPU_CRITICAL_EXIT();
;;;497                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;498                             return ((OS_FLAGS)0);
;;;499                         }
;;;500                     }
;;;501                                                                /* Lock the scheduler/re-enable interrupts                */
;;;502                     OS_CRITICAL_ENTER_CPU_EXIT();              
;;;503                     OS_FlagBlock(&pend_data,
;;;504                                  p_grp,
;;;505                                  flags,
;;;506                                  opt,
;;;507                                  timeout);
;;;508                     OS_CRITICAL_EXIT_NO_SCHED();
;;;509                 }
;;;510                 break;
;;;511    
;;;512    #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;513            case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all required flags are cleared                  */
;;;514                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
;;;515                 if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
;;;516                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;517                         p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we wanted                      */
;;;518                     }
;;;519                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;520                     if (p_ts != (CPU_TS *)0) {
;;;521                        *p_ts  = p_grp->TS;
;;;522                     }
;;;523                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;524    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;525                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;526    #endif                 
;;;527                    *p_err = OS_ERR_NONE;
;;;528                     return (flags_rdy);
;;;529                 } else {                                       /* Block task until events occur or timeout               */
;;;530                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;531                         CPU_CRITICAL_EXIT();
;;;532                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;533                         return ((OS_FLAGS)0);
;;;534                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;535                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;536                             CPU_CRITICAL_EXIT();
;;;537                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;538                             return ((OS_FLAGS)0);
;;;539                         }
;;;540                     }
;;;541                                                                
;;;542                     OS_CRITICAL_ENTER_CPU_EXIT();              /* Lock the scheduler/re-enable interrupts                */
;;;543                     OS_FlagBlock(&pend_data,
;;;544                                  p_grp,
;;;545                                  flags,
;;;546                                  opt,
;;;547                                  timeout);
;;;548                     OS_CRITICAL_EXIT_NO_SCHED();
;;;549                 }
;;;550                 break;
;;;551    
;;;552            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;553                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
;;;554                 if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag cleared                                */
;;;555                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;556                         p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we got                         */
;;;557                     }
;;;558                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;559                     if (p_ts != (CPU_TS *)0) {
;;;560                        *p_ts  = p_grp->TS;
;;;561                     }
;;;562                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;563    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;564                     TRACE_OS_FLAG_PEND(p_grp);                 /* Record the event.                                      */
;;;565    #endif
;;;566                    *p_err = OS_ERR_NONE;
;;;567                     return (flags_rdy);
;;;568                 } else {                                       /* Block task until events occur or timeout               */
;;;569                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;570                         CPU_CRITICAL_EXIT();
;;;571                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;572                         return ((OS_FLAGS)0);
;;;573                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;574                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;575                             CPU_CRITICAL_EXIT();
;;;576                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;577                             return ((OS_FLAGS)0);
;;;578                         }
;;;579                     }
;;;580                                                                
;;;581                     OS_CRITICAL_ENTER_CPU_EXIT();              /* Lock the scheduler/re-enable interrupts                */
;;;582                     OS_FlagBlock(&pend_data,              
;;;583                                  p_grp,
;;;584                                  flags,
;;;585                                  opt,
;;;586                                  timeout);
;;;587                     OS_CRITICAL_EXIT_NO_SCHED();
;;;588                 }
;;;589                 break;
;;;590    #endif
;;;591    
;;;592            default:
;;;593                 CPU_CRITICAL_EXIT();
;;;594    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;595                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;596    #endif
;;;597                *p_err = OS_ERR_OPT_INVALID;
;;;598                 return ((OS_FLAGS)0);
;;;599        }
;;;600    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;601        TRACE_OS_FLAG_PEND_BLOCK(p_grp);                        /* Record the event.                                      */
;;;602    #endif
;;;603        OSSched();                                              /* Find next HPT ready to run                             */
;;;604    
;;;605        CPU_CRITICAL_ENTER();
;;;606        switch (OSTCBCurPtr->PendStatus) {
;;;607            case OS_STATUS_PEND_OK:                             /* We got the event flags                                 */
;;;608                 if (p_ts != (CPU_TS *)0) {
;;;609                    *p_ts  = OSTCBCurPtr->TS;
;;;610                 }
;;;611    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;612                 TRACE_OS_FLAG_PEND(p_grp);                     /* Record the event.                                      */
;;;613    #endif
;;;614                *p_err = OS_ERR_NONE;
;;;615                 break;
;;;616    
;;;617            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;618                 if (p_ts != (CPU_TS *)0) {
;;;619                    *p_ts  = OSTCBCurPtr->TS;
;;;620                 }
;;;621                 CPU_CRITICAL_EXIT();
;;;622    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;623                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;624    #endif
;;;625                *p_err = OS_ERR_PEND_ABORT;
;;;626                 break;
;;;627    
;;;628            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
;;;629                 if (p_ts != (CPU_TS *)0) {
;;;630                    *p_ts  = (CPU_TS  )0;
;;;631                 }
;;;632                 CPU_CRITICAL_EXIT();
;;;633    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;634                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;635    #endif
;;;636                *p_err = OS_ERR_TIMEOUT;
;;;637                 break;
;;;638    
;;;639            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;640                 if (p_ts != (CPU_TS *)0) {
;;;641                    *p_ts  = OSTCBCurPtr->TS;
;;;642                 }
;;;643                 CPU_CRITICAL_EXIT();
;;;644    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;645                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;646    #endif
;;;647                *p_err = OS_ERR_OBJ_DEL;
;;;648                 break;
;;;649    
;;;650            default:
;;;651                 CPU_CRITICAL_EXIT();
;;;652    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;653                 TRACE_OS_FLAG_PEND_FAILED(p_grp);              /* Record the event.                                      */
;;;654    #endif
;;;655                *p_err = OS_ERR_STATUS_INVALID;
;;;656                 break;
;;;657        }
;;;658        if (*p_err != OS_ERR_NONE) {
;;;659            return ((OS_FLAGS)0);
;;;660        }
;;;661    
;;;662        flags_rdy = OSTCBCurPtr->FlagsRdy;
;;;663        if (consume == DEF_TRUE) {                              /* See if we need to consume the flags                    */
;;;664            switch (mode) {
;;;665                case OS_OPT_PEND_FLAG_SET_ALL:
;;;666                case OS_OPT_PEND_FLAG_SET_ANY:                  /* Clear ONLY the flags we got                            */
;;;667                     p_grp->Flags &= ~flags_rdy;
;;;668                     break;
;;;669    
;;;670    #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;671                case OS_OPT_PEND_FLAG_CLR_ALL:
;;;672                case OS_OPT_PEND_FLAG_CLR_ANY:                  /* Set   ONLY the flags we got                            */
;;;673                     p_grp->Flags |=  flags_rdy;
;;;674                     break;
;;;675    #endif
;;;676                default:
;;;677                     CPU_CRITICAL_EXIT();
;;;678                    *p_err = OS_ERR_OPT_INVALID;
;;;679                     return ((OS_FLAGS)0);
;;;680            }
;;;681        }
;;;682        CPU_CRITICAL_EXIT();
;;;683       *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
;;;684        return (flags_rdy);
;;;685    }
000024  b00f              ADD      sp,sp,#0x3c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.42|
00002a  f4097080          AND      r0,r9,#0x100          ;415
00002e  b110              CBZ      r0,|L2.54|
000030  f04f0a01          MOV      r10,#1                ;416
000034  e001              B        |L2.58|
                  |L2.54|
000036  f04f0a00          MOV      r10,#0                ;418
                  |L2.58|
00003a  b10d              CBZ      r5,|L2.64|
00003c  2000              MOVS     r0,#0                 ;422
00003e  6028              STR      r0,[r5,#0]            ;422
                  |L2.64|
000040  f0090b0f          AND      r11,r9,#0xf           ;425
000044  bf00              NOP                            ;426
000046  bf00              NOP                            ;426
000048  f7fffffe          BL       CPU_SR_Save
00004c  9002              STR      r0,[sp,#8]            ;426
00004e  bf00              NOP                            ;426
000050  f7fffffe          BL       CPU_IntDisMeasStart
000054  bf00              NOP                            ;426
000056  f1bb0f04          CMP      r11,#4                ;427
00005a  d003              BEQ      |L2.100|
00005c  f1bb0f08          CMP      r11,#8                ;427
000060  d172              BNE      |L2.328|
000062  e053              B        |L2.268|
                  |L2.100|
000064  6a30              LDR      r0,[r6,#0x20]         ;429
000066  ea000708          AND      r7,r0,r8              ;429
00006a  4547              CMP      r7,r8                 ;430
00006c  d119              BNE      |L2.162|
00006e  f1ba0f01          CMP      r10,#1                ;431
000072  d102              BNE      |L2.122|
000074  6a30              LDR      r0,[r6,#0x20]         ;432
000076  43b8              BICS     r0,r0,r7              ;432
000078  6230              STR      r0,[r6,#0x20]         ;432
                  |L2.122|
00007a  48a1              LDR      r0,|L2.768|
00007c  6800              LDR      r0,[r0,#0]            ;434  ; OSTCBCurPtr
00007e  f8c07080          STR      r7,[r0,#0x80]         ;434
000082  b10d              CBZ      r5,|L2.136|
000084  6a70              LDR      r0,[r6,#0x24]         ;436
000086  6028              STR      r0,[r5,#0]            ;436
                  |L2.136|
000088  bf00              NOP                            ;438
00008a  f7fffffe          BL       CPU_IntDisMeasStop
00008e  bf00              NOP                            ;438
000090  9802              LDR      r0,[sp,#8]            ;438
000092  f7fffffe          BL       CPU_SR_Restore
000096  bf00              NOP                            ;438
000098  bf00              NOP                            ;438
00009a  2000              MOVS     r0,#0                 ;442
00009c  8020              STRH     r0,[r4,#0]            ;442
00009e  4638              MOV      r0,r7                 ;443
0000a0  e7c0              B        |L2.36|
                  |L2.162|
0000a2  f4094000          AND      r0,r9,#0x8000         ;445
0000a6  b168              CBZ      r0,|L2.196|
0000a8  bf00              NOP                            ;446
0000aa  f7fffffe          BL       CPU_IntDisMeasStop
0000ae  bf00              NOP                            ;446
0000b0  9802              LDR      r0,[sp,#8]            ;446
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  bf00              NOP                            ;446
0000b8  bf00              NOP                            ;446
0000ba  f24610b0          MOV      r0,#0x61b0            ;450
0000be  8020              STRH     r0,[r4,#0]            ;450
0000c0  2000              MOVS     r0,#0                 ;451
0000c2  e7af              B        |L2.36|
                  |L2.196|
0000c4  488f              LDR      r0,|L2.772|
0000c6  7800              LDRB     r0,[r0,#0]            ;453  ; OSSchedLockNestingCtr
0000c8  2800              CMP      r0,#0                 ;453
0000ca  dd0d              BLE      |L2.232|
0000cc  bf00              NOP                            ;454
0000ce  f7fffffe          BL       CPU_IntDisMeasStop
0000d2  bf00              NOP                            ;454
0000d4  9802              LDR      r0,[sp,#8]            ;454
0000d6  f7fffffe          BL       CPU_SR_Restore
0000da  bf00              NOP                            ;454
0000dc  bf00              NOP                            ;454
0000de  f6465063          MOV      r0,#0x6d63            ;458
0000e2  8020              STRH     r0,[r4,#0]            ;458
0000e4  2000              MOVS     r0,#0                 ;459
0000e6  e79d              B        |L2.36|
                  |L2.232|
0000e8  980d              LDR      r0,[sp,#0x34]         ;464
0000ea  464b              MOV      r3,r9                 ;464
0000ec  4642              MOV      r2,r8                 ;464
0000ee  4631              MOV      r1,r6                 ;464
0000f0  9000              STR      r0,[sp,#0]            ;464
0000f2  a803              ADD      r0,sp,#0xc            ;464
0000f4  f7fffffe          BL       OS_FlagBlock
0000f8  bf00              NOP                            ;469
0000fa  f7fffffe          BL       CPU_IntDisMeasStop
0000fe  bf00              NOP                            ;469
000100  9802              LDR      r0,[sp,#8]            ;469
000102  f7fffffe          BL       CPU_SR_Restore
000106  bf00              NOP                            ;469
000108  bf00              NOP                            ;469
00010a  e061              B        |L2.464|
                  |L2.268|
00010c  6a30              LDR      r0,[r6,#0x20]         ;474
00010e  ea000708          AND      r7,r0,r8              ;474
000112  b1d7              CBZ      r7,|L2.330|
000114  f1ba0f01          CMP      r10,#1                ;476
000118  d102              BNE      |L2.288|
00011a  6a30              LDR      r0,[r6,#0x20]         ;477
00011c  43b8              BICS     r0,r0,r7              ;477
00011e  6230              STR      r0,[r6,#0x20]         ;477
                  |L2.288|
000120  4877              LDR      r0,|L2.768|
000122  6800              LDR      r0,[r0,#0]            ;479  ; OSTCBCurPtr
000124  f8c07080          STR      r7,[r0,#0x80]         ;479
000128  b10d              CBZ      r5,|L2.302|
00012a  6a70              LDR      r0,[r6,#0x24]         ;481
00012c  6028              STR      r0,[r5,#0]            ;481
                  |L2.302|
00012e  bf00              NOP                            ;483
000130  f7fffffe          BL       CPU_IntDisMeasStop
000134  bf00              NOP                            ;483
000136  9802              LDR      r0,[sp,#8]            ;483
000138  f7fffffe          BL       CPU_SR_Restore
00013c  bf00              NOP                            ;483
00013e  bf00              NOP                            ;483
000140  2000              MOVS     r0,#0                 ;487
000142  8020              STRH     r0,[r4,#0]            ;487
000144  4638              MOV      r0,r7                 ;488
000146  e76d              B        |L2.36|
                  |L2.328|
000148  e034              B        |L2.436|
                  |L2.330|
00014a  f4094000          AND      r0,r9,#0x8000         ;490
00014e  b168              CBZ      r0,|L2.364|
000150  bf00              NOP                            ;491
000152  f7fffffe          BL       CPU_IntDisMeasStop
000156  bf00              NOP                            ;491
000158  9802              LDR      r0,[sp,#8]            ;491
00015a  f7fffffe          BL       CPU_SR_Restore
00015e  bf00              NOP                            ;491
000160  bf00              NOP                            ;491
000162  f24610b0          MOV      r0,#0x61b0            ;492
000166  8020              STRH     r0,[r4,#0]            ;492
000168  2000              MOVS     r0,#0                 ;493
00016a  e75b              B        |L2.36|
                  |L2.364|
00016c  4865              LDR      r0,|L2.772|
00016e  7800              LDRB     r0,[r0,#0]            ;495  ; OSSchedLockNestingCtr
000170  2800              CMP      r0,#0                 ;495
000172  dd0d              BLE      |L2.400|
000174  bf00              NOP                            ;496
000176  f7fffffe          BL       CPU_IntDisMeasStop
00017a  bf00              NOP                            ;496
00017c  9802              LDR      r0,[sp,#8]            ;496
00017e  f7fffffe          BL       CPU_SR_Restore
000182  bf00              NOP                            ;496
000184  bf00              NOP                            ;496
000186  f6465063          MOV      r0,#0x6d63            ;497
00018a  8020              STRH     r0,[r4,#0]            ;497
00018c  2000              MOVS     r0,#0                 ;498
00018e  e749              B        |L2.36|
                  |L2.400|
000190  980d              LDR      r0,[sp,#0x34]         ;503
000192  464b              MOV      r3,r9                 ;503
000194  4642              MOV      r2,r8                 ;503
000196  4631              MOV      r1,r6                 ;503
000198  9000              STR      r0,[sp,#0]            ;503
00019a  a803              ADD      r0,sp,#0xc            ;503
00019c  f7fffffe          BL       OS_FlagBlock
0001a0  bf00              NOP                            ;508
0001a2  f7fffffe          BL       CPU_IntDisMeasStop
0001a6  bf00              NOP                            ;508
0001a8  9802              LDR      r0,[sp,#8]            ;508
0001aa  f7fffffe          BL       CPU_SR_Restore
0001ae  bf00              NOP                            ;508
0001b0  bf00              NOP                            ;508
0001b2  e00d              B        |L2.464|
                  |L2.436|
0001b4  bf00              NOP                            ;593
0001b6  f7fffffe          BL       CPU_IntDisMeasStop
0001ba  bf00              NOP                            ;593
0001bc  9802              LDR      r0,[sp,#8]            ;593
0001be  f7fffffe          BL       CPU_SR_Restore
0001c2  bf00              NOP                            ;593
0001c4  bf00              NOP                            ;593
0001c6  f6456025          MOV      r0,#0x5e25            ;597
0001ca  8020              STRH     r0,[r4,#0]            ;597
0001cc  2000              MOVS     r0,#0                 ;598
0001ce  e729              B        |L2.36|
                  |L2.464|
0001d0  bf00              NOP                            ;471
0001d2  f7fffffe          BL       OSSched
0001d6  bf00              NOP                            ;605
0001d8  bf00              NOP                            ;605
0001da  f7fffffe          BL       CPU_SR_Save
0001de  9002              STR      r0,[sp,#8]            ;605
0001e0  bf00              NOP                            ;605
0001e2  f7fffffe          BL       CPU_IntDisMeasStart
0001e6  bf00              NOP                            ;605
0001e8  4845              LDR      r0,|L2.768|
0001ea  6800              LDR      r0,[r0,#0]            ;606  ; OSTCBCurPtr
0001ec  f8900035          LDRB     r0,[r0,#0x35]         ;606
0001f0  b130              CBZ      r0,|L2.512|
0001f2  2801              CMP      r0,#1                 ;606
0001f4  d00c              BEQ      |L2.528|
0001f6  2802              CMP      r0,#2                 ;606
0001f8  d02c              BEQ      |L2.596|
0001fa  2803              CMP      r0,#3                 ;606
0001fc  d13c              BNE      |L2.632|
0001fe  e019              B        |L2.564|
                  |L2.512|
000200  b11d              CBZ      r5,|L2.522|
000202  483f              LDR      r0,|L2.768|
000204  6800              LDR      r0,[r0,#0]            ;609  ; OSTCBCurPtr
000206  6c80              LDR      r0,[r0,#0x48]         ;609
000208  6028              STR      r0,[r5,#0]            ;609
                  |L2.522|
00020a  2000              MOVS     r0,#0                 ;614
00020c  8020              STRH     r0,[r4,#0]            ;614
00020e  e040              B        |L2.658|
                  |L2.528|
000210  b11d              CBZ      r5,|L2.538|
000212  483b              LDR      r0,|L2.768|
000214  6800              LDR      r0,[r0,#0]            ;619  ; OSTCBCurPtr
000216  6c80              LDR      r0,[r0,#0x48]         ;619
000218  6028              STR      r0,[r5,#0]            ;619
                  |L2.538|
00021a  bf00              NOP                            ;621
00021c  f7fffffe          BL       CPU_IntDisMeasStop
000220  bf00              NOP                            ;621
000222  9802              LDR      r0,[sp,#8]            ;621
000224  f7fffffe          BL       CPU_SR_Restore
000228  bf00              NOP                            ;621
00022a  bf00              NOP                            ;621
00022c  f24610a9          MOV      r0,#0x61a9            ;625
000230  8020              STRH     r0,[r4,#0]            ;625
000232  e02e              B        |L2.658|
                  |L2.564|
000234  b10d              CBZ      r5,|L2.570|
000236  2000              MOVS     r0,#0                 ;630
000238  6028              STR      r0,[r5,#0]            ;630
                  |L2.570|
00023a  bf00              NOP                            ;632
00023c  f7fffffe          BL       CPU_IntDisMeasStop
000240  bf00              NOP                            ;632
000242  9802              LDR      r0,[sp,#8]            ;632
000244  f7fffffe          BL       CPU_SR_Restore
000248  bf00              NOP                            ;632
00024a  bf00              NOP                            ;632
00024c  f24720d9          MOV      r0,#0x72d9            ;636
000250  8020              STRH     r0,[r4,#0]            ;636
000252  e01e              B        |L2.658|
                  |L2.596|
000254  b11d              CBZ      r5,|L2.606|
000256  482a              LDR      r0,|L2.768|
000258  6800              LDR      r0,[r0,#0]            ;641  ; OSTCBCurPtr
00025a  6c80              LDR      r0,[r0,#0x48]         ;641
00025c  6028              STR      r0,[r5,#0]            ;641
                  |L2.606|
00025e  bf00              NOP                            ;643
000260  f7fffffe          BL       CPU_IntDisMeasStop
000264  bf00              NOP                            ;643
000266  9802              LDR      r0,[sp,#8]            ;643
000268  f7fffffe          BL       CPU_SR_Restore
00026c  bf00              NOP                            ;643
00026e  bf00              NOP                            ;643
000270  f64550c2          MOV      r0,#0x5dc2            ;647
000274  8020              STRH     r0,[r4,#0]            ;647
000276  e00c              B        |L2.658|
                  |L2.632|
000278  bf00              NOP                            ;651
00027a  f7fffffe          BL       CPU_IntDisMeasStop
00027e  bf00              NOP                            ;651
000280  9802              LDR      r0,[sp,#8]            ;651
000282  f7fffffe          BL       CPU_SR_Restore
000286  bf00              NOP                            ;651
000288  bf00              NOP                            ;651
00028a  f646602e          MOV      r0,#0x6e2e            ;655
00028e  8020              STRH     r0,[r4,#0]            ;655
000290  bf00              NOP                            ;656
                  |L2.658|
000292  bf00              NOP                            ;615
000294  8820              LDRH     r0,[r4,#0]            ;658
000296  b108              CBZ      r0,|L2.668|
000298  2000              MOVS     r0,#0                 ;659
00029a  e6c3              B        |L2.36|
                  |L2.668|
00029c  4818              LDR      r0,|L2.768|
00029e  6800              LDR      r0,[r0,#0]            ;662  ; OSTCBCurPtr
0002a0  f8d07080          LDR      r7,[r0,#0x80]         ;662
0002a4  f1ba0f01          CMP      r10,#1                ;663
0002a8  d11a              BNE      |L2.736|
0002aa  f1bb0f04          CMP      r11,#4                ;664
0002ae  d003              BEQ      |L2.696|
0002b0  f1bb0f08          CMP      r11,#8                ;664
0002b4  d105              BNE      |L2.706|
0002b6  e000              B        |L2.698|
                  |L2.696|
0002b8  bf00              NOP                            ;666
                  |L2.698|
0002ba  6a30              LDR      r0,[r6,#0x20]         ;667
0002bc  43b8              BICS     r0,r0,r7              ;667
0002be  6230              STR      r0,[r6,#0x20]         ;667
0002c0  e00d              B        |L2.734|
                  |L2.706|
0002c2  bf00              NOP                            ;677
0002c4  f7fffffe          BL       CPU_IntDisMeasStop
0002c8  bf00              NOP                            ;677
0002ca  9802              LDR      r0,[sp,#8]            ;677
0002cc  f7fffffe          BL       CPU_SR_Restore
0002d0  bf00              NOP                            ;677
0002d2  bf00              NOP                            ;677
0002d4  f6456025          MOV      r0,#0x5e25            ;678
0002d8  8020              STRH     r0,[r4,#0]            ;678
0002da  2000              MOVS     r0,#0                 ;679
0002dc  e6a2              B        |L2.36|
                  |L2.734|
0002de  bf00              NOP                            ;668
                  |L2.736|
0002e0  bf00              NOP                            ;682
0002e2  f7fffffe          BL       CPU_IntDisMeasStop
0002e6  bf00              NOP                            ;682
0002e8  9802              LDR      r0,[sp,#8]            ;682
0002ea  f7fffffe          BL       CPU_SR_Restore
0002ee  bf00              NOP                            ;682
0002f0  bf00              NOP                            ;682
0002f2  2000              MOVS     r0,#0                 ;683
0002f4  8020              STRH     r0,[r4,#0]            ;683
0002f6  4638              MOV      r0,r7                 ;684
0002f8  e694              B        |L2.36|
;;;686    
                          ENDP

0002fa  0000              DCW      0x0000
                  |L2.764|
                          DCD      0x47414c46
                  |L2.768|
                          DCD      OSTCBCurPtr
                  |L2.772|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;821    
;;;822    OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
000002  4604              MOV      r4,r0
;;;824        OS_FLAGS   flags;
;;;825        CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;826    
;;;827    
;;;828    
;;;829    #ifdef OS_SAFETY_CRITICAL
;;;830        if (p_err == (OS_ERR *)0) {
;;;831            OS_SAFETY_CRITICAL_EXCEPTION();
;;;832            return ((OS_FLAGS)0);
;;;833        }
;;;834    #endif
;;;835    
;;;836    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;837        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;838           *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
;;;839            return ((OS_FLAGS)0);
;;;840        }
;;;841    #endif
;;;842    
;;;843        CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_IntDisMeasStart
000016  bf00              NOP      
;;;844        flags = OSTCBCurPtr->FlagsRdy;
000018  4808              LDR      r0,|L3.60|
00001a  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00001c  f8d05080          LDR      r5,[r0,#0x80]
;;;845        CPU_CRITICAL_EXIT();
000020  bf00              NOP      
000022  f7fffffe          BL       CPU_IntDisMeasStop
000026  bf00              NOP      
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       CPU_SR_Restore
00002e  bf00              NOP      
000030  bf00              NOP      
;;;846       *p_err = OS_ERR_NONE;
000032  2000              MOVS     r0,#0
000034  8020              STRH     r0,[r4,#0]
;;;847        return (flags);
000036  4628              MOV      r0,r5
;;;848    }
000038  bd70              POP      {r4-r6,pc}
;;;849    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=2

                  OSFlagPost PROC
;;;891    
;;;892    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;893                          OS_FLAGS      flags,
;;;894                          OS_OPT        opt,
;;;895                          OS_ERR       *p_err)
;;;896    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;897        OS_FLAGS  flags_cur;
;;;898        CPU_TS    ts;
;;;899    
;;;900    
;;;901    
;;;902    #ifdef OS_SAFETY_CRITICAL
;;;903        if (p_err == (OS_ERR *)0) {
;;;904    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;905            TRACE_OS_FLAG_POST_FAILED(p_grp);                   /* Record the event.                                      */
;;;906    #endif
;;;907            OS_SAFETY_CRITICAL_EXCEPTION();
;;;908            return ((OS_FLAGS)0);
;;;909        }
;;;910    #endif
;;;911    
;;;912    #if OS_CFG_ARG_CHK_EN > 0u
;;;913        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
;;;914    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;915            TRACE_OS_FLAG_POST_FAILED(p_grp);                   /* Record the event.                                      */
;;;916    #endif
;;;917           *p_err  = OS_ERR_OBJ_PTR_NULL;
;;;918            return ((OS_FLAGS)0);
;;;919        }
;;;920        switch (opt) {                                          /* Validate 'opt'                                         */
;;;921            case OS_OPT_POST_FLAG_SET:
;;;922            case OS_OPT_POST_FLAG_CLR:
;;;923            case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
;;;924            case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
;;;925                 break;
;;;926    
;;;927            default:
;;;928    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;929                 TRACE_OS_FLAG_POST_FAILED(p_grp);              /* Record the event.                                      */
;;;930    #endif
;;;931                *p_err = OS_ERR_OPT_INVALID;
;;;932                 return ((OS_FLAGS)0);
;;;933        }
;;;934    #endif
;;;935    
;;;936    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;937        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure we are pointing to an event flag grp         */
00000c  490b              LDR      r1,|L4.60|
00000e  6828              LDR      r0,[r5,#0]
000010  4288              CMP      r0,r1
000012  d005              BEQ      |L4.32|
;;;938    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;939            TRACE_OS_FLAG_POST_FAILED(p_grp);                   /* Record the event.                                      */
;;;940    #endif
;;;941           *p_err = OS_ERR_OBJ_TYPE;
000014  f64550c4          MOV      r0,#0x5dc4
000018  8020              STRH     r0,[r4,#0]
;;;942            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L4.28|
;;;943        }
;;;944    #endif
;;;945    
;;;946        ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;947    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;948        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;949            OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_FLAG,          /* Post to ISR queue                                      */
;;;950                        (void      *)p_grp,
;;;951                        (void      *)0,
;;;952                        (OS_MSG_SIZE)0,
;;;953                        (OS_FLAGS   )flags,
;;;954                        (OS_OPT     )opt,
;;;955                        (CPU_TS     )ts,
;;;956                        (OS_ERR    *)p_err);
;;;957    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;958            TRACE_OS_FLAG_POST(p_grp);                          /* Record the event.                                      */
;;;959    #endif
;;;960            return ((OS_FLAGS)0);
;;;961        }
;;;962    #endif
;;;963    
;;;964        flags_cur = OS_FlagPost(p_grp,
;;;965                                flags,
;;;966                                opt,
;;;967                                ts,
;;;968                                p_err);
;;;969    
;;;970    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;971        TRACE_OS_FLAG_POST(p_grp);                              /* Record the event.                                      */
;;;972    #endif    
;;;973    
;;;974        return (flags_cur);
;;;975    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L4.32|
000020  f7fffffe          BL       CPU_TS_TmrRd
000024  4681              MOV      r9,r0                 ;946
000026  464b              MOV      r3,r9                 ;964
000028  4642              MOV      r2,r8                 ;964
00002a  4639              MOV      r1,r7                 ;964
00002c  4628              MOV      r0,r5                 ;964
00002e  9400              STR      r4,[sp,#0]            ;964
000030  f7fffffe          BL       OS_FlagPost
000034  4606              MOV      r6,r0                 ;964
000036  4630              MOV      r0,r6                 ;974
000038  e7f0              B        |L4.28|
;;;976    
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      0x47414c46

                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1013   
;;;1014   void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1015                       OS_FLAG_GRP   *p_grp,
;;;1016                       OS_FLAGS       flags,
;;;1017                       OS_OPT         opt,
;;;1018                       OS_TICK        timeout)
;;;1019   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1020       OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
000010  4809              LDR      r0,|L5.56|
000012  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000014  67c4              STR      r4,[r0,#0x7c]
;;;1021       OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
000016  4808              LDR      r0,|L5.56|
000018  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00001a  f8a05084          STRH     r5,[r0,#0x84]
;;;1022       OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
00001e  2000              MOVS     r0,#0
000020  4905              LDR      r1,|L5.56|
000022  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000024  f8c10080          STR      r0,[r1,#0x80]
;;;1023   
;;;1024       OS_Pend(p_pend_data,
000028  4643              MOV      r3,r8
00002a  2201              MOVS     r2,#1
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       OS_Pend
;;;1025               (OS_PEND_OBJ *)((void *)p_grp),
;;;1026                OS_TASK_PEND_ON_FLAG,
;;;1027                timeout);
;;;1028   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1029   
                          ENDP

                  |L5.56|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_FlagClr||, CODE, READONLY, ALIGN=2

                  OS_FlagClr PROC
;;;1046   
;;;1047   void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
000000  b570              PUSH     {r4-r6,lr}
;;;1048   {
000002  4604              MOV      r4,r0
;;;1049       OS_PEND_LIST  *p_pend_list;
;;;1050   
;;;1051   
;;;1052   #if OS_OBJ_TYPE_REQ > 0u
;;;1053       p_grp->Type             = OS_OBJ_TYPE_NONE;
000004  4805              LDR      r0,|L6.28|
000006  6020              STR      r0,[r4,#0]
;;;1054   #endif
;;;1055   #if OS_CFG_DBG_EN > 0u
;;;1056       p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                       */
000008  a005              ADR      r0,|L6.32|
00000a  6060              STR      r0,[r4,#4]
;;;1057   #endif
;;;1058       p_grp->Flags            = (OS_FLAGS )0;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;1059       p_pend_list             = &p_grp->PendList;
000010  f1040508          ADD      r5,r4,#8
;;;1060       OS_PendListInit(p_pend_list);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       OS_PendListInit
;;;1061   }
00001a  bd70              POP      {r4-r6,pc}
;;;1062   
                          ENDP

                  |L6.28|
                          DCD      0x454e4f4e
                  |L6.32|
000020  3f464c41          DCB      "?FLAG",0
000024  4700    
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||i.OS_FlagDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListAdd PROC
;;;1114   #if OS_CFG_DBG_EN > 0u
;;;1115   void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
000000  a109              ADR      r1,|L7.40|
;;;1116   {
;;;1117       p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;1118       p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;1119       if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
000008  4908              LDR      r1,|L7.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
00000c  b911              CBNZ     r1,|L7.20|
;;;1120           p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L7.32|
                  |L7.20|
;;;1121       } else {
;;;1122           p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
000014  4905              LDR      r1,|L7.44|
000016  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;1123           OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
00001a  4904              LDR      r1,|L7.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSFlagDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L7.32|
;;;1124       }
;;;1125       OSFlagDbgListPtr                 =  p_grp;
000020  4902              LDR      r1,|L7.44|
000022  6008              STR      r0,[r1,#0]  ; OSFlagDbgListPtr
;;;1126   }
000024  4770              BX       lr
;;;1127   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L7.44|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListRemove PROC
;;;1129   
;;;1130   void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
000000  6942              LDR      r2,[r0,#0x14]
;;;1131   {
;;;1132       OS_FLAG_GRP  *p_grp_next;
;;;1133       OS_FLAG_GRP  *p_grp_prev;
;;;1134   
;;;1135   
;;;1136       p_grp_prev = p_grp->DbgPrevPtr;
;;;1137       p_grp_next = p_grp->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;1138   
;;;1139       if (p_grp_prev == (OS_FLAG_GRP *)0) {
000004  b93a              CBNZ     r2,|L8.22|
;;;1140           OSFlagDbgListPtr = p_grp_next;
000006  4b09              LDR      r3,|L8.44|
000008  6019              STR      r1,[r3,#0]  ; OSFlagDbgListPtr
;;;1141           if (p_grp_next != (OS_FLAG_GRP *)0) {
00000a  b109              CBZ      r1,|L8.16|
;;;1142               p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L8.16|
;;;1143           }
;;;1144           p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L8.42|
                  |L8.22|
;;;1145   
;;;1146       } else if (p_grp_next == (OS_FLAG_GRP *)0) {
000016  b919              CBNZ     r1,|L8.32|
;;;1147           p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;1148           p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L8.42|
                  |L8.32|
;;;1149   
;;;1150       } else {
;;;1151           p_grp_prev->DbgNextPtr =  p_grp_next;
000020  6191              STR      r1,[r2,#0x18]
;;;1152           p_grp_next->DbgPrevPtr =  p_grp_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;1153           p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;1154           p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
000028  6143              STR      r3,[r0,#0x14]
                  |L8.42|
;;;1155       }
;;;1156   }
00002a  4770              BX       lr
;;;1157   #endif
                          ENDP

                  |L8.44|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1080   
;;;1081   void  OS_FlagInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;1082   {
;;;1083   #ifdef OS_SAFETY_CRITICAL
;;;1084       if (p_err == (OS_ERR *)0) {
;;;1085           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1086           return;
;;;1087       }
;;;1088   #endif
;;;1089   
;;;1090   #if OS_CFG_DBG_EN > 0u
;;;1091       OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
000002  4a03              LDR      r2,|L9.16|
000004  6011              STR      r1,[r2,#0]  ; OSFlagDbgListPtr
;;;1092   #endif
;;;1093   
;;;1094       OSFlagQty        = (OS_OBJ_QTY   )0;
000006  4a03              LDR      r2,|L9.20|
000008  8011              STRH     r1,[r2,#0]
;;;1095      *p_err            = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;1096   }
00000c  4770              BX       lr
;;;1097   
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      OSFlagDbgListPtr
                  |L9.20|
                          DCD      OSFlagQty

                          AREA ||i.OS_FlagPost||, CODE, READONLY, ALIGN=1

                  OS_FlagPost PROC
;;;1202   
;;;1203   OS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1204                          OS_FLAGS      flags,
;;;1205                          OS_OPT        opt,
;;;1206                          CPU_TS        ts,
;;;1207                          OS_ERR       *p_err)
;;;1208   {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9f0e              LDR      r7,[sp,#0x38]
;;;1209       OS_FLAGS        flags_cur;
;;;1210       OS_FLAGS        flags_rdy;
;;;1211       OS_OPT          mode;
;;;1212       OS_PEND_DATA   *p_pend_data;
;;;1213       OS_PEND_DATA   *p_pend_data_next;
;;;1214       OS_PEND_LIST   *p_pend_list;
;;;1215       OS_TCB         *p_tcb;
;;;1216       CPU_SR_ALLOC();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1217   
;;;1218   
;;;1219   
;;;1220       CPU_CRITICAL_ENTER();
000014  bf00              NOP      
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_SR_Save
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  f7fffffe          BL       CPU_IntDisMeasStart
000024  bf00              NOP      
;;;1221       switch (opt) {
000026  f1b90f00          CMP      r9,#0
00002a  d00a              BEQ      |L10.66|
00002c  f1b90f01          CMP      r9,#1
000030  d00d              BEQ      |L10.78|
000032  f5b94f00          CMP      r9,#0x8000
000036  d005              BEQ      |L10.68|
000038  f46f4000          MVN      r0,#0x8000
00003c  4448              ADD      r0,r0,r9
00003e  b960              CBNZ     r0,|L10.90|
000040  e006              B        |L10.80|
                  |L10.66|
;;;1222           case OS_OPT_POST_FLAG_SET:
;;;1223           case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
000042  bf00              NOP      
                  |L10.68|
;;;1224                p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
000044  6a20              LDR      r0,[r4,#0x20]
000046  ea400008          ORR      r0,r0,r8
00004a  6220              STR      r0,[r4,#0x20]
;;;1225                break;
00004c  e015              B        |L10.122|
                  |L10.78|
;;;1226   
;;;1227           case OS_OPT_POST_FLAG_CLR:
;;;1228           case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
00004e  bf00              NOP      
                  |L10.80|
;;;1229                p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
000050  6a20              LDR      r0,[r4,#0x20]
000052  ea200008          BIC      r0,r0,r8
000056  6220              STR      r0,[r4,#0x20]
;;;1230                break;
000058  e00f              B        |L10.122|
                  |L10.90|
;;;1231   
;;;1232           default:
;;;1233                CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
00005a  bf00              NOP      
00005c  f7fffffe          BL       CPU_IntDisMeasStop
000060  bf00              NOP      
000062  9800              LDR      r0,[sp,#0]
000064  f7fffffe          BL       CPU_SR_Restore
000068  bf00              NOP      
00006a  bf00              NOP      
;;;1234               *p_err = OS_ERR_OPT_INVALID;
00006c  f6456025          MOV      r0,#0x5e25
000070  8038              STRH     r0,[r7,#0]
;;;1235                return ((OS_FLAGS)0);
000072  2000              MOVS     r0,#0
                  |L10.116|
;;;1236       }
;;;1237       p_grp->TS   = ts;
;;;1238       p_pend_list = &p_grp->PendList;
;;;1239       if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
;;;1240           CPU_CRITICAL_EXIT();                                    /* No                                                 */
;;;1241          *p_err = OS_ERR_NONE;
;;;1242           return (p_grp->Flags);
;;;1243       }
;;;1244   
;;;1245       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1246       p_pend_data = p_pend_list->HeadPtr;
;;;1247       p_tcb       = p_pend_data->TCBPtr;
;;;1248       while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
;;;1249           p_pend_data_next = p_pend_data->NextPtr;
;;;1250           mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
;;;1251           switch (mode) {
;;;1252               case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node     */
;;;1253                    flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
;;;1254                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1255                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1256                                       flags_rdy,
;;;1257                                       ts);
;;;1258                    }
;;;1259                    break;
;;;1260   
;;;1261               case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                */
;;;1262                    flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
;;;1263                    if (flags_rdy != (OS_FLAGS)0) {
;;;1264                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1265                                       flags_rdy,
;;;1266                                       ts);
;;;1267                    }
;;;1268                    break;
;;;1269   
;;;1270   #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;1271               case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node     */
;;;1272                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1273                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1274                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1275                                       flags_rdy,
;;;1276                                       ts);
;;;1277                    }
;;;1278                    break;
;;;1279   
;;;1280               case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                */
;;;1281                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1282                    if (flags_rdy != (OS_FLAGS)0) {
;;;1283                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1284                                       flags_rdy,
;;;1285                                       ts);
;;;1286                    }
;;;1287                    break;
;;;1288   #endif
;;;1289               default:
;;;1290                    OS_CRITICAL_EXIT();
;;;1291                   *p_err = OS_ERR_FLAG_PEND_OPT;
;;;1292                    return ((OS_FLAGS)0);
;;;1293           }
;;;1294           p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)       */
;;;1295           if (p_pend_data != (OS_PEND_DATA *)0) {
;;;1296               p_tcb = p_pend_data->TCBPtr;
;;;1297           } else {
;;;1298               p_tcb = (OS_TCB *)0;
;;;1299           }
;;;1300       }
;;;1301       OS_CRITICAL_EXIT_NO_SCHED();
;;;1302   
;;;1303       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1304           OSSched();
;;;1305       }
;;;1306   
;;;1307       CPU_CRITICAL_ENTER();
;;;1308       flags_cur = p_grp->Flags;
;;;1309       CPU_CRITICAL_EXIT();
;;;1310      *p_err     = OS_ERR_NONE;
;;;1311       return (flags_cur);
;;;1312   }
000074  b005              ADD      sp,sp,#0x14
000076  e8bd8ff0          POP      {r4-r11,pc}
                  |L10.122|
00007a  bf00              NOP                            ;1225
00007c  f8c4a024          STR      r10,[r4,#0x24]        ;1237
000080  f1040008          ADD      r0,r4,#8              ;1238
000084  9001              STR      r0,[sp,#4]            ;1238
000086  9801              LDR      r0,[sp,#4]            ;1239
000088  8900              LDRH     r0,[r0,#8]            ;1239
00008a  b960              CBNZ     r0,|L10.166|
00008c  bf00              NOP                            ;1240
00008e  f7fffffe          BL       CPU_IntDisMeasStop
000092  bf00              NOP                            ;1240
000094  9800              LDR      r0,[sp,#0]            ;1240
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP                            ;1240
00009c  bf00              NOP                            ;1240
00009e  2000              MOVS     r0,#0                 ;1241
0000a0  8038              STRH     r0,[r7,#0]            ;1241
0000a2  6a20              LDR      r0,[r4,#0x20]         ;1242
0000a4  e7e6              B        |L10.116|
                  |L10.166|
0000a6  9801              LDR      r0,[sp,#4]            ;1246
0000a8  6806              LDR      r6,[r0,#0]            ;1246
0000aa  68b5              LDR      r5,[r6,#8]            ;1247
0000ac  e03a              B        |L10.292|
                  |L10.174|
0000ae  6870              LDR      r0,[r6,#4]            ;1249
0000b0  9002              STR      r0,[sp,#8]            ;1249
0000b2  f8950084          LDRB     r0,[r5,#0x84]         ;1250
0000b6  f000000f          AND      r0,r0,#0xf            ;1250
0000ba  9003              STR      r0,[sp,#0xc]          ;1250
0000bc  9803              LDR      r0,[sp,#0xc]          ;1251
0000be  2804              CMP      r0,#4                 ;1251
0000c0  d002              BEQ      |L10.200|
0000c2  2808              CMP      r0,#8                 ;1251
0000c4  d11a              BNE      |L10.252|
0000c6  e00c              B        |L10.226|
                  |L10.200|
0000c8  6a20              LDR      r0,[r4,#0x20]         ;1253
0000ca  6fe9              LDR      r1,[r5,#0x7c]         ;1253
0000cc  ea000b01          AND      r11,r0,r1             ;1253
0000d0  6fe8              LDR      r0,[r5,#0x7c]         ;1254
0000d2  4558              CMP      r0,r11                ;1254
0000d4  d104              BNE      |L10.224|
0000d6  4652              MOV      r2,r10                ;1255
0000d8  4659              MOV      r1,r11                ;1255
0000da  4628              MOV      r0,r5                 ;1255
0000dc  f7fffffe          BL       OS_FlagTaskRdy
                  |L10.224|
0000e0  e01a              B        |L10.280|
                  |L10.226|
0000e2  6a20              LDR      r0,[r4,#0x20]         ;1262
0000e4  6fe9              LDR      r1,[r5,#0x7c]         ;1262
0000e6  ea000b01          AND      r11,r0,r1             ;1262
0000ea  f1bb0f00          CMP      r11,#0                ;1263
0000ee  d004              BEQ      |L10.250|
0000f0  4652              MOV      r2,r10                ;1264
0000f2  4659              MOV      r1,r11                ;1264
0000f4  4628              MOV      r0,r5                 ;1264
0000f6  f7fffffe          BL       OS_FlagTaskRdy
                  |L10.250|
0000fa  e00d              B        |L10.280|
                  |L10.252|
0000fc  bf00              NOP                            ;1290
0000fe  f7fffffe          BL       CPU_IntDisMeasStop
000102  bf00              NOP                            ;1290
000104  9800              LDR      r0,[sp,#0]            ;1290
000106  f7fffffe          BL       CPU_SR_Restore
00010a  bf00              NOP                            ;1290
00010c  bf00              NOP                            ;1290
00010e  f64320ff          MOV      r0,#0x3aff            ;1291
000112  8038              STRH     r0,[r7,#0]            ;1291
000114  2000              MOVS     r0,#0                 ;1292
000116  e7ad              B        |L10.116|
                  |L10.280|
000118  bf00              NOP                            ;1259
00011a  9e02              LDR      r6,[sp,#8]            ;1294
00011c  b10e              CBZ      r6,|L10.290|
00011e  68b5              LDR      r5,[r6,#8]            ;1296
000120  e000              B        |L10.292|
                  |L10.290|
000122  2500              MOVS     r5,#0                 ;1298
                  |L10.292|
000124  2d00              CMP      r5,#0                 ;1248
000126  d1c2              BNE      |L10.174|
000128  bf00              NOP                            ;1301
00012a  f7fffffe          BL       CPU_IntDisMeasStop
00012e  bf00              NOP                            ;1301
000130  9800              LDR      r0,[sp,#0]            ;1301
000132  f7fffffe          BL       CPU_SR_Restore
000136  bf00              NOP                            ;1301
000138  bf00              NOP                            ;1301
00013a  f4094000          AND      r0,r9,#0x8000         ;1303
00013e  b908              CBNZ     r0,|L10.324|
000140  f7fffffe          BL       OSSched
                  |L10.324|
000144  bf00              NOP                            ;1307
000146  bf00              NOP                            ;1307
000148  f7fffffe          BL       CPU_SR_Save
00014c  9000              STR      r0,[sp,#0]            ;1307
00014e  bf00              NOP                            ;1307
000150  f7fffffe          BL       CPU_IntDisMeasStart
000154  bf00              NOP                            ;1307
000156  6a20              LDR      r0,[r4,#0x20]         ;1308
000158  9004              STR      r0,[sp,#0x10]         ;1308
00015a  bf00              NOP                            ;1309
00015c  f7fffffe          BL       CPU_IntDisMeasStop
000160  bf00              NOP                            ;1309
000162  9800              LDR      r0,[sp,#0]            ;1309
000164  f7fffffe          BL       CPU_SR_Restore
000168  bf00              NOP                            ;1309
00016a  bf00              NOP                            ;1309
00016c  2000              MOVS     r0,#0                 ;1310
00016e  8038              STRH     r0,[r7,#0]            ;1310
000170  9804              LDR      r0,[sp,#0x10]         ;1311
000172  e77f              B        |L10.116|
;;;1313   
                          ENDP


                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=1

                  OS_FlagTaskRdy PROC
;;;1334   
;;;1335   void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1336                          OS_FLAGS   flags_rdy,
;;;1337                          CPU_TS     ts)
;;;1338   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1339       p_tcb->FlagsRdy   = flags_rdy;
000008  3434              ADDS     r4,r4,#0x34
00000a  64e6              STR      r6,[r4,#0x4c]
;;;1340       p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
00000c  2000              MOVS     r0,#0
00000e  7060              STRB     r0,[r4,#1]
;;;1341       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
000010  7020              STRB     r0,[r4,#0]
;;;1342       p_tcb->TS         = ts;
000012  6165              STR      r5,[r4,#0x14]
;;;1343       switch (p_tcb->TaskState) {
000014  78a0              LDRB     r0,[r4,#2]
000016  3c34              SUBS     r4,r4,#0x34
000018  2808              CMP      r0,#8
00001a  d21d              BCS      |L11.88|
00001c  e8dff000          TBB      [pc,r0]
000020  04050809          DCB      0x04,0x05,0x08,0x09
000024  07061718          DCB      0x07,0x06,0x17,0x18
;;;1344           case OS_TASK_STATE_RDY:
;;;1345           case OS_TASK_STATE_DLY:
000028  bf00              NOP      
;;;1346           case OS_TASK_STATE_DLY_SUSPENDED:
00002a  bf00              NOP      
;;;1347           case OS_TASK_STATE_SUSPENDED:
00002c  bf00              NOP      
;;;1348                break;
00002e  e014              B        |L11.90|
;;;1349   
;;;1350           case OS_TASK_STATE_PEND:
;;;1351           case OS_TASK_STATE_PEND_TIMEOUT:
000030  bf00              NOP      
;;;1352                if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
000032  f8940036          LDRB     r0,[r4,#0x36]
000036  2803              CMP      r0,#3
000038  d102              BNE      |L11.64|
;;;1353                    OS_TickListRemove(p_tcb);                  /* Remove from tick list                                  */
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_TickListRemove
                  |L11.64|
;;;1354                }
;;;1355                OS_RdyListInsert(p_tcb);                       /* Insert the task in the ready list                      */
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       OS_RdyListInsert
;;;1356                p_tcb->TaskState = OS_TASK_STATE_RDY;
000046  2000              MOVS     r0,#0
000048  f8840036          STRB     r0,[r4,#0x36]
;;;1357                break;
00004c  e005              B        |L11.90|
;;;1358   
;;;1359           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1360           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00004e  bf00              NOP      
;;;1361                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
000050  2004              MOVS     r0,#4
000052  f8840036          STRB     r0,[r4,#0x36]
;;;1362                break;
000056  e000              B        |L11.90|
                  |L11.88|
;;;1363   
;;;1364           default:
;;;1365                break;
000058  bf00              NOP      
                  |L11.90|
00005a  bf00              NOP                            ;1348
;;;1366       }
;;;1367       OS_PendListRemove(p_tcb);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       OS_PendListRemove
;;;1368   }
000062  bd70              POP      {r4-r6,pc}
;;;1369   #endif
                          ENDP

