; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\os_mem.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\os_mem.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\os_mem.crf ..\UCOSIII\uCOS-III\Source\os_mem.c]
                          THUMB

                          AREA ||i.OSMemCreate||, CODE, READONLY, ALIGN=2

                  OSMemCreate PROC
;;;76     
;;;77     void  OSMemCreate (OS_MEM       *p_mem,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;78                        CPU_CHAR     *p_name,
;;;79                        void         *p_addr,
;;;80                        OS_MEM_QTY    n_blks,
;;;81                        OS_MEM_SIZE   blk_size,
;;;82                        OS_ERR       *p_err)
;;;83     {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dda030          LDR      r10,[sp,#0x30]
;;;84     #if OS_CFG_ARG_CHK_EN > 0u
;;;85         CPU_DATA       align_msk;
;;;86     #endif
;;;87         OS_MEM_QTY     i;
;;;88         OS_MEM_QTY     loops;
;;;89         CPU_INT08U    *p_blk;
;;;90         void         **p_link;
;;;91         CPU_SR_ALLOC();
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;92     
;;;93     
;;;94     
;;;95     #ifdef OS_SAFETY_CRITICAL
;;;96         if (p_err == (OS_ERR *)0) {
;;;97             OS_SAFETY_CRITICAL_EXCEPTION();
;;;98             return;
;;;99         }
;;;100    #endif
;;;101    
;;;102    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;103        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;104           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;105            return;
;;;106        }
;;;107    #endif
;;;108    
;;;109    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;110        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;111           *p_err = OS_ERR_MEM_CREATE_ISR;
;;;112            return;
;;;113        }
;;;114    #endif
;;;115    
;;;116    #if OS_CFG_ARG_CHK_EN > 0u
;;;117        if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
;;;118           *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
;;;119            return;
;;;120        }
;;;121        if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
;;;122           *p_err = OS_ERR_MEM_INVALID_BLKS;
;;;123            return;
;;;124        }
;;;125        if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
;;;126           *p_err = OS_ERR_MEM_INVALID_SIZE;
;;;127            return;
;;;128        }
;;;129        align_msk = sizeof(void *) - 1u;
;;;130        if (align_msk > 0u) {
;;;131            if (((CPU_ADDR)p_addr & align_msk) != 0u){          /* Must be pointer size aligned                           */
;;;132               *p_err = OS_ERR_MEM_INVALID_P_ADDR;
;;;133                return;
;;;134            }
;;;135            if ((blk_size & align_msk) != 0u) {                 /* Block size must be a multiple address size             */
;;;136               *p_err = OS_ERR_MEM_INVALID_SIZE;
;;;137                return;
;;;138            }
;;;139        }
;;;140    #endif
;;;141    
;;;142        p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
000014  46a8              MOV      r8,r5
;;;143        p_blk  = (CPU_INT08U *)p_addr;
000016  462f              MOV      r7,r5
;;;144        loops  = n_blks - 1u;
000018  1e70              SUBS     r0,r6,#1
00001a  b280              UXTH     r0,r0
00001c  9001              STR      r0,[sp,#4]
;;;145        for (i = 0u; i < loops; i++) {
00001e  f04f0b00          MOV      r11,#0
000022  e007              B        |L1.52|
                  |L1.36|
;;;146            p_blk +=  blk_size;
000024  4457              ADD      r7,r7,r10
;;;147           *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
000026  f8c87000          STR      r7,[r8,#0]
;;;148            p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
00002a  46b8              MOV      r8,r7
00002c  f10b0001          ADD      r0,r11,#1             ;145
000030  fa1ffb80          UXTH     r11,r0                ;145
                  |L1.52|
000034  9801              LDR      r0,[sp,#4]            ;145
000036  4583              CMP      r11,r0                ;145
000038  dbf4              BLT      |L1.36|
;;;149        }
;;;150       *p_link             = (void *)0;                         /* Last memory block points to NULL                       */
00003a  2000              MOVS     r0,#0
00003c  f8c80000          STR      r0,[r8,#0]
;;;151    
;;;152        OS_CRITICAL_ENTER();
000040  bf00              NOP      
000042  bf00              NOP      
000044  f7fffffe          BL       CPU_SR_Save
000048  9000              STR      r0,[sp,#0]
00004a  bf00              NOP      
00004c  f7fffffe          BL       CPU_IntDisMeasStart
000050  bf00              NOP      
;;;153    #if OS_OBJ_TYPE_REQ > 0u
;;;154        p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
000052  4810              LDR      r0,|L1.148|
000054  6020              STR      r0,[r4,#0]
;;;155    #endif
;;;156    #if OS_CFG_DBG_EN > 0u
;;;157        p_mem->NamePtr     = p_name;                            /* Save name of memory partition                          */
000056  f8c49008          STR      r9,[r4,#8]
;;;158    #else
;;;159        (void)&p_name;
;;;160    #endif
;;;161        p_mem->AddrPtr     = p_addr;                            /* Store start address of memory partition                */
00005a  6065              STR      r5,[r4,#4]
;;;162        p_mem->FreeListPtr = p_addr;                            /* Initialize pointer to pool of free blocks              */
00005c  60e5              STR      r5,[r4,#0xc]
;;;163        p_mem->NbrFree     = n_blks;                            /* Store number of free blocks in MCB                     */
00005e  82a6              STRH     r6,[r4,#0x14]
;;;164        p_mem->NbrMax      = n_blks;
000060  8266              STRH     r6,[r4,#0x12]
;;;165        p_mem->BlkSize     = blk_size;                          /* Store block size of each memory blocks                 */
000062  f8a4a010          STRH     r10,[r4,#0x10]
;;;166    
;;;167    #if OS_CFG_DBG_EN > 0u
;;;168        OS_MemDbgListAdd(p_mem);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_MemDbgListAdd
;;;169    #endif
;;;170    
;;;171        OSMemQty++;
00006c  480a              LDR      r0,|L1.152|
00006e  8800              LDRH     r0,[r0,#0]  ; OSMemQty
000070  1c40              ADDS     r0,r0,#1
000072  4909              LDR      r1,|L1.152|
000074  8008              STRH     r0,[r1,#0]
;;;172    
;;;173    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;174        TRACE_OS_MEM_CREATE(p_mem, p_name);                     /* Record the event.                                      */
;;;175    #endif
;;;176    
;;;177        OS_CRITICAL_EXIT_NO_SCHED();
000076  bf00              NOP      
000078  f7fffffe          BL       CPU_IntDisMeasStop
00007c  bf00              NOP      
00007e  9800              LDR      r0,[sp,#0]
000080  f7fffffe          BL       CPU_SR_Restore
000084  bf00              NOP      
000086  bf00              NOP      
;;;178       *p_err = OS_ERR_NONE;
000088  2100              MOVS     r1,#0
00008a  980d              LDR      r0,[sp,#0x34]
00008c  8001              STRH     r1,[r0,#0]
;;;179    }
00008e  e8bd9ffc          POP      {r2-r12,pc}
;;;180    
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x204d454d
                  |L1.152|
                          DCD      OSMemQty

                          AREA ||i.OSMemGet||, CODE, READONLY, ALIGN=1

                  OSMemGet PROC
;;;201    
;;;202    void  *OSMemGet (OS_MEM  *p_mem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;203                     OS_ERR  *p_err)
;;;204    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;205        void    *p_blk;
;;;206        CPU_SR_ALLOC();
000008  2700              MOVS     r7,#0
;;;207    
;;;208    
;;;209    
;;;210    #ifdef OS_SAFETY_CRITICAL
;;;211        if (p_err == (OS_ERR *)0) {
;;;212    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;213            TRACE_OS_MEM_GET_FAILED(p_mem);                     /* Record the event.                                      */
;;;214    #endif
;;;215            OS_SAFETY_CRITICAL_EXCEPTION();
;;;216            return ((void *)0);
;;;217        }
;;;218    #endif
;;;219    
;;;220    #if OS_CFG_ARG_CHK_EN > 0u
;;;221        if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
;;;222    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;223            TRACE_OS_MEM_GET_FAILED(p_mem);                     /* Record the event.                                      */
;;;224    #endif
;;;225           *p_err  = OS_ERR_MEM_INVALID_P_MEM;
;;;226            return ((void *)0);
;;;227        }
;;;228    #endif
;;;229    
;;;230        CPU_CRITICAL_ENTER();
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  f7fffffe          BL       CPU_SR_Save
000012  4607              MOV      r7,r0
000014  bf00              NOP      
000016  f7fffffe          BL       CPU_IntDisMeasStart
00001a  bf00              NOP      
;;;231        if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
00001c  8aa0              LDRH     r0,[r4,#0x14]
00001e  b970              CBNZ     r0,|L2.62|
;;;232            CPU_CRITICAL_EXIT();
000020  bf00              NOP      
000022  f7fffffe          BL       CPU_IntDisMeasStop
000026  bf00              NOP      
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       CPU_SR_Restore
00002e  bf00              NOP      
000030  bf00              NOP      
;;;233    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;234            TRACE_OS_MEM_GET_FAILED(p_mem);                     /* Record the event.                                      */
;;;235    #endif
;;;236           *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
000032  f24560c2          MOV      r0,#0x56c2
000036  8028              STRH     r0,[r5,#0]
;;;237            return ((void *)0);                                 /*      Return NULL pointer to caller                     */
000038  2000              MOVS     r0,#0
                  |L2.58|
;;;238        }
;;;239        p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
;;;240        p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
;;;241        p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
;;;242        CPU_CRITICAL_EXIT();
;;;243    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;244        TRACE_OS_MEM_GET(p_mem);                                /* Record the event.                                      */
;;;245    #endif
;;;246       *p_err = OS_ERR_NONE;                                    /*      No error                                          */
;;;247        return (p_blk);                                         /*      Return memory block to caller                     */
;;;248    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L2.62|
00003e  68e6              LDR      r6,[r4,#0xc]          ;239
000040  6830              LDR      r0,[r6,#0]            ;240
000042  60e0              STR      r0,[r4,#0xc]          ;240
000044  8aa0              LDRH     r0,[r4,#0x14]         ;241
000046  1e40              SUBS     r0,r0,#1              ;241
000048  82a0              STRH     r0,[r4,#0x14]         ;241
00004a  bf00              NOP                            ;242
00004c  f7fffffe          BL       CPU_IntDisMeasStop
000050  bf00              NOP                            ;242
000052  4638              MOV      r0,r7                 ;242
000054  f7fffffe          BL       CPU_SR_Restore
000058  bf00              NOP                            ;242
00005a  bf00              NOP                            ;242
00005c  2000              MOVS     r0,#0                 ;246
00005e  8028              STRH     r0,[r5,#0]            ;246
000060  4630              MOV      r0,r6                 ;247
000062  e7ea              B        |L2.58|
;;;249    
                          ENDP


                          AREA ||i.OSMemPut||, CODE, READONLY, ALIGN=1

                  OSMemPut PROC
;;;270    
;;;271    void  OSMemPut (OS_MEM  *p_mem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;272                    void    *p_blk,
;;;273                    OS_ERR  *p_err)
;;;274    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;275        CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;276    
;;;277    
;;;278    
;;;279    #ifdef OS_SAFETY_CRITICAL
;;;280        if (p_err == (OS_ERR *)0) {
;;;281    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;282            TRACE_OS_MEM_PUT_FAILED(p_mem);                     /* Record the event.                                      */
;;;283    #endif
;;;284            OS_SAFETY_CRITICAL_EXCEPTION();
;;;285            return;
;;;286        }
;;;287    #endif
;;;288    
;;;289    #if OS_CFG_ARG_CHK_EN > 0u
;;;290        if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
;;;291    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;292            TRACE_OS_MEM_PUT_FAILED(p_mem);                     /* Record the event.                                      */
;;;293    #endif
;;;294           *p_err  = OS_ERR_MEM_INVALID_P_MEM;
;;;295            return;
;;;296        }
;;;297        if (p_blk == (void *)0) {                               /* Must release a valid block                             */
;;;298    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;299            TRACE_OS_MEM_PUT_FAILED(p_mem);                     /* Record the event.                                      */
;;;300    #endif
;;;301           *p_err  = OS_ERR_MEM_INVALID_P_BLK;
;;;302            return;
;;;303        }
;;;304    #endif
;;;305    
;;;306        CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_IntDisMeasStart
00001c  bf00              NOP      
;;;307        if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
00001e  8aa0              LDRH     r0,[r4,#0x14]
000020  8a61              LDRH     r1,[r4,#0x12]
000022  4288              CMP      r0,r1
000024  db0d              BLT      |L3.66|
;;;308            CPU_CRITICAL_EXIT();
000026  bf00              NOP      
000028  f7fffffe          BL       CPU_IntDisMeasStop
00002c  bf00              NOP      
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP      
000036  bf00              NOP      
;;;309    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;310            TRACE_OS_MEM_PUT_FAILED(p_mem);                     /* Record the event.                                      */
;;;311    #endif
;;;312           *p_err = OS_ERR_MEM_FULL;
000038  f24560ba          MOV      r0,#0x56ba
00003c  8030              STRH     r0,[r6,#0]
                  |L3.62|
;;;313            return;
;;;314        }
;;;315        *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
;;;316        p_mem->FreeListPtr = p_blk;
;;;317        p_mem->NbrFree++;                                       /* One more memory block in this partition                */
;;;318        CPU_CRITICAL_EXIT();
;;;319    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;320        TRACE_OS_MEM_PUT(p_mem);                                /* Record the event.                                      */
;;;321    #endif
;;;322       *p_err              = OS_ERR_NONE;                       /* Notify caller that memory block was released           */
;;;323    }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L3.66|
000042  68e0              LDR      r0,[r4,#0xc]          ;315
000044  6028              STR      r0,[r5,#0]            ;315
000046  60e5              STR      r5,[r4,#0xc]          ;316
000048  8aa0              LDRH     r0,[r4,#0x14]         ;317
00004a  1c40              ADDS     r0,r0,#1              ;317
00004c  82a0              STRH     r0,[r4,#0x14]         ;317
00004e  bf00              NOP                            ;318
000050  f7fffffe          BL       CPU_IntDisMeasStop
000054  bf00              NOP                            ;318
000056  4638              MOV      r0,r7                 ;318
000058  f7fffffe          BL       CPU_SR_Restore
00005c  bf00              NOP                            ;318
00005e  bf00              NOP                            ;318
000060  2000              MOVS     r0,#0                 ;322
000062  8030              STRH     r0,[r6,#0]            ;322
000064  bf00              NOP      
000066  e7ea              B        |L3.62|
;;;324    
                          ENDP


                          AREA ||i.OS_MemDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MemDbgListAdd PROC
;;;340    #if OS_CFG_DBG_EN > 0u
;;;341    void  OS_MemDbgListAdd (OS_MEM  *p_mem)
000000  2100              MOVS     r1,#0
;;;342    {
;;;343        p_mem->DbgPrevPtr               = (OS_MEM *)0;
000002  6181              STR      r1,[r0,#0x18]
;;;344        if (OSMemDbgListPtr == (OS_MEM *)0) {
000004  4907              LDR      r1,|L4.36|
000006  6809              LDR      r1,[r1,#0]  ; OSMemDbgListPtr
000008  b911              CBNZ     r1,|L4.16|
;;;345            p_mem->DbgNextPtr           = (OS_MEM *)0;
00000a  2100              MOVS     r1,#0
00000c  61c1              STR      r1,[r0,#0x1c]
00000e  e005              B        |L4.28|
                  |L4.16|
;;;346        } else {
;;;347            p_mem->DbgNextPtr           =  OSMemDbgListPtr;
000010  4904              LDR      r1,|L4.36|
000012  6809              LDR      r1,[r1,#0]  ; OSMemDbgListPtr
000014  61c1              STR      r1,[r0,#0x1c]
;;;348            OSMemDbgListPtr->DbgPrevPtr =  p_mem;
000016  4903              LDR      r1,|L4.36|
000018  6809              LDR      r1,[r1,#0]  ; OSMemDbgListPtr
00001a  6188              STR      r0,[r1,#0x18]
                  |L4.28|
;;;349        }
;;;350        OSMemDbgListPtr                 =  p_mem;
00001c  4901              LDR      r1,|L4.36|
00001e  6008              STR      r0,[r1,#0]  ; OSMemDbgListPtr
;;;351    }
000020  4770              BX       lr
;;;352    #endif
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      OSMemDbgListPtr

                          AREA ||i.OS_MemInit||, CODE, READONLY, ALIGN=2

                  OS_MemInit PROC
;;;369    
;;;370    void  OS_MemInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;371    {
;;;372    #ifdef OS_SAFETY_CRITICAL
;;;373        if (p_err == (OS_ERR *)0) {
;;;374            OS_SAFETY_CRITICAL_EXCEPTION();
;;;375            return;
;;;376        }
;;;377    #endif
;;;378    
;;;379    #if OS_CFG_DBG_EN > 0u
;;;380        OSMemDbgListPtr = (OS_MEM   *)0;
000002  4a03              LDR      r2,|L5.16|
000004  6011              STR      r1,[r2,#0]  ; OSMemDbgListPtr
;;;381    #endif
;;;382    
;;;383        OSMemQty        = (OS_OBJ_QTY)0;
000006  4a03              LDR      r2,|L5.20|
000008  8011              STRH     r1,[r2,#0]
;;;384       *p_err           = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;385    }
00000c  4770              BX       lr
;;;386    #endif
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      OSMemDbgListPtr
                  |L5.20|
                          DCD      OSMemQty
