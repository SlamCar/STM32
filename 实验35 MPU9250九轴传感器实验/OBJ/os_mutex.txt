; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\os_mutex.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\os_mutex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\os_mutex.crf ..\UCOSIII\uCOS-III\Source\os_mutex.c]
                          THUMB

                          AREA ||i.OSMutexCreate||, CODE, READONLY, ALIGN=2

                  OSMutexCreate PROC
;;;68     
;;;69     void  OSMutexCreate (OS_MUTEX  *p_mutex,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70                          CPU_CHAR  *p_name,
;;;71                          OS_ERR    *p_err)
;;;72     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;73         CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;74     
;;;75     
;;;76     
;;;77     #ifdef OS_SAFETY_CRITICAL
;;;78         if (p_err == (OS_ERR *)0) {
;;;79             OS_SAFETY_CRITICAL_EXCEPTION();
;;;80             return;
;;;81         }
;;;82     #endif
;;;83     
;;;84     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;85         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;86            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;87             return;
;;;88         }
;;;89     #endif
;;;90     
;;;91     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;92         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
;;;93            *p_err = OS_ERR_CREATE_ISR;
;;;94             return;
;;;95         }
;;;96     #endif
;;;97     
;;;98     #if OS_CFG_ARG_CHK_EN > 0u
;;;99         if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
;;;100           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;101            return;
;;;102        }
;;;103    #endif
;;;104    
;;;105        OS_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_IntDisMeasStart
00001c  bf00              NOP      
;;;106    #if OS_OBJ_TYPE_REQ > 0u
;;;107        p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
00001e  4811              LDR      r0,|L1.100|
000020  6020              STR      r0,[r4,#0]
;;;108    #endif
;;;109    #if OS_CFG_DBG_EN > 0u
;;;110        p_mutex->NamePtr           =  p_name;
000022  6065              STR      r5,[r4,#4]
;;;111    #else
;;;112        (void)&p_name;
;;;113    #endif
;;;114        p_mutex->MutexGrpNextPtr   = (OS_MUTEX     *)0;
000024  2000              MOVS     r0,#0
000026  6220              STR      r0,[r4,#0x20]
;;;115        p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
000028  6260              STR      r0,[r4,#0x24]
;;;116        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
00002a  f8840028          STRB     r0,[r4,#0x28]
;;;117        p_mutex->TS                = (CPU_TS        )0;
00002e  62e0              STR      r0,[r4,#0x2c]
;;;118        OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
000030  f1040008          ADD      r0,r4,#8
000034  f7fffffe          BL       OS_PendListInit
;;;119    
;;;120    #if OS_CFG_DBG_EN > 0u
;;;121        OS_MutexDbgListAdd(p_mutex);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       OS_MutexDbgListAdd
;;;122    #endif
;;;123    
;;;124        OSMutexQty++;
00003e  480a              LDR      r0,|L1.104|
000040  8800              LDRH     r0,[r0,#0]  ; OSMutexQty
000042  1c40              ADDS     r0,r0,#1
000044  4908              LDR      r1,|L1.104|
000046  8008              STRH     r0,[r1,#0]
;;;125    
;;;126    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;127        TRACE_OS_MUTEX_CREATE(p_mutex, p_name);                 /* Record the event.                                      */
;;;128    #endif
;;;129    
;;;130        OS_CRITICAL_EXIT_NO_SCHED();
000048  bf00              NOP      
00004a  f7fffffe          BL       CPU_IntDisMeasStop
00004e  bf00              NOP      
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       CPU_SR_Restore
000056  bf00              NOP      
000058  bf00              NOP      
;;;131       *p_err = OS_ERR_NONE;
00005a  2000              MOVS     r0,#0
00005c  8030              STRH     r0,[r6,#0]
;;;132    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;133    
                          ENDP

000062  0000              DCW      0x0000
                  |L1.100|
                          DCD      0x5854554d
                  |L1.104|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexPend||, CODE, READONLY, ALIGN=2

                  OSMutexPend PROC
;;;346    
;;;347    void  OSMutexPend (OS_MUTEX  *p_mutex,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;348                       OS_TICK    timeout,
;;;349                       OS_OPT     opt,
;;;350                       CPU_TS    *p_ts,
;;;351                       OS_ERR    *p_err)
;;;352    {
000004  b088              SUB      sp,sp,#0x20
000006  4605              MOV      r5,r0
000008  4688              MOV      r8,r1
00000a  4691              MOV      r9,r2
00000c  461c              MOV      r4,r3
00000e  9e10              LDR      r6,[sp,#0x40]
;;;353        OS_PEND_DATA  pend_data;
;;;354        OS_TCB       *p_tcb;
;;;355        CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;356    
;;;357    
;;;358    
;;;359    #ifdef OS_SAFETY_CRITICAL
;;;360        if (p_err == (OS_ERR *)0) {
;;;361    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;362            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;363    #endif
;;;364            OS_SAFETY_CRITICAL_EXCEPTION();
;;;365            return;
;;;366        }
;;;367    #endif
;;;368    
;;;369    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;370        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;371    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;372            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;373    #endif
;;;374           *p_err = OS_ERR_PEND_ISR;
;;;375            return;
;;;376        }
;;;377    #endif
;;;378    
;;;379    #if OS_CFG_ARG_CHK_EN > 0u
;;;380        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate arguments                                     */
;;;381    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;382            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;383    #endif
;;;384           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;385            return;
;;;386        }
;;;387        switch (opt) {                                          /* Validate 'opt'                                         */
;;;388            case OS_OPT_PEND_BLOCKING:
;;;389            case OS_OPT_PEND_NON_BLOCKING:
;;;390                 break;
;;;391    
;;;392            default:
;;;393    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;394                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;395    #endif
;;;396                *p_err = OS_ERR_OPT_INVALID;
;;;397                 return;
;;;398        }
;;;399    #endif
;;;400    
;;;401    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;402        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
000014  4972              LDR      r1,|L2.480|
000016  6828              LDR      r0,[r5,#0]
000018  4288              CMP      r0,r1
00001a  d005              BEQ      |L2.40|
;;;403    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;404            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;405    #endif
;;;406           *p_err = OS_ERR_OBJ_TYPE;
00001c  f64550c4          MOV      r0,#0x5dc4
000020  8030              STRH     r0,[r6,#0]
                  |L2.34|
;;;407            return;
;;;408        }
;;;409    #endif
;;;410    
;;;411        if (p_ts != (CPU_TS *)0) {
;;;412           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
;;;413        }
;;;414    
;;;415        CPU_CRITICAL_ENTER();
;;;416        if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
;;;417            p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
;;;418            p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
;;;419            if (p_ts != (CPU_TS *)0) {
;;;420               *p_ts  = p_mutex->TS;
;;;421            }
;;;422            OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);               /* Add mutex to owner's group                             */
;;;423            CPU_CRITICAL_EXIT();
;;;424    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;425            TRACE_OS_MUTEX_PEND(p_mutex);                       /* Record the event.                                      */
;;;426    #endif
;;;427           *p_err = OS_ERR_NONE;
;;;428            return;
;;;429        }
;;;430    
;;;431        if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
;;;432            if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)-1) {
;;;433                CPU_CRITICAL_EXIT();
;;;434    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;435                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);            /* Record the event.                                      */
;;;436    #endif
;;;437               *p_err = OS_ERR_MUTEX_OVF;
;;;438                return;
;;;439            }
;;;440            p_mutex->OwnerNestingCtr++;
;;;441            if (p_ts != (CPU_TS *)0) {
;;;442               *p_ts  = p_mutex->TS;
;;;443            }
;;;444            CPU_CRITICAL_EXIT();
;;;445    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;446            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;447    #endif
;;;448           *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
;;;449            return;
;;;450        }
;;;451    
;;;452        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;453            CPU_CRITICAL_EXIT();
;;;454    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;455            TRACE_OS_MUTEX_PEND_FAILED(p_mutex);                /* Record the event.                                      */
;;;456    #endif
;;;457           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;458            return;
;;;459        } else {
;;;460            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;461                CPU_CRITICAL_EXIT();
;;;462    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;463                TRACE_OS_MUTEX_PEND_FAILED(p_mutex);            /* Record the event.                                      */
;;;464    #endif
;;;465               *p_err = OS_ERR_SCHED_LOCKED;
;;;466                return;
;;;467            }
;;;468        }
;;;469                                                                /* Lock the scheduler/re-enable interrupts                */
;;;470        OS_CRITICAL_ENTER_CPU_EXIT();
;;;471        p_tcb = p_mutex->OwnerTCBPtr;                           /* Point to the TCB of the Mutex owner                    */
;;;472        if (p_tcb->Prio > OSTCBCurPtr->Prio) {                  /* See if mutex owner has a lower priority than current   */
;;;473            OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
;;;474    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;475                     TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
;;;476    #endif
;;;477        }
;;;478    
;;;479        OS_Pend(&pend_data,                                     /* Block task pending on Mutex                            */
;;;480                (OS_PEND_OBJ *)((void *)p_mutex),
;;;481                 OS_TASK_PEND_ON_MUTEX,
;;;482                 timeout);
;;;483    
;;;484        OS_CRITICAL_EXIT_NO_SCHED();
;;;485    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;486        TRACE_OS_MUTEX_PEND_BLOCK(p_mutex);                     /* Record the event.                                      */
;;;487    #endif
;;;488        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;489    
;;;490        CPU_CRITICAL_ENTER();
;;;491        switch (OSTCBCurPtr->PendStatus) {
;;;492            case OS_STATUS_PEND_OK:                             /* We got the mutex                                       */
;;;493                 if (p_ts != (CPU_TS *)0) {
;;;494                    *p_ts  = OSTCBCurPtr->TS;
;;;495                 }
;;;496    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;497                 TRACE_OS_MUTEX_PEND(p_mutex);                  /* Record the event.                                      */
;;;498    #endif
;;;499                *p_err = OS_ERR_NONE;
;;;500                 break;
;;;501    
;;;502            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;503                 if (p_ts != (CPU_TS *)0) {
;;;504                    *p_ts  = OSTCBCurPtr->TS;
;;;505                 }
;;;506    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;507                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;508    #endif
;;;509                *p_err = OS_ERR_PEND_ABORT;
;;;510                 break;
;;;511    
;;;512            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get mutex within timeout       */
;;;513                 if (p_ts != (CPU_TS *)0) {
;;;514                    *p_ts  = (CPU_TS  )0;
;;;515                 }
;;;516    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;517                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;518    #endif
;;;519                *p_err = OS_ERR_TIMEOUT;
;;;520                 break;
;;;521    
;;;522            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;523                 if (p_ts != (CPU_TS *)0) {
;;;524                    *p_ts  = OSTCBCurPtr->TS;
;;;525                 }
;;;526    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;527                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;528    #endif
;;;529                *p_err = OS_ERR_OBJ_DEL;
;;;530                 break;
;;;531    
;;;532            default:
;;;533    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;534                 TRACE_OS_MUTEX_PEND_FAILED(p_mutex);           /* Record the event.                                      */
;;;535    #endif
;;;536                *p_err = OS_ERR_STATUS_INVALID;
;;;537                 break;
;;;538        }
;;;539        CPU_CRITICAL_EXIT();
;;;540    }
000022  b008              ADD      sp,sp,#0x20
000024  e8bd87f0          POP      {r4-r10,pc}
                  |L2.40|
000028  b10c              CBZ      r4,|L2.46|
00002a  2000              MOVS     r0,#0                 ;412
00002c  6020              STR      r0,[r4,#0]            ;412
                  |L2.46|
00002e  bf00              NOP                            ;415
000030  bf00              NOP                            ;415
000032  f7fffffe          BL       CPU_SR_Save
000036  4682              MOV      r10,r0                ;415
000038  bf00              NOP                            ;415
00003a  f7fffffe          BL       CPU_IntDisMeasStart
00003e  bf00              NOP                            ;415
000040  f8950028          LDRB     r0,[r5,#0x28]         ;416
000044  b9c8              CBNZ     r0,|L2.122|
000046  4867              LDR      r0,|L2.484|
000048  6800              LDR      r0,[r0,#0]            ;417  ; OSTCBCurPtr
00004a  6268              STR      r0,[r5,#0x24]         ;417
00004c  2001              MOVS     r0,#1                 ;418
00004e  f8850028          STRB     r0,[r5,#0x28]         ;418
000052  b10c              CBZ      r4,|L2.88|
000054  6ae8              LDR      r0,[r5,#0x2c]         ;420
000056  6020              STR      r0,[r4,#0]            ;420
                  |L2.88|
000058  4629              MOV      r1,r5                 ;422
00005a  4862              LDR      r0,|L2.484|
00005c  6800              LDR      r0,[r0,#0]            ;422  ; OSTCBCurPtr
00005e  f7fffffe          BL       OS_MutexGrpAdd
000062  bf00              NOP                            ;423
000064  f7fffffe          BL       CPU_IntDisMeasStop
000068  bf00              NOP                            ;423
00006a  4650              MOV      r0,r10                ;423
00006c  f7fffffe          BL       CPU_SR_Restore
000070  bf00              NOP                            ;423
000072  bf00              NOP                            ;423
000074  2000              MOVS     r0,#0                 ;427
000076  8030              STRH     r0,[r6,#0]            ;427
000078  e7d3              B        |L2.34|
                  |L2.122|
00007a  495a              LDR      r1,|L2.484|
00007c  6a68              LDR      r0,[r5,#0x24]         ;431
00007e  6809              LDR      r1,[r1,#0]            ;431  ; OSTCBCurPtr
000080  4288              CMP      r0,r1                 ;431
000082  d125              BNE      |L2.208|
000084  f8950028          LDRB     r0,[r5,#0x28]         ;432
000088  28ff              CMP      r0,#0xff              ;432
00008a  d10c              BNE      |L2.166|
00008c  bf00              NOP                            ;433
00008e  f7fffffe          BL       CPU_IntDisMeasStop
000092  bf00              NOP                            ;433
000094  4650              MOV      r0,r10                ;433
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP                            ;433
00009c  bf00              NOP                            ;433
00009e  f2457084          MOV      r0,#0x5784            ;437
0000a2  8030              STRH     r0,[r6,#0]            ;437
0000a4  e7bd              B        |L2.34|
                  |L2.166|
0000a6  f8950028          LDRB     r0,[r5,#0x28]         ;440
0000aa  1c40              ADDS     r0,r0,#1              ;440
0000ac  f8850028          STRB     r0,[r5,#0x28]         ;440
0000b0  b10c              CBZ      r4,|L2.182|
0000b2  6ae8              LDR      r0,[r5,#0x2c]         ;442
0000b4  6020              STR      r0,[r4,#0]            ;442
                  |L2.182|
0000b6  bf00              NOP                            ;444
0000b8  f7fffffe          BL       CPU_IntDisMeasStop
0000bc  bf00              NOP                            ;444
0000be  4650              MOV      r0,r10                ;444
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  bf00              NOP                            ;444
0000c6  bf00              NOP                            ;444
0000c8  f2457082          MOV      r0,#0x5782            ;448
0000cc  8030              STRH     r0,[r6,#0]            ;448
0000ce  e7a8              B        |L2.34|
                  |L2.208|
0000d0  f4094000          AND      r0,r9,#0x8000         ;452
0000d4  b160              CBZ      r0,|L2.240|
0000d6  bf00              NOP                            ;453
0000d8  f7fffffe          BL       CPU_IntDisMeasStop
0000dc  bf00              NOP                            ;453
0000de  4650              MOV      r0,r10                ;453
0000e0  f7fffffe          BL       CPU_SR_Restore
0000e4  bf00              NOP                            ;453
0000e6  bf00              NOP                            ;453
0000e8  f24610b0          MOV      r0,#0x61b0            ;457
0000ec  8030              STRH     r0,[r6,#0]            ;457
0000ee  e798              B        |L2.34|
                  |L2.240|
0000f0  483d              LDR      r0,|L2.488|
0000f2  7800              LDRB     r0,[r0,#0]            ;460  ; OSSchedLockNestingCtr
0000f4  2800              CMP      r0,#0                 ;460
0000f6  dd0c              BLE      |L2.274|
0000f8  bf00              NOP                            ;461
0000fa  f7fffffe          BL       CPU_IntDisMeasStop
0000fe  bf00              NOP                            ;461
000100  4650              MOV      r0,r10                ;461
000102  f7fffffe          BL       CPU_SR_Restore
000106  bf00              NOP                            ;461
000108  bf00              NOP                            ;461
00010a  f6465063          MOV      r0,#0x6d63            ;465
00010e  8030              STRH     r0,[r6,#0]            ;465
000110  e787              B        |L2.34|
                  |L2.274|
000112  6a6f              LDR      r7,[r5,#0x24]         ;471
000114  f8970037          LDRB     r0,[r7,#0x37]         ;472
000118  4932              LDR      r1,|L2.484|
00011a  6809              LDR      r1,[r1,#0]            ;472  ; OSTCBCurPtr
00011c  f8911037          LDRB     r1,[r1,#0x37]         ;472
000120  4288              CMP      r0,r1                 ;472
000122  dd06              BLE      |L2.306|
000124  482f              LDR      r0,|L2.484|
000126  6800              LDR      r0,[r0,#0]            ;473  ; OSTCBCurPtr
000128  f8901037          LDRB     r1,[r0,#0x37]         ;473
00012c  4638              MOV      r0,r7                 ;473
00012e  f7fffffe          BL       OS_TaskChangePrio
                  |L2.306|
000132  4643              MOV      r3,r8                 ;479
000134  2204              MOVS     r2,#4                 ;479
000136  4629              MOV      r1,r5                 ;479
000138  4668              MOV      r0,sp                 ;479
00013a  f7fffffe          BL       OS_Pend
00013e  bf00              NOP                            ;484
000140  f7fffffe          BL       CPU_IntDisMeasStop
000144  bf00              NOP                            ;484
000146  4650              MOV      r0,r10                ;484
000148  f7fffffe          BL       CPU_SR_Restore
00014c  bf00              NOP                            ;484
00014e  bf00              NOP                            ;484
000150  f7fffffe          BL       OSSched
000154  bf00              NOP                            ;490
000156  bf00              NOP                            ;490
000158  f7fffffe          BL       CPU_SR_Save
00015c  4682              MOV      r10,r0                ;490
00015e  bf00              NOP                            ;490
000160  f7fffffe          BL       CPU_IntDisMeasStart
000164  bf00              NOP                            ;490
000166  481f              LDR      r0,|L2.484|
000168  6800              LDR      r0,[r0,#0]            ;491  ; OSTCBCurPtr
00016a  f8900035          LDRB     r0,[r0,#0x35]         ;491
00016e  b130              CBZ      r0,|L2.382|
000170  2801              CMP      r0,#1                 ;491
000172  d00c              BEQ      |L2.398|
000174  2802              CMP      r0,#2                 ;491
000176  d01a              BEQ      |L2.430|
000178  2803              CMP      r0,#3                 ;491
00017a  d121              BNE      |L2.448|
00017c  e010              B        |L2.416|
                  |L2.382|
00017e  b11c              CBZ      r4,|L2.392|
000180  4818              LDR      r0,|L2.484|
000182  6800              LDR      r0,[r0,#0]            ;494  ; OSTCBCurPtr
000184  6c80              LDR      r0,[r0,#0x48]         ;494
000186  6020              STR      r0,[r4,#0]            ;494
                  |L2.392|
000188  2000              MOVS     r0,#0                 ;499
00018a  8030              STRH     r0,[r6,#0]            ;499
00018c  e01c              B        |L2.456|
                  |L2.398|
00018e  b11c              CBZ      r4,|L2.408|
000190  4814              LDR      r0,|L2.484|
000192  6800              LDR      r0,[r0,#0]            ;504  ; OSTCBCurPtr
000194  6c80              LDR      r0,[r0,#0x48]         ;504
000196  6020              STR      r0,[r4,#0]            ;504
                  |L2.408|
000198  f24610a9          MOV      r0,#0x61a9            ;509
00019c  8030              STRH     r0,[r6,#0]            ;509
00019e  e013              B        |L2.456|
                  |L2.416|
0001a0  b10c              CBZ      r4,|L2.422|
0001a2  2000              MOVS     r0,#0                 ;514
0001a4  6020              STR      r0,[r4,#0]            ;514
                  |L2.422|
0001a6  f24720d9          MOV      r0,#0x72d9            ;519
0001aa  8030              STRH     r0,[r6,#0]            ;519
0001ac  e00c              B        |L2.456|
                  |L2.430|
0001ae  b11c              CBZ      r4,|L2.440|
0001b0  480c              LDR      r0,|L2.484|
0001b2  6800              LDR      r0,[r0,#0]            ;524  ; OSTCBCurPtr
0001b4  6c80              LDR      r0,[r0,#0x48]         ;524
0001b6  6020              STR      r0,[r4,#0]            ;524
                  |L2.440|
0001b8  f64550c2          MOV      r0,#0x5dc2            ;529
0001bc  8030              STRH     r0,[r6,#0]            ;529
0001be  e003              B        |L2.456|
                  |L2.448|
0001c0  f646602e          MOV      r0,#0x6e2e            ;536
0001c4  8030              STRH     r0,[r6,#0]            ;536
0001c6  bf00              NOP                            ;537
                  |L2.456|
0001c8  bf00              NOP                            ;500
0001ca  bf00              NOP                            ;539
0001cc  f7fffffe          BL       CPU_IntDisMeasStop
0001d0  bf00              NOP                            ;539
0001d2  4650              MOV      r0,r10                ;539
0001d4  f7fffffe          BL       CPU_SR_Restore
0001d8  bf00              NOP                            ;539
0001da  bf00              NOP                            ;539
0001dc  bf00              NOP      
0001de  e720              B        |L2.34|
;;;541    
                          ENDP

                  |L2.480|
                          DCD      0x5854554d
                  |L2.484|
                          DCD      OSTCBCurPtr
                  |L2.488|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSMutexPost||, CODE, READONLY, ALIGN=2

                  OSMutexPost PROC
;;;703    
;;;704    void  OSMutexPost (OS_MUTEX  *p_mutex,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;705                       OS_OPT     opt,
;;;706                       OS_ERR    *p_err)
;;;707    {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4615              MOV      r5,r2
;;;708        OS_PEND_LIST  *p_pend_list;
;;;709        OS_TCB        *p_tcb;
;;;710        CPU_TS         ts;
;;;711        OS_PRIO        prio_new;
;;;712        CPU_SR_ALLOC();
00000a  f04f0b00          MOV      r11,#0
;;;713    
;;;714    
;;;715    
;;;716    #ifdef OS_SAFETY_CRITICAL
;;;717        if (p_err == (OS_ERR *)0) {
;;;718    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;719            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;720    #endif
;;;721            OS_SAFETY_CRITICAL_EXCEPTION();
;;;722            return;
;;;723        }
;;;724    #endif
;;;725    
;;;726    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;727        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;728    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;729            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;730    #endif
;;;731           *p_err = OS_ERR_POST_ISR;
;;;732            return;
;;;733        }
;;;734    #endif
;;;735    
;;;736    #if OS_CFG_ARG_CHK_EN > 0u
;;;737        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
;;;738    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;739            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;740    #endif
;;;741           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;742            return;
;;;743        }
;;;744        switch (opt) {                                          /* Validate 'opt'                                         */
;;;745            case OS_OPT_POST_NONE:
;;;746            case OS_OPT_POST_NO_SCHED:
;;;747                 break;
;;;748    
;;;749            default:
;;;750    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;751                 TRACE_OS_MUTEX_POST_FAILED(p_mutex);           /* Record the event.                                      */
;;;752    #endif
;;;753                *p_err =  OS_ERR_OPT_INVALID;
;;;754                 return;
;;;755        }
;;;756    #endif
;;;757    
;;;758    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;759        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
00000e  4958              LDR      r1,|L3.368|
000010  6820              LDR      r0,[r4,#0]
000012  4288              CMP      r0,r1
000014  d004              BEQ      |L3.32|
;;;760    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;761            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;762    #endif
;;;763           *p_err = OS_ERR_OBJ_TYPE;
000016  f64550c4          MOV      r0,#0x5dc4
00001a  8028              STRH     r0,[r5,#0]
                  |L3.28|
;;;764            return;
;;;765        }
;;;766    #endif
;;;767    
;;;768        CPU_CRITICAL_ENTER();
;;;769        if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {              /* Make sure the mutex owner is releasing the mutex       */
;;;770            CPU_CRITICAL_EXIT();
;;;771    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;772            TRACE_OS_MUTEX_POST_FAILED(p_mutex);                /* Record the event.                                      */
;;;773    #endif
;;;774           *p_err = OS_ERR_MUTEX_NOT_OWNER;
;;;775            return;
;;;776        }
;;;777    
;;;778    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;779        TRACE_OS_MUTEX_POST(p_mutex);                           /* Record the event.                                      */
;;;780    #endif
;;;781    
;;;782        OS_CRITICAL_ENTER_CPU_EXIT();
;;;783        ts          = OS_TS_GET();                              /* Get timestamp                                          */
;;;784        p_mutex->TS = ts;
;;;785        p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
;;;786        if (p_mutex->OwnerNestingCtr > (OS_NESTING_CTR)0) {     /* Are we done with all nestings?                         */
;;;787            OS_CRITICAL_EXIT();                                 /* No                                                     */
;;;788           *p_err = OS_ERR_MUTEX_NESTING;
;;;789            return;
;;;790        }
;;;791    
;;;792        OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                /* Remove mutex from owner's group                        */
;;;793    
;;;794        p_pend_list = &p_mutex->PendList;
;;;795        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                             */
;;;796            p_mutex->OwnerTCBPtr     = (OS_TCB       *)0;       /* No                                                     */
;;;797            p_mutex->OwnerNestingCtr = (OS_NESTING_CTR)0;
;;;798            OS_CRITICAL_EXIT();
;;;799           *p_err = OS_ERR_NONE;
;;;800            return;
;;;801        }
;;;802                                                                /* Yes                                                    */
;;;803        if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {       /* Has owner inherited a priority?                        */
;;;804            prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr); /* Yes, find highest priority pending                     */
;;;805            prio_new = prio_new > OSTCBCurPtr->BasePrio ? OSTCBCurPtr->BasePrio : prio_new;
;;;806            if (prio_new > OSTCBCurPtr->Prio) {
;;;807                OS_RdyListRemove(OSTCBCurPtr);
;;;808                OSTCBCurPtr->Prio = prio_new;                   /* Lower owner's priority back to its original one        */
;;;809    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;810                TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
;;;811    #endif
;;;812                OS_PrioInsert(prio_new);
;;;813                OS_RdyListInsertTail(OSTCBCurPtr);              /* Insert owner in ready list at new priority             */
;;;814                OSPrioCur         = prio_new;
;;;815            }
;;;816        }
;;;817                                                                /* Get TCB from head of pend list                         */
;;;818        p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
;;;819        p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
;;;820        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
;;;821        OS_MutexGrpAdd(p_tcb, p_mutex);
;;;822                                                                /* Post to mutex                                          */
;;;823        OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
;;;824                (OS_TCB      *)p_tcb,
;;;825                (void        *)0,
;;;826                (OS_MSG_SIZE  )0,
;;;827                (CPU_TS       )ts);
;;;828    
;;;829        OS_CRITICAL_EXIT_NO_SCHED();
;;;830    
;;;831        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;832            OSSched();                                          /* Run the scheduler                                      */
;;;833        }
;;;834    
;;;835       *p_err = OS_ERR_NONE;
;;;836    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L3.32|
000020  bf00              NOP                            ;768
000022  bf00              NOP                            ;768
000024  f7fffffe          BL       CPU_SR_Save
000028  4683              MOV      r11,r0                ;768
00002a  bf00              NOP                            ;768
00002c  f7fffffe          BL       CPU_IntDisMeasStart
000030  bf00              NOP                            ;768
000032  4950              LDR      r1,|L3.372|
000034  6a60              LDR      r0,[r4,#0x24]         ;769
000036  6809              LDR      r1,[r1,#0]            ;769  ; OSTCBCurPtr
000038  4288              CMP      r0,r1                 ;769
00003a  d00c              BEQ      |L3.86|
00003c  bf00              NOP                            ;770
00003e  f7fffffe          BL       CPU_IntDisMeasStop
000042  bf00              NOP                            ;770
000044  4658              MOV      r0,r11                ;770
000046  f7fffffe          BL       CPU_SR_Restore
00004a  bf00              NOP                            ;770
00004c  bf00              NOP                            ;770
00004e  f2457081          MOV      r0,#0x5781            ;774
000052  8028              STRH     r0,[r5,#0]            ;774
000054  e7e2              B        |L3.28|
                  |L3.86|
000056  f7fffffe          BL       CPU_TS_TmrRd
00005a  4680              MOV      r8,r0                 ;783
00005c  3428              ADDS     r4,r4,#0x28           ;784
00005e  f8c48004          STR      r8,[r4,#4]            ;784
000062  7820              LDRB     r0,[r4,#0]            ;785
000064  1e40              SUBS     r0,r0,#1              ;785
000066  7020              STRB     r0,[r4,#0]            ;785
000068  f8140928          LDRB     r0,[r4],#-0x28        ;786
00006c  2800              CMP      r0,#0                 ;786
00006e  dd0c              BLE      |L3.138|
000070  bf00              NOP                            ;787
000072  f7fffffe          BL       CPU_IntDisMeasStop
000076  bf00              NOP                            ;787
000078  4658              MOV      r0,r11                ;787
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  bf00              NOP                            ;787
000080  bf00              NOP                            ;787
000082  f2457083          MOV      r0,#0x5783            ;788
000086  8028              STRH     r0,[r5,#0]            ;788
000088  e7c8              B        |L3.28|
                  |L3.138|
00008a  4621              MOV      r1,r4                 ;792
00008c  4839              LDR      r0,|L3.372|
00008e  6800              LDR      r0,[r0,#0]            ;792  ; OSTCBCurPtr
000090  f7fffffe          BL       OS_MutexGrpRemove
000094  f1040908          ADD      r9,r4,#8              ;794
000098  f8b90008          LDRH     r0,[r9,#8]            ;795
00009c  b978              CBNZ     r0,|L3.190|
00009e  2000              MOVS     r0,#0                 ;796
0000a0  6260              STR      r0,[r4,#0x24]         ;796
0000a2  f8840028          STRB     r0,[r4,#0x28]         ;797
0000a6  bf00              NOP                            ;798
0000a8  f7fffffe          BL       CPU_IntDisMeasStop
0000ac  bf00              NOP                            ;798
0000ae  4658              MOV      r0,r11                ;798
0000b0  f7fffffe          BL       CPU_SR_Restore
0000b4  bf00              NOP                            ;798
0000b6  bf00              NOP                            ;798
0000b8  2000              MOVS     r0,#0                 ;799
0000ba  8028              STRH     r0,[r5,#0]            ;799
0000bc  e7ae              B        |L3.28|
                  |L3.190|
0000be  482d              LDR      r0,|L3.372|
0000c0  6800              LDR      r0,[r0,#0]            ;803  ; OSTCBCurPtr
0000c2  f8900037          LDRB     r0,[r0,#0x37]         ;803
0000c6  492b              LDR      r1,|L3.372|
0000c8  6809              LDR      r1,[r1,#0]            ;803  ; OSTCBCurPtr
0000ca  f8911038          LDRB     r1,[r1,#0x38]         ;803
0000ce  4288              CMP      r0,r1                 ;803
0000d0  d028              BEQ      |L3.292|
0000d2  4828              LDR      r0,|L3.372|
0000d4  6800              LDR      r0,[r0,#0]            ;804  ; OSTCBCurPtr
0000d6  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000da  4606              MOV      r6,r0                 ;804
0000dc  4825              LDR      r0,|L3.372|
0000de  6800              LDR      r0,[r0,#0]            ;805  ; OSTCBCurPtr
0000e0  f8901038          LDRB     r1,[r0,#0x38]         ;805
0000e4  42b1              CMP      r1,r6                 ;805
0000e6  da04              BGE      |L3.242|
0000e8  4822              LDR      r0,|L3.372|
0000ea  6800              LDR      r0,[r0,#0]            ;805  ; OSTCBCurPtr
0000ec  f8900038          LDRB     r0,[r0,#0x38]         ;805
0000f0  e000              B        |L3.244|
                  |L3.242|
0000f2  4630              MOV      r0,r6                 ;805
                  |L3.244|
0000f4  4606              MOV      r6,r0                 ;805
0000f6  481f              LDR      r0,|L3.372|
0000f8  6800              LDR      r0,[r0,#0]            ;806  ; OSTCBCurPtr
0000fa  f8900037          LDRB     r0,[r0,#0x37]         ;806
0000fe  42b0              CMP      r0,r6                 ;806
000100  da10              BGE      |L3.292|
000102  481c              LDR      r0,|L3.372|
000104  6800              LDR      r0,[r0,#0]            ;807  ; OSTCBCurPtr
000106  f7fffffe          BL       OS_RdyListRemove
00010a  481a              LDR      r0,|L3.372|
00010c  6800              LDR      r0,[r0,#0]            ;808  ; OSTCBCurPtr
00010e  f8806037          STRB     r6,[r0,#0x37]         ;808
000112  4630              MOV      r0,r6                 ;812
000114  f7fffffe          BL       OS_PrioInsert
000118  4816              LDR      r0,|L3.372|
00011a  6800              LDR      r0,[r0,#0]            ;813  ; OSTCBCurPtr
00011c  f7fffffe          BL       OS_RdyListInsertTail
000120  4815              LDR      r0,|L3.376|
000122  7006              STRB     r6,[r0,#0]            ;814
                  |L3.292|
000124  f8d90000          LDR      r0,[r9,#0]            ;818
000128  6887              LDR      r7,[r0,#8]            ;818
00012a  6267              STR      r7,[r4,#0x24]         ;819
00012c  2001              MOVS     r0,#1                 ;820
00012e  f8840028          STRB     r0,[r4,#0x28]         ;820
000132  4621              MOV      r1,r4                 ;821
000134  4638              MOV      r0,r7                 ;821
000136  f7fffffe          BL       OS_MutexGrpAdd
00013a  2300              MOVS     r3,#0                 ;823
00013c  461a              MOV      r2,r3                 ;823
00013e  4639              MOV      r1,r7                 ;823
000140  4620              MOV      r0,r4                 ;823
000142  f8cd8000          STR      r8,[sp,#0]            ;823
000146  f7fffffe          BL       OS_Post
00014a  bf00              NOP                            ;829
00014c  f7fffffe          BL       CPU_IntDisMeasStop
000150  bf00              NOP                            ;829
000152  4658              MOV      r0,r11                ;829
000154  f7fffffe          BL       CPU_SR_Restore
000158  bf00              NOP                            ;829
00015a  bf00              NOP                            ;829
00015c  f40a4000          AND      r0,r10,#0x8000        ;831
000160  b908              CBNZ     r0,|L3.358|
000162  f7fffffe          BL       OSSched
                  |L3.358|
000166  2000              MOVS     r0,#0                 ;835
000168  8028              STRH     r0,[r5,#0]            ;835
00016a  bf00              NOP      
00016c  e756              B        |L3.28|
;;;837    
                          ENDP

00016e  0000              DCW      0x0000
                  |L3.368|
                          DCD      0x5854554d
                  |L3.372|
                          DCD      OSTCBCurPtr
                  |L3.376|
                          DCD      OSPrioCur

                          AREA ||i.OS_MutexClr||, CODE, READONLY, ALIGN=2

                  OS_MutexClr PROC
;;;854    
;;;855    void  OS_MutexClr (OS_MUTEX  *p_mutex)
000000  b510              PUSH     {r4,lr}
;;;856    {
000002  4604              MOV      r4,r0
;;;857    #if OS_OBJ_TYPE_REQ > 0u
;;;858        p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
000004  4807              LDR      r0,|L4.36|
000006  6020              STR      r0,[r4,#0]
;;;859    #endif
;;;860    #if OS_CFG_DBG_EN > 0u
;;;861        p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
000008  a007              ADR      r0,|L4.40|
00000a  6060              STR      r0,[r4,#4]
;;;862    #endif
;;;863        p_mutex->MutexGrpNextPtr   = (OS_MUTEX     *)0;
00000c  2000              MOVS     r0,#0
00000e  6220              STR      r0,[r4,#0x20]
;;;864        p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
000010  6260              STR      r0,[r4,#0x24]
;;;865        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
000012  f8840028          STRB     r0,[r4,#0x28]
;;;866        p_mutex->TS                = (CPU_TS        )0;
000016  62e0              STR      r0,[r4,#0x2c]
;;;867        OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
000018  f1040008          ADD      r0,r4,#8
00001c  f7fffffe          BL       OS_PendListInit
;;;868    }
000020  bd10              POP      {r4,pc}
;;;869    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x454e4f4e
                  |L4.40|
000028  3f4d5554          DCB      "?MUTEX",0
00002c  455800  
00002f  00                DCB      0

                          AREA ||i.OS_MutexDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListAdd PROC
;;;886    #if OS_CFG_DBG_EN > 0u
;;;887    void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
000000  a109              ADR      r1,|L5.40|
;;;888    {
;;;889        p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
000002  61c1              STR      r1,[r0,#0x1c]
;;;890        p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
000004  2100              MOVS     r1,#0
000006  6141              STR      r1,[r0,#0x14]
;;;891        if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
000008  4908              LDR      r1,|L5.44|
00000a  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00000c  b911              CBNZ     r1,|L5.20|
;;;892            p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
00000e  2100              MOVS     r1,#0
000010  6181              STR      r1,[r0,#0x18]
000012  e005              B        |L5.32|
                  |L5.20|
;;;893        } else {
;;;894            p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
000014  4905              LDR      r1,|L5.44|
000016  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
000018  6181              STR      r1,[r0,#0x18]
;;;895            OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
00001a  4904              LDR      r1,|L5.44|
00001c  6809              LDR      r1,[r1,#0]  ; OSMutexDbgListPtr
00001e  6148              STR      r0,[r1,#0x14]
                  |L5.32|
;;;896        }
;;;897        OSMutexDbgListPtr                 =  p_mutex;
000020  4902              LDR      r1,|L5.44|
000022  6008              STR      r0,[r1,#0]  ; OSMutexDbgListPtr
;;;898    }
000024  4770              BX       lr
;;;899    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
000028  2000              DCB      " ",0
00002a  00                DCB      0
00002b  00                DCB      0
                  |L5.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListRemove PROC
;;;901    
;;;902    void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
000000  6942              LDR      r2,[r0,#0x14]
;;;903    {
;;;904        OS_MUTEX  *p_mutex_next;
;;;905        OS_MUTEX  *p_mutex_prev;
;;;906    
;;;907    
;;;908        p_mutex_prev = p_mutex->DbgPrevPtr;
;;;909        p_mutex_next = p_mutex->DbgNextPtr;
000002  6981              LDR      r1,[r0,#0x18]
;;;910    
;;;911        if (p_mutex_prev == (OS_MUTEX *)0) {
000004  b93a              CBNZ     r2,|L6.22|
;;;912            OSMutexDbgListPtr = p_mutex_next;
000006  4b09              LDR      r3,|L6.44|
000008  6019              STR      r1,[r3,#0]  ; OSMutexDbgListPtr
;;;913            if (p_mutex_next != (OS_MUTEX *)0) {
00000a  b109              CBZ      r1,|L6.16|
;;;914                p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
00000c  2300              MOVS     r3,#0
00000e  614b              STR      r3,[r1,#0x14]
                  |L6.16|
;;;915            }
;;;916            p_mutex->DbgNextPtr = (OS_MUTEX *)0;
000010  2300              MOVS     r3,#0
000012  6183              STR      r3,[r0,#0x18]
000014  e009              B        |L6.42|
                  |L6.22|
;;;917    
;;;918        } else if (p_mutex_next == (OS_MUTEX *)0) {
000016  b919              CBNZ     r1,|L6.32|
;;;919            p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
000018  2300              MOVS     r3,#0
00001a  6193              STR      r3,[r2,#0x18]
;;;920            p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
00001c  6143              STR      r3,[r0,#0x14]
00001e  e004              B        |L6.42|
                  |L6.32|
;;;921    
;;;922        } else {
;;;923            p_mutex_prev->DbgNextPtr =  p_mutex_next;
000020  6191              STR      r1,[r2,#0x18]
;;;924            p_mutex_next->DbgPrevPtr =  p_mutex_prev;
000022  614a              STR      r2,[r1,#0x14]
;;;925            p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
000024  2300              MOVS     r3,#0
000026  6183              STR      r3,[r0,#0x18]
;;;926            p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
000028  6143              STR      r3,[r0,#0x14]
                  |L6.42|
;;;927        }
;;;928    }
00002a  4770              BX       lr
;;;929    #endif
                          ENDP

                  |L6.44|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexGrpAdd||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpAdd PROC
;;;984    
;;;985    void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;986    {
;;;987        p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
000002  620a              STR      r2,[r1,#0x20]
;;;988        p_tcb->MutexGrpHeadPtr   = p_mutex;
000004  63c1              STR      r1,[r0,#0x3c]
;;;989    }
000006  4770              BX       lr
;;;990    
                          ENDP


                          AREA ||i.OS_MutexGrpPostAll||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPostAll PROC
;;;1082   
;;;1083   void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1084   {
000004  4605              MOV      r5,r0
;;;1085       OS_MUTEX      *p_mutex;
;;;1086       OS_MUTEX      *p_mutex_next;
;;;1087       CPU_TS         ts;
;;;1088       OS_PEND_LIST  *p_pend_list;
;;;1089       OS_TCB        *p_tcb_new;
;;;1090   
;;;1091   
;;;1092       p_mutex = p_tcb->MutexGrpHeadPtr;
000006  6bec              LDR      r4,[r5,#0x3c]
;;;1093   
;;;1094       while(p_mutex != (OS_MUTEX *)0) {
000008  e026              B        |L8.88|
                  |L8.10|
;;;1095   
;;;1096   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1097       TRACE_OS_MUTEX_POST(p_mutex);                               /* Record the event.                                    */
;;;1098   #endif
;;;1099   
;;;1100           p_mutex_next = p_mutex->MutexGrpNextPtr;
00000a  f8d49020          LDR      r9,[r4,#0x20]
;;;1101           ts           = OS_TS_GET();                             /* Get timestamp                                        */
00000e  f7fffffe          BL       CPU_TS_TmrRd
000012  4606              MOV      r6,r0
;;;1102           p_mutex->TS  = ts;
000014  62e6              STR      r6,[r4,#0x2c]
;;;1103           OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
000016  4621              MOV      r1,r4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       OS_MutexGrpRemove
;;;1104   
;;;1105           p_pend_list = &p_mutex->PendList;
00001e  f1040808          ADD      r8,r4,#8
;;;1106           if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                           */
000022  f8b80008          LDRH     r0,[r8,#8]
000026  b920              CBNZ     r0,|L8.50|
;;;1107               p_mutex->OwnerNestingCtr =           0u;            /* Decrement owner's nesting counter                    */
000028  2000              MOVS     r0,#0
00002a  f8840028          STRB     r0,[r4,#0x28]
;;;1108               p_mutex->OwnerTCBPtr     = (OS_TCB *)0;             /* No                                                   */
00002e  6260              STR      r0,[r4,#0x24]
000030  e011              B        |L8.86|
                  |L8.50|
;;;1109           } else {
;;;1110                                                                   /* Get TCB from head of pend list                       */
;;;1111               p_tcb_new = p_pend_list->HeadPtr->TCBPtr;
000032  f8d80000          LDR      r0,[r8,#0]
000036  6887              LDR      r7,[r0,#8]
;;;1112               p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
000038  6265              STR      r5,[r4,#0x24]
;;;1113               p_mutex->OwnerNestingCtr = 1u;
00003a  2001              MOVS     r0,#1
00003c  f8840028          STRB     r0,[r4,#0x28]
;;;1114               OS_MutexGrpAdd(p_tcb_new, p_mutex);
000040  4621              MOV      r1,r4
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       OS_MutexGrpAdd
;;;1115                                                                   /* Post to mutex                                        */
;;;1116               OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
000048  2300              MOVS     r3,#0
00004a  461a              MOV      r2,r3
00004c  4639              MOV      r1,r7
00004e  4620              MOV      r0,r4
000050  9600              STR      r6,[sp,#0]
000052  f7fffffe          BL       OS_Post
                  |L8.86|
;;;1117                                               p_tcb_new,
;;;1118                                       (void *)0,
;;;1119                                               0u,
;;;1120                                               ts);
;;;1121           }
;;;1122   
;;;1123           p_mutex = p_mutex_next;
000056  464c              MOV      r4,r9
                  |L8.88|
000058  2c00              CMP      r4,#0                 ;1094
00005a  d1d6              BNE      |L8.10|
;;;1124       }
;;;1125   
;;;1126   }
00005c  e8bd83f8          POP      {r3-r9,pc}
;;;1127   
                          ENDP


                          AREA ||i.OS_MutexGrpPrioFindHighest||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpPrioFindHighest PROC
;;;1039   
;;;1040   OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
000000  b530              PUSH     {r4,r5,lr}
;;;1041   {
000002  4604              MOV      r4,r0
;;;1042       OS_MUTEX     **pp_mutex;
;;;1043       OS_PRIO        highest_prio;
;;;1044       OS_PRIO        prio;
;;;1045       OS_PEND_DATA  *p_head;
;;;1046   
;;;1047   
;;;1048       highest_prio = OS_CFG_PRIO_MAX - 1u;
000004  203f              MOVS     r0,#0x3f
;;;1049       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000006  f104013c          ADD      r1,r4,#0x3c
;;;1050   
;;;1051       while(*pp_mutex != (OS_MUTEX *)0) {
00000a  e00b              B        |L9.36|
                  |L9.12|
;;;1052           p_head = (*pp_mutex)->PendList.HeadPtr;
00000c  680d              LDR      r5,[r1,#0]
00000e  68ab              LDR      r3,[r5,#8]
;;;1053           if (p_head!= (OS_PEND_DATA *)0) {
000010  b12b              CBZ      r3,|L9.30|
;;;1054               prio = p_head->TCBPtr->Prio;
000012  689d              LDR      r5,[r3,#8]
000014  f8952037          LDRB     r2,[r5,#0x37]
;;;1055               if(prio < highest_prio) {
000018  4282              CMP      r2,r0
00001a  da00              BGE      |L9.30|
;;;1056                   highest_prio = prio;
00001c  4610              MOV      r0,r2
                  |L9.30|
;;;1057               }
;;;1058           }
;;;1059           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
00001e  680d              LDR      r5,[r1,#0]
000020  f1050120          ADD      r1,r5,#0x20
                  |L9.36|
000024  680d              LDR      r5,[r1,#0]            ;1051
000026  2d00              CMP      r5,#0                 ;1051
000028  d1f0              BNE      |L9.12|
;;;1060       }
;;;1061   
;;;1062       return (highest_prio);
;;;1063   }
00002a  bd30              POP      {r4,r5,pc}
;;;1064   
                          ENDP


                          AREA ||i.OS_MutexGrpRemove||, CODE, READONLY, ALIGN=1

                  OS_MutexGrpRemove PROC
;;;1009   
;;;1010   void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
000000  4602              MOV      r2,r0
;;;1011   {
;;;1012       OS_MUTEX  **pp_mutex;
;;;1013   
;;;1014       pp_mutex = &p_tcb->MutexGrpHeadPtr;
000002  f102003c          ADD      r0,r2,#0x3c
;;;1015   
;;;1016       while(*pp_mutex != p_mutex) {
000006  e002              B        |L10.14|
                  |L10.8|
;;;1017           pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
000008  6803              LDR      r3,[r0,#0]
00000a  f1030020          ADD      r0,r3,#0x20
                  |L10.14|
00000e  6803              LDR      r3,[r0,#0]            ;1016
000010  428b              CMP      r3,r1                 ;1016
000012  d1f9              BNE      |L10.8|
;;;1018       }
;;;1019   
;;;1020       *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
000014  6803              LDR      r3,[r0,#0]
000016  6a1b              LDR      r3,[r3,#0x20]
000018  6003              STR      r3,[r0,#0]
;;;1021   }
00001a  4770              BX       lr
;;;1022   
                          ENDP


                          AREA ||i.OS_MutexInit||, CODE, READONLY, ALIGN=2

                  OS_MutexInit PROC
;;;948    
;;;949    void  OS_MutexInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;950    {
;;;951    #ifdef OS_SAFETY_CRITICAL
;;;952        if (p_err == (OS_ERR *)0) {
;;;953            OS_SAFETY_CRITICAL_EXCEPTION();
;;;954            return;
;;;955        }
;;;956    #endif
;;;957    
;;;958    #if OS_CFG_DBG_EN > 0u
;;;959        OSMutexDbgListPtr = (OS_MUTEX *)0;
000002  4a03              LDR      r2,|L11.16|
000004  6011              STR      r1,[r2,#0]  ; OSMutexDbgListPtr
;;;960    #endif
;;;961    
;;;962        OSMutexQty        = (OS_OBJ_QTY)0;
000006  4a03              LDR      r2,|L11.20|
000008  8011              STRH     r1,[r2,#0]
;;;963       *p_err             =  OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;964    }
00000c  4770              BX       lr
;;;965    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      OSMutexDbgListPtr
                  |L11.20|
                          DCD      OSMutexQty
