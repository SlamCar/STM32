; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\os_task.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\os_task.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\os_task.crf ..\UCOSIII\uCOS-III\Source\os_task.c]
                          THUMB

                          AREA ||i.OSTaskChangePrio||, CODE, READONLY, ALIGN=2

                  OSTaskChangePrio PROC
;;;65     #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
;;;66     void  OSTaskChangePrio (OS_TCB   *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;67                             OS_PRIO   prio_new,
;;;68                             OS_ERR   *p_err)
;;;69     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;70     #if OS_CFG_MUTEX_EN > 0u
;;;71         OS_PRIO  prio_high;
;;;72     #endif
;;;73         CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;74     
;;;75     
;;;76     #ifdef OS_SAFETY_CRITICAL
;;;77         if (p_err == (OS_ERR *)0) {
;;;78             OS_SAFETY_CRITICAL_EXCEPTION();
;;;79             return;
;;;80         }
;;;81     #endif
;;;82     
;;;83     #if OS_CFG_ARG_CHK_EN > 0u
;;;84         if ((p_tcb != (OS_TCB *)0u) && (p_tcb->TaskState == OS_TASK_STATE_DEL)) {
;;;85            *p_err = OS_ERR_STATE_INVALID;
;;;86         }
;;;87     #endif
;;;88     
;;;89     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;90         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;91            *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
;;;92             return;
;;;93         }
;;;94     #endif
;;;95     
;;;96     #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;97         if (prio_new == 0) {                                    /* Cannot set to IntQueue Task priority                   */
;;;98            *p_err = OS_ERR_PRIO_INVALID;
;;;99             return;
;;;100        }
;;;101    #endif
;;;102    
;;;103        if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
00000e  2d3f              CMP      r5,#0x3f
000010  d304              BCC      |L1.28|
;;;104           *p_err = OS_ERR_PRIO_INVALID;
000012  f2462073          MOV      r0,#0x6273
000016  8038              STRH     r0,[r7,#0]
                  |L1.24|
;;;105            return;
;;;106        }
;;;107    
;;;108        if (p_tcb == (OS_TCB *)0) {                             /* Are we changing the priority of 'self'?                */
;;;109            CPU_CRITICAL_ENTER();
;;;110            p_tcb = OSTCBCurPtr;
;;;111            CPU_CRITICAL_EXIT();
;;;112        }
;;;113    
;;;114        OS_CRITICAL_ENTER();
;;;115    
;;;116    #if OS_CFG_MUTEX_EN > 0u
;;;117        p_tcb->BasePrio = prio_new;                             /* Update base priority                                   */
;;;118    
;;;119        if (p_tcb->MutexGrpHeadPtr != (OS_MUTEX *)0) {              /* Owning a mutex?                                      */
;;;120            if (prio_new > p_tcb->Prio) {
;;;121                prio_high = OS_MutexGrpPrioFindHighest(p_tcb);
;;;122                if (prio_new > prio_high) {
;;;123                    prio_new = prio_high;
;;;124                }
;;;125            }
;;;126        }
;;;127    #endif
;;;128    
;;;129        OS_TaskChangePrio(p_tcb, prio_new);
;;;130    
;;;131        OS_CRITICAL_EXIT_NO_SCHED();
;;;132    
;;;133        OSSched();                                              /* Run highest priority task ready                        */
;;;134    
;;;135       *p_err = OS_ERR_NONE;
;;;136    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L1.28|
00001c  b99c              CBNZ     r4,|L1.70|
00001e  bf00              NOP                            ;109
000020  bf00              NOP                            ;109
000022  f7fffffe          BL       CPU_SR_Save
000026  4680              MOV      r8,r0                 ;109
000028  bf00              NOP                            ;109
00002a  f7fffffe          BL       CPU_IntDisMeasStart
00002e  bf00              NOP                            ;109
000030  481a              LDR      r0,|L1.156|
000032  6804              LDR      r4,[r0,#0]            ;110  ; OSTCBCurPtr
000034  bf00              NOP                            ;111
000036  f7fffffe          BL       CPU_IntDisMeasStop
00003a  bf00              NOP                            ;111
00003c  4640              MOV      r0,r8                 ;111
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;111
000044  bf00              NOP                            ;111
                  |L1.70|
000046  bf00              NOP                            ;114
000048  bf00              NOP                            ;114
00004a  f7fffffe          BL       CPU_SR_Save
00004e  4680              MOV      r8,r0                 ;114
000050  bf00              NOP                            ;114
000052  f7fffffe          BL       CPU_IntDisMeasStart
000056  bf00              NOP                            ;114
000058  f8845038          STRB     r5,[r4,#0x38]         ;117
00005c  6be0              LDR      r0,[r4,#0x3c]         ;119
00005e  b150              CBZ      r0,|L1.118|
000060  f8940037          LDRB     r0,[r4,#0x37]         ;120
000064  42a8              CMP      r0,r5                 ;120
000066  da06              BGE      |L1.118|
000068  4620              MOV      r0,r4                 ;121
00006a  f7fffffe          BL       OS_MutexGrpPrioFindHighest
00006e  4606              MOV      r6,r0                 ;121
000070  42b5              CMP      r5,r6                 ;122
000072  dd00              BLE      |L1.118|
000074  4635              MOV      r5,r6                 ;123
                  |L1.118|
000076  4629              MOV      r1,r5                 ;129
000078  4620              MOV      r0,r4                 ;129
00007a  f7fffffe          BL       OS_TaskChangePrio
00007e  bf00              NOP                            ;131
000080  f7fffffe          BL       CPU_IntDisMeasStop
000084  bf00              NOP                            ;131
000086  4640              MOV      r0,r8                 ;131
000088  f7fffffe          BL       CPU_SR_Restore
00008c  bf00              NOP                            ;131
00008e  bf00              NOP                            ;131
000090  f7fffffe          BL       OSSched
000094  2000              MOVS     r0,#0                 ;135
000096  8038              STRH     r0,[r7,#0]            ;135
000098  bf00              NOP      
00009a  e7bd              B        |L1.24|
;;;137    #endif
                          ENDP

                  |L1.156|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;224    
;;;225    void  OSTaskCreate (OS_TCB        *p_tcb,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;226                        CPU_CHAR      *p_name,
;;;227                        OS_TASK_PTR    p_task,
;;;228                        void          *p_arg,
;;;229                        OS_PRIO        prio,
;;;230                        CPU_STK       *p_stk_base,
;;;231                        CPU_STK_SIZE   stk_limit,
;;;232                        CPU_STK_SIZE   stk_size,
;;;233                        OS_MSG_QTY     q_size,
;;;234                        OS_TICK        time_quanta,
;;;235                        void          *p_ext,
;;;236                        OS_OPT         opt,
;;;237                        OS_ERR        *p_err)
;;;238    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  4691              MOV      r9,r2
00000a  f8ddb054          LDR      r11,[sp,#0x54]
00000e  e9dda512          LDRD     r10,r5,[sp,#0x48]
000012  9e19              LDR      r6,[sp,#0x64]
;;;239        CPU_STK_SIZE   i;
;;;240    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;241        OS_REG_ID      reg_nbr;
;;;242    #endif
;;;243    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;244        OS_TLS_ID      id;
;;;245    #endif
;;;246    
;;;247        CPU_STK       *p_sp;
;;;248        CPU_STK       *p_stk_limit;
;;;249        CPU_SR_ALLOC();
000014  2000              MOVS     r0,#0
000016  9002              STR      r0,[sp,#8]
;;;250    
;;;251    
;;;252    
;;;253    #ifdef OS_SAFETY_CRITICAL
;;;254        if (p_err == (OS_ERR *)0) {
;;;255    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;256            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;257    #endif
;;;258            OS_SAFETY_CRITICAL_EXCEPTION();
;;;259            return;
;;;260        }
;;;261    #endif
;;;262    
;;;263    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;264        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;265    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;266            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;267    #endif
;;;268           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;269            return;
;;;270        }
;;;271    #endif
;;;272    
;;;273    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;274        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
;;;275    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;276            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;277    #endif
;;;278           *p_err = OS_ERR_TASK_CREATE_ISR;
;;;279            return;
;;;280        }
;;;281    #endif
;;;282    
;;;283    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;284        if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
;;;285    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;286            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;287    #endif
;;;288           *p_err = OS_ERR_TCB_INVALID;
;;;289            return;
;;;290        }
;;;291        if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
;;;292    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;293            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;294    #endif
;;;295           *p_err = OS_ERR_TASK_INVALID;
;;;296            return;
;;;297        }
;;;298        if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
;;;299    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;300            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;301    #endif
;;;302           *p_err = OS_ERR_STK_INVALID;
;;;303            return;
;;;304        }
;;;305        if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
;;;306    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;307            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;308    #endif
;;;309           *p_err = OS_ERR_STK_SIZE_INVALID;
;;;310            return;
;;;311        }
;;;312        if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
;;;313    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;314            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;315    #endif
;;;316           *p_err = OS_ERR_STK_LIMIT_INVALID;
;;;317            return;
;;;318        }
;;;319        if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
;;;320    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;321            TRACE_OS_TASK_CREATE_FAILED(p_tcb);                 /* Record the event.                                      */
;;;322    #endif
;;;323           *p_err = OS_ERR_PRIO_INVALID;
;;;324            return;
;;;325        }
;;;326    #endif
;;;327    
;;;328    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;329        if (prio == (OS_PRIO)0) {
;;;330            if (p_tcb != &OSIntQTaskTCB) {
;;;331    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;332                TRACE_OS_TASK_CREATE_FAILED(p_tcb);             /* Record the event.                                      */
;;;333    #endif
;;;334               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use priority 0                          */
;;;335                return;
;;;336            }
;;;337        }
;;;338    #endif
;;;339    
;;;340        if (prio == (OS_CFG_PRIO_MAX - 1u)) {
000018  f1ba0f3f          CMP      r10,#0x3f
00001c  d109              BNE      |L2.50|
;;;341            if (p_tcb != &OSIdleTaskTCB) {
00001e  4846              LDR      r0,|L2.312|
000020  4284              CMP      r4,r0
000022  d006              BEQ      |L2.50|
;;;342    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;343                TRACE_OS_TASK_CREATE_FAILED(p_tcb);             /* Record the event.                                      */
;;;344    #endif
;;;345               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
000024  f2462173          MOV      r1,#0x6273
000028  981a              LDR      r0,[sp,#0x68]
00002a  8001              STRH     r1,[r0,#0]
                  |L2.44|
;;;346                return;
;;;347            }
;;;348        }
;;;349    
;;;350        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;351    
;;;352       *p_err = OS_ERR_NONE;
;;;353                                                                /* --------------- CLEAR THE TASK'S STACK --------------- */
;;;354        if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
;;;355            if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
;;;356                p_sp = p_stk_base;
;;;357                for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
;;;358                   *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
;;;359                    p_sp++;
;;;360                }
;;;361            }
;;;362        }
;;;363                                                                /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
;;;364    #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
;;;365        p_stk_limit = p_stk_base + stk_limit;
;;;366    #else
;;;367        p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
;;;368    #endif
;;;369    
;;;370        p_sp = OSTaskStkInit(p_task,
;;;371                             p_arg,
;;;372                             p_stk_base,
;;;373                             p_stk_limit,
;;;374                             stk_size,
;;;375                             opt);
;;;376    
;;;377                                                                /* -------------- INITIALIZE THE TCB FIELDS ------------- */
;;;378    #if OS_CFG_DBG_EN > 0u
;;;379        p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
;;;380        p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
;;;381    #endif
;;;382    
;;;383    #if OS_CFG_DBG_EN > 0u
;;;384        p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
;;;385    #else
;;;386        (void)&p_name;
;;;387    #endif
;;;388    
;;;389        p_tcb->Prio          = prio;                            /* Save the task's priority                               */
;;;390    
;;;391    #if OS_CFG_MUTEX_EN > 0u
;;;392        p_tcb->BasePrio      = prio;                            /* Set the base priority                                  */
;;;393    #endif
;;;394    
;;;395        p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
;;;396    #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;397        p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
;;;398    #endif
;;;399    
;;;400    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;401        p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
;;;402        if (time_quanta == (OS_TICK)0) {
;;;403            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;404        } else {
;;;405            p_tcb->TimeQuantaCtr = time_quanta;
;;;406        }
;;;407    #else
;;;408        (void)&time_quanta;
;;;409    #endif
;;;410    
;;;411        p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
;;;412    #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;413        p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
;;;414        p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
;;;415    #endif
;;;416        p_tcb->Opt           = opt;                             /* Save task options                                      */
;;;417    
;;;418    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;419        for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
;;;420            p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
;;;421        }
;;;422    #endif
;;;423    
;;;424    #if OS_CFG_TASK_Q_EN > 0u
;;;425        OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
;;;426                    q_size);
;;;427    #else
;;;428        (void)&q_size;
;;;429    #endif
;;;430    
;;;431        OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
;;;432    
;;;433    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;434        TRACE_OS_TASK_CREATE(p_tcb);                            /* Record the event.                                      */
;;;435        TRACE_OS_TASK_SEM_CREATE(p_tcb, p_name);                /* Record the event.                                      */
;;;436    #if OS_CFG_TASK_Q_EN > 0u
;;;437        TRACE_OS_TASK_MSG_Q_CREATE(&p_tcb->MsgQ, p_name);       /* Record the event.                                      */
;;;438    #endif
;;;439    #endif
;;;440    
;;;441    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;442        for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;443            p_tcb->TLS_Tbl[id] = (OS_TLS)0;
;;;444        }
;;;445        OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
;;;446    #endif
;;;447                                                                /* --------------- ADD TASK TO READY LIST --------------- */
;;;448        OS_CRITICAL_ENTER();
;;;449        OS_PrioInsert(p_tcb->Prio);
;;;450        OS_RdyListInsertTail(p_tcb);
;;;451    
;;;452    #if OS_CFG_DBG_EN > 0u
;;;453        OS_TaskDbgListAdd(p_tcb);
;;;454    #endif
;;;455    
;;;456        OSTaskQty++;                                            /* Increment the #tasks counter                           */
;;;457    
;;;458        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
;;;459            OS_CRITICAL_EXIT();
;;;460            return;
;;;461        }
;;;462    
;;;463        OS_CRITICAL_EXIT_NO_SCHED();
;;;464    
;;;465        OSSched();
;;;466    }
00002c  b009              ADD      sp,sp,#0x24
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.50|
000032  4620              MOV      r0,r4                 ;350
000034  f7fffffe          BL       OS_TaskInitTCB
000038  2100              MOVS     r1,#0                 ;352
00003a  981a              LDR      r0,[sp,#0x68]         ;352
00003c  8001              STRH     r1,[r0,#0]            ;352
00003e  f0060001          AND      r0,r6,#1              ;354
000042  b188              CBZ      r0,|L2.104|
000044  f0060002          AND      r0,r6,#2              ;355
000048  b170              CBZ      r0,|L2.104|
00004a  46a8              MOV      r8,r5                 ;356
00004c  2000              MOVS     r0,#0                 ;357
00004e  9004              STR      r0,[sp,#0x10]         ;357
000050  e007              B        |L2.98|
                  |L2.82|
000052  2000              MOVS     r0,#0                 ;358
000054  f8c80000          STR      r0,[r8,#0]            ;358
000058  f1080804          ADD      r8,r8,#4              ;359
00005c  9804              LDR      r0,[sp,#0x10]         ;357
00005e  1c40              ADDS     r0,r0,#1              ;357
000060  9004              STR      r0,[sp,#0x10]         ;357
                  |L2.98|
000062  9804              LDR      r0,[sp,#0x10]         ;357
000064  4558              CMP      r0,r11                ;357
000066  d3f4              BCC      |L2.82|
                  |L2.104|
000068  9814              LDR      r0,[sp,#0x50]         ;365
00006a  eb050080          ADD      r0,r5,r0,LSL #2       ;365
00006e  9003              STR      r0,[sp,#0xc]          ;365
000070  e9cdb600          STRD     r11,r6,[sp,#0]        ;370
000074  462a              MOV      r2,r5                 ;370
000076  4648              MOV      r0,r9                 ;370
000078  9b03              LDR      r3,[sp,#0xc]          ;370
00007a  9908              LDR      r1,[sp,#0x20]         ;370
00007c  f7fffffe          BL       OSTaskStkInit
000080  4680              MOV      r8,r0                 ;370
000082  f8c49028          STR      r9,[r4,#0x28]         ;379
000086  9808              LDR      r0,[sp,#0x20]         ;380
000088  62e0              STR      r0,[r4,#0x2c]         ;380
00008a  9806              LDR      r0,[sp,#0x18]         ;384
00008c  6220              STR      r0,[r4,#0x20]         ;384
00008e  f884a037          STRB     r10,[r4,#0x37]        ;389
000092  f884a038          STRB     r10,[r4,#0x38]        ;392
000096  f8c48000          STR      r8,[r4,#0]            ;395
00009a  9803              LDR      r0,[sp,#0xc]          ;397
00009c  60a0              STR      r0,[r4,#8]            ;397
00009e  9818              LDR      r0,[sp,#0x60]         ;411
0000a0  6060              STR      r0,[r4,#4]            ;411
0000a2  6265              STR      r5,[r4,#0x24]         ;413
0000a4  f8c4b040          STR      r11,[r4,#0x40]        ;414
0000a8  f8a46044          STRH     r6,[r4,#0x44]         ;416
0000ac  2700              MOVS     r7,#0                 ;419
0000ae  e006              B        |L2.190|
                  |L2.176|
0000b0  2100              MOVS     r1,#0                 ;420
0000b2  f1040078          ADD      r0,r4,#0x78           ;420
0000b6  f8401027          STR      r1,[r0,r7,LSL #2]     ;420
0000ba  1c78              ADDS     r0,r7,#1              ;419
0000bc  b2c7              UXTB     r7,r0                 ;419
                  |L2.190|
0000be  2f00              CMP      r7,#0                 ;419
0000c0  d0f6              BEQ      |L2.176|
0000c2  f1040060          ADD      r0,r4,#0x60           ;425
0000c6  9916              LDR      r1,[sp,#0x58]         ;425
0000c8  f7fffffe          BL       OS_MsgQInit
0000cc  4620              MOV      r0,r4                 ;431
0000ce  f7fffffe          BL       OSTaskCreateHook
0000d2  bf00              NOP                            ;448
0000d4  bf00              NOP                            ;448
0000d6  f7fffffe          BL       CPU_SR_Save
0000da  9002              STR      r0,[sp,#8]            ;448
0000dc  bf00              NOP                            ;448
0000de  f7fffffe          BL       CPU_IntDisMeasStart
0000e2  bf00              NOP                            ;448
0000e4  f8940037          LDRB     r0,[r4,#0x37]         ;449
0000e8  f7fffffe          BL       OS_PrioInsert
0000ec  4620              MOV      r0,r4                 ;450
0000ee  f7fffffe          BL       OS_RdyListInsertTail
0000f2  4620              MOV      r0,r4                 ;453
0000f4  f7fffffe          BL       OS_TaskDbgListAdd
0000f8  4810              LDR      r0,|L2.316|
0000fa  8800              LDRH     r0,[r0,#0]            ;456  ; OSTaskQty
0000fc  1c40              ADDS     r0,r0,#1              ;456
0000fe  490f              LDR      r1,|L2.316|
000100  8008              STRH     r0,[r1,#0]            ;456
000102  480f              LDR      r0,|L2.320|
000104  7800              LDRB     r0,[r0,#0]            ;458  ; OSRunning
000106  2801              CMP      r0,#1                 ;458
000108  d009              BEQ      |L2.286|
00010a  bf00              NOP                            ;459
00010c  f7fffffe          BL       CPU_IntDisMeasStop
000110  bf00              NOP                            ;459
000112  9802              LDR      r0,[sp,#8]            ;459
000114  f7fffffe          BL       CPU_SR_Restore
000118  bf00              NOP                            ;459
00011a  bf00              NOP                            ;459
00011c  e786              B        |L2.44|
                  |L2.286|
00011e  bf00              NOP                            ;463
000120  f7fffffe          BL       CPU_IntDisMeasStop
000124  bf00              NOP                            ;463
000126  9802              LDR      r0,[sp,#8]            ;463
000128  f7fffffe          BL       CPU_SR_Restore
00012c  bf00              NOP                            ;463
00012e  bf00              NOP                            ;463
000130  f7fffffe          BL       OSSched
000134  bf00              NOP      
000136  e779              B        |L2.44|
;;;467    
                          ENDP

                  |L2.312|
                          DCD      OSIdleTaskTCB
                  |L2.316|
                          DCD      OSTaskQty
                  |L2.320|
                          DCD      OSRunning

                          AREA ||i.OSTaskDel||, CODE, READONLY, ALIGN=2

                  OSTaskDel PROC
;;;495    #if OS_CFG_TASK_DEL_EN > 0u
;;;496    void  OSTaskDel (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;497                     OS_ERR  *p_err)
;;;498    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;499    #if OS_CFG_MUTEX_EN > 0u
;;;500        OS_TCB  *p_tcb_owner;
;;;501        OS_PRIO  prio_new;
;;;502    #endif
;;;503        CPU_SR_ALLOC();
000008  f04f0800          MOV      r8,#0
;;;504    
;;;505    
;;;506    
;;;507    #ifdef OS_SAFETY_CRITICAL
;;;508        if (p_err == (OS_ERR *)0) {
;;;509            OS_SAFETY_CRITICAL_EXCEPTION();
;;;510            return;
;;;511        }
;;;512    #endif
;;;513    
;;;514    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;515        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
;;;516           *p_err = OS_ERR_TASK_DEL_ISR;
;;;517            return;
;;;518        }
;;;519    #endif
;;;520    
;;;521        if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
00000c  4860              LDR      r0,|L3.400|
00000e  4284              CMP      r4,r0
000010  d104              BNE      |L3.28|
;;;522           *p_err = OS_ERR_TASK_DEL_IDLE;
000012  f247104c          MOV      r0,#0x714c
000016  8030              STRH     r0,[r6,#0]
                  |L3.24|
;;;523            return;
;;;524        }
;;;525    
;;;526    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;527        if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
;;;528           *p_err = OS_ERR_TASK_DEL_INVALID;
;;;529            return;
;;;530        }
;;;531    #endif
;;;532    
;;;533        if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
;;;534            CPU_CRITICAL_ENTER();
;;;535            p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
;;;536            CPU_CRITICAL_EXIT();
;;;537        }
;;;538    
;;;539        OS_CRITICAL_ENTER();
;;;540        switch (p_tcb->TaskState) {
;;;541            case OS_TASK_STATE_RDY:
;;;542                 OS_RdyListRemove(p_tcb);
;;;543                 break;
;;;544    
;;;545            case OS_TASK_STATE_SUSPENDED:
;;;546                 break;
;;;547    
;;;548            case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
;;;549            case OS_TASK_STATE_DLY_SUSPENDED:
;;;550                 OS_TickListRemove(p_tcb);
;;;551                 break;
;;;552    
;;;553            case OS_TASK_STATE_PEND:
;;;554            case OS_TASK_STATE_PEND_SUSPENDED:
;;;555            case OS_TASK_STATE_PEND_TIMEOUT:
;;;556            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;557                 switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
;;;558                     case OS_TASK_PEND_ON_NOTHING:
;;;559                     case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
;;;560                     case OS_TASK_PEND_ON_TASK_SEM:
;;;561                          break;
;;;562    
;;;563                     case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
;;;564                     case OS_TASK_PEND_ON_MULTI:
;;;565                     case OS_TASK_PEND_ON_Q:
;;;566                     case OS_TASK_PEND_ON_SEM:
;;;567                          OS_PendListRemove(p_tcb);
;;;568                          break;
;;;569    
;;;570    #if OS_CFG_MUTEX_EN > 0u
;;;571                     case OS_TASK_PEND_ON_MUTEX:
;;;572                          p_tcb_owner = ((OS_MUTEX *)p_tcb->PendDataTblPtr->PendObjPtr)->OwnerTCBPtr;
;;;573                          prio_new = p_tcb_owner->Prio;
;;;574                          OS_PendListRemove(p_tcb);
;;;575                          if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
;;;576                              (p_tcb_owner->Prio == p_tcb->Prio)) { /* Has the owner inherited a priority?                */
;;;577                              prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
;;;578                              prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
;;;579                          }
;;;580                          p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;
;;;581    
;;;582                          if (prio_new != p_tcb_owner->Prio) {
;;;583                              OS_TaskChangePrio(p_tcb_owner, prio_new);
;;;584    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;585                              TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
;;;586    #endif
;;;587                          }
;;;588                          break;
;;;589    #endif
;;;590    
;;;591                     default:
;;;592                          break;
;;;593                 }
;;;594                 if ((p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) ||
;;;595                     (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED)) {
;;;596                     OS_TickListRemove(p_tcb);
;;;597                 }
;;;598    
;;;599                 break;
;;;600    
;;;601            default:
;;;602                OS_CRITICAL_EXIT();
;;;603               *p_err = OS_ERR_STATE_INVALID;
;;;604                return;
;;;605        }
;;;606    
;;;607    #if OS_CFG_MUTEX_EN > 0u
;;;608        if(p_tcb->MutexGrpHeadPtr != (OS_MUTEX *)0) {
;;;609            OS_MutexGrpPostAll(p_tcb);
;;;610        }
;;;611    #endif
;;;612    
;;;613    #if OS_CFG_TASK_Q_EN > 0u
;;;614        (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
;;;615    #endif
;;;616    
;;;617        OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
;;;618    
;;;619    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;620        OS_TLS_TaskDel(p_tcb);                                  /* Call TLS hook                                          */
;;;621    #endif
;;;622    
;;;623    #if OS_CFG_DBG_EN > 0u
;;;624        OS_TaskDbgListRemove(p_tcb);
;;;625    #endif
;;;626        OSTaskQty--;                                            /* One less task being managed                            */
;;;627    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;628        TRACE_OS_TASK_DEL(p_tcb);                               /* Record the event.                                      */
;;;629    #endif
;;;630        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;631        p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
;;;632    
;;;633        OS_CRITICAL_EXIT_NO_SCHED();
;;;634    
;;;635       *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
;;;636    
;;;637        OSSched();                                              /* Find new highest priority task                         */
;;;638    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L3.28|
00001c  b99c              CBNZ     r4,|L3.70|
00001e  bf00              NOP                            ;534
000020  bf00              NOP                            ;534
000022  f7fffffe          BL       CPU_SR_Save
000026  4680              MOV      r8,r0                 ;534
000028  bf00              NOP                            ;534
00002a  f7fffffe          BL       CPU_IntDisMeasStart
00002e  bf00              NOP                            ;534
000030  4858              LDR      r0,|L3.404|
000032  6804              LDR      r4,[r0,#0]            ;535  ; OSTCBCurPtr
000034  bf00              NOP                            ;536
000036  f7fffffe          BL       CPU_IntDisMeasStop
00003a  bf00              NOP                            ;536
00003c  4640              MOV      r0,r8                 ;536
00003e  f7fffffe          BL       CPU_SR_Restore
000042  bf00              NOP                            ;536
000044  bf00              NOP                            ;536
                  |L3.70|
000046  bf00              NOP                            ;539
000048  bf00              NOP                            ;539
00004a  f7fffffe          BL       CPU_SR_Save
00004e  4680              MOV      r8,r0                 ;539
000050  bf00              NOP                            ;539
000052  f7fffffe          BL       CPU_IntDisMeasStart
000056  bf00              NOP                            ;539
000058  f8940036          LDRB     r0,[r4,#0x36]         ;540
00005c  2808              CMP      r0,#8                 ;540
00005e  d260              BCS      |L3.290|
000060  e8dff000          TBB      [pc,r0]               ;540
000064  04090e10          DCB      0x04,0x09,0x0e,0x10
000068  080a0f11          DCB      0x08,0x0a,0x0f,0x11
00006c  4620              MOV      r0,r4                 ;542
00006e  f7fffffe          BL       OS_RdyListRemove
000072  e063              B        |L3.316|
000074  e062              B        |L3.316|
000076  bf00              NOP                            ;549
000078  4620              MOV      r0,r4                 ;550
00007a  f7fffffe          BL       OS_TickListRemove
00007e  e05d              B        |L3.316|
000080  bf00              NOP                            ;554
000082  bf00              NOP                            ;555
000084  bf00              NOP                            ;556
000086  f8940034          LDRB     r0,[r4,#0x34]         ;557
00008a  2808              CMP      r0,#8                 ;557
00008c  d23b              BCS      |L3.262|
00008e  e8dff000          TBB      [pc,r0]               ;557
000092  0407              DCB      0x04,0x07
000094  05080e09          DCB      0x05,0x08,0x0e,0x09
000098  0a06              DCB      0x0a,0x06
00009a  bf00              NOP                            ;559
00009c  bf00              NOP                            ;560
00009e  e033              B        |L3.264|
0000a0  bf00              NOP                            ;564
0000a2  bf00              NOP                            ;565
0000a4  bf00              NOP                            ;566
0000a6  4620              MOV      r0,r4                 ;567
0000a8  f7fffffe          BL       OS_PendListRemove
0000ac  e02c              B        |L3.264|
0000ae  6b20              LDR      r0,[r4,#0x30]         ;572
0000b0  68c0              LDR      r0,[r0,#0xc]          ;572
0000b2  6a45              LDR      r5,[r0,#0x24]         ;572
0000b4  f8157f37          LDRB     r7,[r5,#0x37]!        ;573
0000b8  4620              MOV      r0,r4                 ;574
0000ba  f7fffffe          BL       OS_PendListRemove
0000be  7828              LDRB     r0,[r5,#0]            ;575
0000c0  7869              LDRB     r1,[r5,#1]            ;575
0000c2  3d37              SUBS     r5,r5,#0x37           ;575
0000c4  4288              CMP      r0,r1                 ;575
0000c6  d012              BEQ      |L3.238|
0000c8  f8950037          LDRB     r0,[r5,#0x37]         ;576
0000cc  f8941037          LDRB     r1,[r4,#0x37]         ;576
0000d0  4288              CMP      r0,r1                 ;576
0000d2  d10c              BNE      |L3.238|
0000d4  4628              MOV      r0,r5                 ;577
0000d6  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000da  4607              MOV      r7,r0                 ;577
0000dc  f8950038          LDRB     r0,[r5,#0x38]         ;578
0000e0  42b8              CMP      r0,r7                 ;578
0000e2  da02              BGE      |L3.234|
0000e4  f8950038          LDRB     r0,[r5,#0x38]         ;578
0000e8  e000              B        |L3.236|
                  |L3.234|
0000ea  4638              MOV      r0,r7                 ;578
                  |L3.236|
0000ec  4607              MOV      r7,r0                 ;578
                  |L3.238|
0000ee  2000              MOVS     r0,#0                 ;580
0000f0  f8840034          STRB     r0,[r4,#0x34]         ;580
0000f4  f8950037          LDRB     r0,[r5,#0x37]         ;582
0000f8  42b8              CMP      r0,r7                 ;582
0000fa  d003              BEQ      |L3.260|
0000fc  4639              MOV      r1,r7                 ;583
0000fe  4628              MOV      r0,r5                 ;583
000100  f7fffffe          BL       OS_TaskChangePrio
                  |L3.260|
000104  e000              B        |L3.264|
                  |L3.262|
000106  bf00              NOP                            ;592
                  |L3.264|
000108  bf00              NOP                            ;561
00010a  f8940036          LDRB     r0,[r4,#0x36]         ;594
00010e  2803              CMP      r0,#3                 ;594
000110  d003              BEQ      |L3.282|
000112  f8940036          LDRB     r0,[r4,#0x36]         ;595
000116  2807              CMP      r0,#7                 ;595
000118  d102              BNE      |L3.288|
                  |L3.282|
00011a  4620              MOV      r0,r4                 ;596
00011c  f7fffffe          BL       OS_TickListRemove
                  |L3.288|
000120  e00c              B        |L3.316|
                  |L3.290|
000122  bf00              NOP                            ;602
000124  f7fffffe          BL       CPU_IntDisMeasStop
000128  bf00              NOP                            ;602
00012a  4640              MOV      r0,r8                 ;602
00012c  f7fffffe          BL       CPU_SR_Restore
000130  bf00              NOP                            ;602
000132  bf00              NOP                            ;602
000134  f646602d          MOV      r0,#0x6e2d            ;603
000138  8030              STRH     r0,[r6,#0]            ;603
00013a  e76d              B        |L3.24|
                  |L3.316|
00013c  bf00              NOP                            ;543
00013e  6be0              LDR      r0,[r4,#0x3c]         ;608
000140  b110              CBZ      r0,|L3.328|
000142  4620              MOV      r0,r4                 ;609
000144  f7fffffe          BL       OS_MutexGrpPostAll
                  |L3.328|
000148  f1040060          ADD      r0,r4,#0x60           ;614
00014c  f7fffffe          BL       OS_MsgQFreeAll
000150  4620              MOV      r0,r4                 ;617
000152  f7fffffe          BL       OSTaskDelHook
000156  4620              MOV      r0,r4                 ;624
000158  f7fffffe          BL       OS_TaskDbgListRemove
00015c  480e              LDR      r0,|L3.408|
00015e  8800              LDRH     r0,[r0,#0]            ;626  ; OSTaskQty
000160  1e40              SUBS     r0,r0,#1              ;626
000162  490d              LDR      r1,|L3.408|
000164  8008              STRH     r0,[r1,#0]            ;626
000166  4620              MOV      r0,r4                 ;630
000168  f7fffffe          BL       OS_TaskInitTCB
00016c  20ff              MOVS     r0,#0xff              ;631
00016e  f8840036          STRB     r0,[r4,#0x36]         ;631
000172  bf00              NOP                            ;633
000174  f7fffffe          BL       CPU_IntDisMeasStop
000178  bf00              NOP                            ;633
00017a  4640              MOV      r0,r8                 ;633
00017c  f7fffffe          BL       CPU_SR_Restore
000180  bf00              NOP                            ;633
000182  bf00              NOP                            ;633
000184  2000              MOVS     r0,#0                 ;635
000186  8030              STRH     r0,[r6,#0]            ;635
000188  f7fffffe          BL       OSSched
00018c  bf00              NOP      
00018e  e743              B        |L3.24|
;;;639    #endif
                          ENDP

                  |L3.400|
                          DCD      OSIdleTaskTCB
                  |L3.404|
                          DCD      OSTCBCurPtr
                  |L3.408|
                          DCD      OSTaskQty

                          AREA ||i.OSTaskQFlush||, CODE, READONLY, ALIGN=2

                  OSTaskQFlush PROC
;;;665    #if OS_CFG_TASK_Q_EN > 0u
;;;666    OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;667                              OS_ERR  *p_err)
;;;668    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;669        OS_MSG_QTY  entries;
;;;670        CPU_SR_ALLOC();
000008  2600              MOVS     r6,#0
;;;671    
;;;672    
;;;673    
;;;674    #ifdef OS_SAFETY_CRITICAL
;;;675        if (p_err == (OS_ERR *)0) {
;;;676            OS_SAFETY_CRITICAL_EXCEPTION();
;;;677            return ((OS_MSG_QTY)0);
;;;678        }
;;;679    #endif
;;;680    
;;;681    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;682        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
;;;683           *p_err = OS_ERR_FLUSH_ISR;
;;;684            return ((OS_MSG_QTY)0);
;;;685        }
;;;686    #endif
;;;687    
;;;688        if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
00000a  b99c              CBNZ     r4,|L4.52|
;;;689            CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4606              MOV      r6,r0
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_IntDisMeasStart
00001c  bf00              NOP      
;;;690            p_tcb = OSTCBCurPtr;
00001e  4813              LDR      r0,|L4.108|
000020  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
;;;691            CPU_CRITICAL_EXIT();
000022  bf00              NOP      
000024  f7fffffe          BL       CPU_IntDisMeasStop
000028  bf00              NOP      
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       CPU_SR_Restore
000030  bf00              NOP      
000032  bf00              NOP      
                  |L4.52|
;;;692        }
;;;693    
;;;694        OS_CRITICAL_ENTER();
000034  bf00              NOP      
000036  bf00              NOP      
000038  f7fffffe          BL       CPU_SR_Save
00003c  4606              MOV      r6,r0
00003e  bf00              NOP      
000040  f7fffffe          BL       CPU_IntDisMeasStart
000044  bf00              NOP      
;;;695        entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
000046  f1040060          ADD      r0,r4,#0x60
00004a  f7fffffe          BL       OS_MsgQFreeAll
00004e  4607              MOV      r7,r0
;;;696        OS_CRITICAL_EXIT();
000050  bf00              NOP      
000052  f7fffffe          BL       CPU_IntDisMeasStop
000056  bf00              NOP      
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       CPU_SR_Restore
00005e  bf00              NOP      
000060  bf00              NOP      
;;;697       *p_err   = OS_ERR_NONE;
000062  2000              MOVS     r0,#0
000064  8028              STRH     r0,[r5,#0]
;;;698        return (entries);
000066  4638              MOV      r0,r7
;;;699    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;700    #endif
                          ENDP

                  |L4.108|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskQPend||, CODE, READONLY, ALIGN=2

                  OSTaskQPend PROC
;;;743    #if OS_CFG_TASK_Q_EN > 0u
;;;744    void  *OSTaskQPend (OS_TICK       timeout,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;745                        OS_OPT        opt,
;;;746                        OS_MSG_SIZE  *p_msg_size,
;;;747                        CPU_TS       *p_ts,
;;;748                        OS_ERR       *p_err)
;;;749    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;750        OS_MSG_Q     *p_msg_q;
;;;751        void         *p_void;
;;;752        CPU_SR_ALLOC();
00000e  f04f0b00          MOV      r11,#0
;;;753    
;;;754    
;;;755    
;;;756    #ifdef OS_SAFETY_CRITICAL
;;;757        if (p_err == (OS_ERR *)0) {
;;;758            OS_SAFETY_CRITICAL_EXCEPTION();
;;;759            return ((void *)0);
;;;760        }
;;;761    #endif
;;;762    
;;;763    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;764        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
;;;765           *p_err = OS_ERR_PEND_ISR;
;;;766            return ((void *)0);
;;;767        }
;;;768    #endif
;;;769    
;;;770    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;771        if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
;;;772           *p_err = OS_ERR_PTR_INVALID;
;;;773            return ((void *)0);
;;;774        }
;;;775        switch (opt) {                                          /* User must supply a valid option                        */
;;;776            case OS_OPT_PEND_BLOCKING:
;;;777            case OS_OPT_PEND_NON_BLOCKING:
;;;778                 break;
;;;779    
;;;780            default:
;;;781                *p_err = OS_ERR_OPT_INVALID;
;;;782                 return ((void *)0);
;;;783        }
;;;784    #endif
;;;785    
;;;786        if (p_ts != (CPU_TS *)0) {
000012  b10c              CBZ      r4,|L5.24|
;;;787           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
000014  2000              MOVS     r0,#0
000016  6020              STR      r0,[r4,#0]
                  |L5.24|
;;;788        }
;;;789    
;;;790        CPU_CRITICAL_ENTER();
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_SR_Save
000020  4683              MOV      r11,r0
000022  bf00              NOP      
000024  f7fffffe          BL       CPU_IntDisMeasStart
000028  bf00              NOP      
;;;791        p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
00002a  4861              LDR      r0,|L5.432|
00002c  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00002e  f1000960          ADD      r9,r0,#0x60
;;;792        p_void  = OS_MsgQGet(p_msg_q,
000032  462b              MOV      r3,r5
000034  4622              MOV      r2,r4
000036  4631              MOV      r1,r6
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       OS_MsgQGet
00003e  4682              MOV      r10,r0
;;;793                             p_msg_size,
;;;794                             p_ts,
;;;795                             p_err);
;;;796        if (*p_err == OS_ERR_NONE) {
000040  8828              LDRH     r0,[r5,#0]
000042  bb08              CBNZ     r0,|L5.136|
;;;797    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;798            if (p_ts != (CPU_TS *)0) {
000044  b1a4              CBZ      r4,|L5.112|
;;;799                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
000046  f7fffffe          BL       CPU_TS_TmrRd
00004a  6821              LDR      r1,[r4,#0]
00004c  1a40              SUBS     r0,r0,r1
00004e  4958              LDR      r1,|L5.432|
000050  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000052  6708              STR      r0,[r1,#0x70]
;;;800                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
000054  4856              LDR      r0,|L5.432|
000056  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000058  6f40              LDR      r0,[r0,#0x74]
00005a  4955              LDR      r1,|L5.432|
00005c  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00005e  6f09              LDR      r1,[r1,#0x70]
000060  4288              CMP      r0,r1
000062  d205              BCS      |L5.112|
;;;801                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
000064  4852              LDR      r0,|L5.432|
000066  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000068  6f00              LDR      r0,[r0,#0x70]
00006a  4951              LDR      r1,|L5.432|
00006c  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00006e  6748              STR      r0,[r1,#0x74]
                  |L5.112|
;;;802                }
;;;803            }
;;;804    #endif
;;;805            CPU_CRITICAL_EXIT();
000070  bf00              NOP      
000072  f7fffffe          BL       CPU_IntDisMeasStop
000076  bf00              NOP      
000078  4658              MOV      r0,r11
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  bf00              NOP      
000080  bf00              NOP      
;;;806    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;807            TRACE_OS_TASK_MSG_Q_PEND(p_msg_q);                  /* Record the event.                                      */
;;;808    #endif
;;;809            return (p_void);                                    /* Yes, Return oldest message received                    */
000082  4650              MOV      r0,r10
                  |L5.132|
;;;810        }
;;;811    
;;;812        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;813           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;814            CPU_CRITICAL_EXIT();
;;;815    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;816            TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);           /* Record the event.                                      */
;;;817    #endif
;;;818            return ((void *)0);
;;;819        } else {                                                /* Yes                                                    */
;;;820            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
;;;821                CPU_CRITICAL_EXIT();
;;;822    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;823                TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);       /* Record the event.                                      */
;;;824    #endif
;;;825               *p_err = OS_ERR_SCHED_LOCKED;
;;;826                return ((void *)0);
;;;827            }
;;;828        }
;;;829                                                                /* Lock the scheduler/re-enable interrupts                */
;;;830        OS_CRITICAL_ENTER_CPU_EXIT();
;;;831        OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
;;;832                (OS_PEND_OBJ  *)0,
;;;833                (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
;;;834                (OS_TICK       )timeout);
;;;835        OS_CRITICAL_EXIT_NO_SCHED();
;;;836    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;837        TRACE_OS_TASK_MSG_Q_PEND_BLOCK(p_msg_q);                /* Record the event.                                      */
;;;838    #endif
;;;839        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;840    
;;;841        CPU_CRITICAL_ENTER();
;;;842        switch (OSTCBCurPtr->PendStatus) {
;;;843            case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
;;;844                 p_void      = OSTCBCurPtr->MsgPtr;
;;;845                *p_msg_size  = OSTCBCurPtr->MsgSize;
;;;846                 if (p_ts != (CPU_TS *)0) {
;;;847                    *p_ts  = OSTCBCurPtr->TS;
;;;848    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;849                    OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;850                    if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;851                        OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;852                    }
;;;853    #endif
;;;854                 }
;;;855    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;856                 TRACE_OS_TASK_MSG_Q_PEND(p_msg_q);             /* Record the event.                                      */
;;;857    #endif
;;;858                *p_err = OS_ERR_NONE;
;;;859                 break;
;;;860    
;;;861            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;862                 p_void     = (void      *)0;
;;;863                *p_msg_size = (OS_MSG_SIZE)0;
;;;864                 if (p_ts  != (CPU_TS *)0) {
;;;865                    *p_ts   = (CPU_TS  )0;
;;;866                 }
;;;867    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;868                 TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);      /* Record the event.                                      */
;;;869    #endif
;;;870                *p_err      =  OS_ERR_PEND_ABORT;
;;;871                 break;
;;;872    
;;;873            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
;;;874            default:
;;;875                 p_void     = (void      *)0;
;;;876                *p_msg_size = (OS_MSG_SIZE)0;
;;;877                 if (p_ts  != (CPU_TS *)0) {
;;;878                    *p_ts   =  OSTCBCurPtr->TS;
;;;879                 }
;;;880    #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;881                 TRACE_OS_TASK_MSG_Q_PEND_FAILED(p_msg_q);      /* Record the event.                                      */
;;;882    #endif
;;;883                *p_err      =  OS_ERR_TIMEOUT;
;;;884                 break;
;;;885        }
;;;886        CPU_CRITICAL_EXIT();
;;;887        return (p_void);                                        /* Return received message                                */
;;;888    }
000084  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.136|
000088  f4084000          AND      r0,r8,#0x8000         ;812
00008c  b168              CBZ      r0,|L5.170|
00008e  f24610b0          MOV      r0,#0x61b0            ;813
000092  8028              STRH     r0,[r5,#0]            ;813
000094  bf00              NOP                            ;814
000096  f7fffffe          BL       CPU_IntDisMeasStop
00009a  bf00              NOP                            ;814
00009c  4658              MOV      r0,r11                ;814
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  bf00              NOP                            ;814
0000a4  bf00              NOP                            ;814
0000a6  2000              MOVS     r0,#0                 ;818
0000a8  e7ec              B        |L5.132|
                  |L5.170|
0000aa  4842              LDR      r0,|L5.436|
0000ac  7800              LDRB     r0,[r0,#0]            ;820  ; OSSchedLockNestingCtr
0000ae  2800              CMP      r0,#0                 ;820
0000b0  dd0d              BLE      |L5.206|
0000b2  bf00              NOP                            ;821
0000b4  f7fffffe          BL       CPU_IntDisMeasStop
0000b8  bf00              NOP                            ;821
0000ba  4658              MOV      r0,r11                ;821
0000bc  f7fffffe          BL       CPU_SR_Restore
0000c0  bf00              NOP                            ;821
0000c2  bf00              NOP                            ;821
0000c4  f6465063          MOV      r0,#0x6d63            ;825
0000c8  8028              STRH     r0,[r5,#0]            ;825
0000ca  2000              MOVS     r0,#0                 ;826
0000cc  e7da              B        |L5.132|
                  |L5.206|
0000ce  463b              MOV      r3,r7                 ;831
0000d0  2202              MOVS     r2,#2                 ;831
0000d2  2100              MOVS     r1,#0                 ;831
0000d4  4608              MOV      r0,r1                 ;831
0000d6  f7fffffe          BL       OS_Pend
0000da  bf00              NOP                            ;835
0000dc  f7fffffe          BL       CPU_IntDisMeasStop
0000e0  bf00              NOP                            ;835
0000e2  4658              MOV      r0,r11                ;835
0000e4  f7fffffe          BL       CPU_SR_Restore
0000e8  bf00              NOP                            ;835
0000ea  bf00              NOP                            ;835
0000ec  f7fffffe          BL       OSSched
0000f0  bf00              NOP                            ;841
0000f2  bf00              NOP                            ;841
0000f4  f7fffffe          BL       CPU_SR_Save
0000f8  4683              MOV      r11,r0                ;841
0000fa  bf00              NOP                            ;841
0000fc  f7fffffe          BL       CPU_IntDisMeasStart
000100  bf00              NOP                            ;841
000102  482b              LDR      r0,|L5.432|
000104  6800              LDR      r0,[r0,#0]            ;842  ; OSTCBCurPtr
000106  f8900035          LDRB     r0,[r0,#0x35]         ;842
00010a  b120              CBZ      r0,|L5.278|
00010c  2801              CMP      r0,#1                 ;842
00010e  d02a              BEQ      |L5.358|
000110  2803              CMP      r0,#3                 ;842
000112  d132              BNE      |L5.378|
000114  e032              B        |L5.380|
                  |L5.278|
000116  4826              LDR      r0,|L5.432|
000118  6800              LDR      r0,[r0,#0]            ;844  ; OSTCBCurPtr
00011a  f8d0a058          LDR      r10,[r0,#0x58]        ;844
00011e  4824              LDR      r0,|L5.432|
000120  6800              LDR      r0,[r0,#0]            ;845  ; OSTCBCurPtr
000122  f8b0005c          LDRH     r0,[r0,#0x5c]         ;845
000126  8030              STRH     r0,[r6,#0]            ;845
000128  b1d4              CBZ      r4,|L5.352|
00012a  4821              LDR      r0,|L5.432|
00012c  6800              LDR      r0,[r0,#0]            ;847  ; OSTCBCurPtr
00012e  6c80              LDR      r0,[r0,#0x48]         ;847
000130  6020              STR      r0,[r4,#0]            ;847
000132  f7fffffe          BL       CPU_TS_TmrRd
000136  491e              LDR      r1,|L5.432|
000138  6809              LDR      r1,[r1,#0]            ;849  ; OSTCBCurPtr
00013a  6c89              LDR      r1,[r1,#0x48]         ;849
00013c  1a40              SUBS     r0,r0,r1              ;849
00013e  491c              LDR      r1,|L5.432|
000140  6809              LDR      r1,[r1,#0]            ;849  ; OSTCBCurPtr
000142  6708              STR      r0,[r1,#0x70]         ;849
000144  481a              LDR      r0,|L5.432|
000146  6800              LDR      r0,[r0,#0]            ;850  ; OSTCBCurPtr
000148  6f40              LDR      r0,[r0,#0x74]         ;850
00014a  4919              LDR      r1,|L5.432|
00014c  6809              LDR      r1,[r1,#0]            ;850  ; OSTCBCurPtr
00014e  6f09              LDR      r1,[r1,#0x70]         ;850
000150  4288              CMP      r0,r1                 ;850
000152  d205              BCS      |L5.352|
000154  4816              LDR      r0,|L5.432|
000156  6800              LDR      r0,[r0,#0]            ;851  ; OSTCBCurPtr
000158  6f00              LDR      r0,[r0,#0x70]         ;851
00015a  4915              LDR      r1,|L5.432|
00015c  6809              LDR      r1,[r1,#0]            ;851  ; OSTCBCurPtr
00015e  6748              STR      r0,[r1,#0x74]         ;851
                  |L5.352|
000160  2000              MOVS     r0,#0                 ;858
000162  8028              STRH     r0,[r5,#0]            ;858
000164  e017              B        |L5.406|
                  |L5.358|
000166  f04f0a00          MOV      r10,#0                ;862
00016a  2000              MOVS     r0,#0                 ;863
00016c  8030              STRH     r0,[r6,#0]            ;863
00016e  b104              CBZ      r4,|L5.370|
000170  6020              STR      r0,[r4,#0]            ;865
                  |L5.370|
000172  f24610a9          MOV      r0,#0x61a9            ;870
000176  8028              STRH     r0,[r5,#0]            ;870
000178  e00d              B        |L5.406|
                  |L5.378|
00017a  bf00              NOP                            ;873
                  |L5.380|
00017c  f04f0a00          MOV      r10,#0                ;875
000180  2000              MOVS     r0,#0                 ;876
000182  8030              STRH     r0,[r6,#0]            ;876
000184  b11c              CBZ      r4,|L5.398|
000186  480a              LDR      r0,|L5.432|
000188  6800              LDR      r0,[r0,#0]            ;878  ; OSTCBCurPtr
00018a  6c80              LDR      r0,[r0,#0x48]         ;878
00018c  6020              STR      r0,[r4,#0]            ;878
                  |L5.398|
00018e  f24720d9          MOV      r0,#0x72d9            ;883
000192  8028              STRH     r0,[r5,#0]            ;883
000194  bf00              NOP                            ;884
                  |L5.406|
000196  bf00              NOP                            ;859
000198  bf00              NOP                            ;886
00019a  f7fffffe          BL       CPU_IntDisMeasStop
00019e  bf00              NOP                            ;886
0001a0  4658              MOV      r0,r11                ;886
0001a2  f7fffffe          BL       CPU_SR_Restore
0001a6  bf00              NOP                            ;886
0001a8  bf00              NOP                            ;886
0001aa  4650              MOV      r0,r10                ;887
0001ac  e76a              B        |L5.132|
;;;889    #endif
                          ENDP

0001ae  0000              DCW      0x0000
                  |L5.432|
                          DCD      OSTCBCurPtr
                  |L5.436|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskQPendAbort||, CODE, READONLY, ALIGN=1

                  OSTaskQPendAbort PROC
;;;919    #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)
;;;920    CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;921                                   OS_OPT   opt,
;;;922                                   OS_ERR  *p_err)
;;;923    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;924        CPU_TS         ts;
;;;925        CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;926    
;;;927    
;;;928    
;;;929    #ifdef OS_SAFETY_CRITICAL
;;;930        if (p_err == (OS_ERR *)0) {
;;;931            OS_SAFETY_CRITICAL_EXCEPTION();
;;;932            return (DEF_FALSE);
;;;933        }
;;;934    #endif
;;;935    
;;;936    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;937        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;938           *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
;;;939            return (DEF_FALSE);
;;;940        }
;;;941    #endif
;;;942    
;;;943    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;944        switch (opt) {                                          /* User must supply a valid option                        */
;;;945            case OS_OPT_POST_NONE:
;;;946            case OS_OPT_POST_NO_SCHED:
;;;947                 break;
;;;948    
;;;949            default:
;;;950                *p_err = OS_ERR_OPT_INVALID;
;;;951                 return (DEF_FALSE);
;;;952        }
;;;953    #endif
;;;954    
;;;955        CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_IntDisMeasStart
00001c  bf00              NOP      
;;;956    #if OS_CFG_ARG_CHK_EN > 0u
;;;957        if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
;;;958            (p_tcb == OSTCBCurPtr)) {
;;;959            CPU_CRITICAL_EXIT();
;;;960           *p_err = OS_ERR_PEND_ABORT_SELF;                     /* ... doesn't make sense                                 */
;;;961            return (DEF_FALSE);
;;;962        }
;;;963    #endif
;;;964    
;;;965        if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
00001e  f8940034          LDRB     r0,[r4,#0x34]
000022  2802              CMP      r0,#2
000024  d00e              BEQ      |L6.68|
;;;966            CPU_CRITICAL_EXIT();                                /* No                                                     */
000026  bf00              NOP      
000028  f7fffffe          BL       CPU_IntDisMeasStop
00002c  bf00              NOP      
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       CPU_SR_Restore
000034  bf00              NOP      
000036  bf00              NOP      
;;;967           *p_err = OS_ERR_PEND_ABORT_NONE;
000038  f24610ab          MOV      r0,#0x61ab
00003c  8028              STRH     r0,[r5,#0]
;;;968            return (DEF_FALSE);
00003e  2000              MOVS     r0,#0
                  |L6.64|
;;;969        }
;;;970    
;;;971        OS_CRITICAL_ENTER_CPU_EXIT();
;;;972        ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
;;;973        OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
;;;974                     p_tcb,
;;;975                     ts);
;;;976        OS_CRITICAL_EXIT_NO_SCHED();
;;;977        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;978            OSSched();                                          /* Run the scheduler                                      */
;;;979        }
;;;980       *p_err = OS_ERR_NONE;
;;;981        return (DEF_TRUE);
;;;982    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L6.68|
000044  f7fffffe          BL       CPU_TS_TmrRd
000048  4680              MOV      r8,r0                 ;972
00004a  4642              MOV      r2,r8                 ;973
00004c  4621              MOV      r1,r4                 ;973
00004e  2000              MOVS     r0,#0                 ;973
000050  f7fffffe          BL       OS_PendAbort
000054  bf00              NOP                            ;976
000056  f7fffffe          BL       CPU_IntDisMeasStop
00005a  bf00              NOP                            ;976
00005c  4638              MOV      r0,r7                 ;976
00005e  f7fffffe          BL       CPU_SR_Restore
000062  bf00              NOP                            ;976
000064  bf00              NOP                            ;976
000066  f4064000          AND      r0,r6,#0x8000         ;977
00006a  b908              CBNZ     r0,|L6.112|
00006c  f7fffffe          BL       OSSched
                  |L6.112|
000070  2000              MOVS     r0,#0                 ;980
000072  8028              STRH     r0,[r5,#0]            ;980
000074  2001              MOVS     r0,#1                 ;981
000076  e7e3              B        |L6.64|
;;;983    #endif
                          ENDP


                          AREA ||i.OSTaskQPost||, CODE, READONLY, ALIGN=1

                  OSTaskQPost PROC
;;;1021   #if OS_CFG_TASK_Q_EN > 0u
;;;1022   void  OSTaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1023                      void         *p_void,
;;;1024                      OS_MSG_SIZE   msg_size,
;;;1025                      OS_OPT        opt,
;;;1026                      OS_ERR       *p_err)
;;;1027   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;1028       CPU_TS   ts;
;;;1029   
;;;1030   
;;;1031   
;;;1032   #ifdef OS_SAFETY_CRITICAL
;;;1033       if (p_err == (OS_ERR *)0) {
;;;1034   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1035           TRACE_OS_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);      /* Record the event.                                      */
;;;1036   #endif
;;;1037           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1038           return;
;;;1039       }
;;;1040   #endif
;;;1041   
;;;1042   #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;1043       switch (opt) {                                          /* User must supply a valid option                        */
;;;1044           case OS_OPT_POST_FIFO:
;;;1045           case OS_OPT_POST_LIFO:
;;;1046           case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
;;;1047           case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
;;;1048                break;
;;;1049   
;;;1050           default:
;;;1051   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1052                TRACE_OS_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ); /* Record the event.                                      */
;;;1053   #endif
;;;1054               *p_err = OS_ERR_OPT_INVALID;
;;;1055                return;
;;;1056       }
;;;1057   #endif
;;;1058   
;;;1059       ts = OS_TS_GET();                                       /* Get timestamp                                          */
000010  f7fffffe          BL       CPU_TS_TmrRd
000014  4681              MOV      r9,r0
;;;1060   
;;;1061   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1062       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
;;;1063           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
;;;1064                       (void      *)p_tcb,
;;;1065                       (void      *)p_void,
;;;1066                       (OS_MSG_SIZE)msg_size,
;;;1067                       (OS_FLAGS   )0,
;;;1068                       (OS_OPT     )opt,
;;;1069                       (CPU_TS     )ts,
;;;1070                       (OS_ERR    *)p_err);
;;;1071           return;
;;;1072       }
;;;1073   #endif
;;;1074   
;;;1075   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1076       TRACE_OS_TASK_MSG_Q_POST(&p_tcb->MsgQ);                 /* Record the event.                                      */
;;;1077   #endif
;;;1078   
;;;1079       OS_TaskQPost(p_tcb,
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  e9cd9800          STRD     r9,r8,[sp,#0]
000022  f7fffffe          BL       OS_TaskQPost
;;;1080                    p_void,
;;;1081                    msg_size,
;;;1082                    opt,
;;;1083                    ts,
;;;1084                    p_err);
;;;1085   }
000026  e8bd87fc          POP      {r2-r10,pc}
;;;1086   #endif
                          ENDP


                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1112   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1113   OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1114                         OS_REG_ID   id,
;;;1115                         OS_ERR     *p_err)
;;;1116   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1117       OS_REG     value;
;;;1118       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1119   
;;;1120   
;;;1121   
;;;1122   #ifdef OS_SAFETY_CRITICAL
;;;1123       if (p_err == (OS_ERR *)0) {
;;;1124           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1125           return ((OS_REG)0);
;;;1126       }
;;;1127   #endif
;;;1128   
;;;1129   #if OS_CFG_ARG_CHK_EN > 0u
;;;1130       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
;;;1131          *p_err = OS_ERR_REG_ID_INVALID;
;;;1132           return ((OS_REG)0);
;;;1133       }
;;;1134   #endif
;;;1135   
;;;1136       CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4680              MOV      r8,r0
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_IntDisMeasStart
00001e  bf00              NOP      
;;;1137       if (p_tcb == (OS_TCB *)0) {
000020  b90c              CBNZ     r4,|L8.38|
;;;1138           p_tcb = OSTCBCurPtr;
000022  480a              LDR      r0,|L8.76|
000024  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L8.38|
;;;1139       }
;;;1140       value = p_tcb->RegTbl[id];
000026  f1040078          ADD      r0,r4,#0x78
00002a  f8507025          LDR      r7,[r0,r5,LSL #2]
;;;1141       CPU_CRITICAL_EXIT();
00002e  bf00              NOP      
000030  f7fffffe          BL       CPU_IntDisMeasStop
000034  bf00              NOP      
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       CPU_SR_Restore
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;1142      *p_err = OS_ERR_NONE;
000040  2000              MOVS     r0,#0
000042  8030              STRH     r0,[r6,#0]
;;;1143       return ((OS_REG)value);
000044  4638              MOV      r0,r7
;;;1144   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1145   #endif
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskRegGetID||, CODE, READONLY, ALIGN=2

                  OSTaskRegGetID PROC
;;;1165   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1166   OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;1167   {
000002  4604              MOV      r4,r0
;;;1168       OS_REG_ID  id;
;;;1169       CPU_SR_ALLOC();
000004  2600              MOVS     r6,#0
;;;1170   
;;;1171   
;;;1172   
;;;1173   #ifdef OS_SAFETY_CRITICAL
;;;1174       if (p_err == (OS_ERR *)0) {
;;;1175           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1176           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
;;;1177       }
;;;1178   #endif
;;;1179   
;;;1180       CPU_CRITICAL_ENTER();
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_IntDisMeasStart
000016  bf00              NOP      
;;;1181       if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
000018  4811              LDR      r0,|L9.96|
00001a  7800              LDRB     r0,[r0,#0]  ; OSTaskRegNextAvailID
00001c  b168              CBZ      r0,|L9.58|
;;;1182          *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
00001e  f64510da          MOV      r0,#0x59da
000022  8020              STRH     r0,[r4,#0]
;;;1183           CPU_CRITICAL_EXIT();
000024  bf00              NOP      
000026  f7fffffe          BL       CPU_IntDisMeasStop
00002a  bf00              NOP      
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       CPU_SR_Restore
000032  bf00              NOP      
000034  bf00              NOP      
;;;1184           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
000036  2001              MOVS     r0,#1
                  |L9.56|
;;;1185       }
;;;1186        
;;;1187       id    = OSTaskRegNextAvailID;                                 /* Assign the next available ID                     */
;;;1188       OSTaskRegNextAvailID++;                                       /* Increment available ID for next request          */
;;;1189       CPU_CRITICAL_EXIT();
;;;1190      *p_err = OS_ERR_NONE;
;;;1191       return (id);
;;;1192   }
000038  bd70              POP      {r4-r6,pc}
                  |L9.58|
00003a  4809              LDR      r0,|L9.96|
00003c  7805              LDRB     r5,[r0,#0]            ;1187  ; OSTaskRegNextAvailID
00003e  7800              LDRB     r0,[r0,#0]            ;1188  ; OSTaskRegNextAvailID
000040  1c40              ADDS     r0,r0,#1              ;1188
000042  4907              LDR      r1,|L9.96|
000044  7008              STRB     r0,[r1,#0]            ;1188
000046  bf00              NOP                            ;1189
000048  f7fffffe          BL       CPU_IntDisMeasStop
00004c  bf00              NOP                            ;1189
00004e  4630              MOV      r0,r6                 ;1189
000050  f7fffffe          BL       CPU_SR_Restore
000054  bf00              NOP                            ;1189
000056  bf00              NOP                            ;1189
000058  2000              MOVS     r0,#0                 ;1190
00005a  8020              STRH     r0,[r4,#0]            ;1190
00005c  4628              MOV      r0,r5                 ;1191
00005e  e7eb              B        |L9.56|
;;;1193   #endif
                          ENDP

                  |L9.96|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1221   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1222   void  OSTaskRegSet (OS_TCB     *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1223                       OS_REG_ID   id,
;;;1224                       OS_REG      value,
;;;1225                       OS_ERR     *p_err)
;;;1226   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;1227       CPU_SR_ALLOC();
00000c  f04f0800          MOV      r8,#0
;;;1228   
;;;1229   
;;;1230   
;;;1231   #ifdef OS_SAFETY_CRITICAL
;;;1232       if (p_err == (OS_ERR *)0) {
;;;1233           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1234           return;
;;;1235       }
;;;1236   #endif
;;;1237   
;;;1238   #if OS_CFG_ARG_CHK_EN > 0u
;;;1239       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
;;;1240          *p_err = OS_ERR_REG_ID_INVALID;
;;;1241           return;
;;;1242       }
;;;1243   #endif
;;;1244   
;;;1245       CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4680              MOV      r8,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;1246       if (p_tcb == (OS_TCB *)0) {
000022  b90c              CBNZ     r4,|L10.40|
;;;1247           p_tcb = OSTCBCurPtr;
000024  4809              LDR      r0,|L10.76|
000026  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L10.40|
;;;1248       }
;;;1249       p_tcb->RegTbl[id] = value;
000028  f1040078          ADD      r0,r4,#0x78
00002c  f8407025          STR      r7,[r0,r5,LSL #2]
;;;1250       CPU_CRITICAL_EXIT();
000030  bf00              NOP      
000032  f7fffffe          BL       CPU_IntDisMeasStop
000036  bf00              NOP      
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       CPU_SR_Restore
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1251      *p_err             = OS_ERR_NONE;
000042  2000              MOVS     r0,#0
000044  8030              STRH     r0,[r6,#0]
;;;1252   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1253   #endif
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=1

                  OSTaskResume PROC
;;;1277   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1278   void  OSTaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1279                       OS_ERR  *p_err)
;;;1280   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1281       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;1282   
;;;1283   
;;;1284   
;;;1285   #ifdef OS_SAFETY_CRITICAL
;;;1286       if (p_err == (OS_ERR *)0) {
;;;1287           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1288           return;
;;;1289       }
;;;1290   #endif
;;;1291   
;;;1292   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1293       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1294       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1295          *p_err = OS_ERR_TASK_RESUME_ISR;
;;;1296           return;
;;;1297       }
;;;1298   #endif
;;;1299   
;;;1300   
;;;1301       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_IntDisMeasStart
000018  bf00              NOP      
;;;1302   #if OS_CFG_ARG_CHK_EN > 0u
;;;1303       if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
;;;1304           (p_tcb == OSTCBCurPtr)) {
;;;1305           CPU_CRITICAL_EXIT();
;;;1306          *p_err  = OS_ERR_TASK_RESUME_SELF;
;;;1307           return;
;;;1308       }
;;;1309   #endif
;;;1310       CPU_CRITICAL_EXIT();
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStop
000020  bf00              NOP      
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       CPU_SR_Restore
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1311   
;;;1312   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1313       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1314           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_RESUME,   /* Post to ISR queue                                      */
;;;1315                       (void      *)p_tcb,
;;;1316                       (void      *)0,
;;;1317                       (OS_MSG_SIZE)0,
;;;1318                       (OS_FLAGS   )0,
;;;1319                       (OS_OPT     )0,
;;;1320                       (CPU_TS     )0,
;;;1321                       (OS_ERR    *)p_err);
;;;1322           return;
;;;1323       }
;;;1324   #endif
;;;1325   
;;;1326       OS_TaskResume(p_tcb, p_err);
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       OS_TaskResume
;;;1327   
;;;1328   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1329       TRACE_OS_TASK_RESUME(p_tcb);                            /* Record the event.                                      */
;;;1330   #endif
;;;1331   }
000034  bd70              POP      {r4-r6,pc}
;;;1332   #endif
                          ENDP


                          AREA ||i.OSTaskSemPend||, CODE, READONLY, ALIGN=2

                  OSTaskSemPend PROC
;;;1367   
;;;1368   OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1369                              OS_OPT    opt,
;;;1370                              CPU_TS   *p_ts,
;;;1371                              OS_ERR   *p_err)
;;;1372   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;1373       OS_SEM_CTR    ctr;
;;;1374       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;1375   
;;;1376   
;;;1377   
;;;1378   #ifdef OS_SAFETY_CRITICAL
;;;1379       if (p_err == (OS_ERR *)0) {
;;;1380   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1381           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                      */
;;;1382   #endif
;;;1383           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1384           return ((OS_SEM_CTR)0);
;;;1385       }
;;;1386   #endif
;;;1387   
;;;1388   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1389       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1390   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1391           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                      */
;;;1392   #endif
;;;1393          *p_err = OS_ERR_PEND_ISR;
;;;1394           return ((OS_SEM_CTR)0);
;;;1395       }
;;;1396   #endif
;;;1397   
;;;1398   #if OS_CFG_ARG_CHK_EN > 0u
;;;1399       switch (opt) {                                          /* Validate 'opt'                                         */
;;;1400           case OS_OPT_PEND_BLOCKING:
;;;1401           case OS_OPT_PEND_NON_BLOCKING:
;;;1402                break;
;;;1403   
;;;1404           default:
;;;1405   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1406                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1407   #endif
;;;1408               *p_err = OS_ERR_OPT_INVALID;
;;;1409                return ((OS_SEM_CTR)0);
;;;1410       }
;;;1411   #endif
;;;1412   
;;;1413       if (p_ts != (CPU_TS *)0) {
000010  b10c              CBZ      r4,|L12.22|
;;;1414          *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
000012  2000              MOVS     r0,#0
000014  6020              STR      r0,[r4,#0]
                  |L12.22|
;;;1415       }
;;;1416   
;;;1417       CPU_CRITICAL_ENTER();
000016  bf00              NOP      
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4681              MOV      r9,r0
000020  bf00              NOP      
000022  f7fffffe          BL       CPU_IntDisMeasStart
000026  bf00              NOP      
;;;1418       if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
000028  4865              LDR      r0,|L12.448|
00002a  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00002c  6cc0              LDR      r0,[r0,#0x4c]
00002e  b3c0              CBZ      r0,|L12.162|
;;;1419           OSTCBCurPtr->SemCtr--;
000030  4863              LDR      r0,|L12.448|
000032  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000034  6cc0              LDR      r0,[r0,#0x4c]
000036  1e40              SUBS     r0,r0,#1
000038  4961              LDR      r1,|L12.448|
00003a  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00003c  64c8              STR      r0,[r1,#0x4c]
;;;1420           ctr    = OSTCBCurPtr->SemCtr;
00003e  4860              LDR      r0,|L12.448|
000040  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000042  6cc6              LDR      r6,[r0,#0x4c]
;;;1421           if (p_ts != (CPU_TS *)0) {
000044  b11c              CBZ      r4,|L12.78|
;;;1422              *p_ts  = OSTCBCurPtr->TS;
000046  485e              LDR      r0,|L12.448|
000048  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00004a  6c80              LDR      r0,[r0,#0x48]
00004c  6020              STR      r0,[r4,#0]
                  |L12.78|
;;;1423           }
;;;1424   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1425           OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
00004e  f7fffffe          BL       CPU_TS_TmrRd
000052  495b              LDR      r1,|L12.448|
000054  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000056  6c89              LDR      r1,[r1,#0x48]
000058  1a40              SUBS     r0,r0,r1
00005a  4959              LDR      r1,|L12.448|
00005c  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00005e  f8c100a0          STR      r0,[r1,#0xa0]
;;;1426           if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
000062  4857              LDR      r0,|L12.448|
000064  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000066  f8d000a4          LDR      r0,[r0,#0xa4]
00006a  4955              LDR      r1,|L12.448|
00006c  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
00006e  f8d110a0          LDR      r1,[r1,#0xa0]
000072  4288              CMP      r0,r1
000074  d207              BCS      |L12.134|
;;;1427               OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
000076  4852              LDR      r0,|L12.448|
000078  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00007a  f8d000a0          LDR      r0,[r0,#0xa0]
00007e  4950              LDR      r1,|L12.448|
000080  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000082  f8c100a4          STR      r0,[r1,#0xa4]
                  |L12.134|
;;;1428           }
;;;1429   #endif
;;;1430           CPU_CRITICAL_EXIT();
000086  bf00              NOP      
000088  f7fffffe          BL       CPU_IntDisMeasStop
00008c  bf00              NOP      
00008e  4648              MOV      r0,r9
000090  f7fffffe          BL       CPU_SR_Restore
000094  bf00              NOP      
000096  bf00              NOP      
;;;1431   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1432           TRACE_OS_TASK_SEM_PEND(OSTCBCurPtr);                /* Record the event.                                      */
;;;1433   #endif
;;;1434          *p_err = OS_ERR_NONE;
000098  2000              MOVS     r0,#0
00009a  8028              STRH     r0,[r5,#0]
;;;1435           return (ctr);
00009c  4630              MOV      r0,r6
                  |L12.158|
;;;1436       }
;;;1437   
;;;1438       if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;1439           CPU_CRITICAL_EXIT();        
;;;1440          *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;1441   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1442           TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);         /* Record the event.                                      */
;;;1443   #endif
;;;1444           return ((OS_SEM_CTR)0);
;;;1445       } else {                                                /* Yes                                                    */
;;;1446           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;1447               CPU_CRITICAL_EXIT();
;;;1448   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1449               TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);     /* Record the event.                                      */
;;;1450   #endif
;;;1451              *p_err = OS_ERR_SCHED_LOCKED;
;;;1452               return ((OS_SEM_CTR)0);
;;;1453           }
;;;1454       }
;;;1455                                                               /* Lock the scheduler/re-enable interrupts                */
;;;1456       OS_CRITICAL_ENTER_CPU_EXIT();
;;;1457       OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
;;;1458               (OS_PEND_OBJ  *)0,
;;;1459               (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
;;;1460               (OS_TICK       )timeout);
;;;1461       OS_CRITICAL_EXIT_NO_SCHED();
;;;1462   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1463       TRACE_OS_TASK_SEM_PEND_BLOCK(OSTCBCurPtr);              /* Record the event.                                      */
;;;1464   #endif
;;;1465       OSSched();                                              /* Find next highest priority task ready to run           */
;;;1466   
;;;1467       CPU_CRITICAL_ENTER();
;;;1468       switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
;;;1469           case OS_STATUS_PEND_OK:
;;;1470                if (p_ts != (CPU_TS *)0) {
;;;1471                   *p_ts                    =  OSTCBCurPtr->TS;
;;;1472   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1473                   OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1474                   if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1475                       OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1476                   }
;;;1477   #endif
;;;1478                }
;;;1479   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1480                TRACE_OS_TASK_SEM_PEND(OSTCBCurPtr);           /* Record the event.                                      */
;;;1481   #endif
;;;1482               *p_err = OS_ERR_NONE;
;;;1483                break;
;;;1484   
;;;1485           case OS_STATUS_PEND_ABORT:
;;;1486                if (p_ts != (CPU_TS *)0) {
;;;1487                   *p_ts  =  OSTCBCurPtr->TS;
;;;1488                }
;;;1489   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1490                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1491   #endif
;;;1492               *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
;;;1493                break;
;;;1494   
;;;1495           case OS_STATUS_PEND_TIMEOUT:
;;;1496                if (p_ts != (CPU_TS *)0) {
;;;1497                   *p_ts  = (CPU_TS  )0;
;;;1498                }
;;;1499   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1500                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1501   #endif
;;;1502               *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
;;;1503                break;
;;;1504   
;;;1505           default:
;;;1506   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1507                TRACE_OS_TASK_SEM_PEND_FAILED(OSTCBCurPtr);    /* Record the event.                                      */
;;;1508   #endif
;;;1509               *p_err = OS_ERR_STATUS_INVALID;
;;;1510                break;
;;;1511       }
;;;1512       ctr = OSTCBCurPtr->SemCtr;
;;;1513       CPU_CRITICAL_EXIT();
;;;1514       return (ctr);
;;;1515   }
00009e  e8bd87f0          POP      {r4-r10,pc}
                  |L12.162|
0000a2  e7ff              B        |L12.164|
                  |L12.164|
0000a4  f4084000          AND      r0,r8,#0x8000         ;1438
0000a8  b168              CBZ      r0,|L12.198|
0000aa  bf00              NOP                            ;1439
0000ac  f7fffffe          BL       CPU_IntDisMeasStop
0000b0  bf00              NOP                            ;1439
0000b2  4648              MOV      r0,r9                 ;1439
0000b4  f7fffffe          BL       CPU_SR_Restore
0000b8  bf00              NOP                            ;1439
0000ba  bf00              NOP                            ;1439
0000bc  f24610b0          MOV      r0,#0x61b0            ;1440
0000c0  8028              STRH     r0,[r5,#0]            ;1440
0000c2  2000              MOVS     r0,#0                 ;1444
0000c4  e7eb              B        |L12.158|
                  |L12.198|
0000c6  483f              LDR      r0,|L12.452|
0000c8  7800              LDRB     r0,[r0,#0]            ;1446  ; OSSchedLockNestingCtr
0000ca  2800              CMP      r0,#0                 ;1446
0000cc  dd0d              BLE      |L12.234|
0000ce  bf00              NOP                            ;1447
0000d0  f7fffffe          BL       CPU_IntDisMeasStop
0000d4  bf00              NOP                            ;1447
0000d6  4648              MOV      r0,r9                 ;1447
0000d8  f7fffffe          BL       CPU_SR_Restore
0000dc  bf00              NOP                            ;1447
0000de  bf00              NOP                            ;1447
0000e0  f6465063          MOV      r0,#0x6d63            ;1451
0000e4  8028              STRH     r0,[r5,#0]            ;1451
0000e6  2000              MOVS     r0,#0                 ;1452
0000e8  e7d9              B        |L12.158|
                  |L12.234|
0000ea  463b              MOV      r3,r7                 ;1457
0000ec  2207              MOVS     r2,#7                 ;1457
0000ee  2100              MOVS     r1,#0                 ;1457
0000f0  4608              MOV      r0,r1                 ;1457
0000f2  f7fffffe          BL       OS_Pend
0000f6  bf00              NOP                            ;1461
0000f8  f7fffffe          BL       CPU_IntDisMeasStop
0000fc  bf00              NOP                            ;1461
0000fe  4648              MOV      r0,r9                 ;1461
000100  f7fffffe          BL       CPU_SR_Restore
000104  bf00              NOP                            ;1461
000106  bf00              NOP                            ;1461
000108  f7fffffe          BL       OSSched
00010c  bf00              NOP                            ;1467
00010e  bf00              NOP                            ;1467
000110  f7fffffe          BL       CPU_SR_Save
000114  4681              MOV      r9,r0                 ;1467
000116  bf00              NOP                            ;1467
000118  f7fffffe          BL       CPU_IntDisMeasStart
00011c  bf00              NOP                            ;1467
00011e  4828              LDR      r0,|L12.448|
000120  6800              LDR      r0,[r0,#0]            ;1468  ; OSTCBCurPtr
000122  f8900035          LDRB     r0,[r0,#0x35]         ;1468
000126  b120              CBZ      r0,|L12.306|
000128  2801              CMP      r0,#1                 ;1468
00012a  d026              BEQ      |L12.378|
00012c  2803              CMP      r0,#3                 ;1468
00012e  d134              BNE      |L12.410|
000130  e02c              B        |L12.396|
                  |L12.306|
000132  b1fc              CBZ      r4,|L12.372|
000134  4822              LDR      r0,|L12.448|
000136  6800              LDR      r0,[r0,#0]            ;1471  ; OSTCBCurPtr
000138  6c80              LDR      r0,[r0,#0x48]         ;1471
00013a  6020              STR      r0,[r4,#0]            ;1471
00013c  f7fffffe          BL       CPU_TS_TmrRd
000140  491f              LDR      r1,|L12.448|
000142  6809              LDR      r1,[r1,#0]            ;1473  ; OSTCBCurPtr
000144  6c89              LDR      r1,[r1,#0x48]         ;1473
000146  1a40              SUBS     r0,r0,r1              ;1473
000148  491d              LDR      r1,|L12.448|
00014a  6809              LDR      r1,[r1,#0]            ;1473  ; OSTCBCurPtr
00014c  f8c100a0          STR      r0,[r1,#0xa0]         ;1473
000150  481b              LDR      r0,|L12.448|
000152  6800              LDR      r0,[r0,#0]            ;1474  ; OSTCBCurPtr
000154  f8d000a4          LDR      r0,[r0,#0xa4]         ;1474
000158  4919              LDR      r1,|L12.448|
00015a  6809              LDR      r1,[r1,#0]            ;1474  ; OSTCBCurPtr
00015c  f8d110a0          LDR      r1,[r1,#0xa0]         ;1474
000160  4288              CMP      r0,r1                 ;1474
000162  d207              BCS      |L12.372|
000164  4816              LDR      r0,|L12.448|
000166  6800              LDR      r0,[r0,#0]            ;1475  ; OSTCBCurPtr
000168  f8d000a0          LDR      r0,[r0,#0xa0]         ;1475
00016c  4914              LDR      r1,|L12.448|
00016e  6809              LDR      r1,[r1,#0]            ;1475  ; OSTCBCurPtr
000170  f8c100a4          STR      r0,[r1,#0xa4]         ;1475
                  |L12.372|
000174  2000              MOVS     r0,#0                 ;1482
000176  8028              STRH     r0,[r5,#0]            ;1482
000178  e013              B        |L12.418|
                  |L12.378|
00017a  b11c              CBZ      r4,|L12.388|
00017c  4810              LDR      r0,|L12.448|
00017e  6800              LDR      r0,[r0,#0]            ;1487  ; OSTCBCurPtr
000180  6c80              LDR      r0,[r0,#0x48]         ;1487
000182  6020              STR      r0,[r4,#0]            ;1487
                  |L12.388|
000184  f24610a9          MOV      r0,#0x61a9            ;1492
000188  8028              STRH     r0,[r5,#0]            ;1492
00018a  e00a              B        |L12.418|
                  |L12.396|
00018c  b10c              CBZ      r4,|L12.402|
00018e  2000              MOVS     r0,#0                 ;1497
000190  6020              STR      r0,[r4,#0]            ;1497
                  |L12.402|
000192  f24720d9          MOV      r0,#0x72d9            ;1502
000196  8028              STRH     r0,[r5,#0]            ;1502
000198  e003              B        |L12.418|
                  |L12.410|
00019a  f646602e          MOV      r0,#0x6e2e            ;1509
00019e  8028              STRH     r0,[r5,#0]            ;1509
0001a0  bf00              NOP                            ;1510
                  |L12.418|
0001a2  bf00              NOP                            ;1483
0001a4  4806              LDR      r0,|L12.448|
0001a6  6800              LDR      r0,[r0,#0]            ;1512  ; OSTCBCurPtr
0001a8  6cc6              LDR      r6,[r0,#0x4c]         ;1512
0001aa  bf00              NOP                            ;1513
0001ac  f7fffffe          BL       CPU_IntDisMeasStop
0001b0  bf00              NOP                            ;1513
0001b2  4648              MOV      r0,r9                 ;1513
0001b4  f7fffffe          BL       CPU_SR_Restore
0001b8  bf00              NOP                            ;1513
0001ba  bf00              NOP                            ;1513
0001bc  4630              MOV      r0,r6                 ;1514
0001be  e76e              B        |L12.158|
;;;1516   
                          ENDP

                  |L12.448|
                          DCD      OSTCBCurPtr
                  |L12.452|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskSemPendAbort PROC
;;;1546   #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u
;;;1547   CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1548                                    OS_OPT   opt,
;;;1549                                    OS_ERR  *p_err)
;;;1550   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1551       CPU_TS         ts;
;;;1552       CPU_SR_ALLOC();
00000a  2700              MOVS     r7,#0
;;;1553   
;;;1554   
;;;1555   
;;;1556   #ifdef OS_SAFETY_CRITICAL
;;;1557       if (p_err == (OS_ERR *)0) {
;;;1558           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1559           return (DEF_FALSE);
;;;1560       }
;;;1561   #endif
;;;1562   
;;;1563   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1564       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
;;;1565          *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
;;;1566           return (DEF_FALSE);
;;;1567       }
;;;1568   #endif
;;;1569   
;;;1570   #if OS_CFG_ARG_CHK_EN > 0u
;;;1571       switch (opt) {                                          /* Validate 'opt'                                         */
;;;1572           case OS_OPT_POST_NONE:
;;;1573           case OS_OPT_POST_NO_SCHED:
;;;1574                break;
;;;1575   
;;;1576           default:
;;;1577               *p_err =  OS_ERR_OPT_INVALID;
;;;1578                return (DEF_FALSE);
;;;1579       }
;;;1580   #endif
;;;1581   
;;;1582       CPU_CRITICAL_ENTER();
00000c  bf00              NOP      
00000e  bf00              NOP      
000010  f7fffffe          BL       CPU_SR_Save
000014  4607              MOV      r7,r0
000016  bf00              NOP      
000018  f7fffffe          BL       CPU_IntDisMeasStart
00001c  bf00              NOP      
;;;1583       if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
00001e  b11c              CBZ      r4,|L13.40|
;;;1584           (p_tcb == OSTCBCurPtr)) {
000020  4828              LDR      r0,|L13.196|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000024  4284              CMP      r4,r0
000026  d10e              BNE      |L13.70|
                  |L13.40|
;;;1585           CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
000028  bf00              NOP      
00002a  f7fffffe          BL       CPU_IntDisMeasStop
00002e  bf00              NOP      
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       CPU_SR_Restore
000036  bf00              NOP      
000038  bf00              NOP      
;;;1586          *p_err = OS_ERR_PEND_ABORT_SELF;
00003a  f24610ac          MOV      r0,#0x61ac
00003e  8028              STRH     r0,[r5,#0]
;;;1587           return (DEF_FALSE);
000040  2000              MOVS     r0,#0
                  |L13.66|
;;;1588       }
;;;1589   
;;;1590       if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
;;;1591           CPU_CRITICAL_EXIT();
;;;1592          *p_err = OS_ERR_PEND_ABORT_NONE;
;;;1593           return (DEF_FALSE);
;;;1594       }
;;;1595       CPU_CRITICAL_EXIT();
;;;1596   
;;;1597       OS_CRITICAL_ENTER();
;;;1598       ts = OS_TS_GET();
;;;1599       OS_PendAbort((OS_PEND_OBJ *)0,
;;;1600                    p_tcb,
;;;1601                    ts);
;;;1602       OS_CRITICAL_EXIT_NO_SCHED();
;;;1603       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1604           OSSched();                                          /* Run the scheduler                                      */
;;;1605       }
;;;1606      *p_err = OS_ERR_NONE;
;;;1607       return (DEF_TRUE);
;;;1608   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L13.70|
000046  f8940034          LDRB     r0,[r4,#0x34]         ;1590
00004a  2807              CMP      r0,#7                 ;1590
00004c  d00d              BEQ      |L13.106|
00004e  bf00              NOP                            ;1591
000050  f7fffffe          BL       CPU_IntDisMeasStop
000054  bf00              NOP                            ;1591
000056  4638              MOV      r0,r7                 ;1591
000058  f7fffffe          BL       CPU_SR_Restore
00005c  bf00              NOP                            ;1591
00005e  bf00              NOP                            ;1591
000060  f24610ab          MOV      r0,#0x61ab            ;1592
000064  8028              STRH     r0,[r5,#0]            ;1592
000066  2000              MOVS     r0,#0                 ;1593
000068  e7eb              B        |L13.66|
                  |L13.106|
00006a  bf00              NOP                            ;1595
00006c  f7fffffe          BL       CPU_IntDisMeasStop
000070  bf00              NOP                            ;1595
000072  4638              MOV      r0,r7                 ;1595
000074  f7fffffe          BL       CPU_SR_Restore
000078  bf00              NOP                            ;1595
00007a  bf00              NOP                            ;1595
00007c  bf00              NOP                            ;1597
00007e  bf00              NOP                            ;1597
000080  f7fffffe          BL       CPU_SR_Save
000084  4607              MOV      r7,r0                 ;1597
000086  bf00              NOP                            ;1597
000088  f7fffffe          BL       CPU_IntDisMeasStart
00008c  bf00              NOP                            ;1597
00008e  f7fffffe          BL       CPU_TS_TmrRd
000092  4680              MOV      r8,r0                 ;1598
000094  4642              MOV      r2,r8                 ;1599
000096  4621              MOV      r1,r4                 ;1599
000098  2000              MOVS     r0,#0                 ;1599
00009a  f7fffffe          BL       OS_PendAbort
00009e  bf00              NOP                            ;1602
0000a0  f7fffffe          BL       CPU_IntDisMeasStop
0000a4  bf00              NOP                            ;1602
0000a6  4638              MOV      r0,r7                 ;1602
0000a8  f7fffffe          BL       CPU_SR_Restore
0000ac  bf00              NOP                            ;1602
0000ae  bf00              NOP                            ;1602
0000b0  f4064000          AND      r0,r6,#0x8000         ;1603
0000b4  b908              CBNZ     r0,|L13.186|
0000b6  f7fffffe          BL       OSSched
                  |L13.186|
0000ba  2000              MOVS     r0,#0                 ;1606
0000bc  8028              STRH     r0,[r5,#0]            ;1606
0000be  2001              MOVS     r0,#1                 ;1607
0000c0  e7bf              B        |L13.66|
;;;1609   #endif
                          ENDP

0000c2  0000              DCW      0x0000
                  |L13.196|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSemPost||, CODE, READONLY, ALIGN=1

                  OSTaskSemPost PROC
;;;1634   
;;;1635   OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1636                              OS_OPT   opt,
;;;1637                              OS_ERR  *p_err)
;;;1638   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1639       OS_SEM_CTR  ctr;
;;;1640       CPU_TS      ts;
;;;1641   
;;;1642   
;;;1643   
;;;1644   #ifdef OS_SAFETY_CRITICAL
;;;1645       if (p_err == (OS_ERR *)0) {
;;;1646   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1647           TRACE_OS_TASK_SEM_POST_FAILED(p_tcb);               /* Record the event.                                      */
;;;1648   #endif
;;;1649           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1650           return ((OS_SEM_CTR)0);
;;;1651       }
;;;1652   #endif
;;;1653   
;;;1654   #if OS_CFG_ARG_CHK_EN > 0u
;;;1655       switch (opt) {                                          /* Validate 'opt'                                         */
;;;1656           case OS_OPT_POST_NONE:
;;;1657           case OS_OPT_POST_NO_SCHED:
;;;1658                break;
;;;1659   
;;;1660           default:
;;;1661   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1662                TRACE_OS_TASK_SEM_POST_FAILED(p_tcb);          /* Record the event.                                      */
;;;1663   #endif
;;;1664               *p_err =  OS_ERR_OPT_INVALID;
;;;1665                return ((OS_SEM_CTR)0u);
;;;1666       }
;;;1667   #endif
;;;1668   
;;;1669       ts = OS_TS_GET();                                       /* Get timestamp                                          */
00000a  f7fffffe          BL       CPU_TS_TmrRd
00000e  4680              MOV      r8,r0
;;;1670   
;;;1671   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1672       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1673           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
;;;1674                       (void      *)p_tcb,
;;;1675                       (void      *)0,
;;;1676                       (OS_MSG_SIZE)0,
;;;1677                       (OS_FLAGS   )0,
;;;1678                       (OS_OPT     )0,
;;;1679                       (CPU_TS     )ts,
;;;1680                       (OS_ERR    *)p_err);
;;;1681           return ((OS_SEM_CTR)0);
;;;1682       }
;;;1683   #endif
;;;1684   
;;;1685   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;1686       TRACE_OS_TASK_SEM_POST(p_tcb);                          /* Record the event.                                      */
;;;1687   #endif
;;;1688   
;;;1689       ctr = OS_TaskSemPost(p_tcb,
000010  4623              MOV      r3,r4
000012  4642              MOV      r2,r8
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       OS_TaskSemPost
00001c  4607              MOV      r7,r0
;;;1690                            opt,
;;;1691                            ts,
;;;1692                            p_err);
;;;1693   
;;;1694       return (ctr);
00001e  4638              MOV      r0,r7
;;;1695   }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;1696   
                          ENDP


                          AREA ||i.OSTaskSemSet||, CODE, READONLY, ALIGN=2

                  OSTaskSemSet PROC
;;;1717   
;;;1718   OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1719                             OS_SEM_CTR   cnt,
;;;1720                             OS_ERR      *p_err)
;;;1721   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1722       OS_SEM_CTR  ctr;
;;;1723       CPU_SR_ALLOC();
00000a  f04f0800          MOV      r8,#0
;;;1724   
;;;1725   
;;;1726   
;;;1727   #ifdef OS_SAFETY_CRITICAL
;;;1728       if (p_err == (OS_ERR *)0) {
;;;1729           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1730           return ((OS_SEM_CTR)0);
;;;1731       }
;;;1732   #endif
;;;1733   
;;;1734   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1735       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1736          *p_err = OS_ERR_SET_ISR;
;;;1737           return ((OS_SEM_CTR)0);
;;;1738       }
;;;1739   #endif
;;;1740   
;;;1741       CPU_CRITICAL_ENTER();
00000e  bf00              NOP      
000010  bf00              NOP      
000012  f7fffffe          BL       CPU_SR_Save
000016  4680              MOV      r8,r0
000018  bf00              NOP      
00001a  f7fffffe          BL       CPU_IntDisMeasStart
00001e  bf00              NOP      
;;;1742       if (p_tcb == (OS_TCB *)0) {
000020  b90c              CBNZ     r4,|L15.38|
;;;1743           p_tcb = OSTCBCurPtr;
000022  4809              LDR      r0,|L15.72|
000024  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L15.38|
;;;1744       }
;;;1745       ctr           = p_tcb->SemCtr;
000026  6ce7              LDR      r7,[r4,#0x4c]
;;;1746       p_tcb->SemCtr = (OS_SEM_CTR)cnt;
000028  64e5              STR      r5,[r4,#0x4c]
;;;1747       CPU_CRITICAL_EXIT();
00002a  bf00              NOP      
00002c  f7fffffe          BL       CPU_IntDisMeasStop
000030  bf00              NOP      
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       CPU_SR_Restore
000038  bf00              NOP      
00003a  bf00              NOP      
;;;1748      *p_err         =  OS_ERR_NONE;
00003c  2000              MOVS     r0,#0
00003e  8030              STRH     r0,[r6,#0]
;;;1749       return (ctr);
000040  4638              MOV      r0,r7
;;;1750   }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;1751   
                          ENDP

000046  0000              DCW      0x0000
                  |L15.72|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                  OSTaskStkChk PROC
;;;1777   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;1778   void  OSTaskStkChk (OS_TCB        *p_tcb,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1779                       CPU_STK_SIZE  *p_free,
;;;1780                       CPU_STK_SIZE  *p_used,
;;;1781                       OS_ERR        *p_err)
;;;1782   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1783       CPU_STK_SIZE  free_stk;
;;;1784       CPU_STK      *p_stk;
;;;1785       CPU_SR_ALLOC();
00000c  f04f0a00          MOV      r10,#0
;;;1786   
;;;1787   
;;;1788   
;;;1789   #ifdef OS_SAFETY_CRITICAL
;;;1790       if (p_err == (OS_ERR *)0) {
;;;1791           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1792           return;
;;;1793       }
;;;1794   #endif
;;;1795   
;;;1796   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1797       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
;;;1798          *p_err = OS_ERR_TASK_STK_CHK_ISR;
;;;1799           return;
;;;1800       }
;;;1801   #endif
;;;1802   
;;;1803   #if OS_CFG_ARG_CHK_EN > 0u
;;;1804       if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
;;;1805          *p_err  = OS_ERR_PTR_INVALID;
;;;1806           return;
;;;1807       }
;;;1808   
;;;1809       if (p_used == (CPU_STK_SIZE*)0) {
;;;1810          *p_err  = OS_ERR_PTR_INVALID;
;;;1811           return;
;;;1812       }
;;;1813   #endif
;;;1814   
;;;1815       CPU_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4682              MOV      r10,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;1816       if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
000022  b90c              CBNZ     r4,|L16.40|
;;;1817           p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
000024  4824              LDR      r0,|L16.184|
000026  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L16.40|
;;;1818       }
;;;1819   
;;;1820       if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
000028  6820              LDR      r0,[r4,#0]
00002a  b980              CBNZ     r0,|L16.78|
;;;1821           CPU_CRITICAL_EXIT();
00002c  bf00              NOP      
00002e  f7fffffe          BL       CPU_IntDisMeasStop
000032  bf00              NOP      
000034  4650              MOV      r0,r10
000036  f7fffffe          BL       CPU_SR_Restore
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;1822          *p_free = (CPU_STK_SIZE)0;
00003e  2000              MOVS     r0,#0
000040  6028              STR      r0,[r5,#0]
;;;1823          *p_used = (CPU_STK_SIZE)0;
000042  6030              STR      r0,[r6,#0]
;;;1824          *p_err  =  OS_ERR_TASK_NOT_EXIST;
000044  f2471052          MOV      r0,#0x7152
000048  8038              STRH     r0,[r7,#0]
                  |L16.74|
;;;1825           return;
;;;1826       }
;;;1827   
;;;1828       if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
;;;1829           CPU_CRITICAL_EXIT();
;;;1830          *p_free = (CPU_STK_SIZE)0;
;;;1831          *p_used = (CPU_STK_SIZE)0;
;;;1832          *p_err  =  OS_ERR_TASK_OPT;
;;;1833           return;
;;;1834       }
;;;1835       CPU_CRITICAL_EXIT();
;;;1836   
;;;1837       free_stk  = 0u;
;;;1838   #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
;;;1839       p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
;;;1840       while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
;;;1841           p_stk++;
;;;1842           free_stk++;
;;;1843       }
;;;1844   #else
;;;1845       p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
;;;1846       while (*p_stk == (CPU_STK)0) {
;;;1847           free_stk++;
;;;1848           p_stk--;
;;;1849       }
;;;1850   #endif
;;;1851      *p_free = free_stk;
;;;1852      *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
;;;1853      *p_err  = OS_ERR_NONE;
;;;1854   }
00004a  e8bd87f0          POP      {r4-r10,pc}
                  |L16.78|
00004e  f8940044          LDRB     r0,[r4,#0x44]         ;1828
000052  f0000001          AND      r0,r0,#1              ;1828
000056  b978              CBNZ     r0,|L16.120|
000058  bf00              NOP                            ;1829
00005a  f7fffffe          BL       CPU_IntDisMeasStop
00005e  bf00              NOP                            ;1829
000060  4650              MOV      r0,r10                ;1829
000062  f7fffffe          BL       CPU_SR_Restore
000066  bf00              NOP                            ;1829
000068  bf00              NOP                            ;1829
00006a  2000              MOVS     r0,#0                 ;1830
00006c  6028              STR      r0,[r5,#0]            ;1830
00006e  6030              STR      r0,[r6,#0]            ;1831
000070  f2471054          MOV      r0,#0x7154            ;1832
000074  8038              STRH     r0,[r7,#0]            ;1832
000076  e7e8              B        |L16.74|
                  |L16.120|
000078  bf00              NOP                            ;1835
00007a  f7fffffe          BL       CPU_IntDisMeasStop
00007e  bf00              NOP                            ;1835
000080  4650              MOV      r0,r10                ;1835
000082  f7fffffe          BL       CPU_SR_Restore
000086  bf00              NOP                            ;1835
000088  bf00              NOP                            ;1835
00008a  f04f0800          MOV      r8,#0                 ;1837
00008e  f8d49024          LDR      r9,[r4,#0x24]         ;1839
000092  e003              B        |L16.156|
                  |L16.148|
000094  f1090904          ADD      r9,r9,#4              ;1841
000098  f1080801          ADD      r8,r8,#1              ;1842
                  |L16.156|
00009c  f8d90000          LDR      r0,[r9,#0]            ;1840
0000a0  2800              CMP      r0,#0                 ;1840
0000a2  d0f7              BEQ      |L16.148|
0000a4  f8c58000          STR      r8,[r5,#0]            ;1851
0000a8  6c20              LDR      r0,[r4,#0x40]         ;1852
0000aa  eba00008          SUB      r0,r0,r8              ;1852
0000ae  6030              STR      r0,[r6,#0]            ;1852
0000b0  2000              MOVS     r0,#0                 ;1853
0000b2  8038              STRH     r0,[r7,#0]            ;1853
0000b4  bf00              NOP      
0000b6  e7c8              B        |L16.74|
;;;1855   #endif
                          ENDP

                  |L16.184|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;1887   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1888   void   OSTaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1889                         OS_ERR  *p_err)
;;;1890   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1891   #ifdef OS_SAFETY_CRITICAL
;;;1892       if (p_err == (OS_ERR *)0) {
;;;1893           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1894           return;
;;;1895       }
;;;1896   #endif
;;;1897   
;;;1898   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1899       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1900       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1901          *p_err = OS_ERR_TASK_SUSPEND_ISR;
;;;1902           return;
;;;1903       }
;;;1904   #endif
;;;1905   
;;;1906       if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
000006  4806              LDR      r0,|L17.32|
000008  4285              CMP      r5,r0
00000a  d103              BNE      |L17.20|
;;;1907          *p_err = OS_ERR_TASK_SUSPEND_IDLE;
00000c  f247105b          MOV      r0,#0x715b
000010  8020              STRH     r0,[r4,#0]
                  |L17.18|
;;;1908           return;
;;;1909       }
;;;1910   
;;;1911   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1912       if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
;;;1913          *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
;;;1914           return;
;;;1915       }
;;;1916   
;;;1917       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1918           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SUSPEND,  /* Post to ISR queue                                      */
;;;1919                       (void      *)p_tcb,
;;;1920                       (void      *)0,
;;;1921                       (OS_MSG_SIZE)0,
;;;1922                       (OS_FLAGS   )0,
;;;1923                       (OS_OPT     )0,
;;;1924                       (CPU_TS     )0,
;;;1925                       (OS_ERR    *)p_err);
;;;1926           return;
;;;1927       }
;;;1928   #endif
;;;1929   
;;;1930       OS_TaskSuspend(p_tcb, p_err);
;;;1931   }
000012  bd70              POP      {r4-r6,pc}
                  |L17.20|
000014  4621              MOV      r1,r4                 ;1930
000016  4628              MOV      r0,r5                 ;1930
000018  f7fffffe          BL       OS_TaskSuspend
00001c  bf00              NOP      
00001e  e7f8              B        |L17.18|
;;;1932   #endif
                          ENDP

                  |L17.32|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_TaskChangePrio||, CODE, READONLY, ALIGN=2

                  OS_TaskChangePrio PROC
;;;2736   
;;;2737   void  OS_TaskChangePrio(OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2738                           OS_PRIO  prio_new)
;;;2739   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2740       OS_TCB  *p_tcb_owner;
;;;2741   #if OS_CFG_MUTEX_EN > 0
;;;2742       OS_PRIO  prio_cur;
;;;2743   #endif
;;;2744   
;;;2745   
;;;2746       do {
000008  bf00              NOP      
                  |L18.10|
;;;2747           p_tcb_owner = (OS_TCB *)0;
00000a  2600              MOVS     r6,#0
;;;2748   #if OS_CFG_MUTEX_EN > 0
;;;2749           prio_cur    = p_tcb->Prio;
00000c  f8947037          LDRB     r7,[r4,#0x37]
;;;2750   #endif
;;;2751           switch (p_tcb->TaskState) {
000010  f8940036          LDRB     r0,[r4,#0x36]
000014  2808              CMP      r0,#8
000016  d25f              BCS      |L18.216|
000018  e8dff000          TBB      [pc,r0]
00001c  04191e1f          DCB      0x04,0x19,0x1e,0x1f
000020  1a1b2021          DCB      0x1a,0x1b,0x20,0x21
;;;2752               case OS_TASK_STATE_RDY:
;;;2753                    OS_RdyListRemove(p_tcb);                   /* Remove from current priority                           */
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       OS_RdyListRemove
;;;2754                    p_tcb->Prio = prio_new;                    /* Set new task priority                                  */
00002a  f8845037          STRB     r5,[r4,#0x37]
;;;2755                    OS_PrioInsert(p_tcb->Prio);
00002e  f8940037          LDRB     r0,[r4,#0x37]
000032  f7fffffe          BL       OS_PrioInsert
;;;2756                    if (p_tcb == OSTCBCurPtr) {
000036  482c              LDR      r0,|L18.232|
000038  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00003a  4284              CMP      r4,r0
00003c  d103              BNE      |L18.70|
;;;2757                        OS_RdyListInsertHead(p_tcb);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_RdyListInsertHead
000044  e002              B        |L18.76|
                  |L18.70|
;;;2758                    } else {
;;;2759                        OS_RdyListInsertTail(p_tcb);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OS_RdyListInsertTail
                  |L18.76|
;;;2760                    }
;;;2761                    break;
00004c  e046              B        |L18.220|
;;;2762   
;;;2763               case OS_TASK_STATE_DLY:                         /* Nothing to do except change the priority in the OS_TCB */
;;;2764               case OS_TASK_STATE_SUSPENDED:
00004e  bf00              NOP      
;;;2765               case OS_TASK_STATE_DLY_SUSPENDED:
000050  bf00              NOP      
;;;2766                    p_tcb->Prio = prio_new;                    /* Set new task priority                                  */
000052  f8845037          STRB     r5,[r4,#0x37]
;;;2767                    break;
000056  e041              B        |L18.220|
;;;2768   
;;;2769               case OS_TASK_STATE_PEND:
;;;2770               case OS_TASK_STATE_PEND_TIMEOUT:
000058  bf00              NOP      
;;;2771               case OS_TASK_STATE_PEND_SUSPENDED:
00005a  bf00              NOP      
;;;2772               case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
00005c  bf00              NOP      
;;;2773                    p_tcb->Prio = prio_new;                    /* Set new task priority                                  */
00005e  f8845037          STRB     r5,[r4,#0x37]
;;;2774                    switch (p_tcb->PendOn) {                   /* What to do depends on what we are pending on           */
000062  f8940034          LDRB     r0,[r4,#0x34]
000066  2808              CMP      r0,#8
000068  d231              BCS      |L18.206|
00006a  e8dff000          TBB      [pc,r0]
00006e  3004              DCB      0x30,0x04
000070  31050b06          DCB      0x31,0x05,0x0b,0x06
000074  0732              DCB      0x07,0x32
;;;2775                        case OS_TASK_PEND_ON_FLAG:
;;;2776                        case OS_TASK_PEND_ON_MULTI:
000076  bf00              NOP      
;;;2777                        case OS_TASK_PEND_ON_Q:
000078  bf00              NOP      
;;;2778                        case OS_TASK_PEND_ON_SEM:
00007a  bf00              NOP      
;;;2779                             OS_PendListChangePrio(p_tcb);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       OS_PendListChangePrio
;;;2780                             break;
000082  e027              B        |L18.212|
;;;2781   
;;;2782                        case OS_TASK_PEND_ON_MUTEX:
;;;2783   #if OS_CFG_MUTEX_EN > 0
;;;2784                             OS_PendListChangePrio(p_tcb);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       OS_PendListChangePrio
;;;2785                             p_tcb_owner = ((OS_MUTEX *)p_tcb->PendDataTblPtr->PendObjPtr)->OwnerTCBPtr;
00008a  6b20              LDR      r0,[r4,#0x30]
00008c  68c0              LDR      r0,[r0,#0xc]
00008e  6a46              LDR      r6,[r0,#0x24]
;;;2786                             if (prio_cur > prio_new) {         /* Are we increasing the priority?                        */
000090  42af              CMP      r7,r5
000092  dd05              BLE      |L18.160|
;;;2787                                 if (p_tcb_owner->Prio <= prio_new) {/* Yes, do we need to give this prio to the owner?   */
000094  f8960037          LDRB     r0,[r6,#0x37]
000098  42a8              CMP      r0,r5
00009a  dc17              BGT      |L18.204|
;;;2788                                     p_tcb_owner = (OS_TCB *)0;
00009c  2600              MOVS     r6,#0
00009e  e015              B        |L18.204|
                  |L18.160|
;;;2789                                 } else {
;;;2790   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;2791                                    TRACE_OS_MUTEX_TASK_PRIO_INHERIT(p_tcb_owner, prio_new);
;;;2792   #endif
;;;2793                                 }
;;;2794                             } else {
;;;2795                                 if (p_tcb_owner->Prio == prio_cur) {/* No, is it required to check for a lower prio?     */
0000a0  f8960037          LDRB     r0,[r6,#0x37]
0000a4  42b8              CMP      r0,r7
0000a6  d111              BNE      |L18.204|
;;;2796                                     prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       OS_MutexGrpPrioFindHighest
0000ae  4605              MOV      r5,r0
;;;2797                                     prio_new = prio_new > p_tcb_owner->BasePrio ? p_tcb_owner->BasePrio : prio_new;
0000b0  f8960038          LDRB     r0,[r6,#0x38]
0000b4  42a8              CMP      r0,r5
0000b6  da02              BGE      |L18.190|
0000b8  f8960038          LDRB     r0,[r6,#0x38]
0000bc  e000              B        |L18.192|
                  |L18.190|
0000be  4628              MOV      r0,r5
                  |L18.192|
0000c0  4605              MOV      r5,r0
;;;2798                                     if (prio_new == p_tcb_owner->Prio) {
0000c2  f8960037          LDRB     r0,[r6,#0x37]
0000c6  42a8              CMP      r0,r5
0000c8  d100              BNE      |L18.204|
;;;2799                                         p_tcb_owner = (OS_TCB *)0;
0000ca  2600              MOVS     r6,#0
                  |L18.204|
;;;2800                                     } else {
;;;2801   #if (defined(TRACE_CFG_EN) && (TRACE_CFG_EN > 0u))
;;;2802                                        TRACE_OS_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, prio_new);
;;;2803   #endif
;;;2804                                     }
;;;2805                                 }
;;;2806                             }
;;;2807   #endif
;;;2808                            break;
0000cc  e002              B        |L18.212|
                  |L18.206|
;;;2809   
;;;2810                        case OS_TASK_PEND_ON_TASK_Q:
0000ce  bf00              NOP      
;;;2811                        case OS_TASK_PEND_ON_TASK_SEM:
0000d0  bf00              NOP      
;;;2812                        default:
;;;2813                             break;
0000d2  bf00              NOP      
                  |L18.212|
0000d4  bf00              NOP                            ;2780
;;;2814                    }
;;;2815                    break;
0000d6  e001              B        |L18.220|
                  |L18.216|
;;;2816   
;;;2817               default:
;;;2818                    return;
;;;2819           }
;;;2820           p_tcb = p_tcb_owner;
;;;2821       } while (p_tcb != (OS_TCB *)0);
;;;2822   }
0000d8  e8bd81f0          POP      {r4-r8,pc}
                  |L18.220|
0000dc  bf00              NOP                            ;2761
0000de  4634              MOV      r4,r6                 ;2820
0000e0  2c00              CMP      r4,#0                 ;2821
0000e2  d192              BNE      |L18.10|
0000e4  bf00              NOP      
0000e6  e7f7              B        |L18.216|
                          ENDP

                  |L18.232|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListAdd PROC
;;;2011   #if OS_CFG_DBG_EN > 0u
;;;2012   void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
000000  2100              MOVS     r1,#0
;;;2013   {
;;;2014       p_tcb->DbgPrevPtr                = (OS_TCB *)0;
000002  f8c010b4          STR      r1,[r0,#0xb4]
;;;2015       if (OSTaskDbgListPtr == (OS_TCB *)0) {
000006  4909              LDR      r1,|L19.44|
000008  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
00000a  b919              CBNZ     r1,|L19.20|
;;;2016           p_tcb->DbgNextPtr            = (OS_TCB *)0;
00000c  2100              MOVS     r1,#0
00000e  f8c010b8          STR      r1,[r0,#0xb8]
000012  e007              B        |L19.36|
                  |L19.20|
;;;2017       } else {
;;;2018           p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
000014  4905              LDR      r1,|L19.44|
000016  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000018  f8c010b8          STR      r1,[r0,#0xb8]
;;;2019           OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
00001c  4903              LDR      r1,|L19.44|
00001e  6809              LDR      r1,[r1,#0]  ; OSTaskDbgListPtr
000020  f8c100b4          STR      r0,[r1,#0xb4]
                  |L19.36|
;;;2020       }
;;;2021       OSTaskDbgListPtr                 =  p_tcb;
000024  4901              LDR      r1,|L19.44|
000026  6008              STR      r0,[r1,#0]  ; OSTaskDbgListPtr
;;;2022   }
000028  4770              BX       lr
;;;2023   
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListRemove PROC
;;;2025   
;;;2026   void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
000000  f8d020b4          LDR      r2,[r0,#0xb4]
;;;2027   {
;;;2028       OS_TCB  *p_tcb_next;
;;;2029       OS_TCB  *p_tcb_prev;
;;;2030   
;;;2031   
;;;2032       p_tcb_prev = p_tcb->DbgPrevPtr;
;;;2033       p_tcb_next = p_tcb->DbgNextPtr;
000004  f8d010b8          LDR      r1,[r0,#0xb8]
;;;2034   
;;;2035       if (p_tcb_prev == (OS_TCB *)0) {
000008  b94a              CBNZ     r2,|L20.30|
;;;2036           OSTaskDbgListPtr = p_tcb_next;
00000a  4b0d              LDR      r3,|L20.64|
00000c  6019              STR      r1,[r3,#0]  ; OSTaskDbgListPtr
;;;2037           if (p_tcb_next != (OS_TCB *)0) {
00000e  b111              CBZ      r1,|L20.22|
;;;2038               p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
000010  2300              MOVS     r3,#0
000012  f8c130b4          STR      r3,[r1,#0xb4]
                  |L20.22|
;;;2039           }
;;;2040           p_tcb->DbgNextPtr = (OS_TCB *)0;
000016  2300              MOVS     r3,#0
000018  f8c030b8          STR      r3,[r0,#0xb8]
00001c  e00f              B        |L20.62|
                  |L20.30|
;;;2041   
;;;2042       } else if (p_tcb_next == (OS_TCB *)0) {
00001e  b929              CBNZ     r1,|L20.44|
;;;2043           p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
000020  2300              MOVS     r3,#0
000022  f8c230b8          STR      r3,[r2,#0xb8]
;;;2044           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
000026  f8c030b4          STR      r3,[r0,#0xb4]
00002a  e008              B        |L20.62|
                  |L20.44|
;;;2045   
;;;2046       } else {
;;;2047           p_tcb_prev->DbgNextPtr =  p_tcb_next;
00002c  f8c210b8          STR      r1,[r2,#0xb8]
;;;2048           p_tcb_next->DbgPrevPtr =  p_tcb_prev;
000030  f8c120b4          STR      r2,[r1,#0xb4]
;;;2049           p_tcb->DbgNextPtr      = (OS_TCB *)0;
000034  2300              MOVS     r3,#0
000036  f8c030b8          STR      r3,[r0,#0xb8]
;;;2050           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
00003a  f8c030b4          STR      r3,[r0,#0xb4]
                  |L20.62|
;;;2051       }
;;;2052   }
00003e  4770              BX       lr
;;;2053   #endif
                          ENDP

                  |L20.64|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskInit||, CODE, READONLY, ALIGN=2

                  OS_TaskInit PROC
;;;2072   
;;;2073   void  OS_TaskInit (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;2074   {
;;;2075   #ifdef OS_SAFETY_CRITICAL
;;;2076       if (p_err == (OS_ERR *)0) {
;;;2077           OS_SAFETY_CRITICAL_EXCEPTION();
;;;2078           return;
;;;2079       }
;;;2080   #endif
;;;2081   
;;;2082   #if OS_CFG_DBG_EN > 0u
;;;2083       OSTaskDbgListPtr = (OS_TCB      *)0;
000002  4a04              LDR      r2,|L21.20|
000004  6011              STR      r1,[r2,#0]  ; OSTaskDbgListPtr
;;;2084   #endif
;;;2085   
;;;2086       OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
000006  4a04              LDR      r2,|L21.24|
000008  8011              STRH     r1,[r2,#0]
;;;2087       OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
00000a  4a04              LDR      r2,|L21.28|
00000c  6011              STR      r1,[r2,#0]  ; OSTaskCtxSwCtr
;;;2088   
;;;2089      *p_err            = OS_ERR_NONE;
00000e  8001              STRH     r1,[r0,#0]
;;;2090   }
000010  4770              BX       lr
;;;2091   
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      OSTaskDbgListPtr
                  |L21.24|
                          DCD      OSTaskQty
                  |L21.28|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OS_TaskInitTCB||, CODE, READONLY, ALIGN=2

                  OS_TaskInitTCB PROC
;;;2106   
;;;2107   void  OS_TaskInitTCB (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2108   {
000002  4604              MOV      r4,r0
;;;2109   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;2110       OS_REG_ID   reg_id;
;;;2111   #endif
;;;2112   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2113       OS_TLS_ID   id;
;;;2114   #endif
;;;2115   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2116       CPU_TS      ts;
;;;2117   #endif
;;;2118   
;;;2119   
;;;2120       p_tcb->StkPtr             = (CPU_STK       *)0;
000004  2000              MOVS     r0,#0
000006  6020              STR      r0,[r4,#0]
;;;2121   #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;2122       p_tcb->StkLimitPtr        = (CPU_STK       *)0;
000008  60a0              STR      r0,[r4,#8]
;;;2123   #endif
;;;2124   
;;;2125       p_tcb->ExtPtr             = (void          *)0;
00000a  6060              STR      r0,[r4,#4]
;;;2126   
;;;2127       p_tcb->NextPtr            = (OS_TCB        *)0;
00000c  60e0              STR      r0,[r4,#0xc]
;;;2128       p_tcb->PrevPtr            = (OS_TCB        *)0;
00000e  6120              STR      r0,[r4,#0x10]
;;;2129   
;;;2130       p_tcb->TickNextPtr        = (OS_TCB        *)0;
000010  6160              STR      r0,[r4,#0x14]
;;;2131       p_tcb->TickPrevPtr        = (OS_TCB        *)0;
000012  61a0              STR      r0,[r4,#0x18]
;;;2132       p_tcb->TickListPtr        = (OS_TICK_LIST  *)0;
000014  61e0              STR      r0,[r4,#0x1c]
;;;2133   
;;;2134   #if OS_CFG_DBG_EN > 0u
;;;2135       p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
000016  a028              ADR      r0,|L22.184|
000018  6220              STR      r0,[r4,#0x20]
;;;2136   #endif
;;;2137   
;;;2138   #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;2139       p_tcb->StkBasePtr         = (CPU_STK       *)0;
00001a  2000              MOVS     r0,#0
00001c  6260              STR      r0,[r4,#0x24]
;;;2140   #endif
;;;2141   
;;;2142   #if OS_CFG_DBG_EN > 0u
;;;2143       p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
00001e  62a0              STR      r0,[r4,#0x28]
;;;2144       p_tcb->TaskEntryArg       = (void          *)0;
000020  62e0              STR      r0,[r4,#0x2c]
;;;2145   #endif
;;;2146   
;;;2147   #if (OS_CFG_PEND_MULTI_EN > 0u)
;;;2148       p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
000022  6320              STR      r0,[r4,#0x30]
;;;2149       p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
000024  f8a40046          STRH     r0,[r4,#0x46]
;;;2150   #endif
;;;2151   
;;;2152       p_tcb->TS                 = (CPU_TS         )0u;
000028  64a0              STR      r0,[r4,#0x48]
;;;2153   
;;;2154   #if (OS_MSG_EN > 0u)
;;;2155       p_tcb->MsgPtr             = (void          *)0;
00002a  65a0              STR      r0,[r4,#0x58]
;;;2156       p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
00002c  f8a4005c          STRH     r0,[r4,#0x5c]
;;;2157   #endif
;;;2158   
;;;2159   #if OS_CFG_TASK_Q_EN > 0u
;;;2160       OS_MsgQInit(&p_tcb->MsgQ,
000030  2100              MOVS     r1,#0
000032  f1040060          ADD      r0,r4,#0x60
000036  f7fffffe          BL       OS_MsgQInit
;;;2161                   (OS_MSG_QTY)0u);
;;;2162   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2163       p_tcb->MsgQPendTime       = (CPU_TS         )0u;
00003a  2000              MOVS     r0,#0
00003c  6720              STR      r0,[r4,#0x70]
;;;2164       p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
00003e  6760              STR      r0,[r4,#0x74]
;;;2165   #endif
;;;2166   #endif
;;;2167   
;;;2168   #if OS_CFG_FLAG_EN > 0u
;;;2169       p_tcb->FlagsPend          = (OS_FLAGS       )0u;
000040  67e0              STR      r0,[r4,#0x7c]
;;;2170       p_tcb->FlagsOpt           = (OS_OPT         )0u;
000042  f8a40084          STRH     r0,[r4,#0x84]
;;;2171       p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
000046  f8c40080          STR      r0,[r4,#0x80]
;;;2172   #endif
;;;2173   
;;;2174   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;2175       for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
00004a  2500              MOVS     r5,#0
00004c  e006              B        |L22.92|
                  |L22.78|
;;;2176           p_tcb->RegTbl[reg_id] = (OS_REG)0u;
00004e  2100              MOVS     r1,#0
000050  f1040078          ADD      r0,r4,#0x78
000054  f8401025          STR      r1,[r0,r5,LSL #2]
000058  1c68              ADDS     r0,r5,#1              ;2175
00005a  b2c5              UXTB     r5,r0                 ;2175
                  |L22.92|
00005c  2d00              CMP      r5,#0                 ;2175
00005e  d0f6              BEQ      |L22.78|
;;;2177       }
;;;2178   #endif
;;;2179   
;;;2180   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2181       for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;2182           p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
;;;2183       }
;;;2184   #endif
;;;2185   
;;;2186       p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
000060  2000              MOVS     r0,#0
000062  3434              ADDS     r4,r4,#0x34
000064  61a0              STR      r0,[r4,#0x18]
;;;2187   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2188       p_tcb->SemPendTime        = (CPU_TS         )0u;
000066  66e0              STR      r0,[r4,#0x6c]
;;;2189       p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
000068  6720              STR      r0,[r4,#0x70]
;;;2190   #endif
;;;2191   
;;;2192   #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
;;;2193       p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
00006a  60e0              STR      r0,[r4,#0xc]
;;;2194   #endif
;;;2195   
;;;2196   
;;;2197   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2198       p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
00006c  f8840052          STRB     r0,[r4,#0x52]
;;;2199   #endif
;;;2200   
;;;2201   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;2202       p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
000070  67a0              STR      r0,[r4,#0x78]
;;;2203       p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
000072  6760              STR      r0,[r4,#0x74]
;;;2204   #endif
;;;2205   
;;;2206       p_tcb->Opt                = (OS_OPT         )0u;
000074  8220              STRH     r0,[r4,#0x10]
;;;2207   
;;;2208       p_tcb->TickRemain         = (OS_TICK        )0u;
000076  61e0              STR      r0,[r4,#0x1c]
;;;2209       p_tcb->TickCtrPrev        = (OS_TICK        )0u;
000078  6220              STR      r0,[r4,#0x20]
;;;2210   
;;;2211   #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;2212       p_tcb->TimeQuanta         = (OS_TICK        )0u;
;;;2213       p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
;;;2214   #endif
;;;2215   
;;;2216   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2217       p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
00007a  f8a40054          STRH     r0,[r4,#0x54]
;;;2218       p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
00007e  f8a40056          STRH     r0,[r4,#0x56]
;;;2219       p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
000082  65a0              STR      r0,[r4,#0x58]
;;;2220       p_tcb->CyclesDelta        = (CPU_TS         )0u;
000084  65e0              STR      r0,[r4,#0x5c]
;;;2221       ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
000086  f7fffffe          BL       CPU_TS_TmrRd
00008a  4606              MOV      r6,r0
;;;2222       p_tcb->CyclesStart        = ts;
00008c  6626              STR      r6,[r4,#0x60]
;;;2223       p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
00008e  2000              MOVS     r0,#0
000090  6660              STR      r0,[r4,#0x64]
;;;2224   #endif
;;;2225   #ifdef CPU_CFG_INT_DIS_MEAS_EN
;;;2226       p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
000092  67e0              STR      r0,[r4,#0x7c]
;;;2227   #endif
;;;2228   #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;2229       p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
;;;2230   #endif
;;;2231   
;;;2232       p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
000094  7020              STRB     r0,[r4,#0]
;;;2233       p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
000096  7060              STRB     r0,[r4,#1]
;;;2234       p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
000098  70a0              STRB     r0,[r4,#2]
;;;2235   
;;;2236       p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
00009a  2040              MOVS     r0,#0x40
00009c  70e0              STRB     r0,[r4,#3]
;;;2237   #if OS_CFG_MUTEX_EN > 0u
;;;2238       p_tcb->BasePrio           = (OS_PRIO        )OS_PRIO_INIT;
00009e  7120              STRB     r0,[r4,#4]
;;;2239       p_tcb->MutexGrpHeadPtr    = (OS_MUTEX      *)0;
0000a0  2000              MOVS     r0,#0
0000a2  60a0              STR      r0,[r4,#8]
;;;2240   #endif
;;;2241   
;;;2242   #if OS_CFG_DBG_EN > 0u
;;;2243       p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
0000a4  f8c40080          STR      r0,[r4,#0x80]
;;;2244       p_tcb->DbgNextPtr         = (OS_TCB        *)0;
0000a8  f8c40084          STR      r0,[r4,#0x84]
;;;2245       p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
0000ac  a004              ADR      r0,|L22.192|
0000ae  f8c40088          STR      r0,[r4,#0x88]
0000b2  3c34              SUBS     r4,r4,#0x34
;;;2246   #endif
;;;2247   }
0000b4  bd70              POP      {r4-r6,pc}
;;;2248   
                          ENDP

0000b6  0000              DCW      0x0000
                  |L22.184|
0000b8  3f546173          DCB      "?Task",0
0000bc  6b00    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L22.192|
0000c0  2000              DCB      " ",0
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i.OS_TaskQPost||, CODE, READONLY, ALIGN=2

                  OS_TaskQPost PROC
;;;2291   #if OS_CFG_TASK_Q_EN > 0u
;;;2292   void  OS_TaskQPost (OS_TCB       *p_tcb,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2293                       void         *p_void,
;;;2294                       OS_MSG_SIZE   msg_size,
;;;2295                       OS_OPT        opt,
;;;2296                       CPU_TS        ts,
;;;2297                       OS_ERR       *p_err)
;;;2298   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9dd650a          LDRD     r6,r5,[sp,#0x28]
;;;2299       CPU_SR_ALLOC();
000010  f04f0a00          MOV      r10,#0
;;;2300   
;;;2301   
;;;2302   
;;;2303      *p_err = OS_ERR_NONE;                                    /* Assume we won't have any errors                        */
000014  2000              MOVS     r0,#0
000016  8028              STRH     r0,[r5,#0]
;;;2304       OS_CRITICAL_ENTER();
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_SR_Save
000020  4682              MOV      r10,r0
000022  bf00              NOP      
000024  f7fffffe          BL       CPU_IntDisMeasStart
000028  bf00              NOP      
;;;2305       if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
00002a  b90c              CBNZ     r4,|L23.48|
;;;2306           p_tcb = OSTCBCurPtr;
00002c  4830              LDR      r0,|L23.240|
00002e  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L23.48|
;;;2307       }
;;;2308       switch (p_tcb->TaskState) {
000030  f8940036          LDRB     r0,[r4,#0x36]
000034  2808              CMP      r0,#8
000036  d24b              BCS      |L23.208|
000038  e8dff000          TBB      [pc,r0]
00003c  04051a1b          DCB      0x04,0x05,0x1a,0x1b
000040  06071c1d          DCB      0x06,0x07,0x1c,0x1d
;;;2309           case OS_TASK_STATE_RDY:
;;;2310           case OS_TASK_STATE_DLY:
000044  bf00              NOP      
;;;2311           case OS_TASK_STATE_SUSPENDED:
000046  bf00              NOP      
;;;2312           case OS_TASK_STATE_DLY_SUSPENDED:
000048  bf00              NOP      
;;;2313                OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
00004a  464b              MOV      r3,r9
00004c  4642              MOV      r2,r8
00004e  4639              MOV      r1,r7
000050  f1040060          ADD      r0,r4,#0x60
000054  e9cd6500          STRD     r6,r5,[sp,#0]
000058  f7fffffe          BL       OS_MsgQPut
;;;2314                           p_void,
;;;2315                           msg_size,
;;;2316                           opt,
;;;2317                           ts,
;;;2318                           p_err);
;;;2319                OS_CRITICAL_EXIT();
00005c  bf00              NOP      
00005e  f7fffffe          BL       CPU_IntDisMeasStop
000062  bf00              NOP      
000064  4650              MOV      r0,r10
000066  f7fffffe          BL       CPU_SR_Restore
00006a  bf00              NOP      
00006c  bf00              NOP      
;;;2320                break;
00006e  e03c              B        |L23.234|
;;;2321   
;;;2322           case OS_TASK_STATE_PEND:
;;;2323           case OS_TASK_STATE_PEND_TIMEOUT:
000070  bf00              NOP      
;;;2324           case OS_TASK_STATE_PEND_SUSPENDED:
000072  bf00              NOP      
;;;2325           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
000074  bf00              NOP      
;;;2326                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
000076  f8940034          LDRB     r0,[r4,#0x34]
00007a  2802              CMP      r0,#2
00007c  d115              BNE      |L23.170|
;;;2327                    OS_Post((OS_PEND_OBJ *)0,
00007e  4643              MOV      r3,r8
000080  463a              MOV      r2,r7
000082  4621              MOV      r1,r4
000084  2000              MOVS     r0,#0
000086  9600              STR      r6,[sp,#0]
000088  f7fffffe          BL       OS_Post
;;;2328                            p_tcb,
;;;2329                            p_void,
;;;2330                            msg_size,
;;;2331                            ts);
;;;2332                    OS_CRITICAL_EXIT_NO_SCHED();
00008c  bf00              NOP      
00008e  f7fffffe          BL       CPU_IntDisMeasStop
000092  bf00              NOP      
000094  4650              MOV      r0,r10
000096  f7fffffe          BL       CPU_SR_Restore
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;2333                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
00009e  f4094000          AND      r0,r9,#0x8000
0000a2  b9a0              CBNZ     r0,|L23.206|
;;;2334                        OSSched();                             /* Run the scheduler                                      */
0000a4  f7fffffe          BL       OSSched
0000a8  e011              B        |L23.206|
                  |L23.170|
;;;2335                    }
;;;2336                } else {
;;;2337                    OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
0000aa  464b              MOV      r3,r9
0000ac  4642              MOV      r2,r8
0000ae  4639              MOV      r1,r7
0000b0  f1040060          ADD      r0,r4,#0x60
0000b4  e9cd6500          STRD     r6,r5,[sp,#0]
0000b8  f7fffffe          BL       OS_MsgQPut
;;;2338                               p_void,                         /*      ... Deposit the message in the task's queue       */
;;;2339                               msg_size,
;;;2340                               opt,
;;;2341                               ts,
;;;2342                               p_err);
;;;2343                    OS_CRITICAL_EXIT();
0000bc  bf00              NOP      
0000be  f7fffffe          BL       CPU_IntDisMeasStop
0000c2  bf00              NOP      
0000c4  4650              MOV      r0,r10
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP      
0000cc  bf00              NOP      
                  |L23.206|
;;;2344                }
;;;2345                break;
0000ce  e00c              B        |L23.234|
                  |L23.208|
;;;2346   
;;;2347           default:
;;;2348                OS_CRITICAL_EXIT();
0000d0  bf00              NOP      
0000d2  f7fffffe          BL       CPU_IntDisMeasStop
0000d6  bf00              NOP      
0000d8  4650              MOV      r0,r10
0000da  f7fffffe          BL       CPU_SR_Restore
0000de  bf00              NOP      
0000e0  bf00              NOP      
;;;2349               *p_err = OS_ERR_STATE_INVALID;
0000e2  f646602d          MOV      r0,#0x6e2d
0000e6  8028              STRH     r0,[r5,#0]
;;;2350                break;
0000e8  bf00              NOP      
                  |L23.234|
0000ea  bf00              NOP                            ;2320
;;;2351       }
;;;2352   }
0000ec  e8bd87fc          POP      {r2-r10,pc}
;;;2353   #endif
                          ENDP

                  |L23.240|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskResume||, CODE, READONLY, ALIGN=1

                  OS_TaskResume PROC
;;;2379   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2380   void  OS_TaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2381                        OS_ERR  *p_err)
;;;2382   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2383       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2384   
;;;2385   
;;;2386       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_IntDisMeasStart
000018  bf00              NOP      
;;;2387      *p_err  = OS_ERR_NONE;
00001a  2000              MOVS     r0,#0
00001c  8028              STRH     r0,[r5,#0]
;;;2388       switch (p_tcb->TaskState) {
00001e  f8940036          LDRB     r0,[r4,#0x36]
000022  2808              CMP      r0,#8
000024  d268              BCS      |L24.248|
000026  e8dff000          TBB      [pc,r0]
00002a  0405              DCB      0x04,0x05
00002c  0607142b          DCB      0x06,0x07,0x14,0x2b
000030  3f53              DCB      0x3f,0x53
;;;2389           case OS_TASK_STATE_RDY:
;;;2390           case OS_TASK_STATE_DLY:
000032  bf00              NOP      
;;;2391           case OS_TASK_STATE_PEND:
000034  bf00              NOP      
;;;2392           case OS_TASK_STATE_PEND_TIMEOUT:
000036  bf00              NOP      
;;;2393                CPU_CRITICAL_EXIT();
000038  bf00              NOP      
00003a  f7fffffe          BL       CPU_IntDisMeasStop
00003e  bf00              NOP      
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       CPU_SR_Restore
000046  bf00              NOP      
000048  bf00              NOP      
;;;2394               *p_err = OS_ERR_TASK_NOT_SUSPENDED;
00004a  f2471053          MOV      r0,#0x7153
00004e  8028              STRH     r0,[r5,#0]
;;;2395                break;
000050  e05f              B        |L24.274|
;;;2396   
;;;2397           case OS_TASK_STATE_SUSPENDED:
;;;2398                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2399                p_tcb->SuspendCtr--;
000052  f8140f86          LDRB     r0,[r4,#0x86]!
000056  1e40              SUBS     r0,r0,#1
000058  7020              STRB     r0,[r4,#0]
;;;2400                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
00005a  f8140986          LDRB     r0,[r4],#-0x86
00005e  b928              CBNZ     r0,|L24.108|
;;;2401                    p_tcb->TaskState = OS_TASK_STATE_RDY;
000060  2000              MOVS     r0,#0
000062  f8840036          STRB     r0,[r4,#0x36]
;;;2402                    OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_RdyListInsert
                  |L24.108|
;;;2403                }
;;;2404                OS_CRITICAL_EXIT_NO_SCHED();
00006c  bf00              NOP      
00006e  f7fffffe          BL       CPU_IntDisMeasStop
000072  bf00              NOP      
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       CPU_SR_Restore
00007a  bf00              NOP      
00007c  bf00              NOP      
;;;2405                break;
00007e  e048              B        |L24.274|
;;;2406   
;;;2407           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2408                p_tcb->SuspendCtr--;
000080  f8140f86          LDRB     r0,[r4,#0x86]!
000084  1e40              SUBS     r0,r0,#1
000086  7020              STRB     r0,[r4,#0]
;;;2409                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
000088  f8140986          LDRB     r0,[r4],#-0x86
00008c  b910              CBNZ     r0,|L24.148|
;;;2410                    p_tcb->TaskState = OS_TASK_STATE_DLY;
00008e  2001              MOVS     r0,#1
000090  f8840036          STRB     r0,[r4,#0x36]
                  |L24.148|
;;;2411                }
;;;2412                CPU_CRITICAL_EXIT();
000094  bf00              NOP      
000096  f7fffffe          BL       CPU_IntDisMeasStop
00009a  bf00              NOP      
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  bf00              NOP      
0000a4  bf00              NOP      
;;;2413                break;
0000a6  e034              B        |L24.274|
;;;2414   
;;;2415           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2416                p_tcb->SuspendCtr--;
0000a8  f8140f86          LDRB     r0,[r4,#0x86]!
0000ac  1e40              SUBS     r0,r0,#1
0000ae  7020              STRB     r0,[r4,#0]
;;;2417                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
0000b0  f8140986          LDRB     r0,[r4],#-0x86
0000b4  b910              CBNZ     r0,|L24.188|
;;;2418                    p_tcb->TaskState = OS_TASK_STATE_PEND;
0000b6  2002              MOVS     r0,#2
0000b8  f8840036          STRB     r0,[r4,#0x36]
                  |L24.188|
;;;2419                }
;;;2420                CPU_CRITICAL_EXIT();
0000bc  bf00              NOP      
0000be  f7fffffe          BL       CPU_IntDisMeasStop
0000c2  bf00              NOP      
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  bf00              NOP      
0000cc  bf00              NOP      
;;;2421                break;
0000ce  e020              B        |L24.274|
;;;2422   
;;;2423           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2424                p_tcb->SuspendCtr--;
0000d0  f8140f86          LDRB     r0,[r4,#0x86]!
0000d4  1e40              SUBS     r0,r0,#1
0000d6  7020              STRB     r0,[r4,#0]
;;;2425                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
0000d8  f8140986          LDRB     r0,[r4],#-0x86
0000dc  b910              CBNZ     r0,|L24.228|
;;;2426                    p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
0000de  2003              MOVS     r0,#3
0000e0  f8840036          STRB     r0,[r4,#0x36]
                  |L24.228|
;;;2427                }
;;;2428                CPU_CRITICAL_EXIT();
0000e4  bf00              NOP      
0000e6  f7fffffe          BL       CPU_IntDisMeasStop
0000ea  bf00              NOP      
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       CPU_SR_Restore
0000f2  bf00              NOP      
0000f4  bf00              NOP      
;;;2429                break;
0000f6  e00c              B        |L24.274|
                  |L24.248|
;;;2430   
;;;2431           default:
;;;2432                CPU_CRITICAL_EXIT();
0000f8  bf00              NOP      
0000fa  f7fffffe          BL       CPU_IntDisMeasStop
0000fe  bf00              NOP      
000100  4630              MOV      r0,r6
000102  f7fffffe          BL       CPU_SR_Restore
000106  bf00              NOP      
000108  bf00              NOP      
;;;2433               *p_err = OS_ERR_STATE_INVALID;
00010a  f646602d          MOV      r0,#0x6e2d
00010e  8028              STRH     r0,[r5,#0]
                  |L24.272|
;;;2434                return;
;;;2435       }
;;;2436   
;;;2437       OSSched();
;;;2438   }
000110  bd70              POP      {r4-r6,pc}
                  |L24.274|
000112  bf00              NOP                            ;2395
000114  f7fffffe          BL       OSSched
000118  bf00              NOP      
00011a  e7f9              B        |L24.272|
;;;2439   #endif
                          ENDP


                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;2456   
;;;2457   void  OS_TaskReturn (void)
000000  b508              PUSH     {r3,lr}
;;;2458   {
;;;2459       OS_ERR  err;
;;;2460   
;;;2461   
;;;2462   
;;;2463       OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
000002  4804              LDR      r0,|L25.20|
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000006  f7fffffe          BL       OSTaskReturnHook
;;;2464   #if OS_CFG_TASK_DEL_EN > 0u
;;;2465       OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       OSTaskDel
;;;2466                 (OS_ERR *)&err);
;;;2467   #else
;;;2468       for (;;) {
;;;2469           OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
;;;2470                     (OS_OPT  )OS_OPT_TIME_DLY,
;;;2471                     (OS_ERR *)&err);
;;;2472       }
;;;2473   #endif
;;;2474   }
000012  bd08              POP      {r3,pc}
;;;2475   
                          ENDP

                  |L25.20|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSemPost||, CODE, READONLY, ALIGN=2

                  OS_TaskSemPost PROC
;;;2506   
;;;2507   OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2508                               OS_OPT   opt,
;;;2509                               CPU_TS   ts,
;;;2510                               OS_ERR  *p_err)
;;;2511   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;2512       OS_SEM_CTR  ctr;
;;;2513       CPU_SR_ALLOC();
00000c  f04f0900          MOV      r9,#0
;;;2514   
;;;2515   
;;;2516   
;;;2517       OS_CRITICAL_ENTER();
000010  bf00              NOP      
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_SR_Save
000018  4681              MOV      r9,r0
00001a  bf00              NOP      
00001c  f7fffffe          BL       CPU_IntDisMeasStart
000020  bf00              NOP      
;;;2518       if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
000022  b90c              CBNZ     r4,|L26.40|
;;;2519           p_tcb = OSTCBCurPtr;
000024  4871              LDR      r0,|L26.492|
000026  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L26.40|
;;;2520       }
;;;2521       p_tcb->TS = ts;
000028  64a7              STR      r7,[r4,#0x48]
;;;2522      *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
00002a  2000              MOVS     r0,#0
00002c  8028              STRH     r0,[r5,#0]
;;;2523       switch (p_tcb->TaskState) {
00002e  f8940036          LDRB     r0,[r4,#0x36]
000032  2808              CMP      r0,#8
000034  d278              BCS      |L26.296|
000036  e8dff000          TBB      [pc,r0]
00003a  0405              DCB      0x04,0x05
00003c  58590607          DCB      0x58,0x59,0x06,0x07
000040  5a5b              DCB      0x5a,0x5b
;;;2524           case OS_TASK_STATE_RDY:
;;;2525           case OS_TASK_STATE_DLY:
000042  bf00              NOP      
;;;2526           case OS_TASK_STATE_SUSPENDED:
000044  bf00              NOP      
;;;2527           case OS_TASK_STATE_DLY_SUSPENDED:
000046  bf00              NOP      
;;;2528                switch (sizeof(OS_SEM_CTR)) {
000048  2004              MOVS     r0,#4
00004a  2801              CMP      r0,#1
00004c  d004              BEQ      |L26.88|
00004e  2802              CMP      r0,#2
000050  d015              BEQ      |L26.126|
000052  2804              CMP      r0,#4
000054  d139              BNE      |L26.202|
000056  e026              B        |L26.166|
                  |L26.88|
;;;2529                    case 1u:
;;;2530                         if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
000058  6ce0              LDR      r0,[r4,#0x4c]
00005a  28ff              CMP      r0,#0xff
00005c  d10e              BNE      |L26.124|
;;;2531                             OS_CRITICAL_EXIT();
00005e  bf00              NOP      
000060  f7fffffe          BL       CPU_IntDisMeasStop
000064  bf00              NOP      
000066  4648              MOV      r0,r9
000068  f7fffffe          BL       CPU_SR_Restore
00006c  bf00              NOP      
00006e  bf00              NOP      
;;;2532                            *p_err = OS_ERR_SEM_OVF;
000070  f64650c5          MOV      r0,#0x6dc5
000074  8028              STRH     r0,[r5,#0]
;;;2533                             return ((OS_SEM_CTR)0);
000076  2000              MOVS     r0,#0
                  |L26.120|
;;;2534                         }
;;;2535                         break;
;;;2536   
;;;2537                    case 2u:
;;;2538                         if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2539                             OS_CRITICAL_EXIT();
;;;2540                            *p_err = OS_ERR_SEM_OVF;
;;;2541                             return ((OS_SEM_CTR)0);
;;;2542                         }
;;;2543                         break;
;;;2544   
;;;2545                    case 4u:
;;;2546                         if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2547                             OS_CRITICAL_EXIT();
;;;2548                            *p_err = OS_ERR_SEM_OVF;
;;;2549                             return ((OS_SEM_CTR)0);
;;;2550                         }
;;;2551                         break;
;;;2552   
;;;2553                    default:
;;;2554                         break;
;;;2555                }
;;;2556                p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
;;;2557                ctr = p_tcb->SemCtr;
;;;2558                OS_CRITICAL_EXIT();
;;;2559                break;
;;;2560   
;;;2561           case OS_TASK_STATE_PEND:
;;;2562           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2563           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2564           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2565                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
;;;2566                    OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
;;;2567                            (OS_TCB      *)p_tcb,
;;;2568                            (void        *)0,
;;;2569                            (OS_MSG_SIZE  )0u,
;;;2570                            (CPU_TS       )ts);
;;;2571                    ctr = p_tcb->SemCtr;
;;;2572                    OS_CRITICAL_EXIT_NO_SCHED();
;;;2573                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;2574                        OSSched();                                 /* Run the scheduler                                  */
;;;2575                    }
;;;2576                } else {
;;;2577                    switch (sizeof(OS_SEM_CTR)) {
;;;2578                        case 1u:
;;;2579                             if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
;;;2580                                 OS_CRITICAL_EXIT();
;;;2581                                *p_err = OS_ERR_SEM_OVF;
;;;2582                                 return ((OS_SEM_CTR)0);
;;;2583                             }
;;;2584                             break;
;;;2585   
;;;2586                        case 2u:
;;;2587                             if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2588                                 OS_CRITICAL_EXIT();
;;;2589                                *p_err = OS_ERR_SEM_OVF;
;;;2590                                 return ((OS_SEM_CTR)0);
;;;2591                             }
;;;2592                             break;
;;;2593   
;;;2594                        case 4u:
;;;2595                             if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2596                                 OS_CRITICAL_EXIT();
;;;2597                                *p_err = OS_ERR_SEM_OVF;
;;;2598                                 return ((OS_SEM_CTR)0);
;;;2599                             }
;;;2600                             break;
;;;2601   
;;;2602                        default:
;;;2603                             break;
;;;2604                    }
;;;2605                    p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
;;;2606                    ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
;;;2607                    OS_CRITICAL_EXIT();
;;;2608                }
;;;2609                break;
;;;2610   
;;;2611           default:
;;;2612                OS_CRITICAL_EXIT();
;;;2613               *p_err = OS_ERR_STATE_INVALID;
;;;2614                ctr   = (OS_SEM_CTR)0;
;;;2615                break;
;;;2616       }
;;;2617       return (ctr);
;;;2618   }
000078  e8bd83f8          POP      {r3-r9,pc}
                  |L26.124|
00007c  e026              B        |L26.204|
                  |L26.126|
00007e  f64f71ff          MOV      r1,#0xffff            ;2538
000082  6ce0              LDR      r0,[r4,#0x4c]         ;2538
000084  4288              CMP      r0,r1                 ;2538
000086  d10d              BNE      |L26.164|
000088  bf00              NOP                            ;2539
00008a  f7fffffe          BL       CPU_IntDisMeasStop
00008e  bf00              NOP                            ;2539
000090  4648              MOV      r0,r9                 ;2539
000092  f7fffffe          BL       CPU_SR_Restore
000096  bf00              NOP                            ;2539
000098  bf00              NOP                            ;2539
00009a  f64650c5          MOV      r0,#0x6dc5            ;2540
00009e  8028              STRH     r0,[r5,#0]            ;2540
0000a0  2000              MOVS     r0,#0                 ;2541
0000a2  e7e9              B        |L26.120|
                  |L26.164|
0000a4  e012              B        |L26.204|
                  |L26.166|
0000a6  6ce0              LDR      r0,[r4,#0x4c]         ;2546
0000a8  1c40              ADDS     r0,r0,#1              ;2546
0000aa  b968              CBNZ     r0,|L26.200|
0000ac  bf00              NOP                            ;2547
0000ae  f7fffffe          BL       CPU_IntDisMeasStop
0000b2  bf00              NOP                            ;2547
0000b4  4648              MOV      r0,r9                 ;2547
0000b6  f7fffffe          BL       CPU_SR_Restore
0000ba  bf00              NOP                            ;2547
0000bc  bf00              NOP                            ;2547
0000be  f64650c5          MOV      r0,#0x6dc5            ;2548
0000c2  8028              STRH     r0,[r5,#0]            ;2548
0000c4  2000              MOVS     r0,#0                 ;2549
0000c6  e7d7              B        |L26.120|
                  |L26.200|
0000c8  e000              B        |L26.204|
                  |L26.202|
0000ca  bf00              NOP                            ;2554
                  |L26.204|
0000cc  bf00              NOP                            ;2535
0000ce  6ce0              LDR      r0,[r4,#0x4c]         ;2556
0000d0  1c40              ADDS     r0,r0,#1              ;2556
0000d2  64e0              STR      r0,[r4,#0x4c]         ;2556
0000d4  6ce6              LDR      r6,[r4,#0x4c]         ;2557
0000d6  bf00              NOP                            ;2558
0000d8  f7fffffe          BL       CPU_IntDisMeasStop
0000dc  bf00              NOP                            ;2558
0000de  4648              MOV      r0,r9                 ;2558
0000e0  f7fffffe          BL       CPU_SR_Restore
0000e4  bf00              NOP                            ;2558
0000e6  bf00              NOP                            ;2558
0000e8  e07d              B        |L26.486|
0000ea  bf00              NOP                            ;2562
0000ec  bf00              NOP                            ;2563
0000ee  bf00              NOP                            ;2564
0000f0  f8940034          LDRB     r0,[r4,#0x34]         ;2565
0000f4  2807              CMP      r0,#7                 ;2565
0000f6  d118              BNE      |L26.298|
0000f8  2300              MOVS     r3,#0                 ;2566
0000fa  461a              MOV      r2,r3                 ;2566
0000fc  4621              MOV      r1,r4                 ;2566
0000fe  4618              MOV      r0,r3                 ;2566
000100  9700              STR      r7,[sp,#0]            ;2566
000102  f7fffffe          BL       OS_Post
000106  6ce6              LDR      r6,[r4,#0x4c]         ;2571
000108  bf00              NOP                            ;2572
00010a  f7fffffe          BL       CPU_IntDisMeasStop
00010e  bf00              NOP                            ;2572
000110  4648              MOV      r0,r9                 ;2572
000112  f7fffffe          BL       CPU_SR_Restore
000116  bf00              NOP                            ;2572
000118  bf00              NOP                            ;2572
00011a  f4084000          AND      r0,r8,#0x8000         ;2573
00011e  2800              CMP      r0,#0                 ;2573
000120  d152              BNE      |L26.456|
000122  f7fffffe          BL       OSSched
000126  e04f              B        |L26.456|
                  |L26.296|
000128  e04f              B        |L26.458|
                  |L26.298|
00012a  2004              MOVS     r0,#4                 ;2577
00012c  2801              CMP      r0,#1                 ;2577
00012e  d004              BEQ      |L26.314|
000130  2802              CMP      r0,#2                 ;2577
000132  d014              BEQ      |L26.350|
000134  2804              CMP      r0,#4                 ;2577
000136  d138              BNE      |L26.426|
000138  e025              B        |L26.390|
                  |L26.314|
00013a  6ce0              LDR      r0,[r4,#0x4c]         ;2579
00013c  28ff              CMP      r0,#0xff              ;2579
00013e  d10d              BNE      |L26.348|
000140  bf00              NOP                            ;2580
000142  f7fffffe          BL       CPU_IntDisMeasStop
000146  bf00              NOP                            ;2580
000148  4648              MOV      r0,r9                 ;2580
00014a  f7fffffe          BL       CPU_SR_Restore
00014e  bf00              NOP                            ;2580
000150  bf00              NOP                            ;2580
000152  f64650c5          MOV      r0,#0x6dc5            ;2581
000156  8028              STRH     r0,[r5,#0]            ;2581
000158  2000              MOVS     r0,#0                 ;2582
00015a  e78d              B        |L26.120|
                  |L26.348|
00015c  e026              B        |L26.428|
                  |L26.350|
00015e  f64f71ff          MOV      r1,#0xffff            ;2587
000162  6ce0              LDR      r0,[r4,#0x4c]         ;2587
000164  4288              CMP      r0,r1                 ;2587
000166  d10d              BNE      |L26.388|
000168  bf00              NOP                            ;2588
00016a  f7fffffe          BL       CPU_IntDisMeasStop
00016e  bf00              NOP                            ;2588
000170  4648              MOV      r0,r9                 ;2588
000172  f7fffffe          BL       CPU_SR_Restore
000176  bf00              NOP                            ;2588
000178  bf00              NOP                            ;2588
00017a  f64650c5          MOV      r0,#0x6dc5            ;2589
00017e  8028              STRH     r0,[r5,#0]            ;2589
000180  2000              MOVS     r0,#0                 ;2590
000182  e779              B        |L26.120|
                  |L26.388|
000184  e012              B        |L26.428|
                  |L26.390|
000186  6ce0              LDR      r0,[r4,#0x4c]         ;2595
000188  1c40              ADDS     r0,r0,#1              ;2595
00018a  b968              CBNZ     r0,|L26.424|
00018c  bf00              NOP                            ;2596
00018e  f7fffffe          BL       CPU_IntDisMeasStop
000192  bf00              NOP                            ;2596
000194  4648              MOV      r0,r9                 ;2596
000196  f7fffffe          BL       CPU_SR_Restore
00019a  bf00              NOP                            ;2596
00019c  bf00              NOP                            ;2596
00019e  f64650c5          MOV      r0,#0x6dc5            ;2597
0001a2  8028              STRH     r0,[r5,#0]            ;2597
0001a4  2000              MOVS     r0,#0                 ;2598
0001a6  e767              B        |L26.120|
                  |L26.424|
0001a8  e000              B        |L26.428|
                  |L26.426|
0001aa  bf00              NOP                            ;2603
                  |L26.428|
0001ac  bf00              NOP                            ;2584
0001ae  6ce0              LDR      r0,[r4,#0x4c]         ;2605
0001b0  1c40              ADDS     r0,r0,#1              ;2605
0001b2  64e0              STR      r0,[r4,#0x4c]         ;2605
0001b4  6ce6              LDR      r6,[r4,#0x4c]         ;2606
0001b6  bf00              NOP                            ;2607
0001b8  f7fffffe          BL       CPU_IntDisMeasStop
0001bc  bf00              NOP                            ;2607
0001be  4648              MOV      r0,r9                 ;2607
0001c0  f7fffffe          BL       CPU_SR_Restore
0001c4  bf00              NOP                            ;2607
0001c6  bf00              NOP                            ;2607
                  |L26.456|
0001c8  e00d              B        |L26.486|
                  |L26.458|
0001ca  bf00              NOP                            ;2612
0001cc  f7fffffe          BL       CPU_IntDisMeasStop
0001d0  bf00              NOP                            ;2612
0001d2  4648              MOV      r0,r9                 ;2612
0001d4  f7fffffe          BL       CPU_SR_Restore
0001d8  bf00              NOP                            ;2612
0001da  bf00              NOP                            ;2612
0001dc  f646602d          MOV      r0,#0x6e2d            ;2613
0001e0  8028              STRH     r0,[r5,#0]            ;2613
0001e2  2600              MOVS     r6,#0                 ;2614
0001e4  bf00              NOP                            ;2615
                  |L26.486|
0001e6  bf00              NOP                            ;2559
0001e8  4630              MOV      r0,r6                 ;2617
0001ea  e745              B        |L26.120|
;;;2619   
                          ENDP

                  |L26.492|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSuspend||, CODE, READONLY, ALIGN=2

                  OS_TaskSuspend PROC
;;;2650   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2651   void  OS_TaskSuspend (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2652                         OS_ERR  *p_err)
;;;2653   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2654       CPU_SR_ALLOC();
000006  2600              MOVS     r6,#0
;;;2655   
;;;2656   
;;;2657       CPU_CRITICAL_ENTER();
000008  bf00              NOP      
00000a  bf00              NOP      
00000c  f7fffffe          BL       CPU_SR_Save
000010  4606              MOV      r6,r0
000012  bf00              NOP      
000014  f7fffffe          BL       CPU_IntDisMeasStart
000018  bf00              NOP      
;;;2658       if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
00001a  b90c              CBNZ     r4,|L27.32|
;;;2659           p_tcb = OSTCBCurPtr;
00001c  4844              LDR      r0,|L27.304|
00001e  6804              LDR      r4,[r0,#0]  ; OSTCBCurPtr
                  |L27.32|
;;;2660       }
;;;2661   
;;;2662       if (p_tcb == OSTCBCurPtr) {
000020  4843              LDR      r0,|L27.304|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000024  4284              CMP      r4,r0
000026  d110              BNE      |L27.74|
;;;2663           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
000028  4842              LDR      r0,|L27.308|
00002a  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
00002c  2800              CMP      r0,#0
00002e  dd0c              BLE      |L27.74|
;;;2664               CPU_CRITICAL_EXIT();
000030  bf00              NOP      
000032  f7fffffe          BL       CPU_IntDisMeasStop
000036  bf00              NOP      
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       CPU_SR_Restore
00003e  bf00              NOP      
000040  bf00              NOP      
;;;2665              *p_err = OS_ERR_SCHED_LOCKED;
000042  f6465063          MOV      r0,#0x6d63
000046  8028              STRH     r0,[r5,#0]
                  |L27.72|
;;;2666               return;
;;;2667           }
;;;2668       }
;;;2669   
;;;2670      *p_err = OS_ERR_NONE;
;;;2671       switch (p_tcb->TaskState) {
;;;2672           case OS_TASK_STATE_RDY:
;;;2673                OS_CRITICAL_ENTER_CPU_EXIT();
;;;2674                p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
;;;2675                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2676                OS_RdyListRemove(p_tcb);
;;;2677                OS_CRITICAL_EXIT_NO_SCHED();
;;;2678                break;
;;;2679   
;;;2680           case OS_TASK_STATE_DLY:
;;;2681                p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
;;;2682                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2683                CPU_CRITICAL_EXIT();
;;;2684                break;
;;;2685   
;;;2686           case OS_TASK_STATE_PEND:
;;;2687                p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
;;;2688                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2689                CPU_CRITICAL_EXIT();
;;;2690                break;
;;;2691   
;;;2692           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2693                p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
;;;2694                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2695                CPU_CRITICAL_EXIT();
;;;2696                break;
;;;2697   
;;;2698           case OS_TASK_STATE_SUSPENDED:
;;;2699           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2700           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2701           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2702                p_tcb->SuspendCtr++;
;;;2703                CPU_CRITICAL_EXIT();
;;;2704                break;
;;;2705   
;;;2706           default:
;;;2707                CPU_CRITICAL_EXIT();
;;;2708               *p_err = OS_ERR_STATE_INVALID;
;;;2709                return;
;;;2710       }
;;;2711   
;;;2712       OSSched();
;;;2713   }
000048  bd70              POP      {r4-r6,pc}
                  |L27.74|
00004a  2000              MOVS     r0,#0                 ;2670
00004c  8028              STRH     r0,[r5,#0]            ;2670
00004e  f8940036          LDRB     r0,[r4,#0x36]         ;2671
000052  2808              CMP      r0,#8                 ;2671
000054  d25a              BCS      |L27.268|
000056  e8dff000          TBB      [pc,r0]               ;2671
00005a  0417              DCB      0x04,0x17
00005c  27374748          DCB      0x27,0x37,0x47,0x48
000060  494a              DCB      0x49,0x4a
000062  2004              MOVS     r0,#4                 ;2674
000064  f8840036          STRB     r0,[r4,#0x36]         ;2674
000068  2001              MOVS     r0,#1                 ;2675
00006a  f8840086          STRB     r0,[r4,#0x86]         ;2675
00006e  4620              MOV      r0,r4                 ;2676
000070  f7fffffe          BL       OS_RdyListRemove
000074  bf00              NOP                            ;2677
000076  f7fffffe          BL       CPU_IntDisMeasStop
00007a  bf00              NOP                            ;2677
00007c  4630              MOV      r0,r6                 ;2677
00007e  f7fffffe          BL       CPU_SR_Restore
000082  bf00              NOP                            ;2677
000084  bf00              NOP                            ;2677
000086  e04e              B        |L27.294|
000088  2005              MOVS     r0,#5                 ;2681
00008a  f8840036          STRB     r0,[r4,#0x36]         ;2681
00008e  2001              MOVS     r0,#1                 ;2682
000090  f8840086          STRB     r0,[r4,#0x86]         ;2682
000094  bf00              NOP                            ;2683
000096  f7fffffe          BL       CPU_IntDisMeasStop
00009a  bf00              NOP                            ;2683
00009c  4630              MOV      r0,r6                 ;2683
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  bf00              NOP                            ;2683
0000a4  bf00              NOP                            ;2683
0000a6  e03e              B        |L27.294|
0000a8  2006              MOVS     r0,#6                 ;2687
0000aa  f8840036          STRB     r0,[r4,#0x36]         ;2687
0000ae  2001              MOVS     r0,#1                 ;2688
0000b0  f8840086          STRB     r0,[r4,#0x86]         ;2688
0000b4  bf00              NOP                            ;2689
0000b6  f7fffffe          BL       CPU_IntDisMeasStop
0000ba  bf00              NOP                            ;2689
0000bc  4630              MOV      r0,r6                 ;2689
0000be  f7fffffe          BL       CPU_SR_Restore
0000c2  bf00              NOP                            ;2689
0000c4  bf00              NOP                            ;2689
0000c6  e02e              B        |L27.294|
0000c8  2007              MOVS     r0,#7                 ;2693
0000ca  f8840036          STRB     r0,[r4,#0x36]         ;2693
0000ce  2001              MOVS     r0,#1                 ;2694
0000d0  f8840086          STRB     r0,[r4,#0x86]         ;2694
0000d4  bf00              NOP                            ;2695
0000d6  f7fffffe          BL       CPU_IntDisMeasStop
0000da  bf00              NOP                            ;2695
0000dc  4630              MOV      r0,r6                 ;2695
0000de  f7fffffe          BL       CPU_SR_Restore
0000e2  bf00              NOP                            ;2695
0000e4  bf00              NOP                            ;2695
0000e6  e01e              B        |L27.294|
0000e8  bf00              NOP                            ;2699
0000ea  bf00              NOP                            ;2700
0000ec  bf00              NOP                            ;2701
0000ee  f8940086          LDRB     r0,[r4,#0x86]         ;2702
0000f2  1c40              ADDS     r0,r0,#1              ;2702
0000f4  f8840086          STRB     r0,[r4,#0x86]         ;2702
0000f8  bf00              NOP                            ;2703
0000fa  f7fffffe          BL       CPU_IntDisMeasStop
0000fe  bf00              NOP                            ;2703
000100  4630              MOV      r0,r6                 ;2703
000102  f7fffffe          BL       CPU_SR_Restore
000106  bf00              NOP                            ;2703
000108  bf00              NOP                            ;2703
00010a  e00c              B        |L27.294|
                  |L27.268|
00010c  bf00              NOP                            ;2707
00010e  f7fffffe          BL       CPU_IntDisMeasStop
000112  bf00              NOP                            ;2707
000114  4630              MOV      r0,r6                 ;2707
000116  f7fffffe          BL       CPU_SR_Restore
00011a  bf00              NOP                            ;2707
00011c  bf00              NOP                            ;2707
00011e  f646602d          MOV      r0,#0x6e2d            ;2708
000122  8028              STRH     r0,[r5,#0]            ;2708
000124  e790              B        |L27.72|
                  |L27.294|
000126  bf00              NOP                            ;2678
000128  f7fffffe          BL       OSSched
00012c  bf00              NOP      
00012e  e78b              B        |L27.72|
;;;2714   #endif
                          ENDP

                  |L27.304|
                          DCD      OSTCBCurPtr
                  |L27.308|
                          DCD      OSSchedLockNestingCtr
