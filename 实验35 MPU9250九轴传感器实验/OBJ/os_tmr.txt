; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\os_tmr.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\os_tmr.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\os_tmr.crf ..\UCOSIII\uCOS-III\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;114    
;;;115    void  OSTmrCreate (OS_TMR               *p_tmr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;116                       CPU_CHAR             *p_name,
;;;117                       OS_TICK               dly,
;;;118                       OS_TICK               period,
;;;119                       OS_OPT                opt,
;;;120                       OS_TMR_CALLBACK_PTR   p_callback,
;;;121                       void                 *p_callback_arg,
;;;122                       OS_ERR               *p_err)
;;;123    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000010  e9dd890a          LDRD     r8,r9,[sp,#0x28]
;;;124    #ifdef OS_SAFETY_CRITICAL
;;;125        if (p_err == (OS_ERR *)0) {
;;;126            OS_SAFETY_CRITICAL_EXCEPTION();
;;;127            return;
;;;128        }
;;;129    #endif
;;;130    
;;;131    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;132        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;133           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;134            return;
;;;135        }
;;;136    #endif
;;;137    
;;;138    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;139        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;140           *p_err = OS_ERR_TMR_ISR;
;;;141            return;
;;;142        }
;;;143    #endif
;;;144    
;;;145    #if OS_CFG_ARG_CHK_EN > 0u
;;;146        if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
;;;147           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;148            return;
;;;149        }
;;;150    
;;;151        switch (opt) {
;;;152            case OS_OPT_TMR_PERIODIC:
;;;153                 if (period == (OS_TICK)0) {
;;;154                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;155                     return;
;;;156                 }
;;;157                 break;
;;;158    
;;;159            case OS_OPT_TMR_ONE_SHOT:
;;;160                 if (dly == (OS_TICK)0) {
;;;161                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;162                     return;
;;;163                 }
;;;164                 break;
;;;165    
;;;166            default:
;;;167                *p_err = OS_ERR_OPT_INVALID;
;;;168                 return;
;;;169        }
;;;170    #endif
;;;171    
;;;172        if (OSRunning == OS_STATE_OS_RUNNING) {                                /* Only lock when the kernel is running    */
000014  4815              LDR      r0,|L1.108|
000016  7800              LDRB     r0,[r0,#0]  ; OSRunning
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L1.32|
;;;173            OS_TmrLock();
00001c  f7fffffe          BL       OS_TmrLock
                  |L1.32|
;;;174        }
;;;175    
;;;176        p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
000020  2001              MOVS     r0,#1
000022  f8840026          STRB     r0,[r4,#0x26]
;;;177    #if OS_OBJ_TYPE_REQ > 0u
;;;178        p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
000026  4812              LDR      r0,|L1.112|
000028  6020              STR      r0,[r4,#0]
;;;179    #endif
;;;180    #if OS_CFG_DBG_EN > 0u
;;;181        p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
00002a  6065              STR      r5,[r4,#4]
;;;182    #else
;;;183        (void)&p_name;
;;;184    #endif
;;;185        p_tmr->Dly            = (OS_TICK            )dly;
00002c  61e6              STR      r6,[r4,#0x1c]
;;;186        p_tmr->Remain         = (OS_TICK            )0;
00002e  2000              MOVS     r0,#0
000030  61a0              STR      r0,[r4,#0x18]
;;;187        p_tmr->Period         = (OS_TICK            )period;
000032  6227              STR      r7,[r4,#0x20]
;;;188        p_tmr->Opt            = (OS_OPT             )opt;
000034  f8a48024          STRH     r8,[r4,#0x24]
;;;189        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
000038  f8c49008          STR      r9,[r4,#8]
;;;190        p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
00003c  f8c4a00c          STR      r10,[r4,#0xc]
;;;191        p_tmr->NextPtr        = (OS_TMR            *)0;
000040  6120              STR      r0,[r4,#0x10]
;;;192        p_tmr->PrevPtr        = (OS_TMR            *)0;
000042  6160              STR      r0,[r4,#0x14]
;;;193    
;;;194    #if OS_CFG_DBG_EN > 0u
;;;195        OS_TmrDbgListAdd(p_tmr);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       OS_TmrDbgListAdd
;;;196    #endif
;;;197        OSTmrQty++;                                             /* Keep track of the number of timers created             */
00004a  480a              LDR      r0,|L1.116|
00004c  8800              LDRH     r0,[r0,#0]  ; OSTmrQty
00004e  1c40              ADDS     r0,r0,#1
000050  4908              LDR      r1,|L1.116|
000052  8008              STRH     r0,[r1,#0]
;;;198    
;;;199        if (OSRunning == OS_STATE_OS_RUNNING) {
000054  4805              LDR      r0,|L1.108|
000056  7800              LDRB     r0,[r0,#0]  ; OSRunning
000058  2801              CMP      r0,#1
00005a  d101              BNE      |L1.96|
;;;200            OS_TmrUnlock();
00005c  f7fffffe          BL       OS_TmrUnlock
                  |L1.96|
;;;201        }
;;;202    
;;;203       *p_err = OS_ERR_NONE;
000060  2000              MOVS     r0,#0
000062  f8ab0000          STRH     r0,[r11,#0]
;;;204    }
000066  e8bd9ff0          POP      {r4-r12,pc}
;;;205    
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
                          DCD      OSRunning
                  |L1.112|
                          DCD      0x20524d54
                  |L1.116|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;440    
;;;441    OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;442                             OS_ERR  *p_err)
;;;443    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;444        OS_TICK  remain;
;;;445    
;;;446    
;;;447    #ifdef OS_SAFETY_CRITICAL
;;;448        if (p_err == (OS_ERR *)0) {
;;;449            OS_SAFETY_CRITICAL_EXCEPTION();
;;;450            return ((OS_TICK)0);
;;;451        }
;;;452    #endif
;;;453    
;;;454    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;455        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;456           *p_err = OS_ERR_TMR_ISR;
;;;457            return ((OS_TICK)0);
;;;458        }
;;;459    #endif
;;;460    
;;;461    #if OS_CFG_ARG_CHK_EN > 0u
;;;462        if (p_tmr == (OS_TMR *)0) {
;;;463           *p_err = OS_ERR_TMR_INVALID;
;;;464            return ((OS_TICK)0);
;;;465        }
;;;466    #endif
;;;467    
;;;468    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;469        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000006  491c              LDR      r1,|L2.120|
000008  6820              LDR      r0,[r4,#0]
00000a  4288              CMP      r0,r1
00000c  d004              BEQ      |L2.24|
;;;470           *p_err = OS_ERR_OBJ_TYPE;
00000e  f64550c4          MOV      r0,#0x5dc4
000012  8030              STRH     r0,[r6,#0]
;;;471            return ((OS_TICK)0);
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;472        }
;;;473    #endif
;;;474    
;;;475        OS_TmrLock();
;;;476    
;;;477        switch (p_tmr->State) {
;;;478            case OS_TMR_STATE_RUNNING:
;;;479                 remain = p_tmr->Remain;
;;;480                *p_err  = OS_ERR_NONE;
;;;481                 break;
;;;482    
;;;483            case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
;;;484                 if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;485                     if (p_tmr->Dly == 0u) {
;;;486                         remain = p_tmr->Period;
;;;487                     } else {
;;;488                         remain = p_tmr->Dly;
;;;489                     }
;;;490                 } else {
;;;491                     remain = p_tmr->Dly;
;;;492                 }
;;;493                *p_err = OS_ERR_NONE;
;;;494                 break;
;;;495    
;;;496            case OS_TMR_STATE_COMPLETED:                        /* Only ONE-SHOT that timed out can be in this state      */
;;;497                *p_err  = OS_ERR_NONE;
;;;498                 remain = (OS_TICK)0;
;;;499                 break;
;;;500    
;;;501            case OS_TMR_STATE_UNUSED:
;;;502                *p_err  = OS_ERR_TMR_INACTIVE;
;;;503                 remain = (OS_TICK)0;
;;;504                 break;
;;;505    
;;;506            default:
;;;507                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;508                 remain = (OS_TICK)0;
;;;509                 break;
;;;510        }
;;;511    
;;;512        OS_TmrUnlock();
;;;513    
;;;514        return (remain);
;;;515    }
000016  bd70              POP      {r4-r6,pc}
                  |L2.24|
000018  f7fffffe          BL       OS_TmrLock
00001c  f8940026          LDRB     r0,[r4,#0x26]         ;477
000020  b1d8              CBZ      r0,|L2.90|
000022  2801              CMP      r0,#1                 ;477
000024  d008              BEQ      |L2.56|
000026  2802              CMP      r0,#2                 ;477
000028  d002              BEQ      |L2.48|
00002a  2803              CMP      r0,#3                 ;477
00002c  d11a              BNE      |L2.100|
00002e  e010              B        |L2.82|
                  |L2.48|
000030  69a5              LDR      r5,[r4,#0x18]         ;479
000032  2000              MOVS     r0,#0                 ;480
000034  8030              STRH     r0,[r6,#0]            ;480
000036  e01a              B        |L2.110|
                  |L2.56|
000038  8ca0              LDRH     r0,[r4,#0x24]         ;484
00003a  2802              CMP      r0,#2                 ;484
00003c  d105              BNE      |L2.74|
00003e  69e0              LDR      r0,[r4,#0x1c]         ;485
000040  b908              CBNZ     r0,|L2.70|
000042  6a25              LDR      r5,[r4,#0x20]         ;486
000044  e002              B        |L2.76|
                  |L2.70|
000046  69e5              LDR      r5,[r4,#0x1c]         ;488
000048  e000              B        |L2.76|
                  |L2.74|
00004a  69e5              LDR      r5,[r4,#0x1c]         ;491
                  |L2.76|
00004c  2000              MOVS     r0,#0                 ;493
00004e  8030              STRH     r0,[r6,#0]            ;493
000050  e00d              B        |L2.110|
                  |L2.82|
000052  2000              MOVS     r0,#0                 ;497
000054  8030              STRH     r0,[r6,#0]            ;497
000056  2500              MOVS     r5,#0                 ;498
000058  e009              B        |L2.110|
                  |L2.90|
00005a  f247303d          MOV      r0,#0x733d            ;502
00005e  8030              STRH     r0,[r6,#0]            ;502
000060  2500              MOVS     r5,#0                 ;503
000062  e004              B        |L2.110|
                  |L2.100|
000064  f2473041          MOV      r0,#0x7341            ;507
000068  8030              STRH     r0,[r6,#0]            ;507
00006a  2500              MOVS     r5,#0                 ;508
00006c  bf00              NOP                            ;509
                  |L2.110|
00006e  bf00              NOP                            ;481
000070  f7fffffe          BL       OS_TmrUnlock
000074  4628              MOV      r0,r5                 ;514
000076  e7ce              B        |L2.22|
;;;516    
                          ENDP

                  |L2.120|
                          DCD      0x20524d54

                          AREA ||i.OSTmrSet||, CODE, READONLY, ALIGN=2

                  OSTmrSet PROC
;;;346    
;;;347    void  OSTmrSet (OS_TMR               *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;348                    OS_TICK               dly,
;;;349                    OS_TICK               period,
;;;350                    OS_TMR_CALLBACK_PTR   p_callback,
;;;351                    void                 *p_callback_arg,
;;;352                    OS_ERR               *p_err)
;;;353    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd9808          LDRD     r9,r8,[sp,#0x20]
;;;354    #ifdef OS_SAFETY_CRITICAL
;;;355        if (p_err == DEF_NULL) {
;;;356            OS_SAFETY_CRITICAL_EXCEPTION();
;;;357            return;
;;;358        }
;;;359    #endif
;;;360    
;;;361    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0
;;;362        if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
;;;363           *p_err = OS_ERR_TMR_ISR;
;;;364            return;
;;;365        }
;;;366    #endif
;;;367    
;;;368    #if OS_CFG_ARG_CHK_EN > 0
;;;369        if (p_tmr == DEF_NULL) {                                    /* Validate 'p_tmr'                                     */
;;;370           *p_err = OS_ERR_TMR_INVALID;
;;;371            return;
;;;372        }
;;;373    #endif
;;;374    
;;;375    #if OS_CFG_OBJ_TYPE_CHK_EN > 0
;;;376        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
000010  490b              LDR      r1,|L3.64|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d005              BEQ      |L3.36|
;;;377           *p_err = OS_ERR_OBJ_TYPE;
000018  f64550c4          MOV      r0,#0x5dc4
00001c  f8a80000          STRH     r0,[r8,#0]
                  |L3.32|
;;;378            return;
;;;379        }
;;;380    #endif
;;;381    
;;;382    #if OS_CFG_ARG_CHK_EN > 0
;;;383        switch (p_tmr->Opt) {
;;;384            case OS_OPT_TMR_PERIODIC:
;;;385                 if (period == 0u) {
;;;386                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;387                     return;
;;;388                 }
;;;389                 break;
;;;390    
;;;391            case OS_OPT_TMR_ONE_SHOT:
;;;392                 if (dly == 0u) {
;;;393                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;394                     return;
;;;395                 }
;;;396                 break;
;;;397    
;;;398            default:
;;;399                *p_err = OS_ERR_TMR_INVALID;
;;;400                 return;
;;;401        }
;;;402    #endif
;;;403    
;;;404        OS_TmrLock();
;;;405    
;;;406        p_tmr->Dly            = dly;
;;;407        p_tmr->Period         = period;
;;;408        p_tmr->CallbackPtr    = p_callback;
;;;409        p_tmr->CallbackPtrArg = p_callback_arg;
;;;410    
;;;411       *p_err = OS_ERR_NONE;
;;;412    
;;;413        OS_TmrUnlock();
;;;414    
;;;415    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L3.36|
000024  f7fffffe          BL       OS_TmrLock
000028  61e5              STR      r5,[r4,#0x1c]         ;406
00002a  6226              STR      r6,[r4,#0x20]         ;407
00002c  60a7              STR      r7,[r4,#8]            ;408
00002e  f8c4900c          STR      r9,[r4,#0xc]          ;409
000032  2000              MOVS     r0,#0                 ;411
000034  f8a80000          STRH     r0,[r8,#0]            ;411
000038  f7fffffe          BL       OS_TmrUnlock
00003c  bf00              NOP      
00003e  e7ef              B        |L3.32|
;;;416    
                          ENDP

                  |L3.64|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;544    
;;;545    CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;546                             OS_ERR  *p_err)
;;;547    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;548        OS_TMR      *p_next;
;;;549        CPU_BOOLEAN  success;
;;;550    
;;;551        
;;;552    
;;;553    #ifdef OS_SAFETY_CRITICAL
;;;554        if (p_err == (OS_ERR *)0) {
;;;555            OS_SAFETY_CRITICAL_EXCEPTION();
;;;556            return (DEF_FALSE);
;;;557        }
;;;558    #endif
;;;559    
;;;560    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;561        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;562           *p_err = OS_ERR_TMR_ISR;
;;;563            return (DEF_FALSE);
;;;564        }
;;;565    #endif
;;;566    
;;;567    #if OS_CFG_ARG_CHK_EN > 0u
;;;568        if (p_tmr == (OS_TMR *)0) {
;;;569           *p_err = OS_ERR_TMR_INVALID;
;;;570            return (DEF_FALSE);
;;;571        }
;;;572    #endif
;;;573    
;;;574    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;575        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000008  492a              LDR      r1,|L4.180|
00000a  6820              LDR      r0,[r4,#0]
00000c  4288              CMP      r0,r1
00000e  d005              BEQ      |L4.28|
;;;576           *p_err = OS_ERR_OBJ_TYPE;
000010  f64550c4          MOV      r0,#0x5dc4
000014  8028              STRH     r0,[r5,#0]
;;;577            return (DEF_FALSE);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;578        }
;;;579    #endif
;;;580    
;;;581        OS_TmrLock();
;;;582    
;;;583        switch (p_tmr->State) {
;;;584            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;585                 p_tmr->Remain = p_tmr->Dly;
;;;586                *p_err         = OS_ERR_NONE;
;;;587                 success       = DEF_TRUE;
;;;588                 break;
;;;589    
;;;590            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;591            case OS_TMR_STATE_COMPLETED:
;;;592                 p_tmr->State  = OS_TMR_STATE_RUNNING;
;;;593    			 if (p_tmr->Dly == (OS_TICK)0) {
;;;594                     p_tmr->Remain = p_tmr->Period;
;;;595    			 } else {
;;;596                     p_tmr->Remain = p_tmr->Dly;
;;;597                 }
;;;598                 if (OSTmrListPtr ==  (OS_TMR *)0) {            /* Link into timer list                                   */
;;;599                     p_tmr->NextPtr   = (OS_TMR *)0;            /* This is the first timer in the list                    */
;;;600                     p_tmr->PrevPtr   = (OS_TMR *)0;
;;;601                     OSTmrListPtr     = p_tmr;
;;;602                     OSTmrListEntries = 1u;
;;;603                 } else {
;;;604                     p_next           = OSTmrListPtr;           /* Insert at the beginning of the list                    */
;;;605                     p_tmr->NextPtr   = OSTmrListPtr;
;;;606                     p_tmr->PrevPtr   = (OS_TMR *)0;
;;;607                     p_next->PrevPtr  = p_tmr;
;;;608                     OSTmrListPtr     = p_tmr;
;;;609                     OSTmrListEntries++;
;;;610                 }
;;;611                *p_err   = OS_ERR_NONE;
;;;612                 success = DEF_TRUE;
;;;613                 break;
;;;614    
;;;615            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;616                *p_err   = OS_ERR_TMR_INACTIVE;
;;;617                 success = DEF_FALSE;
;;;618                 break;
;;;619    
;;;620            default:
;;;621                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;622                 success = DEF_FALSE;
;;;623                 break;
;;;624        }
;;;625    
;;;626        OS_TmrUnlock();
;;;627    
;;;628        return (success);
;;;629    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L4.28|
00001c  f7fffffe          BL       OS_TmrLock
000020  f8940026          LDRB     r0,[r4,#0x26]         ;583
000024  2800              CMP      r0,#0                 ;583
000026  d035              BEQ      |L4.148|
000028  2801              CMP      r0,#1                 ;583
00002a  d00a              BEQ      |L4.66|
00002c  2802              CMP      r0,#2                 ;583
00002e  d002              BEQ      |L4.54|
000030  2803              CMP      r0,#3                 ;583
000032  d134              BNE      |L4.158|
000034  e006              B        |L4.68|
                  |L4.54|
000036  69e0              LDR      r0,[r4,#0x1c]         ;585
000038  61a0              STR      r0,[r4,#0x18]         ;585
00003a  2000              MOVS     r0,#0                 ;586
00003c  8028              STRH     r0,[r5,#0]            ;586
00003e  2601              MOVS     r6,#1                 ;587
000040  e032              B        |L4.168|
                  |L4.66|
000042  bf00              NOP                            ;591
                  |L4.68|
000044  2002              MOVS     r0,#2                 ;592
000046  f8840026          STRB     r0,[r4,#0x26]         ;592
00004a  69e0              LDR      r0,[r4,#0x1c]         ;593
00004c  b910              CBNZ     r0,|L4.84|
00004e  6a20              LDR      r0,[r4,#0x20]         ;594
000050  61a0              STR      r0,[r4,#0x18]         ;594
000052  e001              B        |L4.88|
                  |L4.84|
000054  69e0              LDR      r0,[r4,#0x1c]         ;596
000056  61a0              STR      r0,[r4,#0x18]         ;596
                  |L4.88|
000058  4817              LDR      r0,|L4.184|
00005a  6800              LDR      r0,[r0,#0]            ;598  ; OSTmrListPtr
00005c  b940              CBNZ     r0,|L4.112|
00005e  2000              MOVS     r0,#0                 ;599
000060  6120              STR      r0,[r4,#0x10]         ;599
000062  6160              STR      r0,[r4,#0x14]         ;600
000064  4814              LDR      r0,|L4.184|
000066  6004              STR      r4,[r0,#0]            ;601  ; OSTmrListPtr
000068  2001              MOVS     r0,#1                 ;602
00006a  4914              LDR      r1,|L4.188|
00006c  8008              STRH     r0,[r1,#0]            ;602
00006e  e00d              B        |L4.140|
                  |L4.112|
000070  4811              LDR      r0,|L4.184|
000072  6807              LDR      r7,[r0,#0]            ;604  ; OSTmrListPtr
000074  6800              LDR      r0,[r0,#0]            ;605  ; OSTmrListPtr
000076  6120              STR      r0,[r4,#0x10]         ;605
000078  2000              MOVS     r0,#0                 ;606
00007a  6160              STR      r0,[r4,#0x14]         ;606
00007c  617c              STR      r4,[r7,#0x14]         ;607
00007e  480e              LDR      r0,|L4.184|
000080  6004              STR      r4,[r0,#0]            ;608  ; OSTmrListPtr
000082  480e              LDR      r0,|L4.188|
000084  8800              LDRH     r0,[r0,#0]            ;609  ; OSTmrListEntries
000086  1c40              ADDS     r0,r0,#1              ;609
000088  490c              LDR      r1,|L4.188|
00008a  8008              STRH     r0,[r1,#0]            ;609
                  |L4.140|
00008c  2000              MOVS     r0,#0                 ;611
00008e  8028              STRH     r0,[r5,#0]            ;611
000090  2601              MOVS     r6,#1                 ;612
000092  e009              B        |L4.168|
                  |L4.148|
000094  f247303d          MOV      r0,#0x733d            ;616
000098  8028              STRH     r0,[r5,#0]            ;616
00009a  2600              MOVS     r6,#0                 ;617
00009c  e004              B        |L4.168|
                  |L4.158|
00009e  f2473041          MOV      r0,#0x7341            ;621
0000a2  8028              STRH     r0,[r5,#0]            ;621
0000a4  2600              MOVS     r6,#0                 ;622
0000a6  bf00              NOP                            ;623
                  |L4.168|
0000a8  bf00              NOP                            ;588
0000aa  f7fffffe          BL       OS_TmrUnlock
0000ae  4630              MOV      r0,r6                 ;628
0000b0  e7b2              B        |L4.24|
;;;630    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L4.180|
                          DCD      0x20524d54
                  |L4.184|
                          DCD      OSTmrListPtr
                  |L4.188|
                          DCD      OSTmrListEntries

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;656    
;;;657    OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;658                             OS_ERR  *p_err)
;;;659    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;660        OS_STATE  state;
;;;661    
;;;662    
;;;663    
;;;664    #ifdef OS_SAFETY_CRITICAL
;;;665        if (p_err == (OS_ERR *)0) {
;;;666            OS_SAFETY_CRITICAL_EXCEPTION();
;;;667            return (OS_TMR_STATE_UNUSED);
;;;668        }
;;;669    #endif
;;;670    
;;;671    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;672        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
;;;673           *p_err = OS_ERR_TMR_ISR;
;;;674            return (OS_TMR_STATE_UNUSED);
;;;675        }
;;;676    #endif
;;;677    
;;;678    #if OS_CFG_ARG_CHK_EN > 0u
;;;679        if (p_tmr == (OS_TMR *)0) {
;;;680           *p_err = OS_ERR_TMR_INVALID;
;;;681            return (OS_TMR_STATE_UNUSED);
;;;682        }
;;;683    #endif
;;;684    
;;;685    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;686        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000006  4912              LDR      r1,|L5.80|
000008  6828              LDR      r0,[r5,#0]
00000a  4288              CMP      r0,r1
00000c  d004              BEQ      |L5.24|
;;;687           *p_err = OS_ERR_OBJ_TYPE;
00000e  f64550c4          MOV      r0,#0x5dc4
000012  8020              STRH     r0,[r4,#0]
;;;688            return (OS_TMR_STATE_UNUSED);
000014  2000              MOVS     r0,#0
                  |L5.22|
;;;689        }
;;;690    #endif
;;;691    
;;;692        OS_TmrLock();
;;;693    
;;;694        state = p_tmr->State;
;;;695        switch (state) {
;;;696            case OS_TMR_STATE_UNUSED:
;;;697            case OS_TMR_STATE_STOPPED:
;;;698            case OS_TMR_STATE_COMPLETED:
;;;699            case OS_TMR_STATE_RUNNING:
;;;700                *p_err = OS_ERR_NONE;
;;;701                 break;
;;;702    
;;;703            default:
;;;704                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;705                 break;
;;;706        }
;;;707    
;;;708        OS_TmrUnlock();
;;;709    
;;;710        return (state);
;;;711    }
000016  bd70              POP      {r4-r6,pc}
                  |L5.24|
000018  f7fffffe          BL       OS_TmrLock
00001c  f8956026          LDRB     r6,[r5,#0x26]         ;694
000020  b136              CBZ      r6,|L5.48|
000022  2e01              CMP      r6,#1                 ;695
000024  d005              BEQ      |L5.50|
000026  2e02              CMP      r6,#2                 ;695
000028  d005              BEQ      |L5.54|
00002a  2e03              CMP      r6,#3                 ;695
00002c  d106              BNE      |L5.60|
00002e  e001              B        |L5.52|
                  |L5.48|
000030  bf00              NOP                            ;697
                  |L5.50|
000032  bf00              NOP                            ;698
                  |L5.52|
000034  bf00              NOP                            ;699
                  |L5.54|
000036  2000              MOVS     r0,#0                 ;700
000038  8020              STRH     r0,[r4,#0]            ;700
00003a  e003              B        |L5.68|
                  |L5.60|
00003c  f2473041          MOV      r0,#0x7341            ;704
000040  8020              STRH     r0,[r4,#0]            ;704
000042  bf00              NOP                            ;705
                  |L5.68|
000044  bf00              NOP                            ;701
000046  f7fffffe          BL       OS_TmrUnlock
00004a  4630              MOV      r0,r6                 ;710
00004c  e7e3              B        |L5.22|
;;;712    
                          ENDP

00004e  0000              DCW      0x0000
                  |L5.80|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;749    
;;;750    CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;751                            OS_OPT   opt,
;;;752                            void    *p_callback_arg,
;;;753                            OS_ERR  *p_err)
;;;754    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461c              MOV      r4,r3
;;;755        OS_TMR_CALLBACK_PTR  p_fnct;
;;;756        CPU_BOOLEAN          success;
;;;757    
;;;758    
;;;759    
;;;760    #ifdef OS_SAFETY_CRITICAL
;;;761        if (p_err == (OS_ERR *)0) {
;;;762            OS_SAFETY_CRITICAL_EXCEPTION();
;;;763            return (DEF_FALSE);
;;;764        }
;;;765    #endif
;;;766    
;;;767    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;768        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
;;;769           *p_err = OS_ERR_TMR_ISR;
;;;770            return (DEF_FALSE);
;;;771        }
;;;772    #endif
;;;773    
;;;774    #if OS_CFG_ARG_CHK_EN > 0u
;;;775        if (p_tmr == (OS_TMR *)0) {
;;;776           *p_err = OS_ERR_TMR_INVALID;
;;;777            return (DEF_FALSE);
;;;778        }
;;;779    #endif
;;;780    
;;;781    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;782        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                             /* Make sure timer was created                  */
00000c  492c              LDR      r1,|L6.192|
00000e  6828              LDR      r0,[r5,#0]
000010  4288              CMP      r0,r1
000012  d005              BEQ      |L6.32|
;;;783           *p_err = OS_ERR_OBJ_TYPE;
000014  f64550c4          MOV      r0,#0x5dc4
000018  8020              STRH     r0,[r4,#0]
;;;784            return (DEF_FALSE);
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;785        }
;;;786    #endif
;;;787    
;;;788        OS_TmrLock();
;;;789    
;;;790        switch (p_tmr->State) {
;;;791            case OS_TMR_STATE_RUNNING:
;;;792                 OS_TmrUnlink(p_tmr);                                     /* Remove from timer list                       */
;;;793                *p_err = OS_ERR_NONE;
;;;794                 switch (opt) {
;;;795                     case OS_OPT_TMR_CALLBACK:
;;;796                          p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
;;;797                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
;;;798                            (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
;;;799                          } else {
;;;800                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;801                          }
;;;802                          break;
;;;803    
;;;804                     case OS_OPT_TMR_CALLBACK_ARG:
;;;805                          p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available ...   */
;;;806                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
;;;807                            (*p_fnct)((void *)p_tmr, p_callback_arg);     /* .. using the 'callback_arg' provided in call */
;;;808                          } else {
;;;809                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;810                          }
;;;811                          break;
;;;812    
;;;813                     case OS_OPT_TMR_NONE:
;;;814                          break;
;;;815    
;;;816                     default:
;;;817                         OS_TmrUnlock();
;;;818                        *p_err = OS_ERR_OPT_INVALID;
;;;819                         return (DEF_FALSE);
;;;820                 }
;;;821                 success = DEF_TRUE;
;;;822                 break;
;;;823    
;;;824            case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
;;;825            case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
;;;826                *p_err   = OS_ERR_TMR_STOPPED;
;;;827                 success = DEF_TRUE;
;;;828                 break;
;;;829    
;;;830            case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
;;;831                *p_err   = OS_ERR_TMR_INACTIVE;
;;;832                 success = DEF_FALSE;
;;;833                 break;
;;;834    
;;;835            default:
;;;836                *p_err   = OS_ERR_TMR_INVALID_STATE;
;;;837                 success = DEF_FALSE;
;;;838                 break;
;;;839        }
;;;840    
;;;841        OS_TmrUnlock();
;;;842    
;;;843        return (success);
;;;844    }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L6.32|
000020  f7fffffe          BL       OS_TmrLock
000024  f8950026          LDRB     r0,[r5,#0x26]         ;790
000028  2800              CMP      r0,#0                 ;790
00002a  d03a              BEQ      |L6.162|
00002c  2801              CMP      r0,#1                 ;790
00002e  d033              BEQ      |L6.152|
000030  2802              CMP      r0,#2                 ;790
000032  d002              BEQ      |L6.58|
000034  2803              CMP      r0,#3                 ;790
000036  d139              BNE      |L6.172|
000038  e02d              B        |L6.150|
                  |L6.58|
00003a  4628              MOV      r0,r5                 ;792
00003c  f7fffffe          BL       OS_TmrUnlink
000040  2000              MOVS     r0,#0                 ;793
000042  8020              STRH     r0,[r4,#0]            ;793
000044  f1b80f00          CMP      r8,#0                 ;794
000048  d01a              BEQ      |L6.128|
00004a  f1b80f03          CMP      r8,#3                 ;794
00004e  d003              BEQ      |L6.88|
000050  f1b80f04          CMP      r8,#4                 ;794
000054  d115              BNE      |L6.130|
000056  e009              B        |L6.108|
                  |L6.88|
000058  68ae              LDR      r6,[r5,#8]            ;796
00005a  b11e              CBZ      r6,|L6.100|
00005c  4628              MOV      r0,r5                 ;798
00005e  68e9              LDR      r1,[r5,#0xc]          ;798
000060  47b0              BLX      r6                    ;798
000062  e002              B        |L6.106|
                  |L6.100|
000064  f2473044          MOV      r0,#0x7344            ;800
000068  8020              STRH     r0,[r4,#0]            ;800
                  |L6.106|
00006a  e011              B        |L6.144|
                  |L6.108|
00006c  68ae              LDR      r6,[r5,#8]            ;805
00006e  b11e              CBZ      r6,|L6.120|
000070  4649              MOV      r1,r9                 ;807
000072  4628              MOV      r0,r5                 ;807
000074  47b0              BLX      r6                    ;807
000076  e002              B        |L6.126|
                  |L6.120|
000078  f2473044          MOV      r0,#0x7344            ;809
00007c  8020              STRH     r0,[r4,#0]            ;809
                  |L6.126|
00007e  e007              B        |L6.144|
                  |L6.128|
000080  e006              B        |L6.144|
                  |L6.130|
000082  f7fffffe          BL       OS_TmrUnlock
000086  f6456025          MOV      r0,#0x5e25            ;818
00008a  8020              STRH     r0,[r4,#0]            ;818
00008c  2000              MOVS     r0,#0                 ;819
00008e  e7c5              B        |L6.28|
                  |L6.144|
000090  bf00              NOP                            ;802
000092  2701              MOVS     r7,#1                 ;821
000094  e00f              B        |L6.182|
                  |L6.150|
000096  bf00              NOP                            ;825
                  |L6.152|
000098  f2473049          MOV      r0,#0x7349            ;826
00009c  8020              STRH     r0,[r4,#0]            ;826
00009e  2701              MOVS     r7,#1                 ;827
0000a0  e009              B        |L6.182|
                  |L6.162|
0000a2  f247303d          MOV      r0,#0x733d            ;831
0000a6  8020              STRH     r0,[r4,#0]            ;831
0000a8  2700              MOVS     r7,#0                 ;832
0000aa  e004              B        |L6.182|
                  |L6.172|
0000ac  f2473041          MOV      r0,#0x7341            ;836
0000b0  8020              STRH     r0,[r4,#0]            ;836
0000b2  2700              MOVS     r7,#0                 ;837
0000b4  bf00              NOP                            ;838
                  |L6.182|
0000b6  bf00              NOP                            ;822
0000b8  f7fffffe          BL       OS_TmrUnlock
0000bc  4638              MOV      r0,r7                 ;843
0000be  e7ad              B        |L6.28|
;;;845    
                          ENDP

                  |L6.192|
                          DCD      0x20524d54

                          AREA ||i.OS_TmrClr||, CODE, READONLY, ALIGN=2

                  OS_TmrClr PROC
;;;861    
;;;862    void  OS_TmrClr (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;863    {
;;;864        p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
000002  f8801026          STRB     r1,[r0,#0x26]
;;;865    #if OS_OBJ_TYPE_REQ > 0u
;;;866        p_tmr->Type           = OS_OBJ_TYPE_NONE;
000006  4907              LDR      r1,|L7.36|
000008  6001              STR      r1,[r0,#0]
;;;867    #endif
;;;868    #if OS_CFG_DBG_EN > 0u
;;;869        p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
00000a  a107              ADR      r1,|L7.40|
00000c  6041              STR      r1,[r0,#4]
;;;870    #endif
;;;871        p_tmr->Dly            = (OS_TICK            )0;
00000e  2100              MOVS     r1,#0
000010  61c1              STR      r1,[r0,#0x1c]
;;;872        p_tmr->Remain         = (OS_TICK            )0;
000012  6181              STR      r1,[r0,#0x18]
;;;873        p_tmr->Period         = (OS_TICK            )0;
000014  6201              STR      r1,[r0,#0x20]
;;;874        p_tmr->Opt            = (OS_OPT             )0;
000016  8481              STRH     r1,[r0,#0x24]
;;;875        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
000018  6081              STR      r1,[r0,#8]
;;;876        p_tmr->CallbackPtrArg = (void              *)0;
00001a  60c1              STR      r1,[r0,#0xc]
;;;877        p_tmr->NextPtr        = (OS_TMR            *)0;
00001c  6101              STR      r1,[r0,#0x10]
;;;878        p_tmr->PrevPtr        = (OS_TMR            *)0;
00001e  6141              STR      r1,[r0,#0x14]
;;;879    }
000020  4770              BX       lr
;;;880    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x454e4f4e
                  |L7.40|
000028  3f544d52          DCB      "?TMR",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.OS_TmrDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListAdd PROC
;;;897    #if OS_CFG_DBG_EN > 0u
;;;898    void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;899    {
;;;900        p_tmr->DbgPrevPtr               = (OS_TMR *)0;
000002  6281              STR      r1,[r0,#0x28]
;;;901        if (OSTmrDbgListPtr == (OS_TMR *)0) {
000004  4907              LDR      r1,|L8.36|
000006  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000008  b911              CBNZ     r1,|L8.16|
;;;902            p_tmr->DbgNextPtr           = (OS_TMR *)0;
00000a  2100              MOVS     r1,#0
00000c  62c1              STR      r1,[r0,#0x2c]
00000e  e005              B        |L8.28|
                  |L8.16|
;;;903        } else {
;;;904            p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
000010  4904              LDR      r1,|L8.36|
000012  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
000014  62c1              STR      r1,[r0,#0x2c]
;;;905            OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
000016  4903              LDR      r1,|L8.36|
000018  6809              LDR      r1,[r1,#0]  ; OSTmrDbgListPtr
00001a  6288              STR      r0,[r1,#0x28]
                  |L8.28|
;;;906        }
;;;907        OSTmrDbgListPtr                 =  p_tmr;
00001c  4901              LDR      r1,|L8.36|
00001e  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;908    }
000020  4770              BX       lr
;;;909    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListRemove PROC
;;;911    
;;;912    void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
000000  6a82              LDR      r2,[r0,#0x28]
;;;913    {
;;;914        OS_TMR  *p_tmr_next;
;;;915        OS_TMR  *p_tmr_prev;
;;;916    
;;;917    
;;;918        p_tmr_prev = p_tmr->DbgPrevPtr;
;;;919        p_tmr_next = p_tmr->DbgNextPtr;
000002  6ac1              LDR      r1,[r0,#0x2c]
;;;920    
;;;921        if (p_tmr_prev == (OS_TMR *)0) {
000004  b93a              CBNZ     r2,|L9.22|
;;;922            OSTmrDbgListPtr = p_tmr_next;
000006  4b09              LDR      r3,|L9.44|
000008  6019              STR      r1,[r3,#0]  ; OSTmrDbgListPtr
;;;923            if (p_tmr_next != (OS_TMR *)0) {
00000a  b109              CBZ      r1,|L9.16|
;;;924                p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
00000c  2300              MOVS     r3,#0
00000e  628b              STR      r3,[r1,#0x28]
                  |L9.16|
;;;925            }
;;;926            p_tmr->DbgNextPtr = (OS_TMR *)0;
000010  2300              MOVS     r3,#0
000012  62c3              STR      r3,[r0,#0x2c]
000014  e009              B        |L9.42|
                  |L9.22|
;;;927    
;;;928        } else if (p_tmr_next == (OS_TMR *)0) {
000016  b919              CBNZ     r1,|L9.32|
;;;929            p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
000018  2300              MOVS     r3,#0
00001a  62d3              STR      r3,[r2,#0x2c]
;;;930            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
00001c  6283              STR      r3,[r0,#0x28]
00001e  e004              B        |L9.42|
                  |L9.32|
;;;931    
;;;932        } else {
;;;933            p_tmr_prev->DbgNextPtr =  p_tmr_next;
000020  62d1              STR      r1,[r2,#0x2c]
;;;934            p_tmr_next->DbgPrevPtr =  p_tmr_prev;
000022  628a              STR      r2,[r1,#0x28]
;;;935            p_tmr->DbgNextPtr      = (OS_TMR *)0;
000024  2300              MOVS     r3,#0
000026  62c3              STR      r3,[r0,#0x2c]
;;;936            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
000028  6283              STR      r3,[r0,#0x28]
                  |L9.42|
;;;937        }
;;;938    }
00002a  4770              BX       lr
;;;939    #endif
                          ENDP

                  |L9.44|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrInit||, CODE, READONLY, ALIGN=2

                  OS_TmrInit PROC
;;;961    
;;;962    void  OS_TmrInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;963    {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;964    #ifdef OS_SAFETY_CRITICAL
;;;965        if (p_err == (OS_ERR *)0) {
;;;966            OS_SAFETY_CRITICAL_EXCEPTION();
;;;967            return;
;;;968        }
;;;969    #endif
;;;970    
;;;971    #if OS_CFG_DBG_EN > 0u
;;;972        OSTmrDbgListPtr = (OS_TMR *)0;
000006  2000              MOVS     r0,#0
000008  492f              LDR      r1,|L10.200|
00000a  6008              STR      r0,[r1,#0]  ; OSTmrDbgListPtr
;;;973    #endif
;;;974    
;;;975        OSTmrListPtr        = (OS_TMR *)0;                      /* Create an empty timer list                             */
00000c  492f              LDR      r1,|L10.204|
00000e  6008              STR      r0,[r1,#0]  ; OSTmrListPtr
;;;976        OSTmrListEntries    = 0u;
000010  492f              LDR      r1,|L10.208|
000012  8008              STRH     r0,[r1,#0]
;;;977    
;;;978        if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
000014  482f              LDR      r0,|L10.212|
000016  6800              LDR      r0,[r0,#0]  ; OSCfg_TmrTaskRate_Hz
000018  b140              CBZ      r0,|L10.44|
;;;979            OSTmrUpdateCnt  = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
00001a  482f              LDR      r0,|L10.216|
00001c  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
00001e  492d              LDR      r1,|L10.212|
000020  6809              LDR      r1,[r1,#0]  ; OSCfg_TmrTaskRate_Hz
000022  fbb0f0f1          UDIV     r0,r0,r1
000026  492d              LDR      r1,|L10.220|
000028  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
00002a  e006              B        |L10.58|
                  |L10.44|
;;;980        } else {
;;;981            OSTmrUpdateCnt  = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
00002c  482a              LDR      r0,|L10.216|
00002e  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000030  210a              MOVS     r1,#0xa
000032  fbb0f0f1          UDIV     r0,r0,r1
000036  4929              LDR      r1,|L10.220|
000038  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCnt
                  |L10.58|
;;;982        }
;;;983        OSTmrUpdateCtr      = OSTmrUpdateCnt;
00003a  4828              LDR      r0,|L10.220|
00003c  6800              LDR      r0,[r0,#0]  ; OSTmrUpdateCnt
00003e  4928              LDR      r1,|L10.224|
000040  6008              STR      r0,[r1,#0]  ; OSTmrUpdateCtr
;;;984    
;;;985        OSTmrTickCtr        = (OS_TICK)0;
000042  2000              MOVS     r0,#0
000044  4927              LDR      r1,|L10.228|
000046  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;986    
;;;987        OSTmrTaskTimeMax    = (CPU_TS)0;
000048  4927              LDR      r1,|L10.232|
00004a  6008              STR      r0,[r1,#0]  ; OSTmrTaskTimeMax
;;;988    
;;;989    #if   OS_CFG_MUTEX_EN > 0u
;;;990        OSMutexCreate(&OSTmrMutex,                              /* Use a mutex to protect the timers                      */
00004c  4622              MOV      r2,r4
00004e  a127              ADR      r1,|L10.236|
000050  482a              LDR      r0,|L10.252|
000052  f7fffffe          BL       OSMutexCreate
;;;991                      "OS Tmr Mutex", 
;;;992                      p_err);
;;;993        if (*p_err != OS_ERR_NONE) {
000056  8820              LDRH     r0,[r4,#0]
000058  b108              CBZ      r0,|L10.94|
                  |L10.90|
;;;994            return;
;;;995        }
;;;996    #endif
;;;997    
;;;998                                                                /* ---------------- CREATE THE TIMER TASK --------------- */
;;;999        if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
;;;1000          *p_err = OS_ERR_TMR_STK_INVALID;
;;;1001           return;
;;;1002       }
;;;1003   
;;;1004       if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
;;;1005          *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
;;;1006           return;
;;;1007       }
;;;1008   
;;;1009       if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
;;;1010          *p_err = OS_ERR_TMR_PRIO_INVALID;
;;;1011           return;
;;;1012       }
;;;1013   
;;;1014       OSTaskCreate((OS_TCB     *)&OSTmrTaskTCB,
;;;1015                    (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
;;;1016                    (OS_TASK_PTR )OS_TmrTask,
;;;1017                    (void       *)0,
;;;1018                    (OS_PRIO     )OSCfg_TmrTaskPrio,
;;;1019                    (CPU_STK    *)OSCfg_TmrTaskStkBasePtr,
;;;1020                    (CPU_STK_SIZE)OSCfg_TmrTaskStkLimit,
;;;1021                    (CPU_STK_SIZE)OSCfg_TmrTaskStkSize,
;;;1022                    (OS_MSG_QTY  )0,
;;;1023                    (OS_TICK     )0,
;;;1024                    (void       *)0,
;;;1025                    (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;1026                    (OS_ERR     *)p_err);
;;;1027   }
00005a  b00a              ADD      sp,sp,#0x28
00005c  bd10              POP      {r4,pc}
                  |L10.94|
00005e  4828              LDR      r0,|L10.256|
000060  6800              LDR      r0,[r0,#0]            ;999  ; OSCfg_TmrTaskStkBasePtr
000062  b918              CBNZ     r0,|L10.108|
000064  f2473047          MOV      r0,#0x7347            ;1000
000068  8020              STRH     r0,[r4,#0]            ;1000
00006a  e7f6              B        |L10.90|
                  |L10.108|
00006c  4825              LDR      r0,|L10.260|
00006e  6800              LDR      r0,[r0,#0]            ;1004  ; OSCfg_TmrTaskStkSize
000070  4925              LDR      r1,|L10.264|
000072  6809              LDR      r1,[r1,#0]            ;1004  ; OSCfg_StkSizeMin
000074  4288              CMP      r0,r1                 ;1004
000076  d203              BCS      |L10.128|
000078  f2473048          MOV      r0,#0x7348            ;1005
00007c  8020              STRH     r0,[r4,#0]            ;1005
00007e  e7ec              B        |L10.90|
                  |L10.128|
000080  4822              LDR      r0,|L10.268|
000082  7800              LDRB     r0,[r0,#0]            ;1009  ; OSCfg_TmrTaskPrio
000084  283f              CMP      r0,#0x3f              ;1009
000086  d303              BCC      |L10.144|
000088  f2473046          MOV      r0,#0x7346            ;1010
00008c  8020              STRH     r0,[r4,#0]            ;1010
00008e  e7e4              B        |L10.90|
                  |L10.144|
000090  200b              MOVS     r0,#0xb               ;1014
000092  2100              MOVS     r1,#0                 ;1014
000094  9105              STR      r1,[sp,#0x14]         ;1014
000096  460a              MOV      r2,r1                 ;1014
000098  e9cd0407          STRD     r0,r4,[sp,#0x1c]      ;1014
00009c  9106              STR      r1,[sp,#0x18]         ;1014
00009e  4819              LDR      r0,|L10.260|
0000a0  6800              LDR      r0,[r0,#0]            ;1014  ; OSCfg_TmrTaskStkSize
0000a2  491b              LDR      r1,|L10.272|
0000a4  6809              LDR      r1,[r1,#0]            ;1014  ; OSCfg_TmrTaskStkLimit
0000a6  4b16              LDR      r3,|L10.256|
0000a8  681b              LDR      r3,[r3,#0]            ;1014  ; OSCfg_TmrTaskStkBasePtr
0000aa  e9cd3101          STRD     r3,r1,[sp,#4]         ;1014
0000ae  e9cd0203          STRD     r0,r2,[sp,#0xc]       ;1014
0000b2  4816              LDR      r0,|L10.268|
0000b4  7800              LDRB     r0,[r0,#0]            ;1014  ; OSCfg_TmrTaskPrio
0000b6  2300              MOVS     r3,#0                 ;1014
0000b8  4a16              LDR      r2,|L10.276|
0000ba  a117              ADR      r1,|L10.280|
0000bc  9000              STR      r0,[sp,#0]            ;1014
0000be  481c              LDR      r0,|L10.304|
0000c0  f7fffffe          BL       OSTaskCreate
0000c4  bf00              NOP      
0000c6  e7c8              B        |L10.90|
;;;1028   
                          ENDP

                  |L10.200|
                          DCD      OSTmrDbgListPtr
                  |L10.204|
                          DCD      OSTmrListPtr
                  |L10.208|
                          DCD      OSTmrListEntries
                  |L10.212|
                          DCD      OSCfg_TmrTaskRate_Hz
                  |L10.216|
                          DCD      OSCfg_TickRate_Hz
                  |L10.220|
                          DCD      OSTmrUpdateCnt
                  |L10.224|
                          DCD      OSTmrUpdateCtr
                  |L10.228|
                          DCD      OSTmrTickCtr
                  |L10.232|
                          DCD      OSTmrTaskTimeMax
                  |L10.236|
0000ec  4f532054          DCB      "OS Tmr Mutex",0
0000f0  6d72204d
0000f4  75746578
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L10.252|
                          DCD      OSTmrMutex
                  |L10.256|
                          DCD      OSCfg_TmrTaskStkBasePtr
                  |L10.260|
                          DCD      OSCfg_TmrTaskStkSize
                  |L10.264|
                          DCD      OSCfg_StkSizeMin
                  |L10.268|
                          DCD      OSCfg_TmrTaskPrio
                  |L10.272|
                          DCD      OSCfg_TmrTaskStkLimit
                  |L10.276|
                          DCD      OS_TmrTask
                  |L10.280|
000118  75432f4f          DCB      "uC/OS-III Timer Task",0
00011c  532d4949
000120  49205469
000124  6d657220
000128  5461736b
00012c  00      
00012d  00                DCB      0
00012e  00                DCB      0
00012f  00                DCB      0
                  |L10.304|
                          DCD      OSTmrTaskTCB

                          AREA ||i.OS_TmrLock||, CODE, READONLY, ALIGN=2

                  OS_TmrLock PROC
;;;1160   
;;;1161   static  void  OS_TmrLock (void)
000000  b50e              PUSH     {r1-r3,lr}
;;;1162   {
;;;1163       OS_ERR  err;
;;;1164   #if OS_CFG_MUTEX_EN > 0u
;;;1165       CPU_TS  ts;
;;;1166   
;;;1167   
;;;1168       OSMutexPend(&OSTmrMutex,                                /* Use a mutex to protect the timers                      */
000002  a802              ADD      r0,sp,#8
000004  ab01              ADD      r3,sp,#4
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  9000              STR      r0,[sp,#0]
00000c  4801              LDR      r0,|L11.20|
00000e  f7fffffe          BL       OSMutexPend
;;;1169                   0u,
;;;1170                   OS_OPT_PEND_BLOCKING,
;;;1171                   &ts,
;;;1172                   &err);
;;;1173   #else
;;;1174       OSSchedLock(&err);                                      /* Lock the scheduler to protect the timers               */
;;;1175   #endif
;;;1176       (void)&err;
;;;1177   }
000012  bd0e              POP      {r1-r3,pc}
;;;1178   
                          ENDP

                  |L11.20|
                          DCD      OSTmrMutex

                          AREA ||i.OS_TmrTask||, CODE, READONLY, ALIGN=2

                  OS_TmrTask PROC
;;;1086   
;;;1087   void  OS_TmrTask (void  *p_arg)
000000  b51c              PUSH     {r2-r4,lr}
;;;1088   {
;;;1089       OS_ERR               err;
;;;1090       OS_TMR_CALLBACK_PTR  p_fnct;
;;;1091       OS_TMR              *p_tmr;
;;;1092       OS_TMR              *p_tmr_next;
;;;1093       CPU_TS               ts;
;;;1094       CPU_TS               ts_start;
;;;1095       CPU_TS               ts_delta;
;;;1096   
;;;1097   
;;;1098   
;;;1099       (void)&p_arg;                                                /* Not using 'p_arg', prevent compiler warning       */
;;;1100       while (DEF_ON) {
000002  e03f              B        |L12.132|
                  |L12.4|
;;;1101           (void)OSTaskSemPend((OS_TICK )0,                         /* Wait for signal indicating time to update tmrs    */
000004  ab01              ADD      r3,sp,#4
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       OSTaskSemPend
;;;1102                               (OS_OPT  )OS_OPT_PEND_BLOCKING,
;;;1103                               (CPU_TS *)&ts,
;;;1104                               (OS_ERR *)&err);
;;;1105   
;;;1106   
;;;1107           OS_TmrLock();
000010  f7fffffe          BL       OS_TmrLock
;;;1108           ts_start = OS_TS_GET();
000014  f7fffffe          BL       CPU_TS_TmrRd
000018  4606              MOV      r6,r0
;;;1109           OSTmrTickCtr++;                                          /* Increment the current time                        */
00001a  481b              LDR      r0,|L12.136|
00001c  6800              LDR      r0,[r0,#0]  ; OSTmrTickCtr
00001e  1c40              ADDS     r0,r0,#1
000020  4919              LDR      r1,|L12.136|
000022  6008              STR      r0,[r1,#0]  ; OSTmrTickCtr
;;;1110           p_tmr    = OSTmrListPtr;
000024  4819              LDR      r0,|L12.140|
000026  6804              LDR      r4,[r0,#0]  ; OSTmrListPtr
;;;1111           while (p_tmr != (OS_TMR *)0) {                           /* Update all the timers in the list                 */
000028  e01f              B        |L12.106|
                  |L12.42|
;;;1112               OSSchedLock(&err);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       OSSchedLock
;;;1113               (void)&err;
;;;1114               p_tmr_next = p_tmr->NextPtr;
000030  f8d48010          LDR      r8,[r4,#0x10]
;;;1115               p_tmr->Remain--;
000034  69a0              LDR      r0,[r4,#0x18]
000036  1e40              SUBS     r0,r0,#1
000038  61a0              STR      r0,[r4,#0x18]
;;;1116               if (p_tmr->Remain == 0) {
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  b980              CBNZ     r0,|L12.96|
;;;1117                   if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
00003e  8ca0              LDRH     r0,[r4,#0x24]
000040  2802              CMP      r0,#2
000042  d102              BNE      |L12.74|
;;;1118                       p_tmr->Remain = p_tmr->Period;               /* Reload the time remaining                         */
000044  6a20              LDR      r0,[r4,#0x20]
000046  61a0              STR      r0,[r4,#0x18]
000048  e005              B        |L12.86|
                  |L12.74|
;;;1119                   } else {
;;;1120                       OS_TmrUnlink(p_tmr);                         /* Remove from list                                  */
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_TmrUnlink
;;;1121                       p_tmr->State = OS_TMR_STATE_COMPLETED;       /* Indicate that the timer has completed             */
000050  2003              MOVS     r0,#3
000052  f8840026          STRB     r0,[r4,#0x26]
                  |L12.86|
;;;1122                   }
;;;1123                   p_fnct = p_tmr->CallbackPtr;                     /* Execute callback function if available            */
000056  68a5              LDR      r5,[r4,#8]
;;;1124                   if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
000058  b115              CBZ      r5,|L12.96|
;;;1125                       (*p_fnct)((void *)p_tmr,
00005a  4620              MOV      r0,r4
00005c  68e1              LDR      r1,[r4,#0xc]
00005e  47a8              BLX      r5
                  |L12.96|
;;;1126                                 p_tmr->CallbackPtrArg);
;;;1127                   }
;;;1128               }
;;;1129               p_tmr = p_tmr_next;
000060  4644              MOV      r4,r8
;;;1130               OSSchedUnlock(&err);
000062  a801              ADD      r0,sp,#4
000064  f7fffffe          BL       OSSchedUnlock
;;;1131               (void)&err;
000068  bf00              NOP      
                  |L12.106|
00006a  2c00              CMP      r4,#0                 ;1111
00006c  d1dd              BNE      |L12.42|
;;;1132           }
;;;1133   
;;;1134           ts_delta = OS_TS_GET() - ts_start;                      /* Measure execution time of timer task              */
00006e  f7fffffe          BL       CPU_TS_TmrRd
000072  1b87              SUBS     r7,r0,r6
;;;1135   
;;;1136           if (OSTmrTaskTimeMax < ts_delta) {
000074  4806              LDR      r0,|L12.144|
000076  6800              LDR      r0,[r0,#0]  ; OSTmrTaskTimeMax
000078  42b8              CMP      r0,r7
00007a  d201              BCS      |L12.128|
;;;1137               OSTmrTaskTimeMax = ts_delta;
00007c  4804              LDR      r0,|L12.144|
00007e  6007              STR      r7,[r0,#0]  ; OSTmrTaskTimeMax
                  |L12.128|
;;;1138           }
;;;1139   
;;;1140           OS_TmrUnlock();
000080  f7fffffe          BL       OS_TmrUnlock
                  |L12.132|
000084  e7be              B        |L12.4|
;;;1141       }
;;;1142   }
;;;1143   
                          ENDP

000086  0000              DCW      0x0000
                  |L12.136|
                          DCD      OSTmrTickCtr
                  |L12.140|
                          DCD      OSTmrListPtr
                  |L12.144|
                          DCD      OSTmrTaskTimeMax

                          AREA ||i.OS_TmrUnlink||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlink PROC
;;;1044   
;;;1045   void  OS_TmrUnlink (OS_TMR  *p_tmr)
000000  b510              PUSH     {r4,lr}
;;;1046   {
;;;1047       OS_TMR  *p_tmr1;
;;;1048       OS_TMR  *p_tmr2;
;;;1049   
;;;1050   
;;;1051   
;;;1052       if (OSTmrListPtr == p_tmr) {                            /* See if timer to remove is at the beginning of list     */
000002  4b0e              LDR      r3,|L13.60|
000004  681b              LDR      r3,[r3,#0]  ; OSTmrListPtr
000006  4283              CMP      r3,r0
000008  d106              BNE      |L13.24|
;;;1053           p_tmr1       = (OS_TMR *)p_tmr->NextPtr;
00000a  6901              LDR      r1,[r0,#0x10]
;;;1054           OSTmrListPtr = (OS_TMR *)p_tmr1;
00000c  4b0b              LDR      r3,|L13.60|
00000e  6019              STR      r1,[r3,#0]  ; OSTmrListPtr
;;;1055           if (p_tmr1 != (OS_TMR *)0) {
000010  b139              CBZ      r1,|L13.34|
;;;1056               p_tmr1->PrevPtr = (OS_TMR *)0;
000012  2300              MOVS     r3,#0
000014  614b              STR      r3,[r1,#0x14]
000016  e004              B        |L13.34|
                  |L13.24|
;;;1057           }
;;;1058       } else {
;;;1059           p_tmr1          = (OS_TMR *)p_tmr->PrevPtr;         /* Remove timer from somewhere in the list                */
000018  6941              LDR      r1,[r0,#0x14]
;;;1060           p_tmr2          = (OS_TMR *)p_tmr->NextPtr;
00001a  6902              LDR      r2,[r0,#0x10]
;;;1061           p_tmr1->NextPtr = p_tmr2;
00001c  610a              STR      r2,[r1,#0x10]
;;;1062           if (p_tmr2 != (OS_TMR *)0) {
00001e  b102              CBZ      r2,|L13.34|
;;;1063               p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
000020  6151              STR      r1,[r2,#0x14]
                  |L13.34|
;;;1064           }
;;;1065       }
;;;1066       p_tmr->State   = OS_TMR_STATE_STOPPED;
000022  2301              MOVS     r3,#1
000024  f8803026          STRB     r3,[r0,#0x26]
;;;1067       p_tmr->NextPtr = (OS_TMR *)0;
000028  2300              MOVS     r3,#0
00002a  6103              STR      r3,[r0,#0x10]
;;;1068       p_tmr->PrevPtr = (OS_TMR *)0;
00002c  6143              STR      r3,[r0,#0x14]
;;;1069       OSTmrListEntries--;
00002e  4b04              LDR      r3,|L13.64|
000030  881b              LDRH     r3,[r3,#0]  ; OSTmrListEntries
000032  1e5b              SUBS     r3,r3,#1
000034  4c02              LDR      r4,|L13.64|
000036  8023              STRH     r3,[r4,#0]
;;;1070   }
000038  bd10              POP      {r4,pc}
;;;1071   
                          ENDP

00003a  0000              DCW      0x0000
                  |L13.60|
                          DCD      OSTmrListPtr
                  |L13.64|
                          DCD      OSTmrListEntries

                          AREA ||i.OS_TmrUnlock||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlock PROC
;;;1181   
;;;1182   static  void  OS_TmrUnlock (void)
000000  b508              PUSH     {r3,lr}
;;;1183   {
;;;1184       OS_ERR  err;
;;;1185   
;;;1186   
;;;1187   #if OS_CFG_MUTEX_EN > 0u
;;;1188       OSMutexPost(&OSTmrMutex,                                /* Use a mutex to protect the timers                      */
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L14.16|
000008  f7fffffe          BL       OSMutexPost
;;;1189                   OS_OPT_POST_NONE,
;;;1190                   &err);
;;;1191   #else
;;;1192       OSSchedUnlock(&err);                                    /* Lock the scheduler to protect the timers               */
;;;1193   #endif
;;;1194       (void)&err;
;;;1195   }
00000c  bd08              POP      {r3,pc}
;;;1196   
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      OSTmrMutex
