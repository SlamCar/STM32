; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\results_holder.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\results_holder.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\results_holder.crf ..\DMP\mllite\results_holder.c]
                          THUMB

                          AREA ||i.inv_enable_results_holder||, CODE, READONLY, ALIGN=2

                  inv_enable_results_holder PROC
;;;312    */
;;;313    inv_error_t inv_enable_results_holder()
000000  b510              PUSH     {r4,lr}
;;;314    {
;;;315        inv_error_t result;
;;;316        result = inv_init_results_holder();
000002  f7fffffe          BL       inv_init_results_holder
000006  4604              MOV      r4,r0
;;;317        if ( result ) {
000008  b10c              CBZ      r4,|L1.14|
;;;318            return result;
00000a  4620              MOV      r0,r4
                  |L1.12|
;;;319        }
;;;320    
;;;321        result = inv_register_mpl_start_notification(inv_start_results_holder);
;;;322        return result;
;;;323    }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  4803              LDR      r0,|L1.28|
000010  f7fffffe          BL       inv_register_mpl_start_notification
000014  4604              MOV      r4,r0                 ;321
000016  4620              MOV      r0,r4                 ;322
000018  e7f8              B        |L1.12|
;;;324    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      inv_start_results_holder

                          AREA ||i.inv_generate_results||, CODE, READONLY, ALIGN=2

                  inv_generate_results PROC
;;;275     */
;;;276    inv_error_t inv_generate_results(struct inv_sensor_cal_t *sensor_cal)
000000  4601              MOV      r1,r0
;;;277    {
;;;278        rh.sensor = sensor_cal;
000002  4802              LDR      r0,|L2.12|
000004  f8c01080          STR      r1,[r0,#0x80]  ; rh
;;;279        return INV_SUCCESS;
000008  2000              MOVS     r0,#0
;;;280    }
00000a  4770              BX       lr
;;;281    
                          ENDP

                  |L2.12|
                          DCD      ||rh||

                          AREA ||i.inv_get_6axis_quaternion||, CODE, READONLY, ALIGN=2

                  inv_get_6axis_quaternion PROC
;;;215     */
;;;216    inv_error_t inv_get_6axis_quaternion(long *data)
000000  b510              PUSH     {r4,lr}
;;;217    {
000002  4601              MOV      r1,r0
;;;218        memcpy(data, rh.gam_quat, sizeof(rh.gam_quat));
000004  4c03              LDR      r4,|L3.20|
000006  3410              ADDS     r4,r4,#0x10
000008  cc1d              LDM      r4,{r0,r2-r4}
00000a  e881001d          STM      r1,{r0,r2-r4}
;;;219        return INV_SUCCESS;
00000e  2000              MOVS     r0,#0
;;;220    }
000010  bd10              POP      {r4,pc}
;;;221    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||rh||

                          AREA ||i.inv_get_acc_state||, CODE, READONLY, ALIGN=2

                  inv_get_acc_state PROC
;;;107     */
;;;108    int inv_get_acc_state()
000000  4801              LDR      r0,|L4.8|
;;;109    {
;;;110        return rh.acc_state;
000002  6d00              LDR      r0,[r0,#0x50]  ; rh
;;;111    }
000004  4770              BX       lr
;;;112    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||rh||

                          AREA ||i.inv_get_accel||, CODE, READONLY, ALIGN=1

                  inv_get_accel PROC
;;;425     */
;;;426    inv_error_t inv_get_accel(long *data)
000000  b510              PUSH     {r4,lr}
;;;427    {
000002  4604              MOV      r4,r0
;;;428        if (data != NULL) {
000004  b134              CBZ      r4,|L5.20|
;;;429            inv_get_accel_set(data, NULL, NULL);
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       inv_get_accel_set
;;;430            return INV_SUCCESS;
000010  2000              MOVS     r0,#0
                  |L5.18|
;;;431        }
;;;432        else {
;;;433            return INV_ERROR_INVALID_PARAMETER;
;;;434        }
;;;435    }
000012  bd10              POP      {r4,pc}
                  |L5.20|
000014  2005              MOVS     r0,#5                 ;433
000016  e7fc              B        |L5.18|
;;;436    
                          ENDP


                          AREA ||i.inv_get_accel_float||, CODE, READONLY, ALIGN=2

                  inv_get_accel_float PROC
;;;442     */
;;;443    inv_error_t inv_get_accel_float(float *data)
000000  b53e              PUSH     {r1-r5,lr}
;;;444    {
000002  4605              MOV      r5,r0
;;;445        long tdata[3];
;;;446        unsigned char i;
;;;447    
;;;448        if (data != NULL && !inv_get_accel(tdata)) {
000004  b1cd              CBZ      r5,|L6.58|
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       inv_get_accel
00000c  b9a8              CBNZ     r0,|L6.58|
;;;449            for (i = 0; i < 3; ++i) {
00000e  2400              MOVS     r4,#0
000010  e00f              B        |L6.50|
                  |L6.18|
;;;450                data[i] = ((float)tdata[i] / (1L << 16));
000012  f85d0024          LDR      r0,[sp,r4,LSL #2]
000016  ee000a10          VMOV     s0,r0
00001a  eeb80ac0          VCVT.F32.S32 s0,s0
00001e  eddf0a08          VLDR     s1,|L6.64|
000022  ee801a20          VDIV.F32 s2,s0,s1
000026  eb050084          ADD      r0,r5,r4,LSL #2
00002a  ed801a00          VSTR     s2,[r0,#0]
00002e  1c60              ADDS     r0,r4,#1              ;449
000030  b2c4              UXTB     r4,r0                 ;449
                  |L6.50|
000032  2c03              CMP      r4,#3                 ;449
000034  dbed              BLT      |L6.18|
;;;451            }
;;;452            return INV_SUCCESS;
000036  2000              MOVS     r0,#0
                  |L6.56|
;;;453        }
;;;454        else {
;;;455            return INV_ERROR_INVALID_PARAMETER;
;;;456        }
;;;457    }
000038  bd3e              POP      {r1-r5,pc}
                  |L6.58|
00003a  2005              MOVS     r0,#5                 ;455
00003c  e7fc              B        |L6.56|
;;;458    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
000040  47800000          DCFS     0x47800000 ; 65536

                          AREA ||i.inv_get_compass_bias_error||, CODE, READONLY, ALIGN=2

                  inv_get_compass_bias_error PROC
;;;388     */
;;;389    void inv_get_compass_bias_error(long *bias_error)
000000  4b02              LDR      r3,|L7.12|
;;;390    {
;;;391        memcpy(bias_error, rh.compass_bias_error, sizeof(rh.compass_bias_error));
000002  3358              ADDS     r3,r3,#0x58
000004  cb0e              LDM      r3,{r1-r3}
000006  e880000e          STM      r0,{r1-r3}
;;;392    }
00000a  4770              BX       lr
;;;393    
                          ENDP

                  |L7.12|
                          DCD      ||rh||

                          AREA ||i.inv_get_compass_correction||, CODE, READONLY, ALIGN=2

                  inv_get_compass_correction PROC
;;;82     */
;;;83     void inv_get_compass_correction(long *data, inv_time_t *timestamp)
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
;;;85         memcpy(data, rh.compass_correction, sizeof(rh.compass_correction));
000002  4d04              LDR      r5,|L8.20|
000004  3540              ADDS     r5,r5,#0x40
000006  cd3c              LDM      r5,{r2-r5}
000008  e880003c          STM      r0,{r2-r5}
;;;86         *timestamp = rh.nav_timestamp;
00000c  4a01              LDR      r2,|L8.20|
00000e  6a12              LDR      r2,[r2,#0x20]  ; rh
000010  600a              STR      r2,[r1,#0]
;;;87     }
000012  bd30              POP      {r4,r5,pc}
;;;88     
                          ENDP

                  |L8.20|
                          DCD      ||rh||

                          AREA ||i.inv_get_compass_state||, CODE, READONLY, ALIGN=2

                  inv_get_compass_state PROC
;;;371     */
;;;372    int inv_get_compass_state()
000000  4801              LDR      r0,|L9.8|
;;;373    {
;;;374        return rh.compass_state;
000002  6f80              LDR      r0,[r0,#0x78]  ; rh
;;;375    }
000004  4770              BX       lr
;;;376    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      ||rh||

                          AREA ||i.inv_get_gravity||, CODE, READONLY, ALIGN=2

                  inv_get_gravity PROC
;;;198     */
;;;199    inv_error_t inv_get_gravity(long *data)
000000  b570              PUSH     {r4-r6,lr}
;;;200    {
000002  4604              MOV      r4,r0
;;;201        data[0] =
000004  4a15              LDR      r2,|L10.92|
000006  68d1              LDR      r1,[r2,#0xc]  ; rh
000008  6850              LDR      r0,[r2,#4]  ; rh
00000a  f7fffffe          BL       inv_q29_mult
00000e  4605              MOV      r5,r0
000010  4a12              LDR      r2,|L10.92|
000012  6811              LDR      r1,[r2,#0]  ; rh
000014  6890              LDR      r0,[r2,#8]  ; rh
000016  f7fffffe          BL       inv_q29_mult
00001a  1a28              SUBS     r0,r5,r0
00001c  6020              STR      r0,[r4,#0]
;;;202            inv_q29_mult(rh.nav_quat[1], rh.nav_quat[3]) - inv_q29_mult(rh.nav_quat[2], rh.nav_quat[0]);
;;;203        data[1] =
00001e  4a0f              LDR      r2,|L10.92|
000020  68d1              LDR      r1,[r2,#0xc]  ; rh
000022  6890              LDR      r0,[r2,#8]  ; rh
000024  f7fffffe          BL       inv_q29_mult
000028  4605              MOV      r5,r0
00002a  4a0c              LDR      r2,|L10.92|
00002c  6811              LDR      r1,[r2,#0]  ; rh
00002e  6850              LDR      r0,[r2,#4]  ; rh
000030  f7fffffe          BL       inv_q29_mult
000034  4428              ADD      r0,r0,r5
000036  6060              STR      r0,[r4,#4]
;;;204            inv_q29_mult(rh.nav_quat[2], rh.nav_quat[3]) + inv_q29_mult(rh.nav_quat[1], rh.nav_quat[0]);
;;;205        data[2] =
000038  4a08              LDR      r2,|L10.92|
00003a  68d1              LDR      r1,[r2,#0xc]  ; rh
00003c  68d0              LDR      r0,[r2,#0xc]  ; rh
00003e  f7fffffe          BL       inv_q29_mult
000042  4605              MOV      r5,r0
000044  4a05              LDR      r2,|L10.92|
000046  6811              LDR      r1,[r2,#0]  ; rh
000048  6810              LDR      r0,[r2,#0]  ; rh
00004a  f7fffffe          BL       inv_q29_mult
00004e  4428              ADD      r0,r0,r5
000050  f1a04080          SUB      r0,r0,#0x40000000
000054  60a0              STR      r0,[r4,#8]
;;;206            (inv_q29_mult(rh.nav_quat[3], rh.nav_quat[3]) + inv_q29_mult(rh.nav_quat[0], rh.nav_quat[0])) -
;;;207            1073741824L;
;;;208    
;;;209        return INV_SUCCESS;
000056  2000              MOVS     r0,#0
;;;210    }
000058  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

00005a  0000              DCW      0x0000
                  |L10.92|
                          DCD      ||rh||

                          AREA ||i.inv_get_gyro_float||, CODE, READONLY, ALIGN=2

                  inv_get_gyro_float PROC
;;;464     */
;;;465    inv_error_t inv_get_gyro_float(float *data)
000000  b53e              PUSH     {r1-r5,lr}
;;;466    {
000002  4605              MOV      r5,r0
;;;467        long tdata[3];
;;;468        unsigned char i;
;;;469    
;;;470        if (data != NULL) {
000004  b1d5              CBZ      r5,|L11.60|
;;;471            inv_get_gyro_set(tdata, NULL, NULL);
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       inv_get_gyro_set
;;;472            for (i = 0; i < 3; ++i) {
000010  2400              MOVS     r4,#0
000012  e00f              B        |L11.52|
                  |L11.20|
;;;473                data[i] = ((float)tdata[i] / (1L << 16));
000014  f85d0024          LDR      r0,[sp,r4,LSL #2]
000018  ee000a10          VMOV     s0,r0
00001c  eeb80ac0          VCVT.F32.S32 s0,s0
000020  eddf0a07          VLDR     s1,|L11.64|
000024  ee801a20          VDIV.F32 s2,s0,s1
000028  eb050084          ADD      r0,r5,r4,LSL #2
00002c  ed801a00          VSTR     s2,[r0,#0]
000030  1c60              ADDS     r0,r4,#1              ;472
000032  b2c4              UXTB     r4,r0                 ;472
                  |L11.52|
000034  2c03              CMP      r4,#3                 ;472
000036  dbed              BLT      |L11.20|
;;;474            }
;;;475            return INV_SUCCESS;
000038  2000              MOVS     r0,#0
                  |L11.58|
;;;476        }
;;;477        else {
;;;478            return INV_ERROR_INVALID_PARAMETER;
;;;479        }
;;;480    }
00003a  bd3e              POP      {r1-r5,pc}
                  |L11.60|
00003c  2005              MOVS     r0,#5                 ;478
00003e  e7fc              B        |L11.58|
;;;481    
                          ENDP

                  |L11.64|
000040  47800000          DCFS     0x47800000 ; 65536

                          AREA ||i.inv_get_heading_confidence_interval||, CODE, READONLY, ALIGN=2

                  inv_get_heading_confidence_interval PROC
;;;492    */
;;;493    float inv_get_heading_confidence_interval(void)
000000  4801              LDR      r0,|L12.8|
;;;494    {
;;;495        return rh.quat_confidence_interval;
000002  ed900a21          VLDR     s0,[r0,#0x84]
;;;496    }
000006  4770              BX       lr
;;;497    
                          ENDP

                  |L12.8|
                          DCD      ||rh||

                          AREA ||i.inv_get_large_mag_field||, CODE, READONLY, ALIGN=2

                  inv_get_large_mag_field PROC
;;;91      */
;;;92     int inv_get_large_mag_field()
000000  4801              LDR      r0,|L13.8|
;;;93     {
;;;94         return rh.large_mag_field;
000002  6f40              LDR      r0,[r0,#0x74]  ; rh
;;;95     }
000004  4770              BX       lr
;;;96     
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||rh||

                          AREA ||i.inv_get_linear_accel||, CODE, READONLY, ALIGN=1

                  inv_get_linear_accel PROC
;;;401     */
;;;402    inv_error_t inv_get_linear_accel(long *data)
000000  b53e              PUSH     {r1-r5,lr}
;;;403    {
000002  4604              MOV      r4,r0
;;;404        long gravity[3];
;;;405    
;;;406        if (data != NULL)
000004  b1c4              CBZ      r4,|L14.56|
;;;407        {
;;;408            inv_get_accel_set(data, NULL, NULL);
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       inv_get_accel_set
;;;409            inv_get_gravity(gravity);
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       inv_get_gravity
;;;410            data[0] -= gravity[0] >> 14;
000016  6820              LDR      r0,[r4,#0]
000018  9900              LDR      r1,[sp,#0]
00001a  eba030a1          SUB      r0,r0,r1,ASR #14
00001e  6020              STR      r0,[r4,#0]
;;;411            data[1] -= gravity[1] >> 14;
000020  6860              LDR      r0,[r4,#4]
000022  9901              LDR      r1,[sp,#4]
000024  eba030a1          SUB      r0,r0,r1,ASR #14
000028  6060              STR      r0,[r4,#4]
;;;412            data[2] -= gravity[2] >> 14;
00002a  68a0              LDR      r0,[r4,#8]
00002c  9902              LDR      r1,[sp,#8]
00002e  eba030a1          SUB      r0,r0,r1,ASR #14
000032  60a0              STR      r0,[r4,#8]
;;;413            return INV_SUCCESS;
000034  2000              MOVS     r0,#0
                  |L14.54|
;;;414        }
;;;415        else {
;;;416            return INV_ERROR_INVALID_PARAMETER;
;;;417        }
;;;418    }
000036  bd3e              POP      {r1-r5,pc}
                  |L14.56|
000038  2005              MOVS     r0,#5                 ;416
00003a  e7fc              B        |L14.54|
;;;419    
                          ENDP


                          AREA ||i.inv_get_linear_accel_float||, CODE, READONLY, ALIGN=2

                  inv_get_linear_accel_float PROC
;;;503     */
;;;504    inv_error_t inv_get_linear_accel_float(float *data)
000000  b53e              PUSH     {r1-r5,lr}
;;;505    {
000002  4605              MOV      r5,r0
;;;506        long tdata[3];
;;;507        unsigned char i;
;;;508    
;;;509        if (data != NULL && !inv_get_linear_accel(tdata)) {
000004  b1cd              CBZ      r5,|L15.58|
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       inv_get_linear_accel
00000c  b9a8              CBNZ     r0,|L15.58|
;;;510            for (i = 0; i < 3; ++i) {
00000e  2400              MOVS     r4,#0
000010  e00f              B        |L15.50|
                  |L15.18|
;;;511                data[i] = ((float)tdata[i] / (1L << 16));
000012  f85d0024          LDR      r0,[sp,r4,LSL #2]
000016  ee000a10          VMOV     s0,r0
00001a  eeb80ac0          VCVT.F32.S32 s0,s0
00001e  eddf0a08          VLDR     s1,|L15.64|
000022  ee801a20          VDIV.F32 s2,s0,s1
000026  eb050084          ADD      r0,r5,r4,LSL #2
00002a  ed801a00          VSTR     s2,[r0,#0]
00002e  1c60              ADDS     r0,r4,#1              ;510
000030  b2c4              UXTB     r4,r0                 ;510
                  |L15.50|
000032  2c03              CMP      r4,#3                 ;510
000034  dbed              BLT      |L15.18|
;;;512            }
;;;513            return INV_SUCCESS;
000036  2000              MOVS     r0,#0
                  |L15.56|
;;;514        }
;;;515        else {
;;;516            return INV_ERROR_INVALID_PARAMETER;
;;;517        }
;;;518    }
000038  bd3e              POP      {r1-r5,pc}
                  |L15.58|
00003a  2005              MOVS     r0,#5                 ;516
00003c  e7fc              B        |L15.56|
;;;519    
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
000040  47800000          DCFS     0x47800000 ; 65536

                          AREA ||i.inv_get_local_field||, CODE, READONLY, ALIGN=2

                  inv_get_local_field PROC
;;;171    */
;;;172    void inv_get_local_field(long *data)
000000  4b02              LDR      r3,|L16.12|
;;;173    {
;;;174        memcpy(data, rh.local_field, sizeof(rh.local_field));
000002  3328              ADDS     r3,r3,#0x28
000004  cb0e              LDM      r3,{r1-r3}
000006  e880000e          STM      r0,{r1-r3}
;;;175    }
00000a  4770              BX       lr
;;;176    
                          ENDP

                  |L16.12|
                          DCD      ||rh||

                          AREA ||i.inv_get_mag_scale||, CODE, READONLY, ALIGN=2

                  inv_get_mag_scale PROC
;;;189     */
;;;190    void inv_get_mag_scale(long *data)
000000  4b02              LDR      r3,|L17.12|
;;;191    {
;;;192        memcpy(data, rh.mag_scale, sizeof(rh.mag_scale));
000002  3334              ADDS     r3,r3,#0x34
000004  cb0e              LDM      r3,{r1-r3}
000006  e880000e          STM      r0,{r1-r3}
;;;193    }
00000a  4770              BX       lr
;;;194    
                          ENDP

                  |L17.12|
                          DCD      ||rh||

                          AREA ||i.inv_get_motion_state||, CODE, READONLY, ALIGN=2

                  inv_get_motion_state PROC
;;;125    */
;;;126    int inv_get_motion_state(unsigned int *cntr)
000000  4601              MOV      r1,r0
;;;127    {
;;;128        *cntr = rh.motion_state_counter;
000002  4803              LDR      r0,|L18.16|
000004  6e80              LDR      r0,[r0,#0x68]  ; rh
000006  6008              STR      r0,[r1,#0]
;;;129        return rh.motion_state;
000008  4801              LDR      r0,|L18.16|
00000a  f8900064          LDRB     r0,[r0,#0x64]  ; rh
;;;130    }
00000e  4770              BX       lr
;;;131    
                          ENDP

                  |L18.16|
                          DCD      ||rh||

                          AREA ||i.inv_get_quaternion||, CODE, READONLY, ALIGN=2

                  inv_get_quaternion PROC
;;;225     */
;;;226    inv_error_t inv_get_quaternion(long *data)
000000  b510              PUSH     {r4,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228        if (rh.status & (INV_COMPASS_CORRECTION_SET | INV_6_AXIS_QUAT_SET)) {
000004  480c              LDR      r0,|L19.56|
000006  f890007c          LDRB     r0,[r0,#0x7c]  ; rh
00000a  f0000003          AND      r0,r0,#3
00000e  b160              CBZ      r0,|L19.42|
;;;229            inv_q_mult(rh.compass_correction, rh.gam_quat, rh.nav_quat);
000010  4a09              LDR      r2,|L19.56|
000012  f1020110          ADD      r1,r2,#0x10
000016  f1010030          ADD      r0,r1,#0x30
00001a  f7fffffe          BL       inv_q_mult
;;;230            rh.status &= ~(INV_COMPASS_CORRECTION_SET | INV_6_AXIS_QUAT_SET);
00001e  4806              LDR      r0,|L19.56|
000020  6fc0              LDR      r0,[r0,#0x7c]  ; rh
000022  f0200003          BIC      r0,r0,#3
000026  4904              LDR      r1,|L19.56|
000028  67c8              STR      r0,[r1,#0x7c]  ; rh
                  |L19.42|
;;;231        }
;;;232        memcpy(data, rh.nav_quat, sizeof(rh.nav_quat));
00002a  4b03              LDR      r3,|L19.56|
00002c  cb0f              LDM      r3,{r0-r3}
00002e  e884000f          STM      r4,{r0-r3}
;;;233        return INV_SUCCESS;
000032  2000              MOVS     r0,#0
;;;234    }
000034  bd10              POP      {r4,pc}
;;;235    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      ||rh||

                          AREA ||i.inv_get_quaternion_float||, CODE, READONLY, ALIGN=1

                  inv_get_quaternion_float PROC
;;;239     */
;;;240    inv_error_t inv_get_quaternion_float(float *data)
000000  b57f              PUSH     {r0-r6,lr}
;;;241    {
000002  4604              MOV      r4,r0
;;;242        long ldata[4];
;;;243        inv_error_t result = inv_get_quaternion(ldata);
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       inv_get_quaternion
00000a  4605              MOV      r5,r0
;;;244        data[0] = inv_q30_to_float(ldata[0]);
00000c  9800              LDR      r0,[sp,#0]
00000e  f7fffffe          BL       inv_q30_to_float
000012  ed840a00          VSTR     s0,[r4,#0]
;;;245        data[1] = inv_q30_to_float(ldata[1]);
000016  9801              LDR      r0,[sp,#4]
000018  f7fffffe          BL       inv_q30_to_float
00001c  ed840a01          VSTR     s0,[r4,#4]
;;;246        data[2] = inv_q30_to_float(ldata[2]);
000020  9802              LDR      r0,[sp,#8]
000022  f7fffffe          BL       inv_q30_to_float
000026  ed840a02          VSTR     s0,[r4,#8]
;;;247        data[3] = inv_q30_to_float(ldata[3]);
00002a  9803              LDR      r0,[sp,#0xc]
00002c  f7fffffe          BL       inv_q30_to_float
000030  ed840a03          VSTR     s0,[r4,#0xc]
;;;248        return result;
000034  4628              MOV      r0,r5
;;;249    }
000036  b004              ADD      sp,sp,#0x10
000038  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP


                          AREA ||i.inv_get_quaternion_set||, CODE, READONLY, ALIGN=1

                  inv_get_quaternion_set PROC
;;;255     */
;;;256    void inv_get_quaternion_set(long *data, int *accuracy, inv_time_t *timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;258        inv_get_quaternion(data);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       inv_get_quaternion
;;;259        *timestamp = inv_get_last_timestamp();
00000e  f7fffffe          BL       inv_get_last_timestamp
000012  6028              STR      r0,[r5,#0]
;;;260        if (inv_get_compass_on()) {
000014  f7fffffe          BL       inv_get_compass_on
000018  b118              CBZ      r0,|L21.34|
;;;261            *accuracy = inv_get_mag_accuracy();
00001a  f7fffffe          BL       inv_get_mag_accuracy
00001e  6020              STR      r0,[r4,#0]
000020  e00f              B        |L21.66|
                  |L21.34|
;;;262        } else if (inv_get_gyro_on()) {
000022  f7fffffe          BL       inv_get_gyro_on
000026  b118              CBZ      r0,|L21.48|
;;;263            *accuracy = inv_get_gyro_accuracy();
000028  f7fffffe          BL       inv_get_gyro_accuracy
00002c  6020              STR      r0,[r4,#0]
00002e  e008              B        |L21.66|
                  |L21.48|
;;;264        }else if (inv_get_accel_on()) {
000030  f7fffffe          BL       inv_get_accel_on
000034  b118              CBZ      r0,|L21.62|
;;;265            *accuracy = inv_get_accel_accuracy();
000036  f7fffffe          BL       inv_get_accel_accuracy
00003a  6020              STR      r0,[r4,#0]
00003c  e001              B        |L21.66|
                  |L21.62|
;;;266        } else {
;;;267            *accuracy = 0;
00003e  2000              MOVS     r0,#0
000040  6020              STR      r0,[r4,#0]
                  |L21.66|
;;;268        }
;;;269    }
000042  bd70              POP      {r4-r6,pc}
;;;270    
                          ENDP


                          AREA ||i.inv_got_accel_bias||, CODE, READONLY, ALIGN=2

                  inv_got_accel_bias PROC
;;;328     */
;;;329    int inv_got_accel_bias()
000000  4801              LDR      r0,|L22.8|
;;;330    {
;;;331        return rh.got_accel_bias;
000002  6d40              LDR      r0,[r0,#0x54]  ; rh
;;;332    }
000004  4770              BX       lr
;;;333    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      ||rh||

                          AREA ||i.inv_got_compass_bias||, CODE, READONLY, ALIGN=2

                  inv_got_compass_bias PROC
;;;346     */
;;;347    int inv_got_compass_bias()
000000  4801              LDR      r0,|L23.8|
;;;348    {
;;;349        return rh.got_compass_bias;
000002  6f00              LDR      r0,[r0,#0x70]  ; rh
;;;350    }
000004  4770              BX       lr
;;;351    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      ||rh||

                          AREA ||i.inv_init_results_holder||, CODE, READONLY, ALIGN=2

                  inv_init_results_holder PROC
;;;297    */
;;;298    inv_error_t inv_init_results_holder(void)
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300        memset(&rh, 0, sizeof(rh));
000002  2188              MOVS     r1,#0x88
000004  480b              LDR      r0,|L24.52|
000006  f7fffffe          BL       __aeabi_memclr4
;;;301        rh.mag_scale[0] = 1L<<30;
00000a  f04f4080          MOV      r0,#0x40000000
00000e  4909              LDR      r1,|L24.52|
000010  6348              STR      r0,[r1,#0x34]  ; rh
;;;302        rh.mag_scale[1] = 1L<<30;
000012  4601              MOV      r1,r0
000014  4807              LDR      r0,|L24.52|
000016  6381              STR      r1,[r0,#0x38]
;;;303        rh.mag_scale[2] = 1L<<30;
000018  63c1              STR      r1,[r0,#0x3c]
;;;304        rh.compass_correction[0] = 1L<<30;
00001a  4608              MOV      r0,r1
00001c  4905              LDR      r1,|L24.52|
00001e  6408              STR      r0,[r1,#0x40]  ; rh
;;;305        rh.gam_quat[0] = 1L<<30;
000020  6108              STR      r0,[r1,#0x10]  ; rh
;;;306        rh.nav_quat[0] = 1L<<30;
000022  6008              STR      r0,[r1,#0]  ; rh
;;;307        rh.quat_confidence_interval = (float)M_PI;
000024  ed9f0a04          VLDR     s0,|L24.56|
000028  4608              MOV      r0,r1
00002a  ed800a21          VSTR     s0,[r0,#0x84]
;;;308        return INV_SUCCESS;
00002e  2000              MOVS     r0,#0
;;;309    }
000030  bd10              POP      {r4,pc}
;;;310    
                          ENDP

000032  0000              DCW      0x0000
                  |L24.52|
                          DCD      ||rh||
                  |L24.56|
000038  40490fdb          DCFS     0x40490fdb ; 3.1415927410125732

                          AREA ||i.inv_q30_to_float||, CODE, READONLY, ALIGN=2

                  inv_q30_to_float PROC
;;;33     
;;;34         static inline float inv_q30_to_float(long q30)
000000  ee000a10          VMOV     s0,r0
;;;35         {
;;;36             return (float) q30 / ((float)(1L << 30));
000004  eef80ac0          VCVT.F32.S32 s1,s0
000008  ed9f1a02          VLDR     s2,|L25.20|
00000c  ee800a81          VDIV.F32 s0,s1,s2
;;;37         }
000010  4770              BX       lr
;;;38     
                          ENDP

000012  0000              DCW      0x0000
                  |L25.20|
000014  4e800000          DCFS     0x4e800000 ; 1073741824

                          AREA ||i.inv_set_acc_state||, CODE, READONLY, ALIGN=2

                  inv_set_acc_state PROC
;;;115     */
;;;116    void inv_set_acc_state(int state)
000000  4901              LDR      r1,|L26.8|
;;;117    {
;;;118        rh.acc_state = state;
000002  6508              STR      r0,[r1,#0x50]  ; rh
;;;119        return;
;;;120    }
000004  4770              BX       lr
;;;121    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      ||rh||

                          AREA ||i.inv_set_accel_bias_found||, CODE, READONLY, ALIGN=2

                  inv_set_accel_bias_found PROC
;;;337     */
;;;338    void inv_set_accel_bias_found(int state)
000000  4901              LDR      r1,|L27.8|
;;;339    {
;;;340        rh.got_accel_bias = state;
000002  6548              STR      r0,[r1,#0x54]  ; rh
;;;341    }
000004  4770              BX       lr
;;;342    
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      ||rh||

                          AREA ||i.inv_set_compass_bias_error||, CODE, READONLY, ALIGN=2

                  inv_set_compass_bias_error PROC
;;;380     */
;;;381    void inv_set_compass_bias_error(const long *bias_error)
000000  b510              PUSH     {r4,lr}
;;;382    {
;;;383        memcpy(rh.compass_bias_error, bias_error, sizeof(rh.compass_bias_error));
000002  4903              LDR      r1,|L28.16|
000004  e890001c          LDM      r0,{r2-r4}
000008  3158              ADDS     r1,r1,#0x58
00000a  c11c              STM      r1!,{r2-r4}
;;;384    }
00000c  bd10              POP      {r4,pc}
;;;385    
                          ENDP

00000e  0000              DCW      0x0000
                  |L28.16|
                          DCD      ||rh||

                          AREA ||i.inv_set_compass_bias_found||, CODE, READONLY, ALIGN=2

                  inv_set_compass_bias_found PROC
;;;355     */
;;;356    void inv_set_compass_bias_found(int state)
000000  4901              LDR      r1,|L29.8|
;;;357    {
;;;358        rh.got_compass_bias = state;
000002  6708              STR      r0,[r1,#0x70]  ; rh
;;;359    }
000004  4770              BX       lr
;;;360    
                          ENDP

000006  0000              DCW      0x0000
                  |L29.8|
                          DCD      ||rh||

                          AREA ||i.inv_set_compass_correction||, CODE, READONLY, ALIGN=2

                  inv_set_compass_correction PROC
;;;70     */
;;;71     void inv_set_compass_correction(const long *data, inv_time_t timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;72     {
;;;73         rh.status |= INV_COMPASS_CORRECTION_SET;
000002  4a07              LDR      r2,|L30.32|
000004  6fd2              LDR      r2,[r2,#0x7c]  ; rh
000006  f0420201          ORR      r2,r2,#1
00000a  4b05              LDR      r3,|L30.32|
00000c  67da              STR      r2,[r3,#0x7c]  ; rh
;;;74         memcpy(rh.compass_correction, data, sizeof(rh.compass_correction));
00000e  461a              MOV      r2,r3
000010  e8900078          LDM      r0,{r3-r6}
000014  3240              ADDS     r2,r2,#0x40
000016  c278              STM      r2!,{r3-r6}
;;;75         rh.nav_timestamp = timestamp;
000018  3a50              SUBS     r2,r2,#0x50
00001a  6211              STR      r1,[r2,#0x20]  ; rh
;;;76     }
00001c  bd70              POP      {r4-r6,pc}
;;;77     
                          ENDP

00001e  0000              DCW      0x0000
                  |L30.32|
                          DCD      ||rh||

                          AREA ||i.inv_set_compass_state||, CODE, READONLY, ALIGN=2

                  inv_set_compass_state PROC
;;;363     */
;;;364    void inv_set_compass_state(int state)
000000  4901              LDR      r1,|L31.8|
;;;365    {
;;;366        rh.compass_state = state;
000002  6788              STR      r0,[r1,#0x78]  ; rh
;;;367    }
000004  4770              BX       lr
;;;368    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      ||rh||

                          AREA ||i.inv_set_heading_confidence_interval||, CODE, READONLY, ALIGN=2

                  inv_set_heading_confidence_interval PROC
;;;484    */
;;;485    void inv_set_heading_confidence_interval(float ci)
000000  4801              LDR      r0,|L32.8|
;;;486    {
;;;487        rh.quat_confidence_interval = ci;
000002  ed800a21          VSTR     s0,[r0,#0x84]
;;;488    }
000006  4770              BX       lr
;;;489    
                          ENDP

                  |L32.8|
                          DCD      ||rh||

                          AREA ||i.inv_set_large_mag_field||, CODE, READONLY, ALIGN=2

                  inv_set_large_mag_field PROC
;;;99      */
;;;100    void inv_set_large_mag_field(int state)
000000  4901              LDR      r1,|L33.8|
;;;101    {
;;;102        rh.large_mag_field = state;
000002  6748              STR      r0,[r1,#0x74]  ; rh
;;;103    }
000004  4770              BX       lr
;;;104    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      ||rh||

                          AREA ||i.inv_set_local_field||, CODE, READONLY, ALIGN=2

                  inv_set_local_field PROC
;;;161    */
;;;162    void inv_set_local_field(const long *data)
000000  b510              PUSH     {r4,lr}
;;;163    {
;;;164        memcpy(rh.local_field, data, sizeof(rh.local_field));
000002  4903              LDR      r1,|L34.16|
000004  e890001c          LDM      r0,{r2-r4}
000008  3128              ADDS     r1,r1,#0x28
00000a  c11c              STM      r1!,{r2-r4}
;;;165    }
00000c  bd10              POP      {r4,pc}
;;;166    
                          ENDP

00000e  0000              DCW      0x0000
                  |L34.16|
                          DCD      ||rh||

                          AREA ||i.inv_set_mag_scale||, CODE, READONLY, ALIGN=2

                  inv_set_mag_scale PROC
;;;180     */
;;;181    void inv_set_mag_scale(const long *data)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183        memcpy(rh.mag_scale, data, sizeof(rh.mag_scale));
000002  4903              LDR      r1,|L35.16|
000004  e890001c          LDM      r0,{r2-r4}
000008  3134              ADDS     r1,r1,#0x34
00000a  c11c              STM      r1!,{r2-r4}
;;;184    }
00000c  bd10              POP      {r4,pc}
;;;185    
                          ENDP

00000e  0000              DCW      0x0000
                  |L35.16|
                          DCD      ||rh||

                          AREA ||i.inv_set_motion_state||, CODE, READONLY, ALIGN=2

                  inv_set_motion_state PROC
;;;135     */
;;;136    void inv_set_motion_state(unsigned char state)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
000002  4604              MOV      r4,r0
;;;138        long set;
;;;139        if (state == rh.motion_state) {
000004  4811              LDR      r0,|L36.76|
000006  f8900064          LDRB     r0,[r0,#0x64]  ; rh
00000a  42a0              CMP      r0,r4
00000c  d10b              BNE      |L36.38|
;;;140            if (state == INV_NO_MOTION) {
00000e  2c02              CMP      r4,#2
000010  d105              BNE      |L36.30|
;;;141                rh.motion_state_counter++;
000012  480e              LDR      r0,|L36.76|
000014  6e80              LDR      r0,[r0,#0x68]  ; rh
000016  1c40              ADDS     r0,r0,#1
000018  490c              LDR      r1,|L36.76|
00001a  6688              STR      r0,[r1,#0x68]  ; rh
00001c  e002              B        |L36.36|
                  |L36.30|
;;;142            } else {
;;;143                rh.motion_state_counter = 0;
00001e  2000              MOVS     r0,#0
000020  490a              LDR      r1,|L36.76|
000022  6688              STR      r0,[r1,#0x68]  ; rh
                  |L36.36|
;;;144            }
;;;145            return;
;;;146        }
;;;147        rh.motion_state_counter = 0;
;;;148        rh.motion_state = state;
;;;149        /* Equivalent to set = state, but #define's may change. */
;;;150        if (state == INV_MOTION)
;;;151            set = INV_MSG_MOTION_EVENT;
;;;152        else
;;;153            set = INV_MSG_NO_MOTION_EVENT;
;;;154        inv_set_message(set, (INV_MSG_MOTION_EVENT | INV_MSG_NO_MOTION_EVENT), 0);
;;;155    }
000024  bd70              POP      {r4-r6,pc}
                  |L36.38|
000026  2000              MOVS     r0,#0                 ;147
000028  4908              LDR      r1,|L36.76|
00002a  6688              STR      r0,[r1,#0x68]         ;147  ; rh
00002c  4608              MOV      r0,r1                 ;148
00002e  f8804064          STRB     r4,[r0,#0x64]         ;148
000032  2c01              CMP      r4,#1                 ;150
000034  d101              BNE      |L36.58|
000036  2501              MOVS     r5,#1                 ;151
000038  e000              B        |L36.60|
                  |L36.58|
00003a  2502              MOVS     r5,#2                 ;153
                  |L36.60|
00003c  2200              MOVS     r2,#0                 ;154
00003e  2103              MOVS     r1,#3                 ;154
000040  4628              MOV      r0,r5                 ;154
000042  f7fffffe          BL       inv_set_message
000046  bf00              NOP      
000048  e7ec              B        |L36.36|
;;;156    
                          ENDP

00004a  0000              DCW      0x0000
                  |L36.76|
                          DCD      ||rh||

                          AREA ||i.inv_start_results_holder||, CODE, READONLY, ALIGN=2

                  inv_start_results_holder PROC
;;;285     */
;;;286    inv_error_t inv_start_results_holder(void)
000000  b510              PUSH     {r4,lr}
;;;287    {
;;;288        inv_register_data_cb(inv_generate_results, INV_PRIORITY_RESULTS_HOLDER,
000002  2207              MOVS     r2,#7
000004  f44f7148          MOV      r1,#0x320
000008  4802              LDR      r0,|L37.20|
00000a  f7fffffe          BL       inv_register_data_cb
;;;289            INV_GYRO_NEW | INV_ACCEL_NEW | INV_MAG_NEW);
;;;290        return INV_SUCCESS;
00000e  2000              MOVS     r0,#0
;;;291    }
000010  bd10              POP      {r4,pc}
;;;292    
                          ENDP

000012  0000              DCW      0x0000
                  |L37.20|
                          DCD      inv_generate_results

                          AREA ||i.inv_store_gaming_quaternion||, CODE, READONLY, ALIGN=2

                  inv_store_gaming_quaternion PROC
;;;58     */
;;;59     void inv_store_gaming_quaternion(const long *quat, inv_time_t timestamp)
000000  b570              PUSH     {r4-r6,lr}
;;;60     {
;;;61         rh.status |= INV_6_AXIS_QUAT_SET;
000002  4a07              LDR      r2,|L38.32|
000004  6fd2              LDR      r2,[r2,#0x7c]  ; rh
000006  f0420202          ORR      r2,r2,#2
00000a  4b05              LDR      r3,|L38.32|
00000c  67da              STR      r2,[r3,#0x7c]  ; rh
;;;62         memcpy(&rh.gam_quat, quat, sizeof(rh.gam_quat));
00000e  461a              MOV      r2,r3
000010  e8900078          LDM      r0,{r3-r6}
000014  3210              ADDS     r2,r2,#0x10
000016  c278              STM      r2!,{r3-r6}
;;;63         rh.gam_timestamp = timestamp;
000018  3a20              SUBS     r2,r2,#0x20
00001a  6251              STR      r1,[r2,#0x24]  ; rh
;;;64     }
00001c  bd70              POP      {r4-r6,pc}
;;;65     
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      ||rh||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||rh||
                          %        136
