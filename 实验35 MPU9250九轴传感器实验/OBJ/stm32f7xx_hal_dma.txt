; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f7xx_hal_dma.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f7xx_hal_dma.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\stm32f7xx_hal_dma.crf ..\HALLIB\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1189     */
;;;1190   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1191   {
;;;1192     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;1193     
;;;1194     /* lookup table for necessary bitshift of flags within status registers */
;;;1195     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1196     hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  65c8              STR      r0,[r1,#0x5c]
;;;1197     
;;;1198     if (stream_number > 3U)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;1199     {
;;;1200       /* return pointer to HISR and HIFCR */
;;;1201       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  6588              STR      r0,[r1,#0x58]
000020  e003              B        |L1.42|
                  |L1.34|
;;;1202     }
;;;1203     else
;;;1204     {
;;;1205       /* return pointer to LISR and LIFCR */
;;;1206       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  6588              STR      r0,[r1,#0x58]
                  |L1.42|
;;;1207     }
;;;1208     
;;;1209     return hdma->StreamBaseAddress;
00002a  6d88              LDR      r0,[r1,#0x58]
;;;1210   }
00002c  4770              BX       lr
;;;1211   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1217     */
;;;1218   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1219   {
;;;1220     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;1221     uint32_t tmp = hdma->Init.FIFOThreshold;
000004  6a8a              LDR      r2,[r1,#0x28]
;;;1222     
;;;1223     /* Memory Data size equal to Byte */
;;;1224     if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
000006  698b              LDR      r3,[r1,#0x18]
000008  bb03              CBNZ     r3,|L2.76|
;;;1225     {
;;;1226       switch (tmp)
00000a  b132              CBZ      r2,|L2.26|
00000c  2a01              CMP      r2,#1
00000e  d00c              BEQ      |L2.42|
000010  2a02              CMP      r2,#2
000012  d010              BEQ      |L2.54|
000014  2a03              CMP      r2,#3
000016  d117              BNE      |L2.72|
000018  e015              B        |L2.70|
                  |L2.26|
;;;1227       {
;;;1228         case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1229           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00001a  6acb              LDR      r3,[r1,#0x2c]
00001c  f0037380          AND      r3,r3,#0x1000000
000020  f1b37f80          CMP      r3,#0x1000000
000024  d100              BNE      |L2.40|
;;;1230           {
;;;1231             status = HAL_ERROR;
000026  2001              MOVS     r0,#1
                  |L2.40|
;;;1232           }
;;;1233           break;
000028  e00f              B        |L2.74|
                  |L2.42|
;;;1234         case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1235           if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00002a  6acb              LDR      r3,[r1,#0x2c]
00002c  f1b37fc0          CMP      r3,#0x1800000
000030  d100              BNE      |L2.52|
;;;1236           {
;;;1237             status = HAL_ERROR;
000032  2001              MOVS     r0,#1
                  |L2.52|
;;;1238           }
;;;1239           break;
000034  e009              B        |L2.74|
                  |L2.54|
;;;1240         case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1241           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000036  6acb              LDR      r3,[r1,#0x2c]
000038  f0037380          AND      r3,r3,#0x1000000
00003c  f1b37f80          CMP      r3,#0x1000000
000040  d100              BNE      |L2.68|
;;;1242           {
;;;1243             status = HAL_ERROR;
000042  2001              MOVS     r0,#1
                  |L2.68|
;;;1244           }
;;;1245           break;
000044  e001              B        |L2.74|
                  |L2.70|
;;;1246         case DMA_FIFO_THRESHOLD_FULL:
;;;1247           break;
000046  e000              B        |L2.74|
                  |L2.72|
;;;1248         default:
;;;1249           break;
000048  bf00              NOP      
                  |L2.74|
00004a  e035              B        |L2.184|
                  |L2.76|
;;;1250       }
;;;1251     }
;;;1252     
;;;1253     /* Memory Data size equal to Half-Word */
;;;1254     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
00004c  698b              LDR      r3,[r1,#0x18]
00004e  f5b35f00          CMP      r3,#0x2000
000052  d11b              BNE      |L2.140|
;;;1255     {
;;;1256       switch (tmp)
000054  b132              CBZ      r2,|L2.100|
000056  2a01              CMP      r2,#1
000058  d006              BEQ      |L2.104|
00005a  2a02              CMP      r2,#2
00005c  d00c              BEQ      |L2.120|
00005e  2a03              CMP      r2,#3
000060  d112              BNE      |L2.136|
000062  e00b              B        |L2.124|
                  |L2.100|
;;;1257       {
;;;1258         case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1259           status = HAL_ERROR;
000064  2001              MOVS     r0,#1
;;;1260           break;
000066  e010              B        |L2.138|
                  |L2.104|
;;;1261         case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1262           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000068  6acb              LDR      r3,[r1,#0x2c]
00006a  f0037380          AND      r3,r3,#0x1000000
00006e  f1b37f80          CMP      r3,#0x1000000
000072  d100              BNE      |L2.118|
;;;1263           {
;;;1264             status = HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L2.118|
;;;1265           }
;;;1266           break;
000076  e008              B        |L2.138|
                  |L2.120|
;;;1267         case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1268           status = HAL_ERROR;
000078  2001              MOVS     r0,#1
;;;1269           break;
00007a  e006              B        |L2.138|
                  |L2.124|
;;;1270         case DMA_FIFO_THRESHOLD_FULL:
;;;1271           if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00007c  6acb              LDR      r3,[r1,#0x2c]
00007e  f1b37fc0          CMP      r3,#0x1800000
000082  d100              BNE      |L2.134|
;;;1272           {
;;;1273             status = HAL_ERROR;
000084  2001              MOVS     r0,#1
                  |L2.134|
;;;1274           }
;;;1275           break;   
000086  e000              B        |L2.138|
                  |L2.136|
;;;1276         default:
;;;1277           break;
000088  bf00              NOP      
                  |L2.138|
00008a  e015              B        |L2.184|
                  |L2.140|
;;;1278       }
;;;1279     }
;;;1280     
;;;1281     /* Memory Data size equal to Word */
;;;1282     else
;;;1283     {
;;;1284       switch (tmp)
00008c  b132              CBZ      r2,|L2.156|
00008e  2a01              CMP      r2,#1
000090  d005              BEQ      |L2.158|
000092  2a02              CMP      r2,#2
000094  d004              BEQ      |L2.160|
000096  2a03              CMP      r2,#3
000098  d10c              BNE      |L2.180|
00009a  e003              B        |L2.164|
                  |L2.156|
;;;1285       {
;;;1286         case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1287         case DMA_FIFO_THRESHOLD_HALFFULL:
00009c  bf00              NOP      
                  |L2.158|
;;;1288         case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00009e  bf00              NOP      
                  |L2.160|
;;;1289           status = HAL_ERROR;
0000a0  2001              MOVS     r0,#1
;;;1290           break;
0000a2  e008              B        |L2.182|
                  |L2.164|
;;;1291         case DMA_FIFO_THRESHOLD_FULL:
;;;1292           if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
0000a4  6acb              LDR      r3,[r1,#0x2c]
0000a6  f0037380          AND      r3,r3,#0x1000000
0000aa  f1b37f80          CMP      r3,#0x1000000
0000ae  d100              BNE      |L2.178|
;;;1293           {
;;;1294             status = HAL_ERROR;
0000b0  2001              MOVS     r0,#1
                  |L2.178|
;;;1295           }
;;;1296   		break;
0000b2  e000              B        |L2.182|
                  |L2.180|
;;;1297         default:
;;;1298           break;
0000b4  bf00              NOP      
                  |L2.182|
0000b6  bf00              NOP                            ;1290
                  |L2.184|
;;;1299       }
;;;1300     } 
;;;1301     
;;;1302     return status; 
;;;1303   }
0000b8  4770              BX       lr
;;;1304   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1155     */
;;;1156   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1157   {
;;;1158     /* Clear DBM bit */
;;;1159     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;1160   
;;;1161     /* Configure DMA Stream data length */
;;;1162     hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;1163   
;;;1164     /* Peripheral to Memory */
;;;1165     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L3.34|
;;;1166     {
;;;1167       /* Configure DMA Stream destination address */
;;;1168       hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;1169   
;;;1170       /* Configure DMA Stream source address */
;;;1171       hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L3.42|
                  |L3.34|
;;;1172     }
;;;1173     /* Memory to Peripheral */
;;;1174     else
;;;1175     {
;;;1176       /* Configure DMA Stream source address */
;;;1177       hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;1178       
;;;1179       /* Configure DMA Stream destination address */
;;;1180       hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L3.42|
;;;1181     }
;;;1182   }
00002a  bd30              POP      {r4,r5,pc}
;;;1183   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522      /* calculate DMA base and stream number */
;;;523      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6da5              LDR      r5,[r4,#0x58]
;;;524      
;;;525      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;526      
;;;527      if(hdma->State != HAL_DMA_STATE_BUSY)
00000c  f8940035          LDRB     r0,[r4,#0x35]
000010  2802              CMP      r0,#2
000012  d008              BEQ      |L4.38|
;;;528      {
;;;529        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000014  2080              MOVS     r0,#0x80
000016  6560              STR      r0,[r4,#0x54]
;;;530        
;;;531        /* Process Unlocked */
;;;532        __HAL_UNLOCK(hdma);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  f8840034          STRB     r0,[r4,#0x34]
000020  bf00              NOP      
;;;533        
;;;534        return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;535      }
;;;536      else
;;;537      {
;;;538        /* Disable all the transfer interrupts */
;;;539        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;540        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;541        
;;;542        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;543        {
;;;544          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;545        }
;;;546        
;;;547        /* Disable the stream */
;;;548        __HAL_DMA_DISABLE(hdma);
;;;549        
;;;550        /* Check if the DMA Stream is effectively disabled */
;;;551        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;552        {
;;;553          /* Check for the Timeout */
;;;554          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;555          {
;;;556            /* Update error code */
;;;557            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;558            
;;;559            /* Process Unlocked */
;;;560            __HAL_UNLOCK(hdma);
;;;561            
;;;562            /* Change the DMA state */
;;;563            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;564            
;;;565            return HAL_TIMEOUT;
;;;566          }
;;;567        }
;;;568        
;;;569        /* Clear all interrupt flags at correct offset within the register */
;;;570        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;571        
;;;572        /* Process Unlocked */
;;;573        __HAL_UNLOCK(hdma);
;;;574        
;;;575        /* Change the DMA state*/
;;;576        hdma->State = HAL_DMA_STATE_READY;
;;;577      }
;;;578      return HAL_OK;
;;;579    }
000024  bd70              POP      {r4-r6,pc}
                  |L4.38|
000026  6820              LDR      r0,[r4,#0]            ;539
000028  6800              LDR      r0,[r0,#0]            ;539
00002a  f0200016          BIC      r0,r0,#0x16           ;539
00002e  6821              LDR      r1,[r4,#0]            ;539
000030  6008              STR      r0,[r1,#0]            ;539
000032  6820              LDR      r0,[r4,#0]            ;540
000034  6940              LDR      r0,[r0,#0x14]         ;540
000036  f0200080          BIC      r0,r0,#0x80           ;540
00003a  6821              LDR      r1,[r4,#0]            ;540
00003c  6148              STR      r0,[r1,#0x14]         ;540
00003e  6c20              LDR      r0,[r4,#0x40]         ;542
000040  b908              CBNZ     r0,|L4.70|
000042  6ca0              LDR      r0,[r4,#0x48]         ;542
000044  b128              CBZ      r0,|L4.82|
                  |L4.70|
000046  6820              LDR      r0,[r4,#0]            ;544
000048  6800              LDR      r0,[r0,#0]            ;544
00004a  f0200008          BIC      r0,r0,#8              ;544
00004e  6821              LDR      r1,[r4,#0]            ;544
000050  6008              STR      r0,[r1,#0]            ;544
                  |L4.82|
000052  6820              LDR      r0,[r4,#0]            ;548
000054  6800              LDR      r0,[r0,#0]            ;548
000056  f0200001          BIC      r0,r0,#1              ;548
00005a  6821              LDR      r1,[r4,#0]            ;548
00005c  6008              STR      r0,[r1,#0]            ;548
00005e  e00f              B        |L4.128|
                  |L4.96|
000060  f7fffffe          BL       HAL_GetTick
000064  1b80              SUBS     r0,r0,r6              ;554
000066  2805              CMP      r0,#5                 ;554
000068  d90a              BLS      |L4.128|
00006a  2020              MOVS     r0,#0x20              ;557
00006c  6560              STR      r0,[r4,#0x54]         ;557
00006e  bf00              NOP                            ;560
000070  2000              MOVS     r0,#0                 ;560
000072  f8840034          STRB     r0,[r4,#0x34]         ;560
000076  bf00              NOP                            ;560
000078  2003              MOVS     r0,#3                 ;563
00007a  f8840035          STRB     r0,[r4,#0x35]         ;563
00007e  e7d1              B        |L4.36|
                  |L4.128|
000080  6820              LDR      r0,[r4,#0]            ;551
000082  6800              LDR      r0,[r0,#0]            ;551
000084  f0000001          AND      r0,r0,#1              ;551
000088  2800              CMP      r0,#0                 ;551
00008a  d1e9              BNE      |L4.96|
00008c  f894105c          LDRB     r1,[r4,#0x5c]         ;570
000090  203f              MOVS     r0,#0x3f              ;570
000092  4088              LSLS     r0,r0,r1              ;570
000094  60a8              STR      r0,[r5,#8]            ;570
000096  bf00              NOP                            ;573
000098  2000              MOVS     r0,#0                 ;573
00009a  f8840034          STRB     r0,[r4,#0x34]         ;573
00009e  bf00              NOP                            ;573
0000a0  2001              MOVS     r0,#1                 ;576
0000a2  f8840035          STRB     r0,[r4,#0x35]         ;576
0000a6  2000              MOVS     r0,#0                 ;578
0000a8  e7bc              B        |L4.36|
;;;580    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;586      */
;;;587    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;588    {
;;;589      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  f8910035          LDRB     r0,[r1,#0x35]
000006  2802              CMP      r0,#2
000008  d003              BEQ      |L5.18|
;;;590      {
;;;591        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000a  2080              MOVS     r0,#0x80
00000c  6548              STR      r0,[r1,#0x54]
;;;592        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L5.16|
;;;593      }
;;;594      else
;;;595      {
;;;596        /* Set Abort State  */
;;;597        hdma->State = HAL_DMA_STATE_ABORT;
;;;598        
;;;599        /* Disable the stream */
;;;600        __HAL_DMA_DISABLE(hdma);
;;;601      }
;;;602    
;;;603      return HAL_OK;
;;;604    }
000010  4770              BX       lr
                  |L5.18|
000012  2005              MOVS     r0,#5                 ;597
000014  f8810035          STRB     r0,[r1,#0x35]         ;597
000018  6808              LDR      r0,[r1,#0]            ;600
00001a  6800              LDR      r0,[r0,#0]            ;600
00001c  f0200001          BIC      r0,r0,#1              ;600
000020  680a              LDR      r2,[r1,#0]            ;600
000022  6010              STR      r0,[r2,#0]            ;600
000024  2000              MOVS     r0,#0                 ;603
000026  e7f3              B        |L5.16|
;;;605    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;325      */
;;;326    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328      DMA_Base_Registers *regs;
;;;329    
;;;330      /* Check the DMA peripheral state */
;;;331      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;332      {
;;;333        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;334      }
;;;335      
;;;336      /* Check the DMA peripheral state */
;;;337      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;338      {
;;;339        /* Return error status */
;;;340        return HAL_BUSY;
;;;341      }
;;;342    
;;;343      /* Disable the selected DMA Streamx */
;;;344      __HAL_DMA_DISABLE(hdma);
;;;345    
;;;346      /* Reset DMA Streamx control register */
;;;347      hdma->Instance->CR   = 0U;
;;;348    
;;;349      /* Reset DMA Streamx number of data to transfer register */
;;;350      hdma->Instance->NDTR = 0U;
;;;351    
;;;352      /* Reset DMA Streamx peripheral address register */
;;;353      hdma->Instance->PAR  = 0U;
;;;354    
;;;355      /* Reset DMA Streamx memory 0 address register */
;;;356      hdma->Instance->M0AR = 0U;
;;;357      
;;;358      /* Reset DMA Streamx memory 1 address register */
;;;359      hdma->Instance->M1AR = 0U;
;;;360      
;;;361      /* Reset DMA Streamx FIFO control register */
;;;362      hdma->Instance->FCR  = (uint32_t)0x00000021U;
;;;363      
;;;364      /* Get DMA steam Base Address */  
;;;365      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;366      
;;;367      /* Clear all interrupt flags at correct offset within the register */
;;;368      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;369    
;;;370      /* Initialize the error code */
;;;371      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;372    
;;;373      /* Initialize the DMA state */
;;;374      hdma->State = HAL_DMA_STATE_RESET;
;;;375    
;;;376      /* Release Lock */
;;;377      __HAL_UNLOCK(hdma);
;;;378    
;;;379      return HAL_OK;
;;;380    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  f8940035          LDRB     r0,[r4,#0x35]         ;337
00000e  2802              CMP      r0,#2                 ;337
000010  d100              BNE      |L6.20|
000012  e7f9              B        |L6.8|
                  |L6.20|
000014  6820              LDR      r0,[r4,#0]            ;344
000016  6800              LDR      r0,[r0,#0]            ;344
000018  f0200001          BIC      r0,r0,#1              ;344
00001c  6821              LDR      r1,[r4,#0]            ;344
00001e  6008              STR      r0,[r1,#0]            ;344
000020  2000              MOVS     r0,#0                 ;347
000022  6821              LDR      r1,[r4,#0]            ;347
000024  6008              STR      r0,[r1,#0]            ;347
000026  6821              LDR      r1,[r4,#0]            ;350
000028  6048              STR      r0,[r1,#4]            ;350
00002a  6821              LDR      r1,[r4,#0]            ;353
00002c  6088              STR      r0,[r1,#8]            ;353
00002e  6821              LDR      r1,[r4,#0]            ;356
000030  60c8              STR      r0,[r1,#0xc]          ;356
000032  6821              LDR      r1,[r4,#0]            ;359
000034  6108              STR      r0,[r1,#0x10]         ;359
000036  2021              MOVS     r0,#0x21              ;362
000038  6821              LDR      r1,[r4,#0]            ;362
00003a  6148              STR      r0,[r1,#0x14]         ;362
00003c  4620              MOV      r0,r4                 ;365
00003e  f7fffffe          BL       DMA_CalcBaseAndBitshift
000042  4605              MOV      r5,r0                 ;365
000044  f894105c          LDRB     r1,[r4,#0x5c]         ;368
000048  203f              MOVS     r0,#0x3f              ;368
00004a  4088              LSLS     r0,r0,r1              ;368
00004c  60a8              STR      r0,[r5,#8]            ;368
00004e  2000              MOVS     r0,#0                 ;371
000050  6560              STR      r0,[r4,#0x54]         ;371
000052  f8840035          STRB     r0,[r4,#0x35]         ;374
000056  bf00              NOP                            ;377
000058  f8840034          STRB     r0,[r4,#0x34]         ;377
00005c  bf00              NOP                            ;377
00005e  bf00              NOP                            ;379
000060  e7d2              B        |L6.8|
;;;381    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1129     */
;;;1130   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1131   {
;;;1132     return hdma->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;1133   }
000004  4770              BX       lr
;;;1134   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1118     */
;;;1119   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1120   {
;;;1121     return hdma->State;
000002  f8910035          LDRB     r0,[r1,#0x35]
;;;1122   }
000006  4770              BX       lr
;;;1123   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;752      */
;;;753    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;754    {
000002  4604              MOV      r4,r0
;;;755      uint32_t tmpisr;
;;;756      __IO uint32_t count = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;757      uint32_t timeout = SystemCoreClock / 9600;
000008  488d              LDR      r0,|L9.576|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f44f5116          MOV      r1,#0x2580
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;758    
;;;759      /* calculate DMA base and stream number */
;;;760      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000014  6da5              LDR      r5,[r4,#0x58]
;;;761    
;;;762      tmpisr = regs->ISR;
000016  682e              LDR      r6,[r5,#0]
;;;763    
;;;764      /* Transfer Error Interrupt management ***************************************/
;;;765      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000018  f894105c          LDRB     r1,[r4,#0x5c]
00001c  2008              MOVS     r0,#8
00001e  4088              LSLS     r0,r0,r1
000020  4030              ANDS     r0,r0,r6
000022  b198              CBZ      r0,|L9.76|
;;;766      {
;;;767        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f0000004          AND      r0,r0,#4
00002c  b170              CBZ      r0,|L9.76|
;;;768        {
;;;769          /* Disable the transfer error interrupt */
;;;770          hdma->Instance->CR  &= ~(DMA_IT_TE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;771          
;;;772          /* Clear the transfer error flag */
;;;773          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003a  f894105c          LDRB     r1,[r4,#0x5c]
00003e  2008              MOVS     r0,#8
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;774          
;;;775          /* Update error code */
;;;776          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400001          ORR      r0,r0,#1
00004a  6560              STR      r0,[r4,#0x54]
                  |L9.76|
;;;777        }
;;;778      }
;;;779      /* FIFO Error Interrupt management ******************************************/
;;;780      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f894105c          LDRB     r1,[r4,#0x5c]
000050  487c              LDR      r0,|L9.580|
000052  4088              LSLS     r0,r0,r1
000054  4030              ANDS     r0,r0,r6
000056  b168              CBZ      r0,|L9.116|
;;;781      {
;;;782        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000058  6820              LDR      r0,[r4,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  f0000080          AND      r0,r0,#0x80
000060  b140              CBZ      r0,|L9.116|
;;;783        {
;;;784          /* Clear the FIFO error flag */
;;;785          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000062  f894105c          LDRB     r1,[r4,#0x5c]
000066  4877              LDR      r0,|L9.580|
000068  4088              LSLS     r0,r0,r1
00006a  60a8              STR      r0,[r5,#8]
;;;786    
;;;787          /* Update error code */
;;;788          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006c  6d60              LDR      r0,[r4,#0x54]
00006e  f0400002          ORR      r0,r0,#2
000072  6560              STR      r0,[r4,#0x54]
                  |L9.116|
;;;789        }
;;;790      }
;;;791      /* Direct Mode Error Interrupt management ***********************************/
;;;792      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000074  f894105c          LDRB     r1,[r4,#0x5c]
000078  4872              LDR      r0,|L9.580|
00007a  1cc0              ADDS     r0,r0,#3
00007c  4088              LSLS     r0,r0,r1
00007e  4030              ANDS     r0,r0,r6
000080  b170              CBZ      r0,|L9.160|
;;;793      {
;;;794        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
000082  6820              LDR      r0,[r4,#0]
000084  6800              LDR      r0,[r0,#0]
000086  f0000002          AND      r0,r0,#2
00008a  b148              CBZ      r0,|L9.160|
;;;795        {
;;;796          /* Clear the direct mode error flag */
;;;797          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
00008c  f894105c          LDRB     r1,[r4,#0x5c]
000090  486c              LDR      r0,|L9.580|
000092  1cc0              ADDS     r0,r0,#3
000094  4088              LSLS     r0,r0,r1
000096  60a8              STR      r0,[r5,#8]
;;;798    
;;;799          /* Update error code */
;;;800          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000098  6d60              LDR      r0,[r4,#0x54]
00009a  f0400004          ORR      r0,r0,#4
00009e  6560              STR      r0,[r4,#0x54]
                  |L9.160|
;;;801        }
;;;802      }
;;;803      /* Half Transfer Complete Interrupt management ******************************/
;;;804      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
0000a0  f894105c          LDRB     r1,[r4,#0x5c]
0000a4  2010              MOVS     r0,#0x10
0000a6  4088              LSLS     r0,r0,r1
0000a8  4030              ANDS     r0,r0,r6
0000aa  b378              CBZ      r0,|L9.268|
;;;805      {
;;;806        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
0000ac  6820              LDR      r0,[r4,#0]
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f0000008          AND      r0,r0,#8
0000b4  b350              CBZ      r0,|L9.268|
;;;807        {
;;;808          /* Clear the half transfer complete flag */
;;;809          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000b6  f894105c          LDRB     r1,[r4,#0x5c]
0000ba  2010              MOVS     r0,#0x10
0000bc  4088              LSLS     r0,r0,r1
0000be  60a8              STR      r0,[r5,#8]
;;;810          
;;;811          /* Multi_Buffering mode enabled */
;;;812          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6800              LDR      r0,[r0,#0]
0000c4  f4002080          AND      r0,r0,#0x40000
0000c8  b180              CBZ      r0,|L9.236|
;;;813          {
;;;814            /* Current memory buffer used is Memory 0 */
;;;815            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f4002000          AND      r0,r0,#0x80000
0000d2  b928              CBNZ     r0,|L9.224|
;;;816            {
;;;817              if(hdma->XferHalfCpltCallback != NULL)
0000d4  6c20              LDR      r0,[r4,#0x40]
0000d6  b1c8              CBZ      r0,|L9.268|
;;;818              {
;;;819                /* Half transfer callback */
;;;820                hdma->XferHalfCpltCallback(hdma);
0000d8  4620              MOV      r0,r4
0000da  6c21              LDR      r1,[r4,#0x40]
0000dc  4788              BLX      r1
0000de  e015              B        |L9.268|
                  |L9.224|
;;;821              }
;;;822            }
;;;823            /* Current memory buffer used is Memory 1 */
;;;824            else
;;;825            {
;;;826              if(hdma->XferM1HalfCpltCallback != NULL)
0000e0  6ca0              LDR      r0,[r4,#0x48]
0000e2  b198              CBZ      r0,|L9.268|
;;;827              {
;;;828                /* Half transfer callback */
;;;829                hdma->XferM1HalfCpltCallback(hdma);
0000e4  4620              MOV      r0,r4
0000e6  6ca1              LDR      r1,[r4,#0x48]
0000e8  4788              BLX      r1
0000ea  e00f              B        |L9.268|
                  |L9.236|
;;;830              }
;;;831            }
;;;832          }
;;;833          else
;;;834          {
;;;835            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;836            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000ec  6820              LDR      r0,[r4,#0]
0000ee  6800              LDR      r0,[r0,#0]
0000f0  f4007080          AND      r0,r0,#0x100
0000f4  b928              CBNZ     r0,|L9.258|
;;;837            {
;;;838              /* Disable the half transfer interrupt */
;;;839              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000f6  6820              LDR      r0,[r4,#0]
0000f8  6800              LDR      r0,[r0,#0]
0000fa  f0200008          BIC      r0,r0,#8
0000fe  6821              LDR      r1,[r4,#0]
000100  6008              STR      r0,[r1,#0]
                  |L9.258|
;;;840            }
;;;841            
;;;842            if(hdma->XferHalfCpltCallback != NULL)
000102  6c20              LDR      r0,[r4,#0x40]
000104  b110              CBZ      r0,|L9.268|
;;;843            {
;;;844              /* Half transfer callback */
;;;845              hdma->XferHalfCpltCallback(hdma);
000106  4620              MOV      r0,r4
000108  6c21              LDR      r1,[r4,#0x40]
00010a  4788              BLX      r1
                  |L9.268|
;;;846            }
;;;847          }
;;;848        }
;;;849      }
;;;850      /* Transfer Complete Interrupt management ***********************************/
;;;851      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
00010c  f894105c          LDRB     r1,[r4,#0x5c]
000110  2020              MOVS     r0,#0x20
000112  4088              LSLS     r0,r0,r1
000114  4030              ANDS     r0,r0,r6
000116  2800              CMP      r0,#0
000118  d065              BEQ      |L9.486|
;;;852      {
;;;853        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
00011a  6820              LDR      r0,[r4,#0]
00011c  6800              LDR      r0,[r0,#0]
00011e  f0000010          AND      r0,r0,#0x10
000122  2800              CMP      r0,#0
000124  d05f              BEQ      |L9.486|
;;;854        {
;;;855          /* Clear the transfer complete flag */
;;;856          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000126  f894105c          LDRB     r1,[r4,#0x5c]
00012a  2020              MOVS     r0,#0x20
00012c  4088              LSLS     r0,r0,r1
00012e  60a8              STR      r0,[r5,#8]
;;;857          
;;;858          if(HAL_DMA_STATE_ABORT == hdma->State)
000130  f8940035          LDRB     r0,[r4,#0x35]
000134  2805              CMP      r0,#5
000136  d128              BNE      |L9.394|
;;;859          {
;;;860            /* Disable all the transfer interrupts */
;;;861            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
000138  6820              LDR      r0,[r4,#0]
00013a  6800              LDR      r0,[r0,#0]
00013c  f0200016          BIC      r0,r0,#0x16
000140  6821              LDR      r1,[r4,#0]
000142  6008              STR      r0,[r1,#0]
;;;862            hdma->Instance->FCR &= ~(DMA_IT_FE);
000144  6820              LDR      r0,[r4,#0]
000146  6940              LDR      r0,[r0,#0x14]
000148  f0200080          BIC      r0,r0,#0x80
00014c  6821              LDR      r1,[r4,#0]
00014e  6148              STR      r0,[r1,#0x14]
;;;863            
;;;864            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
000150  6c20              LDR      r0,[r4,#0x40]
000152  b908              CBNZ     r0,|L9.344|
000154  6ca0              LDR      r0,[r4,#0x48]
000156  b128              CBZ      r0,|L9.356|
                  |L9.344|
;;;865            {
;;;866              hdma->Instance->CR  &= ~(DMA_IT_HT);
000158  6820              LDR      r0,[r4,#0]
00015a  6800              LDR      r0,[r0,#0]
00015c  f0200008          BIC      r0,r0,#8
000160  6821              LDR      r1,[r4,#0]
000162  6008              STR      r0,[r1,#0]
                  |L9.356|
;;;867            }
;;;868    
;;;869            /* Clear all interrupt flags at correct offset within the register */
;;;870            regs->IFCR = 0x3FU << hdma->StreamIndex;
000164  f894105c          LDRB     r1,[r4,#0x5c]
000168  203f              MOVS     r0,#0x3f
00016a  4088              LSLS     r0,r0,r1
00016c  60a8              STR      r0,[r5,#8]
;;;871    
;;;872            /* Process Unlocked */
;;;873            __HAL_UNLOCK(hdma);
00016e  bf00              NOP      
000170  2000              MOVS     r0,#0
000172  f8840034          STRB     r0,[r4,#0x34]
000176  bf00              NOP      
;;;874             
;;;875            /* Change the DMA state */
;;;876            hdma->State = HAL_DMA_STATE_READY;
000178  2001              MOVS     r0,#1
00017a  f8840035          STRB     r0,[r4,#0x35]
;;;877    	
;;;878            if(hdma->XferAbortCallback != NULL)
00017e  6d20              LDR      r0,[r4,#0x50]
000180  b110              CBZ      r0,|L9.392|
;;;879            {
;;;880              hdma->XferAbortCallback(hdma);
000182  4620              MOV      r0,r4
000184  6d21              LDR      r1,[r4,#0x50]
000186  4788              BLX      r1
                  |L9.392|
;;;881            }
;;;882            return;
;;;883          }
;;;884          
;;;885          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
;;;886          {
;;;887            /* Current memory buffer used is Memory 0 */
;;;888            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
;;;889            {
;;;890              if(hdma->XferM1CpltCallback != NULL)
;;;891              {
;;;892                /* Transfer complete Callback for memory1 */
;;;893                hdma->XferM1CpltCallback(hdma);
;;;894              }
;;;895            }
;;;896            /* Current memory buffer used is Memory 1 */
;;;897            else
;;;898            {
;;;899              if(hdma->XferCpltCallback != NULL)
;;;900              {
;;;901                /* Transfer complete Callback for memory0 */
;;;902                hdma->XferCpltCallback(hdma);
;;;903              }
;;;904            }
;;;905          }
;;;906          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;907          else
;;;908          {
;;;909            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;910            {
;;;911              /* Disable the transfer complete interrupt */
;;;912              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;913    
;;;914              /* Process Unlocked */
;;;915              __HAL_UNLOCK(hdma);
;;;916              
;;;917              /* Change the DMA state */
;;;918              hdma->State = HAL_DMA_STATE_READY;
;;;919            }
;;;920            
;;;921            if(hdma->XferCpltCallback != NULL)
;;;922            {
;;;923              /* Transfer complete callback */
;;;924              hdma->XferCpltCallback(hdma);
;;;925            }
;;;926          }
;;;927        }
;;;928      }
;;;929      
;;;930      /* manage error case */
;;;931      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;932      {
;;;933        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;934        {
;;;935          hdma->State = HAL_DMA_STATE_ABORT;
;;;936          
;;;937          /* Disable the stream */
;;;938          __HAL_DMA_DISABLE(hdma);
;;;939          
;;;940          do
;;;941          {
;;;942            if (++count > timeout)
;;;943            {
;;;944              break;
;;;945            }
;;;946          }
;;;947          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;948    
;;;949          /* Process Unlocked */
;;;950          __HAL_UNLOCK(hdma);
;;;951    
;;;952          /* Change the DMA state */
;;;953          hdma->State = HAL_DMA_STATE_READY;
;;;954        }
;;;955        
;;;956        if(hdma->XferErrorCallback != NULL)
;;;957        {
;;;958          /* Transfer error callback */
;;;959          hdma->XferErrorCallback(hdma);
;;;960        }
;;;961      }
;;;962    }
000188  bdf8              POP      {r3-r7,pc}
                  |L9.394|
00018a  6820              LDR      r0,[r4,#0]            ;885
00018c  6800              LDR      r0,[r0,#0]            ;885
00018e  f4002080          AND      r0,r0,#0x40000        ;885
000192  b180              CBZ      r0,|L9.438|
000194  6820              LDR      r0,[r4,#0]            ;888
000196  6800              LDR      r0,[r0,#0]            ;888
000198  f4002000          AND      r0,r0,#0x80000        ;888
00019c  b928              CBNZ     r0,|L9.426|
00019e  6c60              LDR      r0,[r4,#0x44]         ;890
0001a0  b110              CBZ      r0,|L9.424|
0001a2  4620              MOV      r0,r4                 ;893
0001a4  6c61              LDR      r1,[r4,#0x44]         ;893
0001a6  4788              BLX      r1                    ;893
                  |L9.424|
0001a8  e01d              B        |L9.486|
                  |L9.426|
0001aa  6be0              LDR      r0,[r4,#0x3c]         ;899
0001ac  b1d8              CBZ      r0,|L9.486|
0001ae  4620              MOV      r0,r4                 ;902
0001b0  6be1              LDR      r1,[r4,#0x3c]         ;902
0001b2  4788              BLX      r1                    ;902
0001b4  e017              B        |L9.486|
                  |L9.438|
0001b6  6820              LDR      r0,[r4,#0]            ;909
0001b8  6800              LDR      r0,[r0,#0]            ;909
0001ba  f4007080          AND      r0,r0,#0x100          ;909
0001be  b968              CBNZ     r0,|L9.476|
0001c0  6820              LDR      r0,[r4,#0]            ;912
0001c2  6800              LDR      r0,[r0,#0]            ;912
0001c4  f0200010          BIC      r0,r0,#0x10           ;912
0001c8  6821              LDR      r1,[r4,#0]            ;912
0001ca  6008              STR      r0,[r1,#0]            ;912
0001cc  bf00              NOP                            ;915
0001ce  2000              MOVS     r0,#0                 ;915
0001d0  f8840034          STRB     r0,[r4,#0x34]         ;915
0001d4  bf00              NOP                            ;915
0001d6  2001              MOVS     r0,#1                 ;918
0001d8  f8840035          STRB     r0,[r4,#0x35]         ;918
                  |L9.476|
0001dc  6be0              LDR      r0,[r4,#0x3c]         ;921
0001de  b110              CBZ      r0,|L9.486|
0001e0  4620              MOV      r0,r4                 ;924
0001e2  6be1              LDR      r1,[r4,#0x3c]         ;924
0001e4  4788              BLX      r1                    ;924
                  |L9.486|
0001e6  6d60              LDR      r0,[r4,#0x54]         ;931
0001e8  b338              CBZ      r0,|L9.570|
0001ea  6d60              LDR      r0,[r4,#0x54]         ;933
0001ec  f0000001          AND      r0,r0,#1              ;933
0001f0  b1f0              CBZ      r0,|L9.560|
0001f2  2005              MOVS     r0,#5                 ;935
0001f4  f8840035          STRB     r0,[r4,#0x35]         ;935
0001f8  6820              LDR      r0,[r4,#0]            ;938
0001fa  6800              LDR      r0,[r0,#0]            ;938
0001fc  f0200001          BIC      r0,r0,#1              ;938
000200  6821              LDR      r1,[r4,#0]            ;938
000202  6008              STR      r0,[r1,#0]            ;938
000204  bf00              NOP                            ;940
                  |L9.518|
000206  9800              LDR      r0,[sp,#0]            ;942
000208  1c40              ADDS     r0,r0,#1              ;942
00020a  9000              STR      r0,[sp,#0]            ;942
00020c  42b8              CMP      r0,r7                 ;942
00020e  d900              BLS      |L9.530|
000210  e005              B        |L9.542|
                  |L9.530|
000212  6820              LDR      r0,[r4,#0]            ;947
000214  6800              LDR      r0,[r0,#0]            ;947
000216  f0000001          AND      r0,r0,#1              ;947
00021a  2800              CMP      r0,#0                 ;947
00021c  d1f3              BNE      |L9.518|
                  |L9.542|
00021e  bf00              NOP                            ;944
000220  bf00              NOP                            ;950
000222  2000              MOVS     r0,#0                 ;950
000224  f8840034          STRB     r0,[r4,#0x34]         ;950
000228  bf00              NOP                            ;950
00022a  2001              MOVS     r0,#1                 ;953
00022c  f8840035          STRB     r0,[r4,#0x35]         ;953
                  |L9.560|
000230  6ce0              LDR      r0,[r4,#0x4c]         ;956
000232  b110              CBZ      r0,|L9.570|
000234  4620              MOV      r0,r4                 ;959
000236  6ce1              LDR      r1,[r4,#0x4c]         ;959
000238  4788              BLX      r1                    ;959
                  |L9.570|
00023a  bf00              NOP      
00023c  e7a4              B        |L9.392|
;;;963    
                          ENDP

00023e  0000              DCW      0x0000
                  |L9.576|
                          DCD      SystemCoreClock
                  |L9.580|
                          DCD      0x00800001

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;191      */
;;;192    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;193    {
000004  4604              MOV      r4,r0
;;;194      uint32_t tmp = 0U;
000006  2500              MOVS     r5,#0
;;;195      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;196      DMA_Base_Registers *regs;
;;;197    
;;;198      /* Check the DMA peripheral state */
;;;199      if(hdma == NULL)
00000e  b914              CBNZ     r4,|L10.22|
;;;200      {
;;;201        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;202      }
;;;203    
;;;204      /* Check the parameters */
;;;205      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;206      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;207      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;208      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;209      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;210      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;211      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;212      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;213      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;214      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;215      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;216         when FIFO mode is enabled */
;;;217      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;218      {
;;;219        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;220        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;221        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;222      }
;;;223      
;;;224      /* Allocate lock resource */
;;;225      __HAL_UNLOCK(hdma);
;;;226    
;;;227      /* Change DMA peripheral state */
;;;228      hdma->State = HAL_DMA_STATE_BUSY;
;;;229      
;;;230      /* Disable the peripheral */
;;;231      __HAL_DMA_DISABLE(hdma);
;;;232      
;;;233      /* Check if the DMA Stream is effectively disabled */
;;;234      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;235      {
;;;236        /* Check for the Timeout */
;;;237        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;238        {
;;;239          /* Update error code */
;;;240          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;241          
;;;242          /* Change the DMA state */
;;;243          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;244          
;;;245          return HAL_TIMEOUT;
;;;246        }
;;;247      }
;;;248      
;;;249      /* Get the CR register value */
;;;250      tmp = hdma->Instance->CR;
;;;251    
;;;252      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;253      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;254                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;255                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;256                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;257    
;;;258      /* Prepare the DMA Stream configuration */
;;;259      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;260              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;261              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;262              hdma->Init.Mode                | hdma->Init.Priority;
;;;263    
;;;264      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;265      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;266      {
;;;267        /* Get memory burst and peripheral burst */
;;;268        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;269      }
;;;270      
;;;271      /* Write to DMA Stream CR register */
;;;272      hdma->Instance->CR = tmp;  
;;;273    
;;;274      /* Get the FCR register value */
;;;275      tmp = hdma->Instance->FCR;
;;;276    
;;;277      /* Clear Direct mode and FIFO threshold bits */
;;;278      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;279    
;;;280      /* Prepare the DMA Stream FIFO configuration */
;;;281      tmp |= hdma->Init.FIFOMode;
;;;282    
;;;283      /* the FIFO threshold is not used when the FIFO mode is disabled */
;;;284      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;285      {
;;;286        /* Get the FIFO threshold */
;;;287        tmp |= hdma->Init.FIFOThreshold;
;;;288        
;;;289        if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;290        {
;;;291          /* Update error code */
;;;292          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;293          
;;;294          /* Change the DMA state */
;;;295          hdma->State = HAL_DMA_STATE_READY;
;;;296          
;;;297          return HAL_ERROR; 
;;;298        }
;;;299      }
;;;300      
;;;301      /* Write to DMA Stream FCR */
;;;302      hdma->Instance->FCR = tmp;
;;;303    
;;;304      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;305         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;306      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;307      
;;;308      /* Clear all interrupt flags */
;;;309      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;310    
;;;311      /* Initialize the error code */
;;;312      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;313                                                                                         
;;;314      /* Initialize the DMA state */
;;;315      hdma->State = HAL_DMA_STATE_READY;
;;;316    
;;;317      return HAL_OK;
;;;318    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L10.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;217
000018  b100              CBZ      r0,|L10.28|
00001a  bf00              NOP                            ;221
                  |L10.28|
00001c  bf00              NOP                            ;225
00001e  2000              MOVS     r0,#0                 ;225
000020  f8840034          STRB     r0,[r4,#0x34]         ;225
000024  bf00              NOP                            ;225
000026  2002              MOVS     r0,#2                 ;228
000028  f8840035          STRB     r0,[r4,#0x35]         ;228
00002c  6820              LDR      r0,[r4,#0]            ;231
00002e  6800              LDR      r0,[r0,#0]            ;231
000030  f0200001          BIC      r0,r0,#1              ;231
000034  6821              LDR      r1,[r4,#0]            ;231
000036  6008              STR      r0,[r1,#0]            ;231
000038  e00a              B        |L10.80|
                  |L10.58|
00003a  f7fffffe          BL       HAL_GetTick
00003e  1bc0              SUBS     r0,r0,r7              ;237
000040  2805              CMP      r0,#5                 ;237
000042  d905              BLS      |L10.80|
000044  2020              MOVS     r0,#0x20              ;240
000046  6560              STR      r0,[r4,#0x54]         ;240
000048  2003              MOVS     r0,#3                 ;243
00004a  f8840035          STRB     r0,[r4,#0x35]         ;243
00004e  e7e0              B        |L10.18|
                  |L10.80|
000050  6820              LDR      r0,[r4,#0]            ;234
000052  6800              LDR      r0,[r0,#0]            ;234
000054  f0000001          AND      r0,r0,#1              ;234
000058  2800              CMP      r0,#0                 ;234
00005a  d1ee              BNE      |L10.58|
00005c  6820              LDR      r0,[r4,#0]            ;250
00005e  6805              LDR      r5,[r0,#0]            ;250
000060  4820              LDR      r0,|L10.228|
000062  4005              ANDS     r5,r5,r0              ;253
000064  e9d40101          LDRD     r0,r1,[r4,#4]         ;259
000068  4308              ORRS     r0,r0,r1              ;259
00006a  68e1              LDR      r1,[r4,#0xc]          ;259
00006c  4308              ORRS     r0,r0,r1              ;259
00006e  6921              LDR      r1,[r4,#0x10]         ;259
000070  4308              ORRS     r0,r0,r1              ;259
000072  6961              LDR      r1,[r4,#0x14]         ;259
000074  4308              ORRS     r0,r0,r1              ;259
000076  69a1              LDR      r1,[r4,#0x18]         ;259
000078  4308              ORRS     r0,r0,r1              ;259
00007a  69e1              LDR      r1,[r4,#0x1c]         ;259
00007c  4308              ORRS     r0,r0,r1              ;259
00007e  6a21              LDR      r1,[r4,#0x20]         ;259
000080  4308              ORRS     r0,r0,r1              ;259
000082  4305              ORRS     r5,r5,r0              ;259
000084  6a60              LDR      r0,[r4,#0x24]         ;265
000086  2804              CMP      r0,#4                 ;265
000088  d103              BNE      |L10.146|
00008a  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;268
00008e  4308              ORRS     r0,r0,r1              ;268
000090  4305              ORRS     r5,r5,r0              ;268
                  |L10.146|
000092  6820              LDR      r0,[r4,#0]            ;272
000094  6005              STR      r5,[r0,#0]            ;272
000096  6820              LDR      r0,[r4,#0]            ;275
000098  6945              LDR      r5,[r0,#0x14]         ;275
00009a  f0250507          BIC      r5,r5,#7              ;278
00009e  6a60              LDR      r0,[r4,#0x24]         ;281
0000a0  4305              ORRS     r5,r5,r0              ;281
0000a2  6a60              LDR      r0,[r4,#0x24]         ;284
0000a4  2804              CMP      r0,#4                 ;284
0000a6  d10b              BNE      |L10.192|
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;287
0000aa  4305              ORRS     r5,r5,r0              ;287
0000ac  4620              MOV      r0,r4                 ;289
0000ae  f7fffffe          BL       DMA_CheckFifoParam
0000b2  b128              CBZ      r0,|L10.192|
0000b4  2040              MOVS     r0,#0x40              ;292
0000b6  6560              STR      r0,[r4,#0x54]         ;292
0000b8  2001              MOVS     r0,#1                 ;295
0000ba  f8840035          STRB     r0,[r4,#0x35]         ;295
0000be  e7a8              B        |L10.18|
                  |L10.192|
0000c0  6820              LDR      r0,[r4,#0]            ;302
0000c2  6145              STR      r5,[r0,#0x14]         ;302
0000c4  4620              MOV      r0,r4                 ;306
0000c6  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000ca  4606              MOV      r6,r0                 ;306
0000cc  f894105c          LDRB     r1,[r4,#0x5c]         ;309
0000d0  203f              MOVS     r0,#0x3f              ;309
0000d2  4088              LSLS     r0,r0,r1              ;309
0000d4  60b0              STR      r0,[r6,#8]            ;309
0000d6  2000              MOVS     r0,#0                 ;312
0000d8  6560              STR      r0,[r4,#0x54]         ;312
0000da  2001              MOVS     r0,#1                 ;315
0000dc  f8840035          STRB     r0,[r4,#0x35]         ;315
0000e0  2000              MOVS     r0,#0                 ;317
0000e2  e796              B        |L10.18|
;;;319    
                          ENDP

                  |L10.228|
                          DCD      0xe010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=2

                  HAL_DMA_PollForTransfer PROC
;;;616      */
;;;617    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;618    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;619      HAL_StatusTypeDef status = HAL_OK; 
00000a  f04f0a00          MOV      r10,#0
;;;620      uint32_t mask_cpltlevel;
;;;621      uint32_t tickstart = HAL_GetTick(); 
00000e  f7fffffe          BL       HAL_GetTick
000012  4683              MOV      r11,r0
;;;622      uint32_t tmpisr;
;;;623      
;;;624      /* calculate DMA base and stream number */
;;;625      DMA_Base_Registers *regs;
;;;626      
;;;627      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  f8940035          LDRB     r0,[r4,#0x35]
000018  2802              CMP      r0,#2
00001a  d009              BEQ      |L11.48|
;;;628      {
;;;629        /* No transfer ongoing */
;;;630        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001c  2080              MOVS     r0,#0x80
00001e  6560              STR      r0,[r4,#0x54]
;;;631        __HAL_UNLOCK(hdma);
000020  bf00              NOP      
000022  2000              MOVS     r0,#0
000024  f8840034          STRB     r0,[r4,#0x34]
000028  bf00              NOP      
;;;632        return HAL_ERROR;
00002a  2001              MOVS     r0,#1
                  |L11.44|
;;;633      }
;;;634      
;;;635      /* Polling mode not supported in circular mode and double buffering mode */
;;;636      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;637      {
;;;638        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;639        return HAL_ERROR;
;;;640      }
;;;641      
;;;642      /* Get the level transfer complete flag */
;;;643      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;644      {
;;;645        /* Transfer Complete flag */
;;;646        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;647      }
;;;648      else
;;;649      {
;;;650        /* Half Transfer Complete flag */
;;;651        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;652      }
;;;653      
;;;654      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;655      tmpisr = regs->ISR;
;;;656      
;;;657      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;658      {
;;;659        /* Check for the Timeout (Not applicable in circular mode)*/
;;;660        if(Timeout != HAL_MAX_DELAY)
;;;661        {
;;;662          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;663          {
;;;664            /* Update error code */
;;;665            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;666    
;;;667            /* Process Unlocked */
;;;668            __HAL_UNLOCK(hdma);
;;;669            
;;;670            /* Change the DMA state */
;;;671            hdma->State = HAL_DMA_STATE_READY;
;;;672            
;;;673            return HAL_TIMEOUT;
;;;674          }
;;;675        }
;;;676        
;;;677        /* Get the ISR register value */
;;;678        tmpisr = regs->ISR;
;;;679        
;;;680        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;681        {
;;;682          /* Update error code */
;;;683          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;684          
;;;685          /* Clear the transfer error flag */
;;;686          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;687        }
;;;688        
;;;689        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;690        {
;;;691          /* Update error code */
;;;692          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;693          
;;;694          /* Clear the FIFO error flag */
;;;695          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;696        }
;;;697        
;;;698        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;699        {
;;;700          /* Update error code */
;;;701          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;702          
;;;703          /* Clear the Direct Mode error flag */
;;;704          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;705        }
;;;706      }
;;;707      
;;;708      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;709      {
;;;710        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;711        {
;;;712          HAL_DMA_Abort(hdma);
;;;713        
;;;714          /* Clear the half transfer and transfer complete flags */
;;;715          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;716        
;;;717          /* Process Unlocked */
;;;718          __HAL_UNLOCK(hdma);
;;;719    
;;;720          /* Change the DMA state */
;;;721          hdma->State= HAL_DMA_STATE_READY;
;;;722    
;;;723          return HAL_ERROR;
;;;724       }
;;;725      }
;;;726      
;;;727      /* Get the level transfer complete flag */
;;;728      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;729      {
;;;730        /* Clear the half transfer and transfer complete flags */
;;;731        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;732        
;;;733        /* Process Unlocked */
;;;734        __HAL_UNLOCK(hdma);
;;;735    
;;;736        hdma->State = HAL_DMA_STATE_READY;
;;;737      }
;;;738      else
;;;739      {
;;;740        /* Clear the half transfer and transfer complete flags */
;;;741        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;742      }
;;;743      
;;;744      return status;
;;;745    }
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.48|
000030  6820              LDR      r0,[r4,#0]            ;636
000032  6800              LDR      r0,[r0,#0]            ;636
000034  f4007080          AND      r0,r0,#0x100          ;636
000038  b120              CBZ      r0,|L11.68|
00003a  f44f7080          MOV      r0,#0x100             ;638
00003e  6560              STR      r0,[r4,#0x54]         ;638
000040  2001              MOVS     r0,#1                 ;639
000042  e7f3              B        |L11.44|
                  |L11.68|
000044  f1b80f00          CMP      r8,#0                 ;643
000048  d105              BNE      |L11.86|
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;646
00004e  2020              MOVS     r0,#0x20              ;646
000050  fa00f901          LSL      r9,r0,r1              ;646
000054  e004              B        |L11.96|
                  |L11.86|
000056  f894105c          LDRB     r1,[r4,#0x5c]         ;651
00005a  2010              MOVS     r0,#0x10              ;651
00005c  fa00f901          LSL      r9,r0,r1              ;651
                  |L11.96|
000060  6da5              LDR      r5,[r4,#0x58]         ;654
000062  682e              LDR      r6,[r5,#0]            ;655
000064  e044              B        |L11.240|
                  |L11.102|
000066  1c78              ADDS     r0,r7,#1              ;660
000068  b190              CBZ      r0,|L11.144|
00006a  b12f              CBZ      r7,|L11.120|
00006c  f7fffffe          BL       HAL_GetTick
000070  eba0000b          SUB      r0,r0,r11             ;662
000074  42b8              CMP      r0,r7                 ;662
000076  d90b              BLS      |L11.144|
                  |L11.120|
000078  2020              MOVS     r0,#0x20              ;665
00007a  6560              STR      r0,[r4,#0x54]         ;665
00007c  bf00              NOP                            ;668
00007e  2000              MOVS     r0,#0                 ;668
000080  f8840034          STRB     r0,[r4,#0x34]         ;668
000084  bf00              NOP                            ;668
000086  2001              MOVS     r0,#1                 ;671
000088  f8840035          STRB     r0,[r4,#0x35]         ;671
00008c  2003              MOVS     r0,#3                 ;673
00008e  e7cd              B        |L11.44|
                  |L11.144|
000090  682e              LDR      r6,[r5,#0]            ;678
000092  f894105c          LDRB     r1,[r4,#0x5c]         ;680
000096  2008              MOVS     r0,#8                 ;680
000098  4088              LSLS     r0,r0,r1              ;680
00009a  4030              ANDS     r0,r0,r6              ;680
00009c  b140              CBZ      r0,|L11.176|
00009e  6d60              LDR      r0,[r4,#0x54]         ;683
0000a0  f0400001          ORR      r0,r0,#1              ;683
0000a4  6560              STR      r0,[r4,#0x54]         ;683
0000a6  f894105c          LDRB     r1,[r4,#0x5c]         ;686
0000aa  2008              MOVS     r0,#8                 ;686
0000ac  4088              LSLS     r0,r0,r1              ;686
0000ae  60a8              STR      r0,[r5,#8]            ;686
                  |L11.176|
0000b0  f894105c          LDRB     r1,[r4,#0x5c]         ;689
0000b4  482a              LDR      r0,|L11.352|
0000b6  4088              LSLS     r0,r0,r1              ;689
0000b8  4030              ANDS     r0,r0,r6              ;689
0000ba  b140              CBZ      r0,|L11.206|
0000bc  6d60              LDR      r0,[r4,#0x54]         ;692
0000be  f0400002          ORR      r0,r0,#2              ;692
0000c2  6560              STR      r0,[r4,#0x54]         ;692
0000c4  f894105c          LDRB     r1,[r4,#0x5c]         ;695
0000c8  4825              LDR      r0,|L11.352|
0000ca  4088              LSLS     r0,r0,r1              ;695
0000cc  60a8              STR      r0,[r5,#8]            ;695
                  |L11.206|
0000ce  f894105c          LDRB     r1,[r4,#0x5c]         ;698
0000d2  4823              LDR      r0,|L11.352|
0000d4  1cc0              ADDS     r0,r0,#3              ;698
0000d6  4088              LSLS     r0,r0,r1              ;698
0000d8  4030              ANDS     r0,r0,r6              ;698
0000da  b148              CBZ      r0,|L11.240|
0000dc  6d60              LDR      r0,[r4,#0x54]         ;701
0000de  f0400004          ORR      r0,r0,#4              ;701
0000e2  6560              STR      r0,[r4,#0x54]         ;701
0000e4  f894105c          LDRB     r1,[r4,#0x5c]         ;704
0000e8  481d              LDR      r0,|L11.352|
0000ea  1cc0              ADDS     r0,r0,#3              ;704
0000ec  4088              LSLS     r0,r0,r1              ;704
0000ee  60a8              STR      r0,[r5,#8]            ;704
                  |L11.240|
0000f0  ea060009          AND      r0,r6,r9              ;657
0000f4  b920              CBNZ     r0,|L11.256|
0000f6  6d60              LDR      r0,[r4,#0x54]         ;657
0000f8  f0000001          AND      r0,r0,#1              ;657
0000fc  2800              CMP      r0,#0                 ;657
0000fe  d0b2              BEQ      |L11.102|
                  |L11.256|
000100  6d60              LDR      r0,[r4,#0x54]         ;708
000102  b1a0              CBZ      r0,|L11.302|
000104  6d60              LDR      r0,[r4,#0x54]         ;710
000106  f0000001          AND      r0,r0,#1              ;710
00010a  b180              CBZ      r0,|L11.302|
00010c  4620              MOV      r0,r4                 ;712
00010e  f7fffffe          BL       HAL_DMA_Abort
000112  f894105c          LDRB     r1,[r4,#0x5c]         ;715
000116  2030              MOVS     r0,#0x30              ;715
000118  4088              LSLS     r0,r0,r1              ;715
00011a  60a8              STR      r0,[r5,#8]            ;715
00011c  bf00              NOP                            ;718
00011e  2000              MOVS     r0,#0                 ;718
000120  f8840034          STRB     r0,[r4,#0x34]         ;718
000124  bf00              NOP                            ;718
000126  2001              MOVS     r0,#1                 ;721
000128  f8840035          STRB     r0,[r4,#0x35]         ;721
00012c  e77e              B        |L11.44|
                  |L11.302|
00012e  f1b80f00          CMP      r8,#0                 ;728
000132  d10d              BNE      |L11.336|
000134  f894105c          LDRB     r1,[r4,#0x5c]         ;731
000138  2030              MOVS     r0,#0x30              ;731
00013a  4088              LSLS     r0,r0,r1              ;731
00013c  60a8              STR      r0,[r5,#8]            ;731
00013e  bf00              NOP                            ;734
000140  2000              MOVS     r0,#0                 ;734
000142  f8840034          STRB     r0,[r4,#0x34]         ;734
000146  bf00              NOP                            ;734
000148  2001              MOVS     r0,#1                 ;736
00014a  f8840035          STRB     r0,[r4,#0x35]         ;736
00014e  e004              B        |L11.346|
                  |L11.336|
000150  f894105c          LDRB     r1,[r4,#0x5c]         ;741
000154  2010              MOVS     r0,#0x10              ;741
000156  4088              LSLS     r0,r0,r1              ;741
000158  60a8              STR      r0,[r5,#8]            ;741
                  |L11.346|
00015a  4650              MOV      r0,r10                ;744
00015c  e766              B        |L11.44|
;;;746    
                          ENDP

00015e  0000              DCW      0x0000
                  |L11.352|
                          DCD      0x00800001

                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;973      */                      
;;;974    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b510              PUSH     {r4,lr}
;;;975    {
000002  4603              MOV      r3,r0
;;;976    
;;;977      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;978    
;;;979      /* Process locked */
;;;980      __HAL_LOCK(hdma);
000006  bf00              NOP      
000008  f8930034          LDRB     r0,[r3,#0x34]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L12.20|
000010  2002              MOVS     r0,#2
                  |L12.18|
;;;981    
;;;982      if(HAL_DMA_STATE_READY == hdma->State)
;;;983      {
;;;984        switch (CallbackID)
;;;985        {
;;;986        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;987          hdma->XferCpltCallback = pCallback;
;;;988          break;
;;;989          
;;;990        case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;991          hdma->XferHalfCpltCallback = pCallback;
;;;992          break;
;;;993          
;;;994        case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;995          hdma->XferM1CpltCallback = pCallback;
;;;996          break;
;;;997          
;;;998        case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;999          hdma->XferM1HalfCpltCallback = pCallback;
;;;1000         break;
;;;1001         
;;;1002       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1003         hdma->XferErrorCallback = pCallback;
;;;1004         break;
;;;1005         
;;;1006       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1007         hdma->XferAbortCallback = pCallback;
;;;1008         break;
;;;1009         
;;;1010       default:
;;;1011         break;
;;;1012       }
;;;1013     }
;;;1014     else
;;;1015     {
;;;1016       /* Return error status */
;;;1017       status =  HAL_ERROR;
;;;1018     }
;;;1019   
;;;1020     /* Release Lock */
;;;1021     __HAL_UNLOCK(hdma);
;;;1022     
;;;1023     return status;
;;;1024   }
000012  bd10              POP      {r4,pc}
                  |L12.20|
000014  2001              MOVS     r0,#1                 ;980
000016  f8830034          STRB     r0,[r3,#0x34]         ;980
00001a  bf00              NOP                            ;980
00001c  f8930035          LDRB     r0,[r3,#0x35]         ;982
000020  2801              CMP      r0,#1                 ;982
000022  d114              BNE      |L12.78|
000024  2906              CMP      r1,#6                 ;984
000026  d210              BCS      |L12.74|
000028  e8dff001          TBB      [pc,r1]               ;984
00002c  03050709          DCB      0x03,0x05,0x07,0x09
000030  0b0d              DCB      0x0b,0x0d
000032  63da              STR      r2,[r3,#0x3c]         ;987
000034  e00a              B        |L12.76|
000036  641a              STR      r2,[r3,#0x40]         ;991
000038  e008              B        |L12.76|
00003a  645a              STR      r2,[r3,#0x44]         ;995
00003c  e006              B        |L12.76|
00003e  649a              STR      r2,[r3,#0x48]         ;999
000040  e004              B        |L12.76|
000042  64da              STR      r2,[r3,#0x4c]         ;1003
000044  e002              B        |L12.76|
000046  651a              STR      r2,[r3,#0x50]         ;1007
000048  e000              B        |L12.76|
                  |L12.74|
00004a  bf00              NOP                            ;1011
                  |L12.76|
00004c  e000              B        |L12.80|
                  |L12.78|
00004e  2401              MOVS     r4,#1                 ;1017
                  |L12.80|
000050  bf00              NOP                            ;1021
000052  2000              MOVS     r0,#0                 ;1021
000054  f8830034          STRB     r0,[r3,#0x34]         ;1021
000058  bf00              NOP                            ;1021
00005a  4620              MOV      r0,r4                 ;1023
00005c  e7d9              B        |L12.18|
;;;1025   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;412      */
;;;413    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;414    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;415      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;416      
;;;417      /* Check the parameters */
;;;418      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;419    
;;;420      /* Process locked */
;;;421      __HAL_LOCK(hdma);
000010  bf00              NOP      
000012  f8940034          LDRB     r0,[r4,#0x34]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L13.32|
00001a  2002              MOVS     r0,#2
                  |L13.28|
;;;422    
;;;423      if(HAL_DMA_STATE_READY == hdma->State)
;;;424      {
;;;425        /* Change DMA peripheral state */
;;;426        hdma->State = HAL_DMA_STATE_BUSY;
;;;427        
;;;428        /* Initialize the error code */
;;;429        hdma->ErrorCode = HAL_DMA_ERROR_NONE;    
;;;430        
;;;431        /* Configure the source, destination address and the data length */
;;;432        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;433    
;;;434        /* Enable the Peripheral */
;;;435        __HAL_DMA_ENABLE(hdma);
;;;436      }
;;;437      else
;;;438      {
;;;439        /* Process unlocked */
;;;440        __HAL_UNLOCK(hdma);
;;;441        
;;;442        /* Return error status */
;;;443        status = HAL_BUSY;
;;;444      } 
;;;445      return status; 
;;;446    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.32|
000020  2001              MOVS     r0,#1                 ;421
000022  f8840034          STRB     r0,[r4,#0x34]         ;421
000026  bf00              NOP                            ;421
000028  f8940035          LDRB     r0,[r4,#0x35]         ;423
00002c  2801              CMP      r0,#1                 ;423
00002e  d111              BNE      |L13.84|
000030  2002              MOVS     r0,#2                 ;426
000032  f8840035          STRB     r0,[r4,#0x35]         ;426
000036  2000              MOVS     r0,#0                 ;429
000038  6560              STR      r0,[r4,#0x54]         ;429
00003a  463b              MOV      r3,r7                 ;432
00003c  4632              MOV      r2,r6                 ;432
00003e  4629              MOV      r1,r5                 ;432
000040  4620              MOV      r0,r4                 ;432
000042  f7fffffe          BL       DMA_SetConfig
000046  6820              LDR      r0,[r4,#0]            ;435
000048  6800              LDR      r0,[r0,#0]            ;435
00004a  f0400001          ORR      r0,r0,#1              ;435
00004e  6821              LDR      r1,[r4,#0]            ;435
000050  6008              STR      r0,[r1,#0]            ;435
000052  e006              B        |L13.98|
                  |L13.84|
000054  bf00              NOP                            ;440
000056  2000              MOVS     r0,#0                 ;440
000058  f8840034          STRB     r0,[r4,#0x34]         ;440
00005c  bf00              NOP                            ;440
00005e  f04f0802          MOV      r8,#2                 ;443
                  |L13.98|
000062  4640              MOV      r0,r8                 ;445
000064  e7da              B        |L13.28|
;;;447    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;456      */
;;;457    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;458    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;459      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;460    
;;;461      /* calculate DMA base and stream number */
;;;462      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000010  f8d49058          LDR      r9,[r4,#0x58]
;;;463      
;;;464      /* Check the parameters */
;;;465      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;466     
;;;467      /* Process locked */
;;;468      __HAL_LOCK(hdma);
000014  bf00              NOP      
000016  f8940034          LDRB     r0,[r4,#0x34]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L14.36|
00001e  2002              MOVS     r0,#2
                  |L14.32|
;;;469      
;;;470      if(HAL_DMA_STATE_READY == hdma->State)
;;;471      {
;;;472        /* Change DMA peripheral state */
;;;473        hdma->State = HAL_DMA_STATE_BUSY;
;;;474        
;;;475        /* Initialize the error code */
;;;476        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;477        
;;;478        /* Configure the source, destination address and the data length */
;;;479        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;480        
;;;481        /* Clear all interrupt flags at correct offset within the register */
;;;482        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;483        
;;;484        /* Enable Common interrupts*/
;;;485        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;486        hdma->Instance->FCR |= DMA_IT_FE;
;;;487        
;;;488        if(hdma->XferHalfCpltCallback != NULL)
;;;489        {
;;;490          hdma->Instance->CR  |= DMA_IT_HT;
;;;491        }
;;;492        
;;;493        /* Enable the Peripheral */
;;;494        __HAL_DMA_ENABLE(hdma);
;;;495      }
;;;496      else
;;;497      {
;;;498        /* Process unlocked */
;;;499        __HAL_UNLOCK(hdma);	  
;;;500        
;;;501        /* Return error status */
;;;502        status = HAL_BUSY;
;;;503      }
;;;504      
;;;505      return status;
;;;506    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L14.36|
000024  2001              MOVS     r0,#1                 ;468
000026  f8840034          STRB     r0,[r4,#0x34]         ;468
00002a  bf00              NOP                            ;468
00002c  f8940035          LDRB     r0,[r4,#0x35]         ;470
000030  2801              CMP      r0,#1                 ;470
000032  d12b              BNE      |L14.140|
000034  2002              MOVS     r0,#2                 ;473
000036  f8840035          STRB     r0,[r4,#0x35]         ;473
00003a  2000              MOVS     r0,#0                 ;476
00003c  6560              STR      r0,[r4,#0x54]         ;476
00003e  463b              MOV      r3,r7                 ;479
000040  4632              MOV      r2,r6                 ;479
000042  4629              MOV      r1,r5                 ;479
000044  4620              MOV      r0,r4                 ;479
000046  f7fffffe          BL       DMA_SetConfig
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;482
00004e  203f              MOVS     r0,#0x3f              ;482
000050  4088              LSLS     r0,r0,r1              ;482
000052  f8c90008          STR      r0,[r9,#8]            ;482
000056  6820              LDR      r0,[r4,#0]            ;485
000058  6800              LDR      r0,[r0,#0]            ;485
00005a  f0400016          ORR      r0,r0,#0x16           ;485
00005e  6821              LDR      r1,[r4,#0]            ;485
000060  6008              STR      r0,[r1,#0]            ;485
000062  6820              LDR      r0,[r4,#0]            ;486
000064  6940              LDR      r0,[r0,#0x14]         ;486
000066  f0400080          ORR      r0,r0,#0x80           ;486
00006a  6821              LDR      r1,[r4,#0]            ;486
00006c  6148              STR      r0,[r1,#0x14]         ;486
00006e  6c20              LDR      r0,[r4,#0x40]         ;488
000070  b128              CBZ      r0,|L14.126|
000072  6820              LDR      r0,[r4,#0]            ;490
000074  6800              LDR      r0,[r0,#0]            ;490
000076  f0400008          ORR      r0,r0,#8              ;490
00007a  6821              LDR      r1,[r4,#0]            ;490
00007c  6008              STR      r0,[r1,#0]            ;490
                  |L14.126|
00007e  6820              LDR      r0,[r4,#0]            ;494
000080  6800              LDR      r0,[r0,#0]            ;494
000082  f0400001          ORR      r0,r0,#1              ;494
000086  6821              LDR      r1,[r4,#0]            ;494
000088  6008              STR      r0,[r1,#0]            ;494
00008a  e006              B        |L14.154|
                  |L14.140|
00008c  bf00              NOP                            ;499
00008e  2000              MOVS     r0,#0                 ;499
000090  f8840034          STRB     r0,[r4,#0x34]         ;499
000094  bf00              NOP                            ;499
000096  f04f0802          MOV      r8,#2                 ;502
                  |L14.154|
00009a  4640              MOV      r0,r8                 ;505
00009c  e7c0              B        |L14.32|
;;;507    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1033     */              
;;;1034   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;1035   {
;;;1036     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1037     
;;;1038     /* Process locked */
;;;1039     __HAL_LOCK(hdma);
000004  bf00              NOP      
000006  f8920034          LDRB     r0,[r2,#0x34]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L15.18|
00000e  2002              MOVS     r0,#2
                  |L15.16|
;;;1040     
;;;1041     if(HAL_DMA_STATE_READY == hdma->State)
;;;1042     {
;;;1043       switch (CallbackID)
;;;1044       {
;;;1045       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1046         hdma->XferCpltCallback = NULL;
;;;1047         break;
;;;1048         
;;;1049       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1050         hdma->XferHalfCpltCallback = NULL;
;;;1051         break;
;;;1052         
;;;1053       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1054         hdma->XferM1CpltCallback = NULL;
;;;1055         break;
;;;1056         
;;;1057       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1058         hdma->XferM1HalfCpltCallback = NULL;
;;;1059         break;
;;;1060         
;;;1061       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1062         hdma->XferErrorCallback = NULL;
;;;1063         break;
;;;1064         
;;;1065       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1066         hdma->XferAbortCallback = NULL;
;;;1067         break; 
;;;1068         
;;;1069       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1070         hdma->XferCpltCallback = NULL;
;;;1071         hdma->XferHalfCpltCallback = NULL;
;;;1072         hdma->XferM1CpltCallback = NULL;
;;;1073         hdma->XferM1HalfCpltCallback = NULL;
;;;1074         hdma->XferErrorCallback = NULL;
;;;1075         hdma->XferAbortCallback = NULL;
;;;1076         break; 
;;;1077         
;;;1078       default:
;;;1079         status = HAL_ERROR;
;;;1080         break;
;;;1081       }
;;;1082     }
;;;1083     else
;;;1084     {
;;;1085       status = HAL_ERROR;
;;;1086     }
;;;1087     
;;;1088     /* Release Lock */
;;;1089     __HAL_UNLOCK(hdma);
;;;1090     
;;;1091     return status;
;;;1092   }
000010  4770              BX       lr
                  |L15.18|
000012  2001              MOVS     r0,#1                 ;1039
000014  f8820034          STRB     r0,[r2,#0x34]         ;1039
000018  bf00              NOP                            ;1039
00001a  f8920035          LDRB     r0,[r2,#0x35]         ;1041
00001e  2801              CMP      r0,#1                 ;1041
000020  d124              BNE      |L15.108|
000022  2907              CMP      r1,#7                 ;1043
000024  d21f              BCS      |L15.102|
000026  e8dff001          TBB      [pc,r1]               ;1043
00002a  0407              DCB      0x04,0x07
00002c  0a0d1013          DCB      0x0a,0x0d,0x10,0x13
000030  1600              DCB      0x16,0x00
000032  2000              MOVS     r0,#0                 ;1046
000034  63d0              STR      r0,[r2,#0x3c]         ;1046
000036  e018              B        |L15.106|
000038  2000              MOVS     r0,#0                 ;1050
00003a  6410              STR      r0,[r2,#0x40]         ;1050
00003c  e015              B        |L15.106|
00003e  2000              MOVS     r0,#0                 ;1054
000040  6450              STR      r0,[r2,#0x44]         ;1054
000042  e012              B        |L15.106|
000044  2000              MOVS     r0,#0                 ;1058
000046  6490              STR      r0,[r2,#0x48]         ;1058
000048  e00f              B        |L15.106|
00004a  2000              MOVS     r0,#0                 ;1062
00004c  64d0              STR      r0,[r2,#0x4c]         ;1062
00004e  e00c              B        |L15.106|
000050  2000              MOVS     r0,#0                 ;1066
000052  6510              STR      r0,[r2,#0x50]         ;1066
000054  e009              B        |L15.106|
000056  2000              MOVS     r0,#0                 ;1070
000058  63d0              STR      r0,[r2,#0x3c]         ;1070
00005a  6410              STR      r0,[r2,#0x40]         ;1071
00005c  6450              STR      r0,[r2,#0x44]         ;1072
00005e  6490              STR      r0,[r2,#0x48]         ;1073
000060  64d0              STR      r0,[r2,#0x4c]         ;1074
000062  6510              STR      r0,[r2,#0x50]         ;1075
000064  e001              B        |L15.106|
                  |L15.102|
000066  2301              MOVS     r3,#1                 ;1079
000068  bf00              NOP                            ;1080
                  |L15.106|
00006a  e000              B        |L15.110|
                  |L15.108|
00006c  2301              MOVS     r3,#1                 ;1085
                  |L15.110|
00006e  bf00              NOP                            ;1089
000070  2000              MOVS     r0,#0                 ;1089
000072  f8820034          STRB     r0,[r2,#0x34]         ;1089
000076  bf00              NOP                            ;1089
000078  4618              MOV      r0,r3                 ;1091
00007a  e7c9              B        |L15.16|
;;;1093   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
