; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f7xx_hal_qspi.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f7xx_hal_qspi.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\stm32f7xx_hal_qspi.crf ..\HALLIB\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_qspi.c]
                          THUMB

                          AREA ||i.HAL_QSPI_Abort||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Abort PROC
;;;1885   */
;;;1886   HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1887   {
000002  4604              MOV      r4,r0
;;;1888     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1889     uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;1890     
;;;1891     /* Check if the state is in one of the busy states */
;;;1892     if ((hqspi->State & 0x2) != 0)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  f0000002          AND      r0,r0,#2
000014  2800              CMP      r0,#0
000016  d038              BEQ      |L1.138|
;;;1893     {
;;;1894       /* Process unlocked */
;;;1895       __HAL_UNLOCK(hqspi);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  f8840038          STRB     r0,[r4,#0x38]
000020  bf00              NOP      
;;;1896   
;;;1897       if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0000004          AND      r0,r0,#4
00002a  b170              CBZ      r0,|L1.74|
;;;1898       {
;;;1899         /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
;;;1900         CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
00002c  6820              LDR      r0,[r4,#0]
00002e  6800              LDR      r0,[r0,#0]
000030  f0200004          BIC      r0,r0,#4
000034  6821              LDR      r1,[r4,#0]
000036  6008              STR      r0,[r1,#0]
;;;1901         
;;;1902         /* Abort DMA channel */
;;;1903         status = HAL_DMA_Abort(hqspi->hdma);
000038  6b60              LDR      r0,[r4,#0x34]
00003a  f7fffffe          BL       HAL_DMA_Abort
00003e  4605              MOV      r5,r0
;;;1904         if(status != HAL_OK)
000040  b11d              CBZ      r5,|L1.74|
;;;1905         {
;;;1906           hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
000042  6be0              LDR      r0,[r4,#0x3c]
000044  f0400004          ORR      r0,r0,#4
000048  63e0              STR      r0,[r4,#0x3c]
                  |L1.74|
;;;1907         }
;;;1908       }  
;;;1909       
;;;1910       /* Configure QSPI: CR register with Abort request */
;;;1911       SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
00004a  6820              LDR      r0,[r4,#0]
00004c  6800              LDR      r0,[r0,#0]
00004e  f0400002          ORR      r0,r0,#2
000052  6821              LDR      r1,[r4,#0]
000054  6008              STR      r0,[r1,#0]
;;;1912       
;;;1913       /* Wait until TC flag is set to go back in idle state */
;;;1914       status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
000056  6c20              LDR      r0,[r4,#0x40]
000058  4633              MOV      r3,r6
00005a  2201              MOVS     r2,#1
00005c  2102              MOVS     r1,#2
00005e  9000              STR      r0,[sp,#0]
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000066  4605              MOV      r5,r0
;;;1915   
;;;1916       if(status == HAL_OK)
000068  b95d              CBNZ     r5,|L1.130|
;;;1917       {
;;;1918         __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
00006a  2002              MOVS     r0,#2
00006c  6821              LDR      r1,[r4,#0]
00006e  60c8              STR      r0,[r1,#0xc]
;;;1919         
;;;1920         /* Wait until BUSY flag is reset */
;;;1921         status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
000070  6c20              LDR      r0,[r4,#0x40]
000072  4633              MOV      r3,r6
000074  2200              MOVS     r2,#0
000076  2120              MOVS     r1,#0x20
000078  9000              STR      r0,[sp,#0]
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000080  4605              MOV      r5,r0
                  |L1.130|
;;;1922       }
;;;1923       
;;;1924       if (status == HAL_OK)
000082  b915              CBNZ     r5,|L1.138|
;;;1925       {
;;;1926         /* Update state */
;;;1927         hqspi->State = HAL_QSPI_STATE_READY;
000084  2001              MOVS     r0,#1
000086  f8840039          STRB     r0,[r4,#0x39]
                  |L1.138|
;;;1928       }
;;;1929     }
;;;1930   
;;;1931     return status;
00008a  4628              MOV      r0,r5
;;;1932   }
00008c  bdf8              POP      {r3-r7,pc}
;;;1933   
                          ENDP


                          AREA ||i.HAL_QSPI_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_AbortCpltCallback PROC
;;;1708     */
;;;1709   __weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1710   {
;;;1711     /* Prevent unused argument(s) compilation warning */
;;;1712     UNUSED(hqspi);
;;;1713   
;;;1714     /* NOTE: This function should not be modified, when the callback is needed,
;;;1715              the HAL_QSPI_AbortCpltCallback could be implemented in the user file
;;;1716      */
;;;1717   }
;;;1718   
                          ENDP


                          AREA ||i.HAL_QSPI_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_QSPI_Abort_IT PROC
;;;1938   */
;;;1939   HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
000000  b570              PUSH     {r4-r6,lr}
;;;1940   {
000002  4604              MOV      r4,r0
;;;1941     HAL_StatusTypeDef status = HAL_OK;
000004  2500              MOVS     r5,#0
;;;1942     
;;;1943     /* Check if the state is in one of the busy states */
;;;1944     if ((hqspi->State & 0x2) != 0)
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  f0000002          AND      r0,r0,#2
00000e  b370              CBZ      r0,|L3.110|
;;;1945     {
;;;1946       /* Process unlocked */
;;;1947       __HAL_UNLOCK(hqspi);
000010  bf00              NOP      
000012  2000              MOVS     r0,#0
000014  f8840038          STRB     r0,[r4,#0x38]
000018  bf00              NOP      
;;;1948       
;;;1949       /* Update QSPI state */
;;;1950       hqspi->State = HAL_QSPI_STATE_ABORT;   
00001a  2008              MOVS     r0,#8
00001c  f8840039          STRB     r0,[r4,#0x39]
;;;1951       
;;;1952       /* Disable all interrupts */
;;;1953       __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f42010f8          BIC      r0,r0,#0x1f0000
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
;;;1954       
;;;1955       if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
00002c  6820              LDR      r0,[r4,#0]
00002e  6800              LDR      r0,[r0,#0]
000030  f0000004          AND      r0,r0,#4
000034  b160              CBZ      r0,|L3.80|
;;;1956       {
;;;1957         /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
;;;1958         CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
000036  6820              LDR      r0,[r4,#0]
000038  6800              LDR      r0,[r0,#0]
00003a  f0200004          BIC      r0,r0,#4
00003e  6821              LDR      r1,[r4,#0]
000040  6008              STR      r0,[r1,#0]
;;;1959         
;;;1960         /* Abort DMA channel */
;;;1961         hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
000042  480c              LDR      r0,|L3.116|
000044  6b61              LDR      r1,[r4,#0x34]
000046  6508              STR      r0,[r1,#0x50]
;;;1962         HAL_DMA_Abort_IT(hqspi->hdma);
000048  6b60              LDR      r0,[r4,#0x34]
00004a  f7fffffe          BL       HAL_DMA_Abort_IT
00004e  e00e              B        |L3.110|
                  |L3.80|
;;;1963       }  
;;;1964       else
;;;1965       {
;;;1966         /* Clear interrupt */
;;;1967         __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
000050  2002              MOVS     r0,#2
000052  6821              LDR      r1,[r4,#0]
000054  60c8              STR      r0,[r1,#0xc]
;;;1968         
;;;1969         /* Enable the QSPI Transfer Complete Interrupt */
;;;1970         __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f4403000          ORR      r0,r0,#0x20000
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
;;;1971         
;;;1972         /* Configure QSPI: CR register with Abort request */
;;;1973         SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
000062  6820              LDR      r0,[r4,#0]
000064  6800              LDR      r0,[r0,#0]
000066  f0400002          ORR      r0,r0,#2
00006a  6821              LDR      r1,[r4,#0]
00006c  6008              STR      r0,[r1,#0]
                  |L3.110|
;;;1974       }
;;;1975     }
;;;1976   
;;;1977     return status;
00006e  4628              MOV      r0,r5
;;;1978   }
000070  bd70              POP      {r4-r6,pc}
;;;1979   
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      QSPI_DMAAbortCplt

                          AREA ||i.HAL_QSPI_AutoPolling||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_AutoPolling PROC
;;;1403     */
;;;1404   HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1405   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1406     HAL_StatusTypeDef status = HAL_ERROR;
00000c  f04f0801          MOV      r8,#1
;;;1407     uint32_t tickstart = HAL_GetTick();
000010  f7fffffe          BL       HAL_GetTick
000014  4681              MOV      r9,r0
;;;1408     
;;;1409     /* Check the parameters */
;;;1410     assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
;;;1411     if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
000016  69b0              LDR      r0,[r6,#0x18]
000018  b100              CBZ      r0,|L4.28|
;;;1412     {
;;;1413       assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
00001a  bf00              NOP      
                  |L4.28|
;;;1414     }
;;;1415     
;;;1416     assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
;;;1417     if (cmd->AddressMode != QSPI_ADDRESS_NONE)
00001c  69f0              LDR      r0,[r6,#0x1c]
00001e  b100              CBZ      r0,|L4.34|
;;;1418     {
;;;1419       assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
000020  bf00              NOP      
                  |L4.34|
;;;1420     }
;;;1421     
;;;1422     assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
;;;1423     if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
000022  6a30              LDR      r0,[r6,#0x20]
000024  b100              CBZ      r0,|L4.40|
;;;1424     {
;;;1425       assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
000026  bf00              NOP      
                  |L4.40|
;;;1426     }
;;;1427     
;;;1428     assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
;;;1429     assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
;;;1430     
;;;1431     assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
;;;1432     assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
;;;1433     assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
;;;1434     
;;;1435     assert_param(IS_QSPI_INTERVAL(cfg->Interval));
;;;1436     assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
;;;1437     assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
;;;1438     
;;;1439     /* Process locked */
;;;1440     __HAL_LOCK(hqspi);
000028  bf00              NOP      
00002a  f8940038          LDRB     r0,[r4,#0x38]
00002e  2801              CMP      r0,#1
000030  d102              BNE      |L4.56|
000032  2002              MOVS     r0,#2
                  |L4.52|
;;;1441     
;;;1442     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1443     {
;;;1444       
;;;1445       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1446       
;;;1447       /* Update state */
;;;1448       hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
;;;1449       
;;;1450       /* Wait till BUSY flag reset */
;;;1451       status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
;;;1452       
;;;1453       if (status == HAL_OK)
;;;1454       {
;;;1455         /* Configure QSPI: PSMAR register with the status match value */
;;;1456         WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
;;;1457         
;;;1458         /* Configure QSPI: PSMKR register with the status mask value */
;;;1459         WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
;;;1460         
;;;1461         /* Configure QSPI: PIR register with the interval value */
;;;1462         WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
;;;1463         
;;;1464         /* Configure QSPI: CR register with Match mode and Automatic stop enabled 
;;;1465         (otherwise there will be an infinite loop in blocking mode) */
;;;1466         MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
;;;1467                  (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));
;;;1468         
;;;1469         /* Call the configuration function */
;;;1470         cmd->NbData = cfg->StatusBytesSize;
;;;1471         QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
;;;1472         
;;;1473         /* Wait until SM flag is set to go back in idle state */
;;;1474         status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
;;;1475   
;;;1476         if (status == HAL_OK)
;;;1477         {
;;;1478           __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
;;;1479           
;;;1480           /* Update state */
;;;1481           hqspi->State = HAL_QSPI_STATE_READY;
;;;1482         }
;;;1483       }
;;;1484     }
;;;1485     else
;;;1486     {
;;;1487       status = HAL_BUSY;   
;;;1488     }
;;;1489     /* Process unlocked */
;;;1490     __HAL_UNLOCK(hqspi);
;;;1491     
;;;1492     /* Return function status */
;;;1493     return status;  
;;;1494   }
000034  e8bd83f8          POP      {r3-r9,pc}
                  |L4.56|
000038  2001              MOVS     r0,#1                 ;1440
00003a  f8840038          STRB     r0,[r4,#0x38]         ;1440
00003e  bf00              NOP                            ;1440
000040  f8940039          LDRB     r0,[r4,#0x39]         ;1442
000044  2801              CMP      r0,#1                 ;1442
000046  d13c              BNE      |L4.194|
000048  2000              MOVS     r0,#0                 ;1445
00004a  63e0              STR      r0,[r4,#0x3c]         ;1445
00004c  2042              MOVS     r0,#0x42              ;1448
00004e  f8840039          STRB     r0,[r4,#0x39]         ;1448
000052  464b              MOV      r3,r9                 ;1451
000054  2200              MOVS     r2,#0                 ;1451
000056  2120              MOVS     r1,#0x20              ;1451
000058  4620              MOV      r0,r4                 ;1451
00005a  9700              STR      r7,[sp,#0]            ;1451
00005c  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000060  4680              MOV      r8,r0                 ;1451
000062  f1b80f00          CMP      r8,#0                 ;1453
000066  d12e              BNE      |L4.198|
000068  6828              LDR      r0,[r5,#0]            ;1456
00006a  6821              LDR      r1,[r4,#0]            ;1456
00006c  6288              STR      r0,[r1,#0x28]         ;1456
00006e  6868              LDR      r0,[r5,#4]            ;1459
000070  6821              LDR      r1,[r4,#0]            ;1459
000072  6248              STR      r0,[r1,#0x24]         ;1459
000074  68a8              LDR      r0,[r5,#8]            ;1462
000076  6821              LDR      r1,[r4,#0]            ;1462
000078  62c8              STR      r0,[r1,#0x2c]         ;1462
00007a  6820              LDR      r0,[r4,#0]            ;1466
00007c  6800              LDR      r0,[r0,#0]            ;1466
00007e  f4200040          BIC      r0,r0,#0xc00000       ;1466
000082  6929              LDR      r1,[r5,#0x10]         ;1466
000084  f4410180          ORR      r1,r1,#0x400000       ;1466
000088  4308              ORRS     r0,r0,r1              ;1466
00008a  6821              LDR      r1,[r4,#0]            ;1466
00008c  6008              STR      r0,[r1,#0]            ;1466
00008e  68e8              LDR      r0,[r5,#0xc]          ;1470
000090  62b0              STR      r0,[r6,#0x28]         ;1470
000092  f04f6200          MOV      r2,#0x8000000         ;1471
000096  4631              MOV      r1,r6                 ;1471
000098  4620              MOV      r0,r4                 ;1471
00009a  f7fffffe          BL       QSPI_Config
00009e  464b              MOV      r3,r9                 ;1474
0000a0  2201              MOVS     r2,#1                 ;1474
0000a2  2108              MOVS     r1,#8                 ;1474
0000a4  4620              MOV      r0,r4                 ;1474
0000a6  9700              STR      r7,[sp,#0]            ;1474
0000a8  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
0000ac  4680              MOV      r8,r0                 ;1474
0000ae  f1b80f00          CMP      r8,#0                 ;1476
0000b2  d108              BNE      |L4.198|
0000b4  2008              MOVS     r0,#8                 ;1478
0000b6  6821              LDR      r1,[r4,#0]            ;1478
0000b8  60c8              STR      r0,[r1,#0xc]          ;1478
0000ba  2001              MOVS     r0,#1                 ;1481
0000bc  f8840039          STRB     r0,[r4,#0x39]         ;1481
0000c0  e001              B        |L4.198|
                  |L4.194|
0000c2  f04f0802          MOV      r8,#2                 ;1487
                  |L4.198|
0000c6  bf00              NOP                            ;1490
0000c8  2000              MOVS     r0,#0                 ;1490
0000ca  f8840038          STRB     r0,[r4,#0x38]         ;1490
0000ce  bf00              NOP                            ;1490
0000d0  4640              MOV      r0,r8                 ;1493
0000d2  e7af              B        |L4.52|
;;;1495   
                          ENDP


                          AREA ||i.HAL_QSPI_AutoPolling_IT||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_AutoPolling_IT PROC
;;;1503     */
;;;1504   HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1505   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1506     HAL_StatusTypeDef status = HAL_ERROR;
00000a  2701              MOVS     r7,#1
;;;1507     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;1508     
;;;1509     /* Check the parameters */
;;;1510     assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
;;;1511     if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
000012  69b0              LDR      r0,[r6,#0x18]
000014  b100              CBZ      r0,|L5.24|
;;;1512     {
;;;1513       assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
000016  bf00              NOP      
                  |L5.24|
;;;1514     }
;;;1515     
;;;1516     assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
;;;1517     if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000018  69f0              LDR      r0,[r6,#0x1c]
00001a  b100              CBZ      r0,|L5.30|
;;;1518     {
;;;1519       assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
00001c  bf00              NOP      
                  |L5.30|
;;;1520     }
;;;1521     
;;;1522     assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
;;;1523     if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
00001e  6a30              LDR      r0,[r6,#0x20]
000020  b100              CBZ      r0,|L5.36|
;;;1524     {
;;;1525       assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
000022  bf00              NOP      
                  |L5.36|
;;;1526     }
;;;1527     
;;;1528     assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
;;;1529     assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
;;;1530     
;;;1531     assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
;;;1532     assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
;;;1533     assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
;;;1534     
;;;1535     assert_param(IS_QSPI_INTERVAL(cfg->Interval));
;;;1536     assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
;;;1537     assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
;;;1538     assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));
;;;1539     
;;;1540     /* Process locked */
;;;1541     __HAL_LOCK(hqspi);
000024  bf00              NOP      
000026  f8940038          LDRB     r0,[r4,#0x38]
00002a  2801              CMP      r0,#1
00002c  d102              BNE      |L5.52|
00002e  2002              MOVS     r0,#2
                  |L5.48|
;;;1542     
;;;1543     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1544     {
;;;1545       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1546       
;;;1547       /* Update state */
;;;1548       hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
;;;1549       
;;;1550       /* Wait till BUSY flag reset */
;;;1551       status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
;;;1552       
;;;1553       if (status == HAL_OK)
;;;1554       {
;;;1555         /* Configure QSPI: PSMAR register with the status match value */
;;;1556         WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
;;;1557         
;;;1558         /* Configure QSPI: PSMKR register with the status mask value */
;;;1559         WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
;;;1560         
;;;1561         /* Configure QSPI: PIR register with the interval value */
;;;1562         WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
;;;1563         
;;;1564         /* Configure QSPI: CR register with Match mode and Automatic stop mode */
;;;1565         MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS), 
;;;1566                  (cfg->MatchMode | cfg->AutomaticStop));
;;;1567         
;;;1568         /* Clear interrupt */
;;;1569         __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
;;;1570         
;;;1571         /* Call the configuration function */
;;;1572         cmd->NbData = cfg->StatusBytesSize;
;;;1573         QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
;;;1574   
;;;1575         /* Process unlocked */
;;;1576         __HAL_UNLOCK(hqspi);
;;;1577     
;;;1578         /* Enable the QSPI Transfer Error and status match Interrupt */
;;;1579         __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
;;;1580   
;;;1581       }
;;;1582       else
;;;1583       {
;;;1584         /* Process unlocked */
;;;1585         __HAL_UNLOCK(hqspi);
;;;1586       }
;;;1587     }
;;;1588     else
;;;1589     {
;;;1590       status = HAL_BUSY;   
;;;1591   
;;;1592       /* Process unlocked */
;;;1593       __HAL_UNLOCK(hqspi);
;;;1594     }
;;;1595     
;;;1596     /* Return function status */
;;;1597     return status;  
;;;1598   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L5.52|
000034  2001              MOVS     r0,#1                 ;1541
000036  f8840038          STRB     r0,[r4,#0x38]         ;1541
00003a  bf00              NOP                            ;1541
00003c  f8940039          LDRB     r0,[r4,#0x39]         ;1543
000040  2801              CMP      r0,#1                 ;1543
000042  d13d              BNE      |L5.192|
000044  2000              MOVS     r0,#0                 ;1545
000046  63e0              STR      r0,[r4,#0x3c]         ;1545
000048  2042              MOVS     r0,#0x42              ;1548
00004a  f8840039          STRB     r0,[r4,#0x39]         ;1548
00004e  6c20              LDR      r0,[r4,#0x40]         ;1551
000050  4643              MOV      r3,r8                 ;1551
000052  2200              MOVS     r2,#0                 ;1551
000054  2120              MOVS     r1,#0x20              ;1551
000056  9000              STR      r0,[sp,#0]            ;1551
000058  4620              MOV      r0,r4                 ;1551
00005a  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
00005e  4607              MOV      r7,r0                 ;1551
000060  bb4f              CBNZ     r7,|L5.182|
000062  6828              LDR      r0,[r5,#0]            ;1556
000064  6821              LDR      r1,[r4,#0]            ;1556
000066  6288              STR      r0,[r1,#0x28]         ;1556
000068  6868              LDR      r0,[r5,#4]            ;1559
00006a  6821              LDR      r1,[r4,#0]            ;1559
00006c  6248              STR      r0,[r1,#0x24]         ;1559
00006e  68a8              LDR      r0,[r5,#8]            ;1562
000070  6821              LDR      r1,[r4,#0]            ;1562
000072  62c8              STR      r0,[r1,#0x2c]         ;1562
000074  e9d50104          LDRD     r0,r1,[r5,#0x10]      ;1565
000078  4308              ORRS     r0,r0,r1              ;1565
00007a  6821              LDR      r1,[r4,#0]            ;1565
00007c  6809              LDR      r1,[r1,#0]            ;1565
00007e  f4210140          BIC      r1,r1,#0xc00000       ;1565
000082  4308              ORRS     r0,r0,r1              ;1565
000084  6821              LDR      r1,[r4,#0]            ;1565
000086  6008              STR      r0,[r1,#0]            ;1565
000088  2009              MOVS     r0,#9                 ;1569
00008a  6821              LDR      r1,[r4,#0]            ;1569
00008c  60c8              STR      r0,[r1,#0xc]          ;1569
00008e  68e8              LDR      r0,[r5,#0xc]          ;1572
000090  62b0              STR      r0,[r6,#0x28]         ;1572
000092  f04f6200          MOV      r2,#0x8000000         ;1573
000096  4631              MOV      r1,r6                 ;1573
000098  4620              MOV      r0,r4                 ;1573
00009a  f7fffffe          BL       QSPI_Config
00009e  bf00              NOP                            ;1576
0000a0  2000              MOVS     r0,#0                 ;1576
0000a2  f8840038          STRB     r0,[r4,#0x38]         ;1576
0000a6  bf00              NOP                            ;1576
0000a8  6820              LDR      r0,[r4,#0]            ;1579
0000aa  6800              LDR      r0,[r0,#0]            ;1579
0000ac  f4402010          ORR      r0,r0,#0x90000        ;1579
0000b0  6821              LDR      r1,[r4,#0]            ;1579
0000b2  6008              STR      r0,[r1,#0]            ;1579
0000b4  e00a              B        |L5.204|
                  |L5.182|
0000b6  bf00              NOP                            ;1585
0000b8  2000              MOVS     r0,#0                 ;1585
0000ba  f8840038          STRB     r0,[r4,#0x38]         ;1585
0000be  e005              B        |L5.204|
                  |L5.192|
0000c0  2702              MOVS     r7,#2                 ;1590
0000c2  bf00              NOP                            ;1593
0000c4  2000              MOVS     r0,#0                 ;1593
0000c6  f8840038          STRB     r0,[r4,#0x38]         ;1593
0000ca  bf00              NOP                            ;1593
                  |L5.204|
0000cc  4638              MOV      r0,r7                 ;1597
0000ce  e7af              B        |L5.48|
;;;1599   
                          ENDP


                          AREA ||i.HAL_QSPI_CmdCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_CmdCpltCallback PROC
;;;1723     */
;;;1724   __weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1725   {
;;;1726     /* Prevent unused argument(s) compilation warning */
;;;1727     UNUSED(hqspi);
;;;1728     
;;;1729     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1730              the HAL_QSPI_CmdCpltCallback could be implemented in the user file
;;;1731      */
;;;1732   }
;;;1733   
                          ENDP


                          AREA ||i.HAL_QSPI_Command||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Command PROC
;;;644      */
;;;645    HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;646    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;647      HAL_StatusTypeDef status = HAL_ERROR;
00000a  2701              MOVS     r7,#1
;;;648      uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;649      
;;;650      /* Check the parameters */
;;;651      assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
;;;652      if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
000012  69a8              LDR      r0,[r5,#0x18]
000014  b100              CBZ      r0,|L7.24|
;;;653      {
;;;654        assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
000016  bf00              NOP      
                  |L7.24|
;;;655      }
;;;656    
;;;657      assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
;;;658      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000018  69e8              LDR      r0,[r5,#0x1c]
00001a  b100              CBZ      r0,|L7.30|
;;;659      {
;;;660        assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
00001c  bf00              NOP      
                  |L7.30|
;;;661      }
;;;662    
;;;663      assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
;;;664      if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
00001e  6a28              LDR      r0,[r5,#0x20]
000020  b100              CBZ      r0,|L7.36|
;;;665      {
;;;666        assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
000022  bf00              NOP      
                  |L7.36|
;;;667      }
;;;668    
;;;669      assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
;;;670      assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
;;;671    
;;;672      assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
;;;673      assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
;;;674      assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
;;;675      
;;;676      /* Process locked */
;;;677      __HAL_LOCK(hqspi);
000024  bf00              NOP      
000026  f8940038          LDRB     r0,[r4,#0x38]
00002a  2801              CMP      r0,#1
00002c  d102              BNE      |L7.52|
00002e  2002              MOVS     r0,#2
                  |L7.48|
;;;678    
;;;679      if(hqspi->State == HAL_QSPI_STATE_READY)
;;;680      {
;;;681        hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;682        
;;;683        /* Update QSPI state */
;;;684        hqspi->State = HAL_QSPI_STATE_BUSY;   
;;;685        
;;;686        /* Wait till BUSY flag reset */
;;;687        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
;;;688        
;;;689        if (status == HAL_OK)
;;;690        {
;;;691          /* Call the configuration function */
;;;692          QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
;;;693          
;;;694          if (cmd->DataMode == QSPI_DATA_NONE)
;;;695          {
;;;696            /* When there is no data phase, the transfer start as soon as the configuration is done 
;;;697            so wait until TC flag is set to go back in idle state */
;;;698            status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
;;;699    
;;;700            if (status == HAL_OK)
;;;701            {
;;;702              __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
;;;703              
;;;704              /* Update QSPI state */
;;;705              hqspi->State = HAL_QSPI_STATE_READY;   
;;;706            }
;;;707            
;;;708          }
;;;709          else
;;;710          {
;;;711            /* Update QSPI state */
;;;712            hqspi->State = HAL_QSPI_STATE_READY;   
;;;713          }
;;;714        }
;;;715      }
;;;716      else
;;;717      {
;;;718        status = HAL_BUSY;   
;;;719      }
;;;720      
;;;721      /* Process unlocked */
;;;722      __HAL_UNLOCK(hqspi);
;;;723    
;;;724      /* Return function status */
;;;725      return status;
;;;726    }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L7.52|
000034  2001              MOVS     r0,#1                 ;677
000036  f8840038          STRB     r0,[r4,#0x38]         ;677
00003a  bf00              NOP                            ;677
00003c  f8940039          LDRB     r0,[r4,#0x39]         ;679
000040  2801              CMP      r0,#1                 ;679
000042  d128              BNE      |L7.150|
000044  2000              MOVS     r0,#0                 ;681
000046  63e0              STR      r0,[r4,#0x3c]         ;681
000048  2002              MOVS     r0,#2                 ;684
00004a  f8840039          STRB     r0,[r4,#0x39]         ;684
00004e  4643              MOV      r3,r8                 ;687
000050  2200              MOVS     r2,#0                 ;687
000052  2120              MOVS     r1,#0x20              ;687
000054  4620              MOV      r0,r4                 ;687
000056  9600              STR      r6,[sp,#0]            ;687
000058  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
00005c  4607              MOV      r7,r0                 ;687
00005e  b9df              CBNZ     r7,|L7.152|
000060  2200              MOVS     r2,#0                 ;692
000062  4629              MOV      r1,r5                 ;692
000064  4620              MOV      r0,r4                 ;692
000066  f7fffffe          BL       QSPI_Config
00006a  6a68              LDR      r0,[r5,#0x24]         ;694
00006c  b978              CBNZ     r0,|L7.142|
00006e  4643              MOV      r3,r8                 ;698
000070  2201              MOVS     r2,#1                 ;698
000072  2102              MOVS     r1,#2                 ;698
000074  4620              MOV      r0,r4                 ;698
000076  9600              STR      r6,[sp,#0]            ;698
000078  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
00007c  4607              MOV      r7,r0                 ;698
00007e  b95f              CBNZ     r7,|L7.152|
000080  2002              MOVS     r0,#2                 ;702
000082  6821              LDR      r1,[r4,#0]            ;702
000084  60c8              STR      r0,[r1,#0xc]          ;702
000086  2001              MOVS     r0,#1                 ;705
000088  f8840039          STRB     r0,[r4,#0x39]         ;705
00008c  e004              B        |L7.152|
                  |L7.142|
00008e  2001              MOVS     r0,#1                 ;712
000090  f8840039          STRB     r0,[r4,#0x39]         ;712
000094  e000              B        |L7.152|
                  |L7.150|
000096  2702              MOVS     r7,#2                 ;718
                  |L7.152|
000098  bf00              NOP                            ;722
00009a  2000              MOVS     r0,#0                 ;722
00009c  f8840038          STRB     r0,[r4,#0x38]         ;722
0000a0  bf00              NOP                            ;722
0000a2  4638              MOV      r0,r7                 ;725
0000a4  e7c4              B        |L7.48|
;;;727    
                          ENDP


                          AREA ||i.HAL_QSPI_Command_IT||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Command_IT PROC
;;;734      */
;;;735    HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
000000  b5f8              PUSH     {r3-r7,lr}
;;;736    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;737      HAL_StatusTypeDef status = HAL_ERROR;
000006  2601              MOVS     r6,#1
;;;738      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;739      
;;;740      /* Check the parameters */
;;;741      assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
;;;742      if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
00000e  69a8              LDR      r0,[r5,#0x18]
000010  b100              CBZ      r0,|L8.20|
;;;743      {
;;;744        assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
000012  bf00              NOP      
                  |L8.20|
;;;745      }
;;;746    
;;;747      assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
;;;748      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000014  69e8              LDR      r0,[r5,#0x1c]
000016  b100              CBZ      r0,|L8.26|
;;;749      {
;;;750        assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
000018  bf00              NOP      
                  |L8.26|
;;;751      }
;;;752    
;;;753      assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
;;;754      if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
00001a  6a28              LDR      r0,[r5,#0x20]
00001c  b100              CBZ      r0,|L8.32|
;;;755      {
;;;756        assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
00001e  bf00              NOP      
                  |L8.32|
;;;757      }
;;;758    
;;;759      assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
;;;760      assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
;;;761    
;;;762      assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
;;;763      assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
;;;764      assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
;;;765      
;;;766      /* Process locked */
;;;767      __HAL_LOCK(hqspi);
000020  bf00              NOP      
000022  f8940038          LDRB     r0,[r4,#0x38]
000026  2801              CMP      r0,#1
000028  d101              BNE      |L8.46|
00002a  2002              MOVS     r0,#2
                  |L8.44|
;;;768    
;;;769      if(hqspi->State == HAL_QSPI_STATE_READY)
;;;770      {
;;;771        hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;772        
;;;773        /* Update QSPI state */
;;;774        hqspi->State = HAL_QSPI_STATE_BUSY;   
;;;775        
;;;776        /* Wait till BUSY flag reset */
;;;777        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
;;;778        
;;;779        if (status == HAL_OK)
;;;780        {
;;;781          if (cmd->DataMode == QSPI_DATA_NONE)
;;;782          {
;;;783            /* Clear interrupt */
;;;784            __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
;;;785          }
;;;786          
;;;787          /* Call the configuration function */
;;;788          QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
;;;789          
;;;790          if (cmd->DataMode == QSPI_DATA_NONE)
;;;791          {
;;;792            /* When there is no data phase, the transfer start as soon as the configuration is done 
;;;793            so activate TC and TE interrupts */
;;;794            /* Process unlocked */
;;;795            __HAL_UNLOCK(hqspi);
;;;796    
;;;797            /* Enable the QSPI Transfer Error Interrupt */
;;;798            __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
;;;799          }
;;;800          else
;;;801          {
;;;802            /* Update QSPI state */
;;;803            hqspi->State = HAL_QSPI_STATE_READY;   
;;;804    
;;;805            /* Process unlocked */
;;;806            __HAL_UNLOCK(hqspi);
;;;807          }
;;;808        }
;;;809        else
;;;810        {
;;;811          /* Process unlocked */
;;;812          __HAL_UNLOCK(hqspi);
;;;813        }
;;;814      }
;;;815      else
;;;816      {
;;;817        status = HAL_BUSY;   
;;;818    
;;;819        /* Process unlocked */
;;;820        __HAL_UNLOCK(hqspi);
;;;821      }
;;;822      
;;;823      /* Return function status */
;;;824      return status;
;;;825    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L8.46|
00002e  2001              MOVS     r0,#1                 ;767
000030  f8840038          STRB     r0,[r4,#0x38]         ;767
000034  bf00              NOP                            ;767
000036  f8940039          LDRB     r0,[r4,#0x39]         ;769
00003a  2801              CMP      r0,#1                 ;769
00003c  d133              BNE      |L8.166|
00003e  2000              MOVS     r0,#0                 ;771
000040  63e0              STR      r0,[r4,#0x3c]         ;771
000042  2002              MOVS     r0,#2                 ;774
000044  f8840039          STRB     r0,[r4,#0x39]         ;774
000048  6c20              LDR      r0,[r4,#0x40]         ;777
00004a  463b              MOV      r3,r7                 ;777
00004c  2200              MOVS     r2,#0                 ;777
00004e  2120              MOVS     r1,#0x20              ;777
000050  9000              STR      r0,[sp,#0]            ;777
000052  4620              MOV      r0,r4                 ;777
000054  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000058  4606              MOV      r6,r0                 ;777
00005a  b9fe              CBNZ     r6,|L8.156|
00005c  6a68              LDR      r0,[r5,#0x24]         ;781
00005e  b910              CBNZ     r0,|L8.102|
000060  2003              MOVS     r0,#3                 ;784
000062  6821              LDR      r1,[r4,#0]            ;784
000064  60c8              STR      r0,[r1,#0xc]          ;784
                  |L8.102|
000066  2200              MOVS     r2,#0                 ;788
000068  4629              MOV      r1,r5                 ;788
00006a  4620              MOV      r0,r4                 ;788
00006c  f7fffffe          BL       QSPI_Config
000070  6a68              LDR      r0,[r5,#0x24]         ;790
000072  b958              CBNZ     r0,|L8.140|
000074  bf00              NOP                            ;795
000076  2000              MOVS     r0,#0                 ;795
000078  f8840038          STRB     r0,[r4,#0x38]         ;795
00007c  bf00              NOP                            ;795
00007e  6820              LDR      r0,[r4,#0]            ;798
000080  6800              LDR      r0,[r0,#0]            ;798
000082  f4403040          ORR      r0,r0,#0x30000        ;798
000086  6821              LDR      r1,[r4,#0]            ;798
000088  6008              STR      r0,[r1,#0]            ;798
00008a  e012              B        |L8.178|
                  |L8.140|
00008c  2001              MOVS     r0,#1                 ;803
00008e  f8840039          STRB     r0,[r4,#0x39]         ;803
000092  bf00              NOP                            ;806
000094  2000              MOVS     r0,#0                 ;806
000096  f8840038          STRB     r0,[r4,#0x38]         ;806
00009a  e00a              B        |L8.178|
                  |L8.156|
00009c  bf00              NOP                            ;812
00009e  2000              MOVS     r0,#0                 ;812
0000a0  f8840038          STRB     r0,[r4,#0x38]         ;812
0000a4  e005              B        |L8.178|
                  |L8.166|
0000a6  2602              MOVS     r6,#2                 ;817
0000a8  bf00              NOP                            ;820
0000aa  2000              MOVS     r0,#0                 ;820
0000ac  f8840038          STRB     r0,[r4,#0x38]         ;820
0000b0  bf00              NOP                            ;820
                  |L8.178|
0000b2  4630              MOV      r0,r6                 ;824
0000b4  e7ba              B        |L8.44|
;;;826    
                          ENDP


                          AREA ||i.HAL_QSPI_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_DeInit PROC
;;;329      */
;;;330    HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
000000  b510              PUSH     {r4,lr}
;;;331    {
000002  4604              MOV      r4,r0
;;;332      /* Check the QSPI handle allocation */
;;;333      if(hqspi == NULL)
000004  b90c              CBNZ     r4,|L9.10|
;;;334      {
;;;335        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L9.8|
;;;336      }
;;;337    
;;;338      /* Process locked */
;;;339      __HAL_LOCK(hqspi);
;;;340    
;;;341      /* Disable the QSPI Peripheral Clock */
;;;342      __HAL_QSPI_DISABLE(hqspi);
;;;343    
;;;344      /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
;;;345      HAL_QSPI_MspDeInit(hqspi);
;;;346    
;;;347      /* Set QSPI error code to none */
;;;348      hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;349    
;;;350      /* Initialize the QSPI state */
;;;351      hqspi->State = HAL_QSPI_STATE_RESET;
;;;352    
;;;353      /* Release Lock */
;;;354      __HAL_UNLOCK(hqspi);
;;;355    
;;;356      return HAL_OK;
;;;357    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  bf00              NOP                            ;339
00000c  f8940038          LDRB     r0,[r4,#0x38]         ;339
000010  2801              CMP      r0,#1                 ;339
000012  d101              BNE      |L9.24|
000014  2002              MOVS     r0,#2                 ;339
000016  e7f7              B        |L9.8|
                  |L9.24|
000018  2001              MOVS     r0,#1                 ;339
00001a  f8840038          STRB     r0,[r4,#0x38]         ;339
00001e  bf00              NOP                            ;339
000020  6820              LDR      r0,[r4,#0]            ;342
000022  6800              LDR      r0,[r0,#0]            ;342
000024  f0200001          BIC      r0,r0,#1              ;342
000028  6821              LDR      r1,[r4,#0]            ;342
00002a  6008              STR      r0,[r1,#0]            ;342
00002c  4620              MOV      r0,r4                 ;345
00002e  f7fffffe          BL       HAL_QSPI_MspDeInit
000032  2000              MOVS     r0,#0                 ;348
000034  63e0              STR      r0,[r4,#0x3c]         ;348
000036  f8840039          STRB     r0,[r4,#0x39]         ;351
00003a  bf00              NOP                            ;354
00003c  f8840038          STRB     r0,[r4,#0x38]         ;354
000040  bf00              NOP                            ;354
000042  bf00              NOP                            ;356
000044  e7e0              B        |L9.8|
;;;358    
                          ENDP


                          AREA ||i.HAL_QSPI_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_ErrorCallback PROC
;;;1693     */
;;;1694   __weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1695   {
;;;1696     /* Prevent unused argument(s) compilation warning */
;;;1697     UNUSED(hqspi);
;;;1698     
;;;1699     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1700               the HAL_QSPI_ErrorCallback could be implemented in the user file
;;;1701      */
;;;1702   }
;;;1703   
                          ENDP


                          AREA ||i.HAL_QSPI_FifoThresholdCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_FifoThresholdCallback PROC
;;;1798     */
;;;1799   __weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1800   {
;;;1801     /* Prevent unused argument(s) compilation warning */
;;;1802     UNUSED(hqspi);
;;;1803     
;;;1804     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1805               the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
;;;1806      */
;;;1807   }
;;;1808   
                          ENDP


                          AREA ||i.HAL_QSPI_GetError||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_GetError PROC
;;;1875   */
;;;1876   uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
000000  4601              MOV      r1,r0
;;;1877   {
;;;1878     return hqspi->ErrorCode;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;1879   }
000004  4770              BX       lr
;;;1880   
                          ENDP


                          AREA ||i.HAL_QSPI_GetFifoThreshold||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_GetFifoThreshold PROC
;;;2026     */
;;;2027   uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
000000  4601              MOV      r1,r0
;;;2028   {
;;;2029     return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> POSITION_VAL(QUADSPI_CR_FTHRES)) + 1);
000002  6808              LDR      r0,[r1,#0]
000004  6800              LDR      r0,[r0,#0]
000006  f40050f8          AND      r0,r0,#0x1f00
00000a  f44f52f8          MOV      r2,#0x1f00
00000e  fa92f2a2          RBIT     r2,r2
000012  fab2f282          CLZ      r2,r2
000016  40d0              LSRS     r0,r0,r2
000018  1c40              ADDS     r0,r0,#1
;;;2030   }
00001a  4770              BX       lr
;;;2031   
                          ENDP


                          AREA ||i.HAL_QSPI_GetState||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_GetState PROC
;;;1864     */
;;;1865   HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
000000  4601              MOV      r1,r0
;;;1866   {
;;;1867     /* Return QSPI handle state */
;;;1868     return hqspi->State;
000002  f8910039          LDRB     r0,[r1,#0x39]
;;;1869   }
000006  4770              BX       lr
;;;1870   
                          ENDP


                          AREA ||i.HAL_QSPI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_QSPI_IRQHandler PROC
;;;417      */
;;;418    void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;419    {
000004  4604              MOV      r4,r0
;;;420      __IO uint32_t *data_reg;
;;;421      uint32_t flag = READ_REG(hqspi->Instance->SR);
000006  6820              LDR      r0,[r4,#0]
000008  6886              LDR      r6,[r0,#8]
;;;422      uint32_t itsource = READ_REG(hqspi->Instance->CR);
00000a  6820              LDR      r0,[r4,#0]
00000c  6807              LDR      r7,[r0,#0]
;;;423    
;;;424      /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
;;;425      if(((flag & QSPI_FLAG_FT)!= RESET) && ((itsource & QSPI_IT_FT)!= RESET))
00000e  f0060004          AND      r0,r6,#4
000012  2800              CMP      r0,#0
000014  d048              BEQ      |L15.168|
000016  f4072080          AND      r0,r7,#0x40000
00001a  2800              CMP      r0,#0
00001c  d044              BEQ      |L15.168|
;;;426      {
;;;427        data_reg = &hqspi->Instance->DR;
00001e  6820              LDR      r0,[r4,#0]
000020  f1000520          ADD      r5,r0,#0x20
;;;428    
;;;429        if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
000024  f8940039          LDRB     r0,[r4,#0x39]
000028  2812              CMP      r0,#0x12
00002a  d11a              BNE      |L15.98|
;;;430        {
;;;431          /* Transmission process */
;;;432          while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != 0)
00002c  e012              B        |L15.84|
                  |L15.46|
;;;433          {
;;;434            if (hqspi->TxXferCount > 0)
00002e  8d60              LDRH     r0,[r4,#0x2a]
000030  2800              CMP      r0,#0
000032  dd08              BLE      |L15.70|
;;;435            {
;;;436              /* Fill the FIFO until it is full */
;;;437              *(__IO uint8_t *)data_reg = *hqspi->pTxBuffPtr++;
000034  6a61              LDR      r1,[r4,#0x24]
000036  1c48              ADDS     r0,r1,#1
000038  6260              STR      r0,[r4,#0x24]
00003a  7808              LDRB     r0,[r1,#0]
00003c  7028              STRB     r0,[r5,#0]
;;;438              hqspi->TxXferCount--;
00003e  8d60              LDRH     r0,[r4,#0x2a]
000040  1e40              SUBS     r0,r0,#1
000042  8560              STRH     r0,[r4,#0x2a]
000044  e006              B        |L15.84|
                  |L15.70|
;;;439            }
;;;440            else
;;;441            {
;;;442              /* No more data available for the transfer */
;;;443              /* Disable the QSPI FIFO Threshold Interrupt */
;;;444              __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
000046  6820              LDR      r0,[r4,#0]
000048  6800              LDR      r0,[r0,#0]
00004a  f4202080          BIC      r0,r0,#0x40000
00004e  6821              LDR      r1,[r4,#0]
000050  6008              STR      r0,[r1,#0]
;;;445              break;
000052  e005              B        |L15.96|
                  |L15.84|
000054  6820              LDR      r0,[r4,#0]            ;432
000056  6880              LDR      r0,[r0,#8]            ;432
000058  f3c00080          UBFX     r0,r0,#2,#1           ;432
00005c  2800              CMP      r0,#0                 ;432
00005e  d1e6              BNE      |L15.46|
                  |L15.96|
000060  e01e              B        |L15.160|
                  |L15.98|
;;;446            }
;;;447          }
;;;448        }
;;;449        else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
000062  f8940039          LDRB     r0,[r4,#0x39]
000066  2822              CMP      r0,#0x22
000068  d11a              BNE      |L15.160|
;;;450        {
;;;451          /* Receiving Process */
;;;452          while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != 0)
00006a  e012              B        |L15.146|
                  |L15.108|
;;;453          {
;;;454            if (hqspi->RxXferCount > 0)
00006c  8e60              LDRH     r0,[r4,#0x32]
00006e  2800              CMP      r0,#0
000070  dd08              BLE      |L15.132|
;;;455            {
;;;456              /* Read the FIFO until it is empty */
;;;457              *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
000072  7829              LDRB     r1,[r5,#0]
000074  6ae2              LDR      r2,[r4,#0x2c]
000076  1c50              ADDS     r0,r2,#1
000078  62e0              STR      r0,[r4,#0x2c]
00007a  7011              STRB     r1,[r2,#0]
;;;458              hqspi->RxXferCount--;
00007c  8e60              LDRH     r0,[r4,#0x32]
00007e  1e40              SUBS     r0,r0,#1
000080  8660              STRH     r0,[r4,#0x32]
000082  e006              B        |L15.146|
                  |L15.132|
;;;459            }
;;;460            else
;;;461            {
;;;462              /* All data have been received for the transfer */
;;;463              /* Disable the QSPI FIFO Threshold Interrupt */
;;;464              __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
000084  6820              LDR      r0,[r4,#0]
000086  6800              LDR      r0,[r0,#0]
000088  f4202080          BIC      r0,r0,#0x40000
00008c  6821              LDR      r1,[r4,#0]
00008e  6008              STR      r0,[r1,#0]
;;;465              break;
000090  e005              B        |L15.158|
                  |L15.146|
000092  6820              LDR      r0,[r4,#0]            ;452
000094  6880              LDR      r0,[r0,#8]            ;452
000096  f3c00080          UBFX     r0,r0,#2,#1           ;452
00009a  2800              CMP      r0,#0                 ;452
00009c  d1e6              BNE      |L15.108|
                  |L15.158|
00009e  bf00              NOP      
                  |L15.160|
;;;466            }
;;;467          }
;;;468        }
;;;469        
;;;470        /* FIFO Threshold callback */
;;;471        HAL_QSPI_FifoThresholdCallback(hqspi);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_QSPI_FifoThresholdCallback
0000a6  e0d5              B        |L15.596|
                  |L15.168|
;;;472      }
;;;473    
;;;474      /* QSPI Transfer Complete interrupt occurred -------------------------------*/
;;;475      else if(((flag & QSPI_FLAG_TC)!= RESET) && ((itsource & QSPI_IT_TC)!= RESET))
0000a8  f0060002          AND      r0,r6,#2
0000ac  2800              CMP      r0,#0
0000ae  d07e              BEQ      |L15.430|
0000b0  f4073000          AND      r0,r7,#0x20000
0000b4  2800              CMP      r0,#0
0000b6  d07a              BEQ      |L15.430|
;;;476      {
;;;477        /* Clear interrupt */
;;;478        WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
0000b8  2002              MOVS     r0,#2
0000ba  6821              LDR      r1,[r4,#0]
0000bc  60c8              STR      r0,[r1,#0xc]
;;;479    
;;;480        /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
;;;481        __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
0000be  6820              LDR      r0,[r4,#0]
0000c0  6800              LDR      r0,[r0,#0]
0000c2  f42020e0          BIC      r0,r0,#0x70000
0000c6  6821              LDR      r1,[r4,#0]
0000c8  6008              STR      r0,[r1,#0]
;;;482        
;;;483        /* Transfer complete callback */
;;;484        if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
0000ca  f8940039          LDRB     r0,[r4,#0x39]
0000ce  2812              CMP      r0,#0x12
0000d0  d119              BNE      |L15.262|
;;;485        {
;;;486          if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
0000d2  6820              LDR      r0,[r4,#0]
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0000004          AND      r0,r0,#4
0000da  b168              CBZ      r0,|L15.248|
;;;487          {
;;;488            /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
;;;489            CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
0000dc  6820              LDR      r0,[r4,#0]
0000de  6800              LDR      r0,[r0,#0]
0000e0  f0200004          BIC      r0,r0,#4
0000e4  6821              LDR      r1,[r4,#0]
0000e6  6008              STR      r0,[r1,#0]
;;;490            
;;;491            /* Disable the DMA channel */
;;;492            __HAL_DMA_DISABLE(hqspi->hdma);
0000e8  6b60              LDR      r0,[r4,#0x34]
0000ea  6800              LDR      r0,[r0,#0]
0000ec  6800              LDR      r0,[r0,#0]
0000ee  f0200001          BIC      r0,r0,#1
0000f2  6b61              LDR      r1,[r4,#0x34]
0000f4  6809              LDR      r1,[r1,#0]
0000f6  6008              STR      r0,[r1,#0]
                  |L15.248|
;;;493          }
;;;494    
;;;495    #if defined(QSPI1_V1_0)
;;;496    /* Clear Busy bit */
;;;497          HAL_QSPI_Abort_IT(hqspi);
;;;498    #endif
;;;499          
;;;500          /* Change state of QSPI */
;;;501          hqspi->State = HAL_QSPI_STATE_READY;
0000f8  2001              MOVS     r0,#1
0000fa  f8840039          STRB     r0,[r4,#0x39]
;;;502    
;;;503          /* TX Complete callback */
;;;504          HAL_QSPI_TxCpltCallback(hqspi);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       HAL_QSPI_TxCpltCallback
000104  e0a6              B        |L15.596|
                  |L15.262|
;;;505        }
;;;506        else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
000106  f8940039          LDRB     r0,[r4,#0x39]
00010a  2822              CMP      r0,#0x22
00010c  d132              BNE      |L15.372|
;;;507        {
;;;508          if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
00010e  6820              LDR      r0,[r4,#0]
000110  6800              LDR      r0,[r0,#0]
000112  f0000004          AND      r0,r0,#4
000116  b170              CBZ      r0,|L15.310|
;;;509          {
;;;510            /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
;;;511            CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
000118  6820              LDR      r0,[r4,#0]
00011a  6800              LDR      r0,[r0,#0]
00011c  f0200004          BIC      r0,r0,#4
000120  6821              LDR      r1,[r4,#0]
000122  6008              STR      r0,[r1,#0]
;;;512            
;;;513            /* Disable the DMA channel */
;;;514            __HAL_DMA_DISABLE(hqspi->hdma);
000124  6b60              LDR      r0,[r4,#0x34]
000126  6800              LDR      r0,[r0,#0]
000128  6800              LDR      r0,[r0,#0]
00012a  f0200001          BIC      r0,r0,#1
00012e  6b61              LDR      r1,[r4,#0x34]
000130  6809              LDR      r1,[r1,#0]
000132  6008              STR      r0,[r1,#0]
000134  e017              B        |L15.358|
                  |L15.310|
;;;515          }
;;;516          else
;;;517          {
;;;518            data_reg = &hqspi->Instance->DR;
000136  6820              LDR      r0,[r4,#0]
000138  f1000520          ADD      r5,r0,#0x20
;;;519            while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0)
00013c  e00c              B        |L15.344|
                  |L15.318|
;;;520            {
;;;521              if (hqspi->RxXferCount > 0)
00013e  8e60              LDRH     r0,[r4,#0x32]
000140  2800              CMP      r0,#0
000142  dd08              BLE      |L15.342|
;;;522              {
;;;523                /* Read the last data received in the FIFO until it is empty */
;;;524                *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
000144  7829              LDRB     r1,[r5,#0]
000146  6ae2              LDR      r2,[r4,#0x2c]
000148  1c50              ADDS     r0,r2,#1
00014a  62e0              STR      r0,[r4,#0x2c]
00014c  7011              STRB     r1,[r2,#0]
;;;525                hqspi->RxXferCount--;
00014e  8e60              LDRH     r0,[r4,#0x32]
000150  1e40              SUBS     r0,r0,#1
000152  8660              STRH     r0,[r4,#0x32]
000154  e000              B        |L15.344|
                  |L15.342|
;;;526              }
;;;527              else
;;;528              {
;;;529                /* All data have been received for the transfer */
;;;530                break;
000156  e005              B        |L15.356|
                  |L15.344|
000158  6820              LDR      r0,[r4,#0]            ;519
00015a  6880              LDR      r0,[r0,#8]            ;519
00015c  f40050f8          AND      r0,r0,#0x1f00         ;519
000160  2800              CMP      r0,#0                 ;519
000162  d1ec              BNE      |L15.318|
                  |L15.356|
000164  bf00              NOP      
                  |L15.358|
;;;531              }
;;;532            }
;;;533          }
;;;534    #if defined(QSPI1_V1_0)
;;;535          /* Workaround - Extra data written in the FIFO at the end of a read transfer */
;;;536          HAL_QSPI_Abort_IT(hqspi);
;;;537    #endif /* QSPI_V1_0*/      
;;;538          
;;;539          /* Change state of QSPI */
;;;540          hqspi->State = HAL_QSPI_STATE_READY;
000166  2001              MOVS     r0,#1
000168  f8840039          STRB     r0,[r4,#0x39]
;;;541    
;;;542          /* RX Complete callback */
;;;543          HAL_QSPI_RxCpltCallback(hqspi);
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       HAL_QSPI_RxCpltCallback
000172  e06f              B        |L15.596|
                  |L15.372|
;;;544        }
;;;545        else if(hqspi->State == HAL_QSPI_STATE_BUSY)
000174  f8940039          LDRB     r0,[r4,#0x39]
000178  2802              CMP      r0,#2
00017a  d106              BNE      |L15.394|
;;;546        {
;;;547          /* Change state of QSPI */
;;;548          hqspi->State = HAL_QSPI_STATE_READY;
00017c  2001              MOVS     r0,#1
00017e  f8840039          STRB     r0,[r4,#0x39]
;;;549    
;;;550          /* Command Complete callback */
;;;551          HAL_QSPI_CmdCpltCallback(hqspi);
000182  4620              MOV      r0,r4
000184  f7fffffe          BL       HAL_QSPI_CmdCpltCallback
000188  e064              B        |L15.596|
                  |L15.394|
;;;552        }
;;;553        else if(hqspi->State == HAL_QSPI_STATE_ABORT)
00018a  f8940039          LDRB     r0,[r4,#0x39]
00018e  2808              CMP      r0,#8
000190  d160              BNE      |L15.596|
;;;554        {
;;;555          /* Change state of QSPI */
;;;556          hqspi->State = HAL_QSPI_STATE_READY;
000192  2001              MOVS     r0,#1
000194  f8840039          STRB     r0,[r4,#0x39]
;;;557    
;;;558          if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
000198  6be0              LDR      r0,[r4,#0x3c]
00019a  b920              CBNZ     r0,|L15.422|
;;;559          {
;;;560            /* Abort called by the user */
;;;561    
;;;562            /* Abort Complete callback */
;;;563            HAL_QSPI_AbortCpltCallback(hqspi);
00019c  4620              MOV      r0,r4
00019e  f7fffffe          BL       HAL_QSPI_AbortCpltCallback
0001a2  e057              B        |L15.596|
0001a4  e003              B        |L15.430|
                  |L15.422|
;;;564          }
;;;565          else 
;;;566          {
;;;567            /* Abort due to an error (eg :  DMA error) */
;;;568    
;;;569            /* Error callback */
;;;570            HAL_QSPI_ErrorCallback(hqspi);
0001a6  4620              MOV      r0,r4
0001a8  f7fffffe          BL       HAL_QSPI_ErrorCallback
0001ac  e052              B        |L15.596|
                  |L15.430|
;;;571          }
;;;572        }
;;;573      }
;;;574    
;;;575      /* QSPI Status Match interrupt occurred ------------------------------------*/
;;;576      else if(((flag & QSPI_FLAG_SM)!= RESET) && ((itsource & QSPI_IT_SM)!= RESET))
0001ae  f0060008          AND      r0,r6,#8
0001b2  b1b8              CBZ      r0,|L15.484|
0001b4  f4072000          AND      r0,r7,#0x80000
0001b8  b1a0              CBZ      r0,|L15.484|
;;;577      {
;;;578        /* Clear interrupt */
;;;579        WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
0001ba  2008              MOVS     r0,#8
0001bc  6821              LDR      r1,[r4,#0]
0001be  60c8              STR      r0,[r1,#0xc]
;;;580       
;;;581        /* Check if the automatic poll mode stop is activated */
;;;582        if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0)
0001c0  6820              LDR      r0,[r4,#0]
0001c2  6800              LDR      r0,[r0,#0]
0001c4  f4000080          AND      r0,r0,#0x400000
0001c8  b140              CBZ      r0,|L15.476|
;;;583        {
;;;584          /* Disable the QSPI Transfer Error and Status Match Interrupts */
;;;585          __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
0001ca  6820              LDR      r0,[r4,#0]
0001cc  6800              LDR      r0,[r0,#0]
0001ce  f4202010          BIC      r0,r0,#0x90000
0001d2  6821              LDR      r1,[r4,#0]
0001d4  6008              STR      r0,[r1,#0]
;;;586    
;;;587          /* Change state of QSPI */
;;;588          hqspi->State = HAL_QSPI_STATE_READY;
0001d6  2001              MOVS     r0,#1
0001d8  f8840039          STRB     r0,[r4,#0x39]
                  |L15.476|
;;;589        }
;;;590    
;;;591        /* Status match callback */
;;;592        HAL_QSPI_StatusMatchCallback(hqspi);
0001dc  4620              MOV      r0,r4
0001de  f7fffffe          BL       HAL_QSPI_StatusMatchCallback
0001e2  e037              B        |L15.596|
                  |L15.484|
;;;593      }
;;;594    
;;;595      /* QSPI Transfer Error interrupt occurred ----------------------------------*/
;;;596      else if(((flag & QSPI_FLAG_TE)!= RESET) && ((itsource & QSPI_IT_TE)!= RESET))
0001e4  f0060001          AND      r0,r6,#1
0001e8  b340              CBZ      r0,|L15.572|
0001ea  f4073080          AND      r0,r7,#0x10000
0001ee  b328              CBZ      r0,|L15.572|
;;;597      {
;;;598        /* Clear interrupt */
;;;599        WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
0001f0  2001              MOVS     r0,#1
0001f2  6821              LDR      r1,[r4,#0]
0001f4  60c8              STR      r0,[r1,#0xc]
;;;600        
;;;601        /* Disable all the QSPI Interrupts */
;;;602        __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
0001f6  6820              LDR      r0,[r4,#0]
0001f8  6800              LDR      r0,[r0,#0]
0001fa  f4202070          BIC      r0,r0,#0xf0000
0001fe  6821              LDR      r1,[r4,#0]
000200  6008              STR      r0,[r1,#0]
;;;603    
;;;604        /* Set error code */
;;;605        hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
000202  6be0              LDR      r0,[r4,#0x3c]
000204  f0400002          ORR      r0,r0,#2
000208  63e0              STR      r0,[r4,#0x3c]
;;;606        
;;;607        if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN)!= RESET)
00020a  6820              LDR      r0,[r4,#0]
00020c  6800              LDR      r0,[r0,#0]
00020e  f0000004          AND      r0,r0,#4
000212  b160              CBZ      r0,|L15.558|
;;;608        {
;;;609          /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
;;;610          CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
000214  6820              LDR      r0,[r4,#0]
000216  6800              LDR      r0,[r0,#0]
000218  f0200004          BIC      r0,r0,#4
00021c  6821              LDR      r1,[r4,#0]
00021e  6008              STR      r0,[r1,#0]
;;;611          
;;;612          /* Disable the DMA channel */
;;;613          hqspi->hdma->XferAbortCallback = QSPI_DMAAbortCplt;
000220  480d              LDR      r0,|L15.600|
000222  6b61              LDR      r1,[r4,#0x34]
000224  6508              STR      r0,[r1,#0x50]
;;;614          HAL_DMA_Abort_IT(hqspi->hdma);
000226  6b60              LDR      r0,[r4,#0x34]
000228  f7fffffe          BL       HAL_DMA_Abort_IT
00022c  e012              B        |L15.596|
                  |L15.558|
;;;615        }
;;;616        else
;;;617        {
;;;618          /* Change state of QSPI */
;;;619          hqspi->State = HAL_QSPI_STATE_READY;
00022e  2001              MOVS     r0,#1
000230  f8840039          STRB     r0,[r4,#0x39]
;;;620          
;;;621          /* Error callback */
;;;622          HAL_QSPI_ErrorCallback(hqspi);
000234  4620              MOV      r0,r4
000236  f7fffffe          BL       HAL_QSPI_ErrorCallback
00023a  e00b              B        |L15.596|
                  |L15.572|
;;;623        }
;;;624      }
;;;625    
;;;626      /* QSPI Timeout interrupt occurred -----------------------------------------*/
;;;627      else if(((flag & QSPI_FLAG_TO)!= RESET) && ((itsource & QSPI_IT_TO)!= RESET))
00023c  f0060010          AND      r0,r6,#0x10
000240  b140              CBZ      r0,|L15.596|
000242  f4071080          AND      r0,r7,#0x100000
000246  b128              CBZ      r0,|L15.596|
;;;628      {
;;;629        /* Clear interrupt */
;;;630        WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
000248  2010              MOVS     r0,#0x10
00024a  6821              LDR      r1,[r4,#0]
00024c  60c8              STR      r0,[r1,#0xc]
;;;631        
;;;632        /* Time out callback */
;;;633        HAL_QSPI_TimeOutCallback(hqspi);
00024e  4620              MOV      r0,r4
000250  f7fffffe          BL       HAL_QSPI_TimeOutCallback
                  |L15.596|
;;;634      }
;;;635    }
000254  e8bd81f0          POP      {r4-r8,pc}
;;;636    
                          ENDP

                  |L15.600|
                          DCD      QSPI_DMAAbortCplt

                          AREA ||i.HAL_QSPI_Init||, CODE, READONLY, ALIGN=2

                  HAL_QSPI_Init PROC
;;;250      */
;;;251    HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
000000  b5f8              PUSH     {r3-r7,lr}
;;;252    {
000002  4604              MOV      r4,r0
;;;253      HAL_StatusTypeDef status = HAL_ERROR;
000004  2501              MOVS     r5,#1
;;;254      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;255      
;;;256      /* Check the QSPI handle allocation */
;;;257      if(hqspi == NULL)
00000c  b90c              CBNZ     r4,|L16.18|
;;;258      {
;;;259        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L16.16|
;;;260      }
;;;261    
;;;262      /* Check the parameters */
;;;263      assert_param(IS_QSPI_ALL_INSTANCE(hqspi->Instance));
;;;264      assert_param(IS_QSPI_CLOCK_PRESCALER(hqspi->Init.ClockPrescaler));
;;;265      assert_param(IS_QSPI_FIFO_THRESHOLD(hqspi->Init.FifoThreshold));
;;;266      assert_param(IS_QSPI_SSHIFT(hqspi->Init.SampleShifting));
;;;267      assert_param(IS_QSPI_FLASH_SIZE(hqspi->Init.FlashSize));
;;;268      assert_param(IS_QSPI_CS_HIGH_TIME(hqspi->Init.ChipSelectHighTime));
;;;269      assert_param(IS_QSPI_CLOCK_MODE(hqspi->Init.ClockMode));
;;;270      assert_param(IS_QSPI_DUAL_FLASH_MODE(hqspi->Init.DualFlash));
;;;271    
;;;272      if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
;;;273      {
;;;274        assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
;;;275      }
;;;276      
;;;277      /* Process locked */
;;;278      __HAL_LOCK(hqspi);
;;;279        
;;;280      if(hqspi->State == HAL_QSPI_STATE_RESET)
;;;281      { 
;;;282        /* Allocate lock resource and initialize it */
;;;283        hqspi->Lock = HAL_UNLOCKED;
;;;284         
;;;285        /* Init the low level hardware : GPIO, CLOCK */
;;;286        HAL_QSPI_MspInit(hqspi);
;;;287                 
;;;288        /* Configure the default timeout for the QSPI memory access */
;;;289        HAL_QSPI_SetTimeout(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE);
;;;290      }
;;;291      
;;;292      /* Configure QSPI FIFO Threshold */
;;;293      MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, ((hqspi->Init.FifoThreshold - 1) << 8));
;;;294    
;;;295      /* Wait till BUSY flag reset */
;;;296      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
;;;297    
;;;298      if(status == HAL_OK)
;;;299      {
;;;300                    
;;;301        /* Configure QSPI Clock Prescaler and Sample Shift */
;;;302        MODIFY_REG(hqspi->Instance->CR,(QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM), ((hqspi->Init.ClockPrescaler << 24)| hqspi->Init.SampleShifting | hqspi->Init.FlashID| hqspi->Init.DualFlash ));
;;;303            
;;;304        /* Configure QSPI Flash Size, CS High Time and Clock Mode */
;;;305        MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE), 
;;;306                   ((hqspi->Init.FlashSize << 16) | hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));
;;;307        
;;;308        /* Enable the QSPI peripheral */
;;;309        __HAL_QSPI_ENABLE(hqspi);
;;;310      
;;;311        /* Set QSPI error code to none */
;;;312        hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;  
;;;313    
;;;314        /* Initialize the QSPI state */
;;;315        hqspi->State = HAL_QSPI_STATE_READY;
;;;316      }
;;;317      
;;;318      /* Release Lock */
;;;319      __HAL_UNLOCK(hqspi);
;;;320    
;;;321      /* Return function status */
;;;322      return status;
;;;323    }
000010  bdf8              POP      {r3-r7,pc}
                  |L16.18|
000012  6a20              LDR      r0,[r4,#0x20]         ;272
000014  2840              CMP      r0,#0x40              ;272
000016  d000              BEQ      |L16.26|
000018  bf00              NOP                            ;274
                  |L16.26|
00001a  bf00              NOP                            ;278
00001c  f8940038          LDRB     r0,[r4,#0x38]         ;278
000020  2801              CMP      r0,#1                 ;278
000022  d101              BNE      |L16.40|
000024  2002              MOVS     r0,#2                 ;278
000026  e7f3              B        |L16.16|
                  |L16.40|
000028  2001              MOVS     r0,#1                 ;278
00002a  f8840038          STRB     r0,[r4,#0x38]         ;278
00002e  bf00              NOP                            ;278
000030  f8940039          LDRB     r0,[r4,#0x39]         ;280
000034  b950              CBNZ     r0,|L16.76|
000036  2000              MOVS     r0,#0                 ;283
000038  f8840038          STRB     r0,[r4,#0x38]         ;283
00003c  4620              MOV      r0,r4                 ;286
00003e  f7fffffe          BL       HAL_QSPI_MspInit
000042  f2413188          MOV      r1,#0x1388            ;289
000046  4620              MOV      r0,r4                 ;289
000048  f7fffffe          BL       HAL_QSPI_SetTimeout
                  |L16.76|
00004c  6820              LDR      r0,[r4,#0]            ;293
00004e  6800              LDR      r0,[r0,#0]            ;293
000050  f42051f8          BIC      r1,r0,#0x1f00         ;293
000054  68a0              LDR      r0,[r4,#8]            ;293
000056  1e40              SUBS     r0,r0,#1              ;293
000058  ea412000          ORR      r0,r1,r0,LSL #8       ;293
00005c  6821              LDR      r1,[r4,#0]            ;293
00005e  6008              STR      r0,[r1,#0]            ;293
000060  6c20              LDR      r0,[r4,#0x40]         ;296
000062  4633              MOV      r3,r6                 ;296
000064  2200              MOVS     r2,#0                 ;296
000066  2120              MOVS     r1,#0x20              ;296
000068  9000              STR      r0,[sp,#0]            ;296
00006a  4620              MOV      r0,r4                 ;296
00006c  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000070  4605              MOV      r5,r0                 ;296
000072  bb35              CBNZ     r5,|L16.194|
000074  7921              LDRB     r1,[r4,#4]            ;302
000076  68e0              LDR      r0,[r4,#0xc]          ;302
000078  ea406001          ORR      r0,r0,r1,LSL #24      ;302
00007c  69e1              LDR      r1,[r4,#0x1c]         ;302
00007e  4308              ORRS     r0,r0,r1              ;302
000080  6a21              LDR      r1,[r4,#0x20]         ;302
000082  4308              ORRS     r0,r0,r1              ;302
000084  6821              LDR      r1,[r4,#0]            ;302
000086  6809              LDR      r1,[r1,#0]            ;302
000088  4a11              LDR      r2,|L16.208|
00008a  4011              ANDS     r1,r1,r2              ;302
00008c  4308              ORRS     r0,r0,r1              ;302
00008e  6821              LDR      r1,[r4,#0]            ;302
000090  6008              STR      r0,[r1,#0]            ;302
000092  8a20              LDRH     r0,[r4,#0x10]         ;305
000094  6961              LDR      r1,[r4,#0x14]         ;305
000096  ea414000          ORR      r0,r1,r0,LSL #16      ;305
00009a  69a1              LDR      r1,[r4,#0x18]         ;305
00009c  4308              ORRS     r0,r0,r1              ;305
00009e  6821              LDR      r1,[r4,#0]            ;305
0000a0  6849              LDR      r1,[r1,#4]            ;305
0000a2  4a0c              LDR      r2,|L16.212|
0000a4  4011              ANDS     r1,r1,r2              ;305
0000a6  4308              ORRS     r0,r0,r1              ;305
0000a8  6821              LDR      r1,[r4,#0]            ;305
0000aa  6048              STR      r0,[r1,#4]            ;305
0000ac  6820              LDR      r0,[r4,#0]            ;309
0000ae  6800              LDR      r0,[r0,#0]            ;309
0000b0  f0400001          ORR      r0,r0,#1              ;309
0000b4  6821              LDR      r1,[r4,#0]            ;309
0000b6  6008              STR      r0,[r1,#0]            ;309
0000b8  2000              MOVS     r0,#0                 ;312
0000ba  63e0              STR      r0,[r4,#0x3c]         ;312
0000bc  2001              MOVS     r0,#1                 ;315
0000be  f8840039          STRB     r0,[r4,#0x39]         ;315
                  |L16.194|
0000c2  bf00              NOP                            ;319
0000c4  2000              MOVS     r0,#0                 ;319
0000c6  f8840038          STRB     r0,[r4,#0x38]         ;319
0000ca  bf00              NOP                            ;319
0000cc  4628              MOV      r0,r5                 ;322
0000ce  e79f              B        |L16.16|
;;;324    
                          ENDP

                  |L16.208|
                          DCD      0x00ffff2f
                  |L16.212|
                          DCD      0xffe0f8fe

                          AREA ||i.HAL_QSPI_MemoryMapped||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_MemoryMapped PROC
;;;1607     */
;;;1608   HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1609   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1610     HAL_StatusTypeDef status = HAL_ERROR;
00000a  2701              MOVS     r7,#1
;;;1611     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;1612     
;;;1613     /* Check the parameters */
;;;1614     assert_param(IS_QSPI_INSTRUCTION_MODE(cmd->InstructionMode));
;;;1615     if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
000012  69a8              LDR      r0,[r5,#0x18]
000014  b100              CBZ      r0,|L17.24|
;;;1616     {
;;;1617     assert_param(IS_QSPI_INSTRUCTION(cmd->Instruction));
000016  bf00              NOP      
                  |L17.24|
;;;1618     }
;;;1619   
;;;1620     assert_param(IS_QSPI_ADDRESS_MODE(cmd->AddressMode));
;;;1621     if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000018  69e8              LDR      r0,[r5,#0x1c]
00001a  b100              CBZ      r0,|L17.30|
;;;1622     {
;;;1623       assert_param(IS_QSPI_ADDRESS_SIZE(cmd->AddressSize));
00001c  bf00              NOP      
                  |L17.30|
;;;1624     }
;;;1625   
;;;1626     assert_param(IS_QSPI_ALTERNATE_BYTES_MODE(cmd->AlternateByteMode));
;;;1627     if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
00001e  6a28              LDR      r0,[r5,#0x20]
000020  b100              CBZ      r0,|L17.36|
;;;1628     {
;;;1629       assert_param(IS_QSPI_ALTERNATE_BYTES_SIZE(cmd->AlternateBytesSize));
000022  bf00              NOP      
                  |L17.36|
;;;1630     }
;;;1631   
;;;1632     assert_param(IS_QSPI_DUMMY_CYCLES(cmd->DummyCycles));
;;;1633     assert_param(IS_QSPI_DATA_MODE(cmd->DataMode));
;;;1634   
;;;1635     assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
;;;1636     assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
;;;1637     assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));
;;;1638   
;;;1639     assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));
;;;1640     
;;;1641     /* Process locked */
;;;1642     __HAL_LOCK(hqspi);
000024  bf00              NOP      
000026  f8940038          LDRB     r0,[r4,#0x38]
00002a  2801              CMP      r0,#1
00002c  d102              BNE      |L17.52|
00002e  2002              MOVS     r0,#2
                  |L17.48|
;;;1643     
;;;1644     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1645     {
;;;1646       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1647       
;;;1648       /* Update state */
;;;1649       hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
;;;1650       
;;;1651       /* Wait till BUSY flag reset */
;;;1652       status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
;;;1653       
;;;1654       if (status == HAL_OK)
;;;1655       {
;;;1656         /* Configure QSPI: CR register with timeout counter enable */
;;;1657       MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
;;;1658   
;;;1659       if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
;;;1660         {
;;;1661           assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));
;;;1662           
;;;1663           /* Configure QSPI: LPTR register with the low-power timeout value */
;;;1664           WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
;;;1665           
;;;1666           /* Clear interrupt */
;;;1667           __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
;;;1668   
;;;1669           /* Enable the QSPI TimeOut Interrupt */
;;;1670           __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
;;;1671         }
;;;1672         
;;;1673         /* Call the configuration function */
;;;1674         QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
;;;1675       }
;;;1676     }
;;;1677     else
;;;1678     {
;;;1679       status = HAL_BUSY;   
;;;1680     }
;;;1681   
;;;1682     /* Process unlocked */
;;;1683     __HAL_UNLOCK(hqspi);
;;;1684     
;;;1685     /* Return function status */
;;;1686     return status;  
;;;1687   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L17.52|
000034  2001              MOVS     r0,#1                 ;1642
000036  f8840038          STRB     r0,[r4,#0x38]         ;1642
00003a  bf00              NOP                            ;1642
00003c  f8940039          LDRB     r0,[r4,#0x39]         ;1644
000040  2801              CMP      r0,#1                 ;1644
000042  d12c              BNE      |L17.158|
000044  2000              MOVS     r0,#0                 ;1646
000046  63e0              STR      r0,[r4,#0x3c]         ;1646
000048  2082              MOVS     r0,#0x82              ;1649
00004a  f8840039          STRB     r0,[r4,#0x39]         ;1649
00004e  6c20              LDR      r0,[r4,#0x40]         ;1652
000050  4643              MOV      r3,r8                 ;1652
000052  2200              MOVS     r2,#0                 ;1652
000054  2120              MOVS     r1,#0x20              ;1652
000056  9000              STR      r0,[sp,#0]            ;1652
000058  4620              MOV      r0,r4                 ;1652
00005a  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
00005e  4607              MOV      r7,r0                 ;1652
000060  b9f7              CBNZ     r7,|L17.160|
000062  6820              LDR      r0,[r4,#0]            ;1657
000064  6800              LDR      r0,[r0,#0]            ;1657
000066  f0200008          BIC      r0,r0,#8              ;1657
00006a  6871              LDR      r1,[r6,#4]            ;1657
00006c  4308              ORRS     r0,r0,r1              ;1657
00006e  6821              LDR      r1,[r4,#0]            ;1657
000070  6008              STR      r0,[r1,#0]            ;1657
000072  6870              LDR      r0,[r6,#4]            ;1659
000074  2808              CMP      r0,#8                 ;1659
000076  d10b              BNE      |L17.144|
000078  6830              LDR      r0,[r6,#0]            ;1664
00007a  6821              LDR      r1,[r4,#0]            ;1664
00007c  6308              STR      r0,[r1,#0x30]         ;1664
00007e  2010              MOVS     r0,#0x10              ;1667
000080  6821              LDR      r1,[r4,#0]            ;1667
000082  60c8              STR      r0,[r1,#0xc]          ;1667
000084  6820              LDR      r0,[r4,#0]            ;1670
000086  6800              LDR      r0,[r0,#0]            ;1670
000088  f4401080          ORR      r0,r0,#0x100000       ;1670
00008c  6821              LDR      r1,[r4,#0]            ;1670
00008e  6008              STR      r0,[r1,#0]            ;1670
                  |L17.144|
000090  f04f6240          MOV      r2,#0xc000000         ;1674
000094  4629              MOV      r1,r5                 ;1674
000096  4620              MOV      r0,r4                 ;1674
000098  f7fffffe          BL       QSPI_Config
00009c  e000              B        |L17.160|
                  |L17.158|
00009e  2702              MOVS     r7,#2                 ;1679
                  |L17.160|
0000a0  bf00              NOP                            ;1683
0000a2  2000              MOVS     r0,#0                 ;1683
0000a4  f8840038          STRB     r0,[r4,#0x38]         ;1683
0000a8  bf00              NOP                            ;1683
0000aa  4638              MOV      r0,r7                 ;1686
0000ac  e7c0              B        |L17.48|
;;;1688   
                          ENDP


                          AREA ||i.HAL_QSPI_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_MspDeInit PROC
;;;378      */
;;;379     __weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;380    {
;;;381      /* Prevent unused argument(s) compilation warning */
;;;382      UNUSED(hqspi);
;;;383      
;;;384      /* NOTE : This function should not be modified, when the callback is needed,
;;;385                the HAL_QSPI_MspDeInit can be implemented in the user file
;;;386       */ 
;;;387    }
;;;388    
                          ENDP


                          AREA ||i.HAL_QSPI_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_MspInit PROC
;;;363      */
;;;364     __weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;365    {
;;;366      /* Prevent unused argument(s) compilation warning */
;;;367      UNUSED(hqspi);
;;;368      
;;;369      /* NOTE : This function should not be modified, when the callback is needed,
;;;370                the HAL_QSPI_MspInit can be implemented in the user file
;;;371       */ 
;;;372    }
;;;373    
                          ENDP


                          AREA ||i.HAL_QSPI_Receive||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Receive PROC
;;;920      */
;;;921    HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;922    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;923      HAL_StatusTypeDef status = HAL_OK;
00000a  2500              MOVS     r5,#0
;;;924      uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;925      uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
000012  6820              LDR      r0,[r4,#0]
000014  f8d09018          LDR      r9,[r0,#0x18]
;;;926      __IO uint32_t *data_reg = &hqspi->Instance->DR;
000018  6820              LDR      r0,[r4,#0]
00001a  f1000a20          ADD      r10,r0,#0x20
;;;927    
;;;928      /* Process locked */
;;;929      __HAL_LOCK(hqspi);
00001e  bf00              NOP      
000020  f8940038          LDRB     r0,[r4,#0x38]
000024  2801              CMP      r0,#1
000026  d102              BNE      |L20.46|
000028  2002              MOVS     r0,#2
                  |L20.42|
;;;930      
;;;931      if(hqspi->State == HAL_QSPI_STATE_READY)
;;;932      {
;;;933        hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;934        if(pData != NULL )
;;;935        {
;;;936          /* Update state */
;;;937          hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
;;;938        
;;;939          /* Configure counters and size of the handle */
;;;940          hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
;;;941          hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
;;;942          hqspi->pRxBuffPtr = pData;
;;;943    
;;;944          /* Configure QSPI: CCR register with functional as indirect read */
;;;945          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
;;;946    
;;;947          /* Start the transfer by re-writing the address in AR register */
;;;948          WRITE_REG(hqspi->Instance->AR, addr_reg);
;;;949          
;;;950          while(hqspi->RxXferCount > 0)
;;;951          {
;;;952            /* Wait until FT or TC flag is set to read received data */
;;;953            status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
;;;954    
;;;955            if  (status != HAL_OK)
;;;956            { 
;;;957              break;
;;;958            }
;;;959    
;;;960            *hqspi->pRxBuffPtr++ = *(__IO uint8_t *)data_reg;
;;;961            hqspi->RxXferCount--;
;;;962          }
;;;963        
;;;964          if (status == HAL_OK)
;;;965          {
;;;966            /* Wait until TC flag is set to go back in idle state */
;;;967            status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
;;;968    
;;;969            if  (status == HAL_OK)
;;;970            {
;;;971              /* Clear Transfer Complete bit */
;;;972              __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
;;;973              
;;;974    #if defined(QSPI1_V1_0)
;;;975             /* Workaround - Extra data written in the FIFO at the end of a read transfer */
;;;976             status = HAL_QSPI_Abort(hqspi);
;;;977    #endif /* QSPI_V1_0 */  
;;;978            }
;;;979          }
;;;980    
;;;981          /* Update QSPI state */
;;;982          hqspi->State = HAL_QSPI_STATE_READY;    
;;;983        }
;;;984        else
;;;985        {
;;;986          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;987          status = HAL_ERROR;
;;;988        }
;;;989      }
;;;990      else
;;;991      {
;;;992        status = HAL_BUSY;
;;;993      }
;;;994      
;;;995      /* Process unlocked */
;;;996      __HAL_UNLOCK(hqspi);
;;;997    
;;;998      return status;
;;;999    }
00002a  e8bd8ff8          POP      {r3-r11,pc}
                  |L20.46|
00002e  2001              MOVS     r0,#1                 ;929
000030  f8840038          STRB     r0,[r4,#0x38]         ;929
000034  bf00              NOP                            ;929
000036  f8940039          LDRB     r0,[r4,#0x39]         ;931
00003a  2801              CMP      r0,#1                 ;931
00003c  d149              BNE      |L20.210|
00003e  2000              MOVS     r0,#0                 ;933
000040  63e0              STR      r0,[r4,#0x3c]         ;933
000042  2e00              CMP      r6,#0                 ;934
000044  d03f              BEQ      |L20.198|
000046  2022              MOVS     r0,#0x22              ;937
000048  f8840039          STRB     r0,[r4,#0x39]         ;937
00004c  6820              LDR      r0,[r4,#0]            ;940
00004e  6900              LDR      r0,[r0,#0x10]         ;940
000050  1c40              ADDS     r0,r0,#1              ;940
000052  8660              STRH     r0,[r4,#0x32]         ;940
000054  6820              LDR      r0,[r4,#0]            ;941
000056  6900              LDR      r0,[r0,#0x10]         ;941
000058  1c40              ADDS     r0,r0,#1              ;941
00005a  8620              STRH     r0,[r4,#0x30]         ;941
00005c  62e6              STR      r6,[r4,#0x2c]         ;942
00005e  6820              LDR      r0,[r4,#0]            ;945
000060  6940              LDR      r0,[r0,#0x14]         ;945
000062  f0206040          BIC      r0,r0,#0xc000000      ;945
000066  f0406080          ORR      r0,r0,#0x4000000      ;945
00006a  6821              LDR      r1,[r4,#0]            ;945
00006c  6148              STR      r0,[r1,#0x14]         ;945
00006e  6820              LDR      r0,[r4,#0]            ;948
000070  f8c09018          STR      r9,[r0,#0x18]         ;948
000074  e012              B        |L20.156|
                  |L20.118|
000076  4643              MOV      r3,r8                 ;953
000078  2201              MOVS     r2,#1                 ;953
00007a  2106              MOVS     r1,#6                 ;953
00007c  4620              MOV      r0,r4                 ;953
00007e  9700              STR      r7,[sp,#0]            ;953
000080  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000084  4605              MOV      r5,r0                 ;953
000086  b105              CBZ      r5,|L20.138|
000088  e00b              B        |L20.162|
                  |L20.138|
00008a  f89a1000          LDRB     r1,[r10,#0]           ;960
00008e  6ae2              LDR      r2,[r4,#0x2c]         ;960
000090  1c50              ADDS     r0,r2,#1              ;960
000092  62e0              STR      r0,[r4,#0x2c]         ;960
000094  7011              STRB     r1,[r2,#0]            ;960
000096  8e60              LDRH     r0,[r4,#0x32]         ;961
000098  1e40              SUBS     r0,r0,#1              ;961
00009a  8660              STRH     r0,[r4,#0x32]         ;961
                  |L20.156|
00009c  8e60              LDRH     r0,[r4,#0x32]         ;950
00009e  2800              CMP      r0,#0                 ;950
0000a0  dce9              BGT      |L20.118|
                  |L20.162|
0000a2  bf00              NOP                            ;957
0000a4  b95d              CBNZ     r5,|L20.190|
0000a6  4643              MOV      r3,r8                 ;967
0000a8  2201              MOVS     r2,#1                 ;967
0000aa  2102              MOVS     r1,#2                 ;967
0000ac  4620              MOV      r0,r4                 ;967
0000ae  9700              STR      r7,[sp,#0]            ;967
0000b0  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
0000b4  4605              MOV      r5,r0                 ;967
0000b6  b915              CBNZ     r5,|L20.190|
0000b8  2002              MOVS     r0,#2                 ;972
0000ba  6821              LDR      r1,[r4,#0]            ;972
0000bc  60c8              STR      r0,[r1,#0xc]          ;972
                  |L20.190|
0000be  2001              MOVS     r0,#1                 ;982
0000c0  f8840039          STRB     r0,[r4,#0x39]         ;982
0000c4  e006              B        |L20.212|
                  |L20.198|
0000c6  6be0              LDR      r0,[r4,#0x3c]         ;986
0000c8  f0400008          ORR      r0,r0,#8              ;986
0000cc  63e0              STR      r0,[r4,#0x3c]         ;986
0000ce  2501              MOVS     r5,#1                 ;987
0000d0  e000              B        |L20.212|
                  |L20.210|
0000d2  2502              MOVS     r5,#2                 ;992
                  |L20.212|
0000d4  bf00              NOP                            ;996
0000d6  2000              MOVS     r0,#0                 ;996
0000d8  f8840038          STRB     r0,[r4,#0x38]         ;996
0000dc  bf00              NOP                            ;996
0000de  4628              MOV      r0,r5                 ;998
0000e0  e7a3              B        |L20.42|
;;;1000   
                          ENDP


                          AREA ||i.HAL_QSPI_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_QSPI_Receive_DMA PROC
;;;1269     */
;;;1270   HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;1271   {
000004  4604              MOV      r4,r0
;;;1272     HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;1273     uint32_t *tmp;
;;;1274     uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
000008  6820              LDR      r0,[r4,#0]
00000a  f8d08018          LDR      r8,[r0,#0x18]
;;;1275     uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1);
00000e  6820              LDR      r0,[r4,#0]
000010  6900              LDR      r0,[r0,#0x10]
000012  1c45              ADDS     r5,r0,#1
;;;1276     
;;;1277     /* Process locked */
;;;1278     __HAL_LOCK(hqspi);
000014  bf00              NOP      
000016  f8940038          LDRB     r0,[r4,#0x38]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L21.36|
00001e  2002              MOVS     r0,#2
                  |L21.32|
;;;1279     
;;;1280     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1281     {
;;;1282       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1283       
;;;1284       if(pData != NULL ) 
;;;1285       {
;;;1286         /* Configure counters of the handle */
;;;1287         if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_BYTE)
;;;1288         {
;;;1289           hqspi->RxXferCount = data_size;
;;;1290         }
;;;1291         else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_HALFWORD)
;;;1292         {
;;;1293           if (((data_size % 2) != 0) || ((hqspi->Init.FifoThreshold % 2) != 0))
;;;1294           {
;;;1295             /* The number of data or the fifo threshold is not aligned on halfword 
;;;1296             => no transfer possible with DMA peripheral access configured as halfword */
;;;1297             hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1298             status = HAL_ERROR;
;;;1299             
;;;1300             /* Process unlocked */
;;;1301             __HAL_UNLOCK(hqspi);
;;;1302           }
;;;1303           else
;;;1304           {
;;;1305             hqspi->RxXferCount = (data_size >> 1);
;;;1306           }
;;;1307         }
;;;1308         else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_WORD)
;;;1309         {
;;;1310           if (((data_size % 4) != 0) || ((hqspi->Init.FifoThreshold % 4) != 0))
;;;1311           {
;;;1312             /* The number of data or the fifo threshold is not aligned on word 
;;;1313             => no transfer possible with DMA peripheral access configured as word */
;;;1314             hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1315             status = HAL_ERROR;
;;;1316             
;;;1317             /* Process unlocked */
;;;1318             __HAL_UNLOCK(hqspi);
;;;1319           }
;;;1320           else
;;;1321           {
;;;1322             hqspi->RxXferCount = (data_size >> 2);
;;;1323           }
;;;1324         }
;;;1325         
;;;1326         if (status == HAL_OK)
;;;1327         {
;;;1328           
;;;1329           /* Update state */
;;;1330           hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
;;;1331           
;;;1332           /* Clear interrupt */
;;;1333           __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
;;;1334           
;;;1335           /* Configure size and pointer of the handle */
;;;1336           hqspi->RxXferSize = hqspi->RxXferCount;
;;;1337           hqspi->pRxBuffPtr = pData;
;;;1338           
;;;1339           /* Set the QSPI DMA transfer complete callback */
;;;1340           hqspi->hdma->XferCpltCallback = QSPI_DMARxCplt;
;;;1341           
;;;1342           /* Set the QSPI DMA Half transfer complete callback */
;;;1343           hqspi->hdma->XferHalfCpltCallback = QSPI_DMARxHalfCplt;
;;;1344           
;;;1345           /* Set the DMA error callback */
;;;1346           hqspi->hdma->XferErrorCallback = QSPI_DMAError;
;;;1347           
;;;1348           /* Clear the DMA abort callback */      
;;;1349           hqspi->hdma->XferAbortCallback = NULL;
;;;1350           
;;;1351           /* Configure the direction of the DMA */
;;;1352           hqspi->hdma->Init.Direction = DMA_PERIPH_TO_MEMORY;
;;;1353           MODIFY_REG(hqspi->hdma->Instance->CR, DMA_SxCR_DIR, hqspi->hdma->Init.Direction);
;;;1354           
;;;1355           /* Enable the DMA Channel */
;;;1356           tmp = (uint32_t*)&pData;
;;;1357           HAL_DMA_Start_IT(hqspi->hdma, (uint32_t)&hqspi->Instance->DR, *(uint32_t*)tmp, hqspi->RxXferSize);
;;;1358           
;;;1359           /* Configure QSPI: CCR register with functional as indirect read */
;;;1360           MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
;;;1361           
;;;1362           /* Start the transfer by re-writing the address in AR register */
;;;1363           WRITE_REG(hqspi->Instance->AR, addr_reg);
;;;1364           
;;;1365           /* Process unlocked */
;;;1366           __HAL_UNLOCK(hqspi);
;;;1367           
;;;1368           /* Enable the QSPI transfer error Interrupt */
;;;1369           __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
;;;1370           
;;;1371           /* Enable the DMA transfer by setting the DMAEN bit in the QSPI CR register */
;;;1372           SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
;;;1373         }
;;;1374       }
;;;1375       else
;;;1376       {
;;;1377         hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1378         status = HAL_ERROR;
;;;1379         
;;;1380         /* Process unlocked */
;;;1381         __HAL_UNLOCK(hqspi);
;;;1382       }
;;;1383     }
;;;1384     else
;;;1385     {
;;;1386       status = HAL_BUSY; 
;;;1387       
;;;1388       /* Process unlocked */
;;;1389       __HAL_UNLOCK(hqspi);
;;;1390     }
;;;1391     
;;;1392     return status;
;;;1393   }
000020  e8bd81fc          POP      {r2-r8,pc}
                  |L21.36|
000024  2001              MOVS     r0,#1                 ;1278
000026  f8840038          STRB     r0,[r4,#0x38]         ;1278
00002a  bf00              NOP                            ;1278
00002c  f8940039          LDRB     r0,[r4,#0x39]         ;1280
000030  2801              CMP      r0,#1                 ;1280
000032  d17d              BNE      |L21.304|
000034  2000              MOVS     r0,#0                 ;1282
000036  63e0              STR      r0,[r4,#0x3c]         ;1282
000038  9801              LDR      r0,[sp,#4]            ;1284
00003a  2800              CMP      r0,#0                 ;1284
00003c  d079              BEQ      |L21.306|
00003e  6b60              LDR      r0,[r4,#0x34]         ;1287
000040  6940              LDR      r0,[r0,#0x14]         ;1287
000042  b908              CBNZ     r0,|L21.72|
000044  8665              STRH     r5,[r4,#0x32]         ;1289
000046  e032              B        |L21.174|
                  |L21.72|
000048  6b60              LDR      r0,[r4,#0x34]         ;1291
00004a  6940              LDR      r0,[r0,#0x14]         ;1291
00004c  f5b06f00          CMP      r0,#0x800             ;1291
000050  d114              BNE      |L21.124|
000052  f0050001          AND      r0,r5,#1              ;1293
000056  b918              CBNZ     r0,|L21.96|
000058  7a20              LDRB     r0,[r4,#8]            ;1293
00005a  f0000001          AND      r0,r0,#1              ;1293
00005e  b148              CBZ      r0,|L21.116|
                  |L21.96|
000060  6be0              LDR      r0,[r4,#0x3c]         ;1297
000062  f0400008          ORR      r0,r0,#8              ;1297
000066  63e0              STR      r0,[r4,#0x3c]         ;1297
000068  2601              MOVS     r6,#1                 ;1298
00006a  bf00              NOP                            ;1301
00006c  2000              MOVS     r0,#0                 ;1301
00006e  f8840038          STRB     r0,[r4,#0x38]         ;1301
000072  e01c              B        |L21.174|
                  |L21.116|
000074  f3c5004f          UBFX     r0,r5,#1,#16          ;1305
000078  8660              STRH     r0,[r4,#0x32]         ;1305
00007a  e018              B        |L21.174|
                  |L21.124|
00007c  6b60              LDR      r0,[r4,#0x34]         ;1308
00007e  6940              LDR      r0,[r0,#0x14]         ;1308
000080  f5b05f80          CMP      r0,#0x1000            ;1308
000084  d113              BNE      |L21.174|
000086  f0050003          AND      r0,r5,#3              ;1310
00008a  b918              CBNZ     r0,|L21.148|
00008c  7a20              LDRB     r0,[r4,#8]            ;1310
00008e  f0000003          AND      r0,r0,#3              ;1310
000092  b148              CBZ      r0,|L21.168|
                  |L21.148|
000094  6be0              LDR      r0,[r4,#0x3c]         ;1314
000096  f0400008          ORR      r0,r0,#8              ;1314
00009a  63e0              STR      r0,[r4,#0x3c]         ;1314
00009c  2601              MOVS     r6,#1                 ;1315
00009e  bf00              NOP                            ;1318
0000a0  2000              MOVS     r0,#0                 ;1318
0000a2  f8840038          STRB     r0,[r4,#0x38]         ;1318
0000a6  e002              B        |L21.174|
                  |L21.168|
0000a8  f3c5008f          UBFX     r0,r5,#2,#16          ;1322
0000ac  8660              STRH     r0,[r4,#0x32]         ;1322
                  |L21.174|
0000ae  2e00              CMP      r6,#0                 ;1326
0000b0  d15d              BNE      |L21.366|
0000b2  2022              MOVS     r0,#0x22              ;1330
0000b4  f8840039          STRB     r0,[r4,#0x39]         ;1330
0000b8  2003              MOVS     r0,#3                 ;1333
0000ba  6821              LDR      r1,[r4,#0]            ;1333
0000bc  60c8              STR      r0,[r1,#0xc]          ;1333
0000be  8e60              LDRH     r0,[r4,#0x32]         ;1336
0000c0  8620              STRH     r0,[r4,#0x30]         ;1336
0000c2  9801              LDR      r0,[sp,#4]            ;1337
0000c4  62e0              STR      r0,[r4,#0x2c]         ;1337
0000c6  482b              LDR      r0,|L21.372|
0000c8  6b61              LDR      r1,[r4,#0x34]         ;1340
0000ca  63c8              STR      r0,[r1,#0x3c]         ;1340
0000cc  482a              LDR      r0,|L21.376|
0000ce  6b61              LDR      r1,[r4,#0x34]         ;1343
0000d0  6408              STR      r0,[r1,#0x40]         ;1343
0000d2  482a              LDR      r0,|L21.380|
0000d4  6b61              LDR      r1,[r4,#0x34]         ;1346
0000d6  64c8              STR      r0,[r1,#0x4c]         ;1346
0000d8  2000              MOVS     r0,#0                 ;1349
0000da  6b61              LDR      r1,[r4,#0x34]         ;1349
0000dc  6508              STR      r0,[r1,#0x50]         ;1349
0000de  2100              MOVS     r1,#0                 ;1352
0000e0  6b60              LDR      r0,[r4,#0x34]         ;1352
0000e2  6081              STR      r1,[r0,#8]            ;1352
0000e4  6b60              LDR      r0,[r4,#0x34]         ;1353
0000e6  6800              LDR      r0,[r0,#0]            ;1353
0000e8  6800              LDR      r0,[r0,#0]            ;1353
0000ea  f02000c0          BIC      r0,r0,#0xc0           ;1353
0000ee  6b61              LDR      r1,[r4,#0x34]         ;1353
0000f0  6889              LDR      r1,[r1,#8]            ;1353
0000f2  4308              ORRS     r0,r0,r1              ;1353
0000f4  6b61              LDR      r1,[r4,#0x34]         ;1353
0000f6  6809              LDR      r1,[r1,#0]            ;1353
0000f8  6008              STR      r0,[r1,#0]            ;1353
0000fa  af01              ADD      r7,sp,#4              ;1356
0000fc  8e23              LDRH     r3,[r4,#0x30]         ;1357
0000fe  683a              LDR      r2,[r7,#0]            ;1357
000100  f8d4c000          LDR      r12,[r4,#0]           ;1357
000104  f10c0120          ADD      r1,r12,#0x20          ;1357
000108  6b60              LDR      r0,[r4,#0x34]         ;1357
00010a  f7fffffe          BL       HAL_DMA_Start_IT
00010e  6820              LDR      r0,[r4,#0]            ;1360
000110  6940              LDR      r0,[r0,#0x14]         ;1360
000112  f0206040          BIC      r0,r0,#0xc000000      ;1360
000116  f0406080          ORR      r0,r0,#0x4000000      ;1360
00011a  6821              LDR      r1,[r4,#0]            ;1360
00011c  6148              STR      r0,[r1,#0x14]         ;1360
00011e  6820              LDR      r0,[r4,#0]            ;1363
000120  f8c08018          STR      r8,[r0,#0x18]         ;1363
000124  bf00              NOP                            ;1366
000126  2000              MOVS     r0,#0                 ;1366
000128  f8840038          STRB     r0,[r4,#0x38]         ;1366
00012c  bf00              NOP                            ;1366
00012e  e001              B        |L21.308|
                  |L21.304|
000130  e017              B        |L21.354|
                  |L21.306|
000132  e00c              B        |L21.334|
                  |L21.308|
000134  6820              LDR      r0,[r4,#0]            ;1369
000136  6800              LDR      r0,[r0,#0]            ;1369
000138  f4403080          ORR      r0,r0,#0x10000        ;1369
00013c  6821              LDR      r1,[r4,#0]            ;1369
00013e  6008              STR      r0,[r1,#0]            ;1369
000140  6820              LDR      r0,[r4,#0]            ;1372
000142  6800              LDR      r0,[r0,#0]            ;1372
000144  f0400004          ORR      r0,r0,#4              ;1372
000148  6821              LDR      r1,[r4,#0]            ;1372
00014a  6008              STR      r0,[r1,#0]            ;1372
00014c  e00f              B        |L21.366|
                  |L21.334|
00014e  6be0              LDR      r0,[r4,#0x3c]         ;1377
000150  f0400008          ORR      r0,r0,#8              ;1377
000154  63e0              STR      r0,[r4,#0x3c]         ;1377
000156  2601              MOVS     r6,#1                 ;1378
000158  bf00              NOP                            ;1381
00015a  2000              MOVS     r0,#0                 ;1381
00015c  f8840038          STRB     r0,[r4,#0x38]         ;1381
000160  e005              B        |L21.366|
                  |L21.354|
000162  2602              MOVS     r6,#2                 ;1386
000164  bf00              NOP                            ;1389
000166  2000              MOVS     r0,#0                 ;1389
000168  f8840038          STRB     r0,[r4,#0x38]         ;1389
00016c  bf00              NOP                            ;1389
                  |L21.366|
00016e  4630              MOV      r0,r6                 ;1392
000170  e756              B        |L21.32|
;;;1394   
                          ENDP

000172  0000              DCW      0x0000
                  |L21.372|
                          DCD      QSPI_DMARxCplt
                  |L21.376|
                          DCD      QSPI_DMARxHalfCplt
                  |L21.380|
                          DCD      QSPI_DMAError

                          AREA ||i.HAL_QSPI_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Receive_IT PROC
;;;1067     */
;;;1068   HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
000000  b530              PUSH     {r4,r5,lr}
;;;1069   {
000002  4602              MOV      r2,r0
;;;1070     HAL_StatusTypeDef status = HAL_OK;
000004  2300              MOVS     r3,#0
;;;1071     uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
000006  6810              LDR      r0,[r2,#0]
000008  6984              LDR      r4,[r0,#0x18]
;;;1072     
;;;1073     /* Process locked */
;;;1074     __HAL_LOCK(hqspi);
00000a  bf00              NOP      
00000c  f8920038          LDRB     r0,[r2,#0x38]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L22.24|
000014  2002              MOVS     r0,#2
                  |L22.22|
;;;1075   
;;;1076     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1077     {
;;;1078       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1079       
;;;1080       if(pData != NULL )
;;;1081       {
;;;1082         /* Update state */
;;;1083         hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
;;;1084       
;;;1085         /* Configure counters and size of the handle */
;;;1086         hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
;;;1087         hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
;;;1088         hqspi->pRxBuffPtr = pData;
;;;1089   
;;;1090         /* Configure QSPI: CCR register with functional as indirect read */
;;;1091         MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
;;;1092   
;;;1093         /* Start the transfer by re-writing the address in AR register */
;;;1094         WRITE_REG(hqspi->Instance->AR, addr_reg);
;;;1095   
;;;1096         /* Clear interrupt */
;;;1097         __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
;;;1098   
;;;1099         /* Process unlocked */
;;;1100         __HAL_UNLOCK(hqspi);
;;;1101   
;;;1102         /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
;;;1103         __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
;;;1104       }
;;;1105       else
;;;1106       {
;;;1107         hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1108         status = HAL_ERROR;
;;;1109   
;;;1110         /* Process unlocked */
;;;1111         __HAL_UNLOCK(hqspi);
;;;1112       }
;;;1113     }
;;;1114     else
;;;1115     {
;;;1116       status = HAL_BUSY;   
;;;1117   
;;;1118       /* Process unlocked */
;;;1119       __HAL_UNLOCK(hqspi);
;;;1120     }
;;;1121   
;;;1122     return status;
;;;1123   }
000016  bd30              POP      {r4,r5,pc}
                  |L22.24|
000018  2001              MOVS     r0,#1                 ;1074
00001a  f8820038          STRB     r0,[r2,#0x38]         ;1074
00001e  bf00              NOP                            ;1074
000020  f8920039          LDRB     r0,[r2,#0x39]         ;1076
000024  2801              CMP      r0,#1                 ;1076
000026  d131              BNE      |L22.140|
000028  2000              MOVS     r0,#0                 ;1078
00002a  63d0              STR      r0,[r2,#0x3c]         ;1078
00002c  b321              CBZ      r1,|L22.120|
00002e  2022              MOVS     r0,#0x22              ;1083
000030  f8820039          STRB     r0,[r2,#0x39]         ;1083
000034  6810              LDR      r0,[r2,#0]            ;1086
000036  6900              LDR      r0,[r0,#0x10]         ;1086
000038  1c40              ADDS     r0,r0,#1              ;1086
00003a  8650              STRH     r0,[r2,#0x32]         ;1086
00003c  6810              LDR      r0,[r2,#0]            ;1087
00003e  6900              LDR      r0,[r0,#0x10]         ;1087
000040  1c40              ADDS     r0,r0,#1              ;1087
000042  8610              STRH     r0,[r2,#0x30]         ;1087
000044  62d1              STR      r1,[r2,#0x2c]         ;1088
000046  6810              LDR      r0,[r2,#0]            ;1091
000048  6940              LDR      r0,[r0,#0x14]         ;1091
00004a  f0206040          BIC      r0,r0,#0xc000000      ;1091
00004e  f0406080          ORR      r0,r0,#0x4000000      ;1091
000052  6815              LDR      r5,[r2,#0]            ;1091
000054  6168              STR      r0,[r5,#0x14]         ;1091
000056  6810              LDR      r0,[r2,#0]            ;1094
000058  6184              STR      r4,[r0,#0x18]         ;1094
00005a  2003              MOVS     r0,#3                 ;1097
00005c  6815              LDR      r5,[r2,#0]            ;1097
00005e  60e8              STR      r0,[r5,#0xc]          ;1097
000060  bf00              NOP                            ;1100
000062  2000              MOVS     r0,#0                 ;1100
000064  f8820038          STRB     r0,[r2,#0x38]         ;1100
000068  bf00              NOP                            ;1100
00006a  6810              LDR      r0,[r2,#0]            ;1103
00006c  6800              LDR      r0,[r0,#0]            ;1103
00006e  f44020e0          ORR      r0,r0,#0x70000        ;1103
000072  6815              LDR      r5,[r2,#0]            ;1103
000074  6028              STR      r0,[r5,#0]            ;1103
000076  e00f              B        |L22.152|
                  |L22.120|
000078  6bd0              LDR      r0,[r2,#0x3c]         ;1107
00007a  f0400008          ORR      r0,r0,#8              ;1107
00007e  63d0              STR      r0,[r2,#0x3c]         ;1107
000080  2301              MOVS     r3,#1                 ;1108
000082  bf00              NOP                            ;1111
000084  2000              MOVS     r0,#0                 ;1111
000086  f8820038          STRB     r0,[r2,#0x38]         ;1111
00008a  e005              B        |L22.152|
                  |L22.140|
00008c  2302              MOVS     r3,#2                 ;1116
00008e  bf00              NOP                            ;1119
000090  2000              MOVS     r0,#0                 ;1119
000092  f8820038          STRB     r0,[r2,#0x38]         ;1119
000096  bf00              NOP                            ;1119
                  |L22.152|
000098  4618              MOV      r0,r3                 ;1122
00009a  e7bc              B        |L22.22|
;;;1124   
                          ENDP


                          AREA ||i.HAL_QSPI_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_RxCpltCallback PROC
;;;1738     */
;;;1739   __weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1740   {
;;;1741     /* Prevent unused argument(s) compilation warning */
;;;1742     UNUSED(hqspi);
;;;1743     
;;;1744     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1745              the HAL_QSPI_RxCpltCallback could be implemented in the user file
;;;1746      */
;;;1747   }
;;;1748   
                          ENDP


                          AREA ||i.HAL_QSPI_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_RxHalfCpltCallback PROC
;;;1768     */
;;;1769   __weak void HAL_QSPI_RxHalfCpltCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1770   {
;;;1771     /* Prevent unused argument(s) compilation warning */
;;;1772     UNUSED(hqspi);
;;;1773     
;;;1774     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1775              the HAL_QSPI_RxHalfCpltCallback could be implemented in the user file
;;;1776      */
;;;1777   }
;;;1778   
                          ENDP


                          AREA ||i.HAL_QSPI_SetFifoThreshold||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_SetFifoThreshold PROC
;;;1994     */
;;;1995   HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
000000  b530              PUSH     {r4,r5,lr}
;;;1996   {
000002  4602              MOV      r2,r0
;;;1997     HAL_StatusTypeDef status = HAL_OK;
000004  2300              MOVS     r3,#0
;;;1998   
;;;1999     /* Process locked */
;;;2000     __HAL_LOCK(hqspi);
000006  bf00              NOP      
000008  f8920038          LDRB     r0,[r2,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L25.20|
000010  2002              MOVS     r0,#2
                  |L25.18|
;;;2001   
;;;2002     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;2003     {
;;;2004       /* Synchronize init structure with new FIFO threshold value */
;;;2005       hqspi->Init.FifoThreshold = Threshold;
;;;2006       
;;;2007       /* Configure QSPI FIFO Threshold */
;;;2008       MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES, 
;;;2009                  ((hqspi->Init.FifoThreshold - 1) << POSITION_VAL(QUADSPI_CR_FTHRES)));
;;;2010     }
;;;2011     else
;;;2012     {
;;;2013       status = HAL_BUSY;   
;;;2014     }
;;;2015     
;;;2016     /* Process unlocked */
;;;2017     __HAL_UNLOCK(hqspi);
;;;2018   
;;;2019     /* Return function status */
;;;2020     return status;
;;;2021   }
000012  bd30              POP      {r4,r5,pc}
                  |L25.20|
000014  2001              MOVS     r0,#1                 ;2000
000016  f8820038          STRB     r0,[r2,#0x38]         ;2000
00001a  bf00              NOP                            ;2000
00001c  f8920039          LDRB     r0,[r2,#0x39]         ;2002
000020  2801              CMP      r0,#1                 ;2002
000022  d111              BNE      |L25.72|
000024  6091              STR      r1,[r2,#8]            ;2005
000026  6810              LDR      r0,[r2,#0]            ;2008
000028  6800              LDR      r0,[r0,#0]            ;2008
00002a  f42054f8          BIC      r4,r0,#0x1f00         ;2008
00002e  6890              LDR      r0,[r2,#8]            ;2008
000030  1e40              SUBS     r0,r0,#1              ;2008
000032  f44f55f8          MOV      r5,#0x1f00            ;2008
000036  fa95f5a5          RBIT     r5,r5                 ;2008
00003a  fab5f585          CLZ      r5,r5                 ;2008
00003e  40a8              LSLS     r0,r0,r5              ;2008
000040  4304              ORRS     r4,r4,r0              ;2008
000042  6810              LDR      r0,[r2,#0]            ;2008
000044  6004              STR      r4,[r0,#0]            ;2008
000046  e000              B        |L25.74|
                  |L25.72|
000048  2302              MOVS     r3,#2                 ;2013
                  |L25.74|
00004a  bf00              NOP                            ;2017
00004c  2000              MOVS     r0,#0                 ;2017
00004e  f8820038          STRB     r0,[r2,#0x38]         ;2017
000052  bf00              NOP                            ;2017
000054  4618              MOV      r0,r3                 ;2020
000056  e7dc              B        |L25.18|
;;;2022   
                          ENDP


                          AREA ||i.HAL_QSPI_SetTimeout||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_SetTimeout PROC
;;;1984     */
;;;1985   void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
000000  6401              STR      r1,[r0,#0x40]
;;;1986   {
;;;1987     hqspi->Timeout = Timeout;
;;;1988   }
000002  4770              BX       lr
;;;1989   
                          ENDP


                          AREA ||i.HAL_QSPI_StatusMatchCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_StatusMatchCallback PROC
;;;1813     */
;;;1814   __weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1815   {
;;;1816     /* Prevent unused argument(s) compilation warning */
;;;1817     UNUSED(hqspi);
;;;1818       
;;;1819     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1820               the HAL_QSPI_StatusMatchCallback could be implemented in the user file
;;;1821      */
;;;1822   }
;;;1823   
                          ENDP


                          AREA ||i.HAL_QSPI_TimeOutCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_TimeOutCallback PROC
;;;1828     */
;;;1829   __weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1830   {
;;;1831     /* Prevent unused argument(s) compilation warning */
;;;1832     UNUSED(hqspi);
;;;1833     
;;;1834     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1835               the HAL_QSPI_TimeOutCallback could be implemented in the user file
;;;1836      */
;;;1837   }
;;;1838   
                          ENDP


                          AREA ||i.HAL_QSPI_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Transmit PROC
;;;834      */
;;;835    HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;836    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;837       HAL_StatusTypeDef status = HAL_OK;
00000a  2500              MOVS     r5,#0
;;;838      uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;839      __IO uint32_t *data_reg = &hqspi->Instance->DR;
000012  6820              LDR      r0,[r4,#0]
000014  f1000920          ADD      r9,r0,#0x20
;;;840    
;;;841      /* Process locked */
;;;842      __HAL_LOCK(hqspi);
000018  bf00              NOP      
00001a  f8940038          LDRB     r0,[r4,#0x38]
00001e  2801              CMP      r0,#1
000020  d102              BNE      |L29.40|
000022  2002              MOVS     r0,#2
                  |L29.36|
;;;843    
;;;844      if(hqspi->State == HAL_QSPI_STATE_READY)
;;;845      {
;;;846        hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;847    
;;;848        if(pData != NULL )
;;;849        {
;;;850          /* Update state */
;;;851          hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
;;;852          
;;;853          /* Configure counters and size of the handle */
;;;854          hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
;;;855          hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
;;;856          hqspi->pTxBuffPtr = pData;
;;;857        
;;;858          /* Configure QSPI: CCR register with functional as indirect write */
;;;859          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
;;;860    
;;;861          while(hqspi->TxXferCount > 0)
;;;862          {
;;;863            /* Wait until FT flag is set to send data */
;;;864            status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
;;;865    
;;;866            if (status != HAL_OK)
;;;867            { 
;;;868              break;
;;;869            }
;;;870    
;;;871            *(__IO uint8_t *)data_reg = *hqspi->pTxBuffPtr++;
;;;872            hqspi->TxXferCount--;
;;;873          }
;;;874        
;;;875          if (status == HAL_OK)
;;;876          {
;;;877            /* Wait until TC flag is set to go back in idle state */
;;;878            status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
;;;879    
;;;880            if (status == HAL_OK)
;;;881            {
;;;882              /* Clear Transfer Complete bit */
;;;883              __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
;;;884              
;;;885    #if defined(QSPI1_V1_0)
;;;886              /* Clear Busy bit */
;;;887              status = HAL_QSPI_Abort(hqspi);
;;;888    #endif /* QSPI_V1_0 */ 
;;;889            }
;;;890          }
;;;891        
;;;892          /* Update QSPI state */
;;;893          hqspi->State = HAL_QSPI_STATE_READY;    
;;;894        }
;;;895        else
;;;896        {
;;;897          hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;898          status = HAL_ERROR;
;;;899        }
;;;900      }
;;;901      else
;;;902      {
;;;903        status = HAL_BUSY;
;;;904      }
;;;905    
;;;906      /* Process unlocked */
;;;907      __HAL_UNLOCK(hqspi);
;;;908    
;;;909      return status;
;;;910    }
000024  e8bd83f8          POP      {r3-r9,pc}
                  |L29.40|
000028  2001              MOVS     r0,#1                 ;842
00002a  f8840038          STRB     r0,[r4,#0x38]         ;842
00002e  bf00              NOP                            ;842
000030  f8940039          LDRB     r0,[r4,#0x39]         ;844
000034  2801              CMP      r0,#1                 ;844
000036  d144              BNE      |L29.194|
000038  2000              MOVS     r0,#0                 ;846
00003a  63e0              STR      r0,[r4,#0x3c]         ;846
00003c  2e00              CMP      r6,#0                 ;848
00003e  d03a              BEQ      |L29.182|
000040  2012              MOVS     r0,#0x12              ;851
000042  f8840039          STRB     r0,[r4,#0x39]         ;851
000046  6820              LDR      r0,[r4,#0]            ;854
000048  6900              LDR      r0,[r0,#0x10]         ;854
00004a  1c40              ADDS     r0,r0,#1              ;854
00004c  8560              STRH     r0,[r4,#0x2a]         ;854
00004e  6820              LDR      r0,[r4,#0]            ;855
000050  6900              LDR      r0,[r0,#0x10]         ;855
000052  1c40              ADDS     r0,r0,#1              ;855
000054  8520              STRH     r0,[r4,#0x28]         ;855
000056  6266              STR      r6,[r4,#0x24]         ;856
000058  6820              LDR      r0,[r4,#0]            ;859
00005a  6940              LDR      r0,[r0,#0x14]         ;859
00005c  f0206040          BIC      r0,r0,#0xc000000      ;859
000060  6821              LDR      r1,[r4,#0]            ;859
000062  6148              STR      r0,[r1,#0x14]         ;859
000064  e012              B        |L29.140|
                  |L29.102|
000066  4643              MOV      r3,r8                 ;864
000068  2201              MOVS     r2,#1                 ;864
00006a  2104              MOVS     r1,#4                 ;864
00006c  4620              MOV      r0,r4                 ;864
00006e  9700              STR      r7,[sp,#0]            ;864
000070  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
000074  4605              MOV      r5,r0                 ;864
000076  b105              CBZ      r5,|L29.122|
000078  e00b              B        |L29.146|
                  |L29.122|
00007a  6a61              LDR      r1,[r4,#0x24]         ;871
00007c  1c48              ADDS     r0,r1,#1              ;871
00007e  6260              STR      r0,[r4,#0x24]         ;871
000080  7808              LDRB     r0,[r1,#0]            ;871
000082  f8890000          STRB     r0,[r9,#0]            ;871
000086  8d60              LDRH     r0,[r4,#0x2a]         ;872
000088  1e40              SUBS     r0,r0,#1              ;872
00008a  8560              STRH     r0,[r4,#0x2a]         ;872
                  |L29.140|
00008c  8d60              LDRH     r0,[r4,#0x2a]         ;861
00008e  2800              CMP      r0,#0                 ;861
000090  dce9              BGT      |L29.102|
                  |L29.146|
000092  bf00              NOP                            ;868
000094  b95d              CBNZ     r5,|L29.174|
000096  4643              MOV      r3,r8                 ;878
000098  2201              MOVS     r2,#1                 ;878
00009a  2102              MOVS     r1,#2                 ;878
00009c  4620              MOV      r0,r4                 ;878
00009e  9700              STR      r7,[sp,#0]            ;878
0000a0  f7fffffe          BL       QSPI_WaitFlagStateUntilTimeout
0000a4  4605              MOV      r5,r0                 ;878
0000a6  b915              CBNZ     r5,|L29.174|
0000a8  2002              MOVS     r0,#2                 ;883
0000aa  6821              LDR      r1,[r4,#0]            ;883
0000ac  60c8              STR      r0,[r1,#0xc]          ;883
                  |L29.174|
0000ae  2001              MOVS     r0,#1                 ;893
0000b0  f8840039          STRB     r0,[r4,#0x39]         ;893
0000b4  e006              B        |L29.196|
                  |L29.182|
0000b6  6be0              LDR      r0,[r4,#0x3c]         ;897
0000b8  f0400008          ORR      r0,r0,#8              ;897
0000bc  63e0              STR      r0,[r4,#0x3c]         ;897
0000be  2501              MOVS     r5,#1                 ;898
0000c0  e000              B        |L29.196|
                  |L29.194|
0000c2  2502              MOVS     r5,#2                 ;903
                  |L29.196|
0000c4  bf00              NOP                            ;907
0000c6  2000              MOVS     r0,#0                 ;907
0000c8  f8840038          STRB     r0,[r4,#0x38]         ;907
0000cc  bf00              NOP                            ;907
0000ce  4628              MOV      r0,r5                 ;909
0000d0  e7a8              B        |L29.36|
;;;911    
                          ENDP


                          AREA ||i.HAL_QSPI_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_QSPI_Transmit_DMA PROC
;;;1135     */
;;;1136   HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;1137   {
000004  4604              MOV      r4,r0
;;;1138     HAL_StatusTypeDef status = HAL_OK;
000006  2600              MOVS     r6,#0
;;;1139     uint32_t *tmp;
;;;1140     uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1);
000008  6820              LDR      r0,[r4,#0]
00000a  6900              LDR      r0,[r0,#0x10]
00000c  1c45              ADDS     r5,r0,#1
;;;1141     
;;;1142     /* Process locked */
;;;1143     __HAL_LOCK(hqspi);
00000e  bf00              NOP      
000010  f8940038          LDRB     r0,[r4,#0x38]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L30.30|
000018  2002              MOVS     r0,#2
                  |L30.26|
;;;1144     
;;;1145     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1146     {
;;;1147       /* Clear the error code */                
;;;1148       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1149       
;;;1150       if(pData != NULL ) 
;;;1151       {
;;;1152         /* Configure counters of the handle */
;;;1153         if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_BYTE)
;;;1154         {
;;;1155           hqspi->TxXferCount = data_size;
;;;1156         }
;;;1157         else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_HALFWORD)
;;;1158         {
;;;1159           if (((data_size % 2) != 0) || ((hqspi->Init.FifoThreshold % 2) != 0))
;;;1160           {
;;;1161             /* The number of data or the fifo threshold is not aligned on halfword 
;;;1162             => no transfer possible with DMA peripheral access configured as halfword */
;;;1163             hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1164             status = HAL_ERROR;
;;;1165             
;;;1166             /* Process unlocked */
;;;1167             __HAL_UNLOCK(hqspi);
;;;1168           }
;;;1169           else
;;;1170           {
;;;1171             hqspi->TxXferCount = (data_size >> 1);
;;;1172           }
;;;1173         }
;;;1174         else if (hqspi->hdma->Init.PeriphDataAlignment == DMA_PDATAALIGN_WORD)
;;;1175         {
;;;1176           if (((data_size % 4) != 0) || ((hqspi->Init.FifoThreshold % 4) != 0))
;;;1177           {
;;;1178             /* The number of data or the fifo threshold is not aligned on word 
;;;1179             => no transfer possible with DMA peripheral access configured as word */
;;;1180             hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1181             status = HAL_ERROR;
;;;1182             
;;;1183             /* Process unlocked */
;;;1184             __HAL_UNLOCK(hqspi);
;;;1185           }
;;;1186           else
;;;1187           {
;;;1188             hqspi->TxXferCount = (data_size >> 2);
;;;1189           }
;;;1190         }
;;;1191         
;;;1192         if (status == HAL_OK)
;;;1193         {
;;;1194   
;;;1195         /* Update state */
;;;1196         hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
;;;1197   
;;;1198         /* Clear interrupt */
;;;1199         __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
;;;1200   
;;;1201         /* Configure size and pointer of the handle */
;;;1202         hqspi->TxXferSize = hqspi->TxXferCount;
;;;1203         hqspi->pTxBuffPtr = pData;
;;;1204       
;;;1205         /* Configure QSPI: CCR register with functional mode as indirect write */
;;;1206         MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
;;;1207       
;;;1208         /* Set the QSPI DMA transfer complete callback */
;;;1209         hqspi->hdma->XferCpltCallback = QSPI_DMATxCplt;
;;;1210       
;;;1211         /* Set the QSPI DMA Half transfer complete callback */
;;;1212         hqspi->hdma->XferHalfCpltCallback = QSPI_DMATxHalfCplt;
;;;1213       
;;;1214         /* Set the DMA error callback */
;;;1215         hqspi->hdma->XferErrorCallback = QSPI_DMAError;
;;;1216         
;;;1217         /* Clear the DMA abort callback */      
;;;1218         hqspi->hdma->XferAbortCallback = NULL;
;;;1219   
;;;1220         /* Configure the direction of the DMA */
;;;1221         hqspi->hdma->Init.Direction = DMA_MEMORY_TO_PERIPH;
;;;1222         MODIFY_REG(hqspi->hdma->Instance->CR, DMA_SxCR_DIR, hqspi->hdma->Init.Direction);
;;;1223   
;;;1224         /* Enable the QSPI transmit DMA Channel */
;;;1225         tmp = (uint32_t*)&pData;
;;;1226         HAL_DMA_Start_IT(hqspi->hdma, *(uint32_t*)tmp, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize);
;;;1227   
;;;1228         /* Process unlocked */
;;;1229         __HAL_UNLOCK(hqspi);
;;;1230   
;;;1231         /* Enable the QSPI transfer error Interrupt */
;;;1232         __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
;;;1233   
;;;1234         /* Enable the DMA transfer by setting the DMAEN bit in the QSPI CR register */
;;;1235         SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
;;;1236       }
;;;1237       }
;;;1238       else
;;;1239       {
;;;1240         hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1241         
;;;1242         status = HAL_ERROR;
;;;1243   
;;;1244         /* Process unlocked */
;;;1245         __HAL_UNLOCK(hqspi);
;;;1246       }
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       status = HAL_BUSY;   
;;;1251   
;;;1252       /* Process unlocked */
;;;1253       __HAL_UNLOCK(hqspi);
;;;1254     }
;;;1255   
;;;1256     return status;
;;;1257   }
00001a  e8bd81fc          POP      {r2-r8,pc}
                  |L30.30|
00001e  2001              MOVS     r0,#1                 ;1143
000020  f8840038          STRB     r0,[r4,#0x38]         ;1143
000024  bf00              NOP                            ;1143
000026  f8940039          LDRB     r0,[r4,#0x39]         ;1145
00002a  2801              CMP      r0,#1                 ;1145
00002c  d17e              BNE      |L30.300|
00002e  2000              MOVS     r0,#0                 ;1148
000030  63e0              STR      r0,[r4,#0x3c]         ;1148
000032  9801              LDR      r0,[sp,#4]            ;1150
000034  2800              CMP      r0,#0                 ;1150
000036  d07a              BEQ      |L30.302|
000038  6b60              LDR      r0,[r4,#0x34]         ;1153
00003a  6940              LDR      r0,[r0,#0x14]         ;1153
00003c  b908              CBNZ     r0,|L30.66|
00003e  8565              STRH     r5,[r4,#0x2a]         ;1155
000040  e032              B        |L30.168|
                  |L30.66|
000042  6b60              LDR      r0,[r4,#0x34]         ;1157
000044  6940              LDR      r0,[r0,#0x14]         ;1157
000046  f5b06f00          CMP      r0,#0x800             ;1157
00004a  d114              BNE      |L30.118|
00004c  f0050001          AND      r0,r5,#1              ;1159
000050  b918              CBNZ     r0,|L30.90|
000052  7a20              LDRB     r0,[r4,#8]            ;1159
000054  f0000001          AND      r0,r0,#1              ;1159
000058  b148              CBZ      r0,|L30.110|
                  |L30.90|
00005a  6be0              LDR      r0,[r4,#0x3c]         ;1163
00005c  f0400008          ORR      r0,r0,#8              ;1163
000060  63e0              STR      r0,[r4,#0x3c]         ;1163
000062  2601              MOVS     r6,#1                 ;1164
000064  bf00              NOP                            ;1167
000066  2000              MOVS     r0,#0                 ;1167
000068  f8840038          STRB     r0,[r4,#0x38]         ;1167
00006c  e01c              B        |L30.168|
                  |L30.110|
00006e  f3c5004f          UBFX     r0,r5,#1,#16          ;1171
000072  8560              STRH     r0,[r4,#0x2a]         ;1171
000074  e018              B        |L30.168|
                  |L30.118|
000076  6b60              LDR      r0,[r4,#0x34]         ;1174
000078  6940              LDR      r0,[r0,#0x14]         ;1174
00007a  f5b05f80          CMP      r0,#0x1000            ;1174
00007e  d113              BNE      |L30.168|
000080  f0050003          AND      r0,r5,#3              ;1176
000084  b918              CBNZ     r0,|L30.142|
000086  7a20              LDRB     r0,[r4,#8]            ;1176
000088  f0000003          AND      r0,r0,#3              ;1176
00008c  b148              CBZ      r0,|L30.162|
                  |L30.142|
00008e  6be0              LDR      r0,[r4,#0x3c]         ;1180
000090  f0400008          ORR      r0,r0,#8              ;1180
000094  63e0              STR      r0,[r4,#0x3c]         ;1180
000096  2601              MOVS     r6,#1                 ;1181
000098  bf00              NOP                            ;1184
00009a  2000              MOVS     r0,#0                 ;1184
00009c  f8840038          STRB     r0,[r4,#0x38]         ;1184
0000a0  e002              B        |L30.168|
                  |L30.162|
0000a2  f3c5008f          UBFX     r0,r5,#2,#16          ;1188
0000a6  8560              STRH     r0,[r4,#0x2a]         ;1188
                  |L30.168|
0000a8  2e00              CMP      r6,#0                 ;1192
0000aa  d158              BNE      |L30.350|
0000ac  2012              MOVS     r0,#0x12              ;1196
0000ae  f8840039          STRB     r0,[r4,#0x39]         ;1196
0000b2  2003              MOVS     r0,#3                 ;1199
0000b4  6821              LDR      r1,[r4,#0]            ;1199
0000b6  60c8              STR      r0,[r1,#0xc]          ;1199
0000b8  8d60              LDRH     r0,[r4,#0x2a]         ;1202
0000ba  8520              STRH     r0,[r4,#0x28]         ;1202
0000bc  9801              LDR      r0,[sp,#4]            ;1203
0000be  6260              STR      r0,[r4,#0x24]         ;1203
0000c0  6820              LDR      r0,[r4,#0]            ;1206
0000c2  6940              LDR      r0,[r0,#0x14]         ;1206
0000c4  f0206040          BIC      r0,r0,#0xc000000      ;1206
0000c8  6821              LDR      r1,[r4,#0]            ;1206
0000ca  6148              STR      r0,[r1,#0x14]         ;1206
0000cc  4825              LDR      r0,|L30.356|
0000ce  6b61              LDR      r1,[r4,#0x34]         ;1209
0000d0  63c8              STR      r0,[r1,#0x3c]         ;1209
0000d2  4825              LDR      r0,|L30.360|
0000d4  6b61              LDR      r1,[r4,#0x34]         ;1212
0000d6  6408              STR      r0,[r1,#0x40]         ;1212
0000d8  4824              LDR      r0,|L30.364|
0000da  6b61              LDR      r1,[r4,#0x34]         ;1215
0000dc  64c8              STR      r0,[r1,#0x4c]         ;1215
0000de  2000              MOVS     r0,#0                 ;1218
0000e0  6b61              LDR      r1,[r4,#0x34]         ;1218
0000e2  6508              STR      r0,[r1,#0x50]         ;1218
0000e4  2140              MOVS     r1,#0x40              ;1221
0000e6  6b60              LDR      r0,[r4,#0x34]         ;1221
0000e8  6081              STR      r1,[r0,#8]            ;1221
0000ea  6b60              LDR      r0,[r4,#0x34]         ;1222
0000ec  6800              LDR      r0,[r0,#0]            ;1222
0000ee  6800              LDR      r0,[r0,#0]            ;1222
0000f0  f02000c0          BIC      r0,r0,#0xc0           ;1222
0000f4  6b61              LDR      r1,[r4,#0x34]         ;1222
0000f6  6889              LDR      r1,[r1,#8]            ;1222
0000f8  4308              ORRS     r0,r0,r1              ;1222
0000fa  6b61              LDR      r1,[r4,#0x34]         ;1222
0000fc  6809              LDR      r1,[r1,#0]            ;1222
0000fe  6008              STR      r0,[r1,#0]            ;1222
000100  af01              ADD      r7,sp,#4              ;1225
000102  8d23              LDRH     r3,[r4,#0x28]         ;1226
000104  f8d4c000          LDR      r12,[r4,#0]           ;1226
000108  f10c0220          ADD      r2,r12,#0x20          ;1226
00010c  6839              LDR      r1,[r7,#0]            ;1226
00010e  6b60              LDR      r0,[r4,#0x34]         ;1226
000110  f7fffffe          BL       HAL_DMA_Start_IT
000114  bf00              NOP                            ;1229
000116  2000              MOVS     r0,#0                 ;1229
000118  f8840038          STRB     r0,[r4,#0x38]         ;1229
00011c  bf00              NOP                            ;1229
00011e  6820              LDR      r0,[r4,#0]            ;1232
000120  6800              LDR      r0,[r0,#0]            ;1232
000122  f4403080          ORR      r0,r0,#0x10000        ;1232
000126  6821              LDR      r1,[r4,#0]            ;1232
000128  6008              STR      r0,[r1,#0]            ;1232
00012a  e001              B        |L30.304|
                  |L30.300|
00012c  e011              B        |L30.338|
                  |L30.302|
00012e  e006              B        |L30.318|
                  |L30.304|
000130  6820              LDR      r0,[r4,#0]            ;1235
000132  6800              LDR      r0,[r0,#0]            ;1235
000134  f0400004          ORR      r0,r0,#4              ;1235
000138  6821              LDR      r1,[r4,#0]            ;1235
00013a  6008              STR      r0,[r1,#0]            ;1235
00013c  e00f              B        |L30.350|
                  |L30.318|
00013e  6be0              LDR      r0,[r4,#0x3c]         ;1240
000140  f0400008          ORR      r0,r0,#8              ;1240
000144  63e0              STR      r0,[r4,#0x3c]         ;1240
000146  2601              MOVS     r6,#1                 ;1242
000148  bf00              NOP                            ;1245
00014a  2000              MOVS     r0,#0                 ;1245
00014c  f8840038          STRB     r0,[r4,#0x38]         ;1245
000150  e005              B        |L30.350|
                  |L30.338|
000152  2602              MOVS     r6,#2                 ;1250
000154  bf00              NOP                            ;1253
000156  2000              MOVS     r0,#0                 ;1253
000158  f8840038          STRB     r0,[r4,#0x38]         ;1253
00015c  bf00              NOP                            ;1253
                  |L30.350|
00015e  4630              MOV      r0,r6                 ;1256
000160  e75b              B        |L30.26|
;;;1258                             
                          ENDP

000162  0000              DCW      0x0000
                  |L30.356|
                          DCD      QSPI_DMATxCplt
                  |L30.360|
                          DCD      QSPI_DMATxHalfCplt
                  |L30.364|
                          DCD      QSPI_DMAError

                          AREA ||i.HAL_QSPI_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_Transmit_IT PROC
;;;1007     */
;;;1008   HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
000000  b510              PUSH     {r4,lr}
;;;1009   {  
000002  4602              MOV      r2,r0
;;;1010     HAL_StatusTypeDef status = HAL_OK;
000004  2300              MOVS     r3,#0
;;;1011     
;;;1012     /* Process locked */
;;;1013     __HAL_LOCK(hqspi);
000006  bf00              NOP      
000008  f8920038          LDRB     r0,[r2,#0x38]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L31.20|
000010  2002              MOVS     r0,#2
                  |L31.18|
;;;1014   
;;;1015     if(hqspi->State == HAL_QSPI_STATE_READY)
;;;1016     {
;;;1017       hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
;;;1018       if(pData != NULL )
;;;1019       {
;;;1020         /* Update state */
;;;1021         hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
;;;1022   
;;;1023         /* Configure counters and size of the handle */
;;;1024         hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1;
;;;1025         hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1;
;;;1026         hqspi->pTxBuffPtr = pData;
;;;1027       
;;;1028         /* Configure QSPI: CCR register with functional as indirect write */
;;;1029         MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
;;;1030       
;;;1031         /* Clear interrupt */
;;;1032         __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
;;;1033   
;;;1034         /* Process unlocked */
;;;1035         __HAL_UNLOCK(hqspi);
;;;1036         
;;;1037         /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
;;;1038         __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
;;;1039         
;;;1040       }
;;;1041       else
;;;1042       {
;;;1043         hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
;;;1044         status = HAL_ERROR;
;;;1045   
;;;1046         /* Process unlocked */
;;;1047         __HAL_UNLOCK(hqspi);
;;;1048       }
;;;1049     }
;;;1050     else
;;;1051     {
;;;1052       status = HAL_BUSY;
;;;1053   
;;;1054       /* Process unlocked */
;;;1055       __HAL_UNLOCK(hqspi);
;;;1056     }
;;;1057   
;;;1058     return status;
;;;1059   }
000012  bd10              POP      {r4,pc}
                  |L31.20|
000014  2001              MOVS     r0,#1                 ;1013
000016  f8820038          STRB     r0,[r2,#0x38]         ;1013
00001a  bf00              NOP                            ;1013
00001c  f8920039          LDRB     r0,[r2,#0x39]         ;1015
000020  2801              CMP      r0,#1                 ;1015
000022  d12d              BNE      |L31.128|
000024  2000              MOVS     r0,#0                 ;1017
000026  63d0              STR      r0,[r2,#0x3c]         ;1017
000028  b301              CBZ      r1,|L31.108|
00002a  2012              MOVS     r0,#0x12              ;1021
00002c  f8820039          STRB     r0,[r2,#0x39]         ;1021
000030  6810              LDR      r0,[r2,#0]            ;1024
000032  6900              LDR      r0,[r0,#0x10]         ;1024
000034  1c40              ADDS     r0,r0,#1              ;1024
000036  8550              STRH     r0,[r2,#0x2a]         ;1024
000038  6810              LDR      r0,[r2,#0]            ;1025
00003a  6900              LDR      r0,[r0,#0x10]         ;1025
00003c  1c40              ADDS     r0,r0,#1              ;1025
00003e  8510              STRH     r0,[r2,#0x28]         ;1025
000040  6251              STR      r1,[r2,#0x24]         ;1026
000042  6810              LDR      r0,[r2,#0]            ;1029
000044  6940              LDR      r0,[r0,#0x14]         ;1029
000046  f0206040          BIC      r0,r0,#0xc000000      ;1029
00004a  6814              LDR      r4,[r2,#0]            ;1029
00004c  6160              STR      r0,[r4,#0x14]         ;1029
00004e  2003              MOVS     r0,#3                 ;1032
000050  6814              LDR      r4,[r2,#0]            ;1032
000052  60e0              STR      r0,[r4,#0xc]          ;1032
000054  bf00              NOP                            ;1035
000056  2000              MOVS     r0,#0                 ;1035
000058  f8820038          STRB     r0,[r2,#0x38]         ;1035
00005c  bf00              NOP                            ;1035
00005e  6810              LDR      r0,[r2,#0]            ;1038
000060  6800              LDR      r0,[r0,#0]            ;1038
000062  f44020e0          ORR      r0,r0,#0x70000        ;1038
000066  6814              LDR      r4,[r2,#0]            ;1038
000068  6020              STR      r0,[r4,#0]            ;1038
00006a  e00f              B        |L31.140|
                  |L31.108|
00006c  6bd0              LDR      r0,[r2,#0x3c]         ;1043
00006e  f0400008          ORR      r0,r0,#8              ;1043
000072  63d0              STR      r0,[r2,#0x3c]         ;1043
000074  2301              MOVS     r3,#1                 ;1044
000076  bf00              NOP                            ;1047
000078  2000              MOVS     r0,#0                 ;1047
00007a  f8820038          STRB     r0,[r2,#0x38]         ;1047
00007e  e005              B        |L31.140|
                  |L31.128|
000080  2302              MOVS     r3,#2                 ;1052
000082  bf00              NOP                            ;1055
000084  2000              MOVS     r0,#0                 ;1055
000086  f8820038          STRB     r0,[r2,#0x38]         ;1055
00008a  bf00              NOP                            ;1055
                  |L31.140|
00008c  4618              MOV      r0,r3                 ;1058
00008e  e7c0              B        |L31.18|
;;;1060   
                          ENDP


                          AREA ||i.HAL_QSPI_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_TxCpltCallback PROC
;;;1753     */
;;;1754    __weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1755   {
;;;1756     /* Prevent unused argument(s) compilation warning */
;;;1757     UNUSED(hqspi);
;;;1758     
;;;1759     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1760              the HAL_QSPI_TxCpltCallback could be implemented in the user file
;;;1761      */ 
;;;1762   }
;;;1763   
                          ENDP


                          AREA ||i.HAL_QSPI_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_QSPI_TxHalfCpltCallback PROC
;;;1783     */
;;;1784    __weak void HAL_QSPI_TxHalfCpltCallback(QSPI_HandleTypeDef *hqspi)
000000  4770              BX       lr
;;;1785   {
;;;1786     /* Prevent unused argument(s) compilation warning */
;;;1787     UNUSED(hqspi);
;;;1788     
;;;1789     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1790              the HAL_QSPI_TxHalfCpltCallback could be implemented in the user file
;;;1791      */ 
;;;1792   }
;;;1793   
                          ENDP


                          AREA ||i.QSPI_Config||, CODE, READONLY, ALIGN=1

                  QSPI_Config PROC
;;;2190     */
;;;2191   static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
000000  b510              PUSH     {r4,lr}
;;;2192   {
;;;2193     assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));
;;;2194   
;;;2195     if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
000002  6a4b              LDR      r3,[r1,#0x24]
000004  b133              CBZ      r3,|L34.20|
000006  f1b26f40          CMP      r2,#0xc000000
00000a  d003              BEQ      |L34.20|
;;;2196     {
;;;2197       /* Configure QSPI: DLR register with the number of data to read or write */
;;;2198       WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1));
00000c  6a8b              LDR      r3,[r1,#0x28]
00000e  1e5b              SUBS     r3,r3,#1
000010  6804              LDR      r4,[r0,#0]
000012  6123              STR      r3,[r4,#0x10]
                  |L34.20|
;;;2199     }
;;;2200         
;;;2201     if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
000014  698b              LDR      r3,[r1,#0x18]
000016  2b00              CMP      r3,#0
000018  d076              BEQ      |L34.264|
;;;2202     {
;;;2203       if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  b3e3              CBZ      r3,|L34.152|
;;;2204       {
;;;2205         /* Configure QSPI: ABR register with alternate bytes value */
;;;2206         WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
00001e  688b              LDR      r3,[r1,#8]
000020  6804              LDR      r4,[r0,#0]
000022  61e3              STR      r3,[r4,#0x1c]
;;;2207   
;;;2208         if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000024  69cb              LDR      r3,[r1,#0x1c]
000026  b1fb              CBZ      r3,|L34.104|
;;;2209         {
;;;2210           /*---- Command with instruction, address and alternate bytes ----*/
;;;2211           /* Configure QSPI: CCR register with all communications parameters */
;;;2212           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
000028  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
00002c  4323              ORRS     r3,r3,r4
00002e  6b4c              LDR      r4,[r1,#0x34]
000030  4323              ORRS     r3,r3,r4
000032  6a4c              LDR      r4,[r1,#0x24]
000034  4323              ORRS     r3,r3,r4
000036  8a8c              LDRH     r4,[r1,#0x14]
000038  ea434384          ORR      r3,r3,r4,LSL #18
00003c  690c              LDR      r4,[r1,#0x10]
00003e  4323              ORRS     r3,r3,r4
000040  6a0c              LDR      r4,[r1,#0x20]
000042  4323              ORRS     r3,r3,r4
000044  68cc              LDR      r4,[r1,#0xc]
000046  4323              ORRS     r3,r3,r4
000048  69cc              LDR      r4,[r1,#0x1c]
00004a  4323              ORRS     r3,r3,r4
00004c  698c              LDR      r4,[r1,#0x18]
00004e  4323              ORRS     r3,r3,r4
000050  680c              LDR      r4,[r1,#0]
000052  4323              ORRS     r3,r3,r4
000054  4313              ORRS     r3,r3,r2
000056  6804              LDR      r4,[r0,#0]
000058  6163              STR      r3,[r4,#0x14]
;;;2213                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateBytesSize |
;;;2214                                            cmd->AlternateByteMode | cmd->AddressSize | cmd->AddressMode |
;;;2215                                            cmd->InstructionMode | cmd->Instruction | FunctionalMode));
;;;2216   
;;;2217           if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
00005a  f1b26f40          CMP      r2,#0xc000000
00005e  d002              BEQ      |L34.102|
;;;2218           {
;;;2219             /* Configure QSPI: AR register with address value */
;;;2220             WRITE_REG(hqspi->Instance->AR, cmd->Address);
000060  684b              LDR      r3,[r1,#4]
000062  6804              LDR      r4,[r0,#0]
000064  61a3              STR      r3,[r4,#0x18]
                  |L34.102|
000066  e0be              B        |L34.486|
                  |L34.104|
;;;2221           }
;;;2222         }
;;;2223         else
;;;2224         {
;;;2225           /*---- Command with instruction and alternate bytes ----*/
;;;2226           /* Configure QSPI: CCR register with all communications parameters */
;;;2227           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
000068  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
00006c  4323              ORRS     r3,r3,r4
00006e  6b4c              LDR      r4,[r1,#0x34]
000070  4323              ORRS     r3,r3,r4
000072  6a4c              LDR      r4,[r1,#0x24]
000074  4323              ORRS     r3,r3,r4
000076  8a8c              LDRH     r4,[r1,#0x14]
000078  ea434384          ORR      r3,r3,r4,LSL #18
00007c  690c              LDR      r4,[r1,#0x10]
00007e  4323              ORRS     r3,r3,r4
000080  6a0c              LDR      r4,[r1,#0x20]
000082  4323              ORRS     r3,r3,r4
000084  69cc              LDR      r4,[r1,#0x1c]
000086  4323              ORRS     r3,r3,r4
000088  698c              LDR      r4,[r1,#0x18]
00008a  4323              ORRS     r3,r3,r4
00008c  680c              LDR      r4,[r1,#0]
00008e  4323              ORRS     r3,r3,r4
000090  4313              ORRS     r3,r3,r2
000092  6804              LDR      r4,[r0,#0]
000094  6163              STR      r3,[r4,#0x14]
000096  e0a6              B        |L34.486|
                  |L34.152|
000098  e7ff              B        |L34.154|
                  |L34.154|
;;;2228                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateBytesSize |
;;;2229                                            cmd->AlternateByteMode | cmd->AddressMode | cmd->InstructionMode | 
;;;2230                                            cmd->Instruction | FunctionalMode));
;;;2231         }
;;;2232       }
;;;2233       else
;;;2234       {
;;;2235         if (cmd->AddressMode != QSPI_ADDRESS_NONE)
00009a  69cb              LDR      r3,[r1,#0x1c]
00009c  b1eb              CBZ      r3,|L34.218|
;;;2236         {
;;;2237           /*---- Command with instruction and address ----*/
;;;2238           /* Configure QSPI: CCR register with all communications parameters */
;;;2239           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
00009e  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
0000a2  4323              ORRS     r3,r3,r4
0000a4  6b4c              LDR      r4,[r1,#0x34]
0000a6  4323              ORRS     r3,r3,r4
0000a8  6a4c              LDR      r4,[r1,#0x24]
0000aa  4323              ORRS     r3,r3,r4
0000ac  8a8c              LDRH     r4,[r1,#0x14]
0000ae  ea434384          ORR      r3,r3,r4,LSL #18
0000b2  6a0c              LDR      r4,[r1,#0x20]
0000b4  4323              ORRS     r3,r3,r4
0000b6  68cc              LDR      r4,[r1,#0xc]
0000b8  4323              ORRS     r3,r3,r4
0000ba  69cc              LDR      r4,[r1,#0x1c]
0000bc  4323              ORRS     r3,r3,r4
0000be  698c              LDR      r4,[r1,#0x18]
0000c0  4323              ORRS     r3,r3,r4
0000c2  680c              LDR      r4,[r1,#0]
0000c4  4323              ORRS     r3,r3,r4
0000c6  4313              ORRS     r3,r3,r2
0000c8  6804              LDR      r4,[r0,#0]
0000ca  6163              STR      r3,[r4,#0x14]
;;;2240                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateByteMode | 
;;;2241                                            cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode | 
;;;2242                                            cmd->Instruction | FunctionalMode));
;;;2243   
;;;2244           if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
0000cc  f1b26f40          CMP      r2,#0xc000000
0000d0  d0c9              BEQ      |L34.102|
;;;2245           {
;;;2246             /* Configure QSPI: AR register with address value */
;;;2247             WRITE_REG(hqspi->Instance->AR, cmd->Address);
0000d2  684b              LDR      r3,[r1,#4]
0000d4  6804              LDR      r4,[r0,#0]
0000d6  61a3              STR      r3,[r4,#0x18]
0000d8  e085              B        |L34.486|
                  |L34.218|
;;;2248           }
;;;2249         }
;;;2250         else
;;;2251         {
;;;2252           /*---- Command with only instruction ----*/
;;;2253           /* Configure QSPI: CCR register with all communications parameters */
;;;2254           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
0000da  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
0000de  4323              ORRS     r3,r3,r4
0000e0  6b4c              LDR      r4,[r1,#0x34]
0000e2  4323              ORRS     r3,r3,r4
0000e4  6a4c              LDR      r4,[r1,#0x24]
0000e6  4323              ORRS     r3,r3,r4
0000e8  8a8c              LDRH     r4,[r1,#0x14]
0000ea  ea434384          ORR      r3,r3,r4,LSL #18
0000ee  6a0c              LDR      r4,[r1,#0x20]
0000f0  4323              ORRS     r3,r3,r4
0000f2  69cc              LDR      r4,[r1,#0x1c]
0000f4  4323              ORRS     r3,r3,r4
0000f6  698c              LDR      r4,[r1,#0x18]
0000f8  4323              ORRS     r3,r3,r4
0000fa  680c              LDR      r4,[r1,#0]
0000fc  4323              ORRS     r3,r3,r4
0000fe  4313              ORRS     r3,r3,r2
000100  6804              LDR      r4,[r0,#0]
000102  6163              STR      r3,[r4,#0x14]
000104  e06f              B        |L34.486|
000106  e7ff              B        |L34.264|
                  |L34.264|
;;;2255                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateByteMode | 
;;;2256                                            cmd->AddressMode | cmd->InstructionMode | cmd->Instruction  | 
;;;2257                                            FunctionalMode));
;;;2258         }
;;;2259       }
;;;2260     }
;;;2261     else
;;;2262     {
;;;2263       if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
000108  6a0b              LDR      r3,[r1,#0x20]
00010a  b3c3              CBZ      r3,|L34.382|
;;;2264       {
;;;2265         /* Configure QSPI: ABR register with alternate bytes value */
;;;2266         WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
00010c  688b              LDR      r3,[r1,#8]
00010e  6804              LDR      r4,[r0,#0]
000110  61e3              STR      r3,[r4,#0x1c]
;;;2267   
;;;2268         if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000112  69cb              LDR      r3,[r1,#0x1c]
000114  b1eb              CBZ      r3,|L34.338|
;;;2269         {
;;;2270           /*---- Command with address and alternate bytes ----*/
;;;2271           /* Configure QSPI: CCR register with all communications parameters */
;;;2272           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
000116  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
00011a  4323              ORRS     r3,r3,r4
00011c  6b4c              LDR      r4,[r1,#0x34]
00011e  4323              ORRS     r3,r3,r4
000120  6a4c              LDR      r4,[r1,#0x24]
000122  4323              ORRS     r3,r3,r4
000124  8a8c              LDRH     r4,[r1,#0x14]
000126  ea434384          ORR      r3,r3,r4,LSL #18
00012a  690c              LDR      r4,[r1,#0x10]
00012c  4323              ORRS     r3,r3,r4
00012e  6a0c              LDR      r4,[r1,#0x20]
000130  4323              ORRS     r3,r3,r4
000132  68cc              LDR      r4,[r1,#0xc]
000134  4323              ORRS     r3,r3,r4
000136  69cc              LDR      r4,[r1,#0x1c]
000138  4323              ORRS     r3,r3,r4
00013a  698c              LDR      r4,[r1,#0x18]
00013c  4323              ORRS     r3,r3,r4
00013e  4313              ORRS     r3,r3,r2
000140  6804              LDR      r4,[r0,#0]
000142  6163              STR      r3,[r4,#0x14]
;;;2273                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateBytesSize |
;;;2274                                            cmd->AlternateByteMode | cmd->AddressSize | cmd->AddressMode |
;;;2275                                            cmd->InstructionMode | FunctionalMode));
;;;2276   
;;;2277           if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
000144  f1b26f40          CMP      r2,#0xc000000
000148  d04d              BEQ      |L34.486|
;;;2278           {
;;;2279             /* Configure QSPI: AR register with address value */
;;;2280             WRITE_REG(hqspi->Instance->AR, cmd->Address);
00014a  684b              LDR      r3,[r1,#4]
00014c  6804              LDR      r4,[r0,#0]
00014e  61a3              STR      r3,[r4,#0x18]
000150  e049              B        |L34.486|
                  |L34.338|
;;;2281           }
;;;2282         }
;;;2283         else
;;;2284         {
;;;2285           /*---- Command with only alternate bytes ----*/
;;;2286           /* Configure QSPI: CCR register with all communications parameters */
;;;2287           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
000152  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
000156  4323              ORRS     r3,r3,r4
000158  6b4c              LDR      r4,[r1,#0x34]
00015a  4323              ORRS     r3,r3,r4
00015c  6a4c              LDR      r4,[r1,#0x24]
00015e  4323              ORRS     r3,r3,r4
000160  8a8c              LDRH     r4,[r1,#0x14]
000162  ea434384          ORR      r3,r3,r4,LSL #18
000166  690c              LDR      r4,[r1,#0x10]
000168  4323              ORRS     r3,r3,r4
00016a  6a0c              LDR      r4,[r1,#0x20]
00016c  4323              ORRS     r3,r3,r4
00016e  69cc              LDR      r4,[r1,#0x1c]
000170  4323              ORRS     r3,r3,r4
000172  698c              LDR      r4,[r1,#0x18]
000174  4323              ORRS     r3,r3,r4
000176  4313              ORRS     r3,r3,r2
000178  6804              LDR      r4,[r0,#0]
00017a  6163              STR      r3,[r4,#0x14]
00017c  e033              B        |L34.486|
                  |L34.382|
00017e  e7ff              B        |L34.384|
                  |L34.384|
;;;2288                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateBytesSize |
;;;2289                                            cmd->AlternateByteMode | cmd->AddressMode | cmd->InstructionMode | 
;;;2290                                            FunctionalMode));
;;;2291         }
;;;2292       }
;;;2293       else
;;;2294       {
;;;2295         if (cmd->AddressMode != QSPI_ADDRESS_NONE)
000180  69cb              LDR      r3,[r1,#0x1c]
000182  b1db              CBZ      r3,|L34.444|
;;;2296         {
;;;2297           /*---- Command with only address ----*/
;;;2298           /* Configure QSPI: CCR register with all communications parameters */
;;;2299           WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
000184  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
000188  4323              ORRS     r3,r3,r4
00018a  6b4c              LDR      r4,[r1,#0x34]
00018c  4323              ORRS     r3,r3,r4
00018e  6a4c              LDR      r4,[r1,#0x24]
000190  4323              ORRS     r3,r3,r4
000192  8a8c              LDRH     r4,[r1,#0x14]
000194  ea434384          ORR      r3,r3,r4,LSL #18
000198  6a0c              LDR      r4,[r1,#0x20]
00019a  4323              ORRS     r3,r3,r4
00019c  68cc              LDR      r4,[r1,#0xc]
00019e  4323              ORRS     r3,r3,r4
0001a0  69cc              LDR      r4,[r1,#0x1c]
0001a2  4323              ORRS     r3,r3,r4
0001a4  698c              LDR      r4,[r1,#0x18]
0001a6  4323              ORRS     r3,r3,r4
0001a8  4313              ORRS     r3,r3,r2
0001aa  6804              LDR      r4,[r0,#0]
0001ac  6163              STR      r3,[r4,#0x14]
;;;2300                                            cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateByteMode | 
;;;2301                                            cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode | 
;;;2302                                            FunctionalMode));
;;;2303   
;;;2304           if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
0001ae  f1b26f40          CMP      r2,#0xc000000
0001b2  d018              BEQ      |L34.486|
;;;2305           {
;;;2306             /* Configure QSPI: AR register with address value */
;;;2307             WRITE_REG(hqspi->Instance->AR, cmd->Address);
0001b4  684b              LDR      r3,[r1,#4]
0001b6  6804              LDR      r4,[r0,#0]
0001b8  61a3              STR      r3,[r4,#0x18]
0001ba  e014              B        |L34.486|
                  |L34.444|
;;;2308           }
;;;2309         }
;;;2310         else
;;;2311         {
;;;2312           /*---- Command with only data phase ----*/
;;;2313           if (cmd->DataMode != QSPI_DATA_NONE)
0001bc  6a4b              LDR      r3,[r1,#0x24]
0001be  b193              CBZ      r3,|L34.486|
;;;2314           {
;;;2315             /* Configure QSPI: CCR register with all communications parameters */
;;;2316             WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
0001c0  e9d1340b          LDRD     r3,r4,[r1,#0x2c]
0001c4  4323              ORRS     r3,r3,r4
0001c6  6b4c              LDR      r4,[r1,#0x34]
0001c8  4323              ORRS     r3,r3,r4
0001ca  6a4c              LDR      r4,[r1,#0x24]
0001cc  4323              ORRS     r3,r3,r4
0001ce  8a8c              LDRH     r4,[r1,#0x14]
0001d0  ea434384          ORR      r3,r3,r4,LSL #18
0001d4  6a0c              LDR      r4,[r1,#0x20]
0001d6  4323              ORRS     r3,r3,r4
0001d8  69cc              LDR      r4,[r1,#0x1c]
0001da  4323              ORRS     r3,r3,r4
0001dc  698c              LDR      r4,[r1,#0x18]
0001de  4323              ORRS     r3,r3,r4
0001e0  4313              ORRS     r3,r3,r2
0001e2  6804              LDR      r4,[r0,#0]
0001e4  6163              STR      r3,[r4,#0x14]
                  |L34.486|
;;;2317                                              cmd->DataMode | (cmd->DummyCycles << 18) | cmd->AlternateByteMode | 
;;;2318                                              cmd->AddressMode | cmd->InstructionMode | FunctionalMode));
;;;2319           }
;;;2320         }
;;;2321       }
;;;2322     }
;;;2323   }
0001e6  bd10              POP      {r4,pc}
;;;2324   /**
                          ENDP


                          AREA ||i.QSPI_DMAAbortCplt||, CODE, READONLY, ALIGN=1

                  QSPI_DMAAbortCplt PROC
;;;2118     */
;;;2119   static void QSPI_DMAAbortCplt(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2120   {
000002  4605              MOV      r5,r0
;;;2121     QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2122   
;;;2123     hqspi->RxXferCount = 0;
000006  2000              MOVS     r0,#0
000008  8660              STRH     r0,[r4,#0x32]
;;;2124     hqspi->TxXferCount = 0;
00000a  8560              STRH     r0,[r4,#0x2a]
;;;2125   
;;;2126     if(hqspi->State == HAL_QSPI_STATE_ABORT)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2808              CMP      r0,#8
000012  d10f              BNE      |L35.52|
;;;2127     {
;;;2128       /* DMA Abort called by QSPI abort */
;;;2129       /* Clear interrupt */
;;;2130       __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
000014  2002              MOVS     r0,#2
000016  6821              LDR      r1,[r4,#0]
000018  60c8              STR      r0,[r1,#0xc]
;;;2131       
;;;2132       /* Enable the QSPI Transfer Complete Interrupt */
;;;2133       __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
00001a  6820              LDR      r0,[r4,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f4403000          ORR      r0,r0,#0x20000
000022  6821              LDR      r1,[r4,#0]
000024  6008              STR      r0,[r1,#0]
;;;2134       
;;;2135       /* Configure QSPI: CR register with Abort request */
;;;2136       SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
000026  6820              LDR      r0,[r4,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0400002          ORR      r0,r0,#2
00002e  6821              LDR      r1,[r4,#0]
000030  6008              STR      r0,[r1,#0]
000032  e005              B        |L35.64|
                  |L35.52|
;;;2137     }
;;;2138     else
;;;2139     {
;;;2140       /* DMA Abort called due to a transfer error interrupt */
;;;2141       /* Change state of QSPI */
;;;2142       hqspi->State = HAL_QSPI_STATE_READY;
000034  2001              MOVS     r0,#1
000036  f8840039          STRB     r0,[r4,#0x39]
;;;2143       
;;;2144       /* Error callback */
;;;2145       HAL_QSPI_ErrorCallback(hqspi);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_QSPI_ErrorCallback
                  |L35.64|
;;;2146     }
;;;2147   }
000040  bd70              POP      {r4-r6,pc}
;;;2148   
                          ENDP


                          AREA ||i.QSPI_DMAError||, CODE, READONLY, ALIGN=1

                  QSPI_DMAError PROC
;;;2094     */
;;;2095   static void QSPI_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2096   {
000002  4605              MOV      r5,r0
;;;2097     QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;2098     
;;;2099     /* if DMA error is FIFO error ignore it */
;;;2100     if(HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_DMA_GetError
00000c  2802              CMP      r0,#2
00000e  d00f              BEQ      |L36.48|
;;;2101     {
;;;2102       hqspi->RxXferCount = 0;
000010  2000              MOVS     r0,#0
000012  8660              STRH     r0,[r4,#0x32]
;;;2103       hqspi->TxXferCount = 0;
000014  8560              STRH     r0,[r4,#0x2a]
;;;2104       hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
000016  6be0              LDR      r0,[r4,#0x3c]
000018  f0400004          ORR      r0,r0,#4
00001c  63e0              STR      r0,[r4,#0x3c]
;;;2105       
;;;2106       /* Disable the DMA transfer by clearing the DMAEN bit in the QSPI CR register */
;;;2107       CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
00001e  6820              LDR      r0,[r4,#0]
000020  6800              LDR      r0,[r0,#0]
000022  f0200004          BIC      r0,r0,#4
000026  6821              LDR      r1,[r4,#0]
000028  6008              STR      r0,[r1,#0]
;;;2108       
;;;2109       /* Abort the QSPI */
;;;2110       HAL_QSPI_Abort_IT(hqspi);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       HAL_QSPI_Abort_IT
                  |L36.48|
;;;2111     }
;;;2112   }
000030  bd70              POP      {r4-r6,pc}
;;;2113   
                          ENDP


                          AREA ||i.QSPI_DMARxCplt||, CODE, READONLY, ALIGN=1

                  QSPI_DMARxCplt PROC
;;;2042     */
;;;2043   static void QSPI_DMARxCplt(DMA_HandleTypeDef *hdma)  
000000  4601              MOV      r1,r0
;;;2044   {
;;;2045     QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b88              LDR      r0,[r1,#0x38]
;;;2046     hqspi->RxXferCount = 0;
000004  2200              MOVS     r2,#0
000006  8642              STRH     r2,[r0,#0x32]
;;;2047     
;;;2048     /* Enable the QSPI transfer complete Interrupt */
;;;2049     __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
000008  6802              LDR      r2,[r0,#0]
00000a  6812              LDR      r2,[r2,#0]
00000c  f4423200          ORR      r2,r2,#0x20000
000010  6803              LDR      r3,[r0,#0]
000012  601a              STR      r2,[r3,#0]
;;;2050   }
000014  4770              BX       lr
;;;2051   
                          ENDP


                          AREA ||i.QSPI_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  QSPI_DMARxHalfCplt PROC
;;;2070     */
;;;2071   static void QSPI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2072   {
000002  4604              MOV      r4,r0
;;;2073     QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2074   
;;;2075     HAL_QSPI_RxHalfCpltCallback(hqspi); 
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_QSPI_RxHalfCpltCallback
;;;2076   }
00000c  bd70              POP      {r4-r6,pc}
;;;2077   
                          ENDP


                          AREA ||i.QSPI_DMATxCplt||, CODE, READONLY, ALIGN=1

                  QSPI_DMATxCplt PROC
;;;2056     */
;;;2057   static void QSPI_DMATxCplt(DMA_HandleTypeDef *hdma)     
000000  4601              MOV      r1,r0
;;;2058   {
;;;2059     QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6b88              LDR      r0,[r1,#0x38]
;;;2060     hqspi->TxXferCount = 0;
000004  2200              MOVS     r2,#0
000006  8542              STRH     r2,[r0,#0x2a]
;;;2061     
;;;2062     /* Enable the QSPI transfer complete Interrupt */
;;;2063     __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
000008  6802              LDR      r2,[r0,#0]
00000a  6812              LDR      r2,[r2,#0]
00000c  f4423200          ORR      r2,r2,#0x20000
000010  6803              LDR      r3,[r0,#0]
000012  601a              STR      r2,[r3,#0]
;;;2064   }
000014  4770              BX       lr
;;;2065   
                          ENDP


                          AREA ||i.QSPI_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  QSPI_DMATxHalfCplt PROC
;;;2082     */
;;;2083   static void QSPI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2084   {
000002  4604              MOV      r4,r0
;;;2085     QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;2086   
;;;2087     HAL_QSPI_TxHalfCpltCallback(hqspi);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_QSPI_TxHalfCpltCallback
;;;2088   }
00000c  bd70              POP      {r4-r6,pc}
;;;2089   
                          ENDP


                          AREA ||i.QSPI_WaitFlagStateUntilTimeout||, CODE, READONLY, ALIGN=1

                  QSPI_WaitFlagStateUntilTimeout PROC
;;;2157     */
;;;2158   static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2159                                                           FlagStatus State, uint32_t tickstart, uint32_t Timeout)
;;;2160   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;2161     /* Wait until flag is in expected state */    
;;;2162     while((FlagStatus)(__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
00000e  e012              B        |L41.54|
                  |L41.16|
;;;2163     {
;;;2164       /* Check for the Timeout */
;;;2165       if (Timeout != HAL_MAX_DELAY)
000010  1c68              ADDS     r0,r5,#1
000012  b180              CBZ      r0,|L41.54|
;;;2166       {
;;;2167         if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
000014  b12d              CBZ      r5,|L41.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42a8              CMP      r0,r5
000020  d909              BLS      |L41.54|
                  |L41.34|
;;;2168         {
;;;2169           hqspi->State     = HAL_QSPI_STATE_ERROR;
000022  2004              MOVS     r0,#4
000024  f8840039          STRB     r0,[r4,#0x39]
;;;2170           hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
000028  6be0              LDR      r0,[r4,#0x3c]
00002a  f0400001          ORR      r0,r0,#1
00002e  63e0              STR      r0,[r4,#0x3c]
;;;2171           
;;;2172           return HAL_ERROR;
000030  2001              MOVS     r0,#1
                  |L41.50|
;;;2173         }
;;;2174       }
;;;2175     }
;;;2176     return HAL_OK;
;;;2177   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L41.54|
000036  6820              LDR      r0,[r4,#0]            ;2162
000038  6880              LDR      r0,[r0,#8]            ;2162
00003a  4030              ANDS     r0,r0,r6              ;2162
00003c  b108              CBZ      r0,|L41.66|
00003e  2001              MOVS     r0,#1                 ;2162
000040  e000              B        |L41.68|
                  |L41.66|
000042  2000              MOVS     r0,#0                 ;2162
                  |L41.68|
000044  42b8              CMP      r0,r7                 ;2162
000046  d1e3              BNE      |L41.16|
000048  2000              MOVS     r0,#0                 ;2176
00004a  e7f2              B        |L41.50|
;;;2178   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_qspi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_qspi_c_9f327679____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_qspi_c_9f327679____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_qspi_c_9f327679____REVSH|
#line 402
|__asm___20_stm32f7xx_hal_qspi_c_9f327679____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_qspi_c_9f327679____RRX|
#line 587
|__asm___20_stm32f7xx_hal_qspi_c_9f327679____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
