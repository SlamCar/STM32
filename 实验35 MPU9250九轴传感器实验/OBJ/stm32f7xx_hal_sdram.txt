; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f7xx_hal_sdram.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f7xx_hal_sdram.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\stm32f7xx_hal_sdram.crf ..\HALLIB\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c]
                          THUMB

                          AREA ||i.HAL_SDRAM_DMA_XferCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DMA_XferCpltCallback PROC
;;;264      */
;;;265    __weak void HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;266    {
;;;267      /* Prevent unused argument(s) compilation warning */
;;;268      UNUSED(hdma);
;;;269     
;;;270      /* NOTE: This function Should not be modified, when the callback is needed,
;;;271                the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
;;;272       */ 
;;;273    }
;;;274    
                          ENDP


                          AREA ||i.HAL_SDRAM_DMA_XferErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DMA_XferErrorCallback PROC
;;;279      */
;;;280    __weak void HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;281    {
;;;282      /* Prevent unused argument(s) compilation warning */
;;;283      UNUSED(hdma);
;;;284     
;;;285      /* NOTE: This function Should not be modified, when the callback is needed,
;;;286                the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
;;;287       */ 
;;;288    }
;;;289    
                          ENDP


                          AREA ||i.HAL_SDRAM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DeInit PROC
;;;174      */
;;;175    HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177      /* Initialize the low level hardware (MSP) */
;;;178      HAL_SDRAM_MspDeInit(hsdram);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_SDRAM_MspDeInit
;;;179    
;;;180      /* Configure the SDRAM registers with their reset values */
;;;181      FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
00000a  e9d40100          LDRD     r0,r1,[r4,#0]
00000e  f7fffffe          BL       FMC_SDRAM_DeInit
;;;182    
;;;183      /* Reset the SDRAM controller state */
;;;184      hsdram->State = HAL_SDRAM_STATE_RESET;
000012  2000              MOVS     r0,#0
000014  f884002c          STRB     r0,[r4,#0x2c]
;;;185    
;;;186      /* Release Lock */
;;;187      __HAL_UNLOCK(hsdram);
000018  bf00              NOP      
00001a  f884002d          STRB     r0,[r4,#0x2d]
00001e  bf00              NOP      
;;;188    
;;;189      return HAL_OK;
;;;190    }
000020  bd10              POP      {r4,pc}
;;;191    
                          ENDP


                          AREA ||i.HAL_SDRAM_GetModeStatus||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_GetModeStatus PROC
;;;806      */
;;;807    uint32_t HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;808    {
000002  4604              MOV      r4,r0
;;;809      /* Return the SDRAM memory current mode */
;;;810      return(FMC_SDRAM_GetModeStatus(hsdram->Instance, hsdram->Init.SDBank));
000004  e9d40100          LDRD     r0,r1,[r4,#0]
000008  f7fffffe          BL       FMC_SDRAM_GetModeStatus
;;;811    }
00000c  bd10              POP      {r4,pc}
;;;812    
                          ENDP


                          AREA ||i.HAL_SDRAM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_GetState PROC
;;;837      */
;;;838    HAL_SDRAM_StateTypeDef HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram)
000000  4601              MOV      r1,r0
;;;839    {
;;;840      return hsdram->State;
000002  f891002c          LDRB     r0,[r1,#0x2c]
;;;841    }
000006  4770              BX       lr
;;;842    
                          ENDP


                          AREA ||i.HAL_SDRAM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_IRQHandler PROC
;;;229    */
;;;230    void HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232      /* Check SDRAM interrupt Rising edge flag */
;;;233      if(__FMC_SDRAM_GET_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_IT))
000004  6820              LDR      r0,[r4,#0]
000006  6980              LDR      r0,[r0,#0x18]
000008  f0000001          AND      r0,r0,#1
00000c  b140              CBZ      r0,|L6.32|
;;;234      {
;;;235        /* SDRAM refresh error interrupt callback */
;;;236        HAL_SDRAM_RefreshErrorCallback(hsdram);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_SDRAM_RefreshErrorCallback
;;;237        
;;;238        /* Clear SDRAM refresh error interrupt pending bit */
;;;239        __FMC_SDRAM_CLEAR_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_ERROR);
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  f0400001          ORR      r0,r0,#1
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
                  |L6.32|
;;;240      }
;;;241    }
000020  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.HAL_SDRAM_Init||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Init PROC
;;;137      */
;;;138    HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {   
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;140      /* Check the SDRAM handle parameter */
;;;141      if(hsdram == NULL)
000006  b90c              CBNZ     r4,|L7.12|
;;;142      {
;;;143        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;144      }
;;;145      
;;;146      if(hsdram->State == HAL_SDRAM_STATE_RESET)
;;;147      {  
;;;148        /* Allocate lock resource and initialize it */
;;;149        hsdram->Lock = HAL_UNLOCKED;
;;;150        /* Initialize the low level hardware (MSP) */
;;;151        HAL_SDRAM_MspInit(hsdram);
;;;152      }
;;;153      
;;;154      /* Initialize the SDRAM controller state */
;;;155      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;156      
;;;157      /* Initialize SDRAM control Interface */
;;;158      FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
;;;159      
;;;160      /* Initialize SDRAM timing Interface */
;;;161      FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
;;;162      
;;;163      /* Update the SDRAM controller state */
;;;164      hsdram->State = HAL_SDRAM_STATE_READY;
;;;165      
;;;166      return HAL_OK;
;;;167    }
00000a  bd70              POP      {r4-r6,pc}
                  |L7.12|
00000c  f894002c          LDRB     r0,[r4,#0x2c]         ;146
000010  b928              CBNZ     r0,|L7.30|
000012  2000              MOVS     r0,#0                 ;149
000014  f884002d          STRB     r0,[r4,#0x2d]         ;149
000018  4620              MOV      r0,r4                 ;151
00001a  f7fffffe          BL       HAL_SDRAM_MspInit
                  |L7.30|
00001e  2002              MOVS     r0,#2                 ;155
000020  f884002c          STRB     r0,[r4,#0x2c]         ;155
000024  1d21              ADDS     r1,r4,#4              ;158
000026  6820              LDR      r0,[r4,#0]            ;158
000028  f7fffffe          BL       FMC_SDRAM_Init
00002c  4629              MOV      r1,r5                 ;161
00002e  e9d40200          LDRD     r0,r2,[r4,#0]         ;161
000032  f7fffffe          BL       FMC_SDRAM_Timing_Init
000036  2001              MOVS     r0,#1                 ;164
000038  f884002c          STRB     r0,[r4,#0x2c]         ;164
00003c  2000              MOVS     r0,#0                 ;166
00003e  e7e4              B        |L7.10|
;;;168    
                          ENDP


                          AREA ||i.HAL_SDRAM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_MspDeInit PROC
;;;213      */
;;;214    __weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;215    {
;;;216      /* Prevent unused argument(s) compilation warning */
;;;217      UNUSED(hsdram);
;;;218     
;;;219      /* NOTE: This function Should not be modified, when the callback is needed,
;;;220                the HAL_SDRAM_MspDeInit could be implemented in the user file
;;;221       */ 
;;;222    }
;;;223    
                          ENDP


                          AREA ||i.HAL_SDRAM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_MspInit PROC
;;;197      */
;;;198    __weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;199    {
;;;200      /* Prevent unused argument(s) compilation warning */
;;;201      UNUSED(hsdram);
;;;202     
;;;203      /* NOTE: This function Should not be modified, when the callback is needed,
;;;204                the HAL_SDRAM_MspInit could be implemented in the user file
;;;205       */ 
;;;206    }
;;;207    
                          ENDP


                          AREA ||i.HAL_SDRAM_ProgramRefreshRate||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_ProgramRefreshRate PROC
;;;753      */
;;;754    HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
000000  b570              PUSH     {r4-r6,lr}
;;;755    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;756      /* Check the SDRAM controller state */
;;;757      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000006  f894002c          LDRB     r0,[r4,#0x2c]
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L10.16|
                  |L10.14|
;;;758      {
;;;759        return HAL_BUSY;
;;;760      } 
;;;761      
;;;762      /* Update the SDRAM state */
;;;763      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;764      
;;;765      /* Program the refresh rate */
;;;766      FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
;;;767      
;;;768      /* Update the SDRAM state */
;;;769      hsdram->State = HAL_SDRAM_STATE_READY;
;;;770      
;;;771      return HAL_OK;   
;;;772    }
00000e  bd70              POP      {r4-r6,pc}
                  |L10.16|
000010  2002              MOVS     r0,#2                 ;763
000012  f884002c          STRB     r0,[r4,#0x2c]         ;763
000016  4629              MOV      r1,r5                 ;766
000018  6820              LDR      r0,[r4,#0]            ;766
00001a  f7fffffe          BL       FMC_SDRAM_ProgramRefreshRate
00001e  2001              MOVS     r0,#1                 ;769
000020  f884002c          STRB     r0,[r4,#0x2c]         ;769
000024  2000              MOVS     r0,#0                 ;771
000026  e7f2              B        |L10.14|
;;;773    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_16b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_16b PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;403    {
000002  4604              MOV      r4,r0
;;;404      __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
000004  460d              MOV      r5,r1
;;;405      
;;;406      /* Process Locked */
;;;407      __HAL_LOCK(hsdram);
000006  bf00              NOP      
000008  f894002d          LDRB     r0,[r4,#0x2d]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L11.20|
000010  2002              MOVS     r0,#2
                  |L11.18|
;;;408      
;;;409      /* Check the SDRAM controller state */
;;;410      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
;;;411      {
;;;412        return HAL_BUSY;
;;;413      }
;;;414      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
;;;415      {
;;;416        return  HAL_ERROR; 
;;;417      }  
;;;418      
;;;419      /* Read data from source */
;;;420      for(; BufferSize != 0; BufferSize--)
;;;421      {
;;;422        *pDstBuffer = *(__IO uint16_t *)pSdramAddress;  
;;;423        pDstBuffer++;
;;;424        pSdramAddress++;               
;;;425      }
;;;426      
;;;427      /* Process Unlocked */
;;;428      __HAL_UNLOCK(hsdram);       
;;;429      
;;;430      return HAL_OK; 
;;;431    }
000012  bd30              POP      {r4,r5,pc}
                  |L11.20|
000014  2001              MOVS     r0,#1                 ;407
000016  f884002d          STRB     r0,[r4,#0x2d]         ;407
00001a  bf00              NOP                            ;407
00001c  f894002c          LDRB     r0,[r4,#0x2c]         ;410
000020  2802              CMP      r0,#2                 ;410
000022  d100              BNE      |L11.38|
000024  e7f5              B        |L11.18|
                  |L11.38|
000026  f894002c          LDRB     r0,[r4,#0x2c]         ;414
00002a  2805              CMP      r0,#5                 ;414
00002c  d101              BNE      |L11.50|
00002e  2001              MOVS     r0,#1                 ;416
000030  e7ef              B        |L11.18|
                  |L11.50|
000032  e004              B        |L11.62|
                  |L11.52|
000034  8828              LDRH     r0,[r5,#0]            ;422
000036  8010              STRH     r0,[r2,#0]            ;422
000038  1c92              ADDS     r2,r2,#2              ;423
00003a  1cad              ADDS     r5,r5,#2              ;424
00003c  1e5b              SUBS     r3,r3,#1              ;420
                  |L11.62|
00003e  2b00              CMP      r3,#0                 ;420
000040  d1f8              BNE      |L11.52|
000042  bf00              NOP                            ;428
000044  2000              MOVS     r0,#0                 ;428
000046  f884002d          STRB     r0,[r4,#0x2d]         ;428
00004a  bf00              NOP                            ;428
00004c  bf00              NOP                            ;430
00004e  e7e0              B        |L11.18|
;;;432    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_32b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_32b PROC
;;;484      */
;;;485    HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;486    {
000002  4604              MOV      r4,r0
;;;487      __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
000004  460d              MOV      r5,r1
;;;488      
;;;489      /* Process Locked */
;;;490      __HAL_LOCK(hsdram);
000006  bf00              NOP      
000008  f894002d          LDRB     r0,[r4,#0x2d]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L12.20|
000010  2002              MOVS     r0,#2
                  |L12.18|
;;;491      
;;;492      /* Check the SDRAM controller state */
;;;493      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
;;;494      {
;;;495        return HAL_BUSY;
;;;496      }
;;;497      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
;;;498      {
;;;499        return  HAL_ERROR; 
;;;500      }  
;;;501      
;;;502      /* Read data from source */
;;;503      for(; BufferSize != 0; BufferSize--)
;;;504      {
;;;505        *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
;;;506        pDstBuffer++;
;;;507        pSdramAddress++;               
;;;508      }
;;;509      
;;;510      /* Process Unlocked */
;;;511      __HAL_UNLOCK(hsdram);       
;;;512      
;;;513      return HAL_OK; 
;;;514    }
000012  bd30              POP      {r4,r5,pc}
                  |L12.20|
000014  2001              MOVS     r0,#1                 ;490
000016  f884002d          STRB     r0,[r4,#0x2d]         ;490
00001a  bf00              NOP                            ;490
00001c  f894002c          LDRB     r0,[r4,#0x2c]         ;493
000020  2802              CMP      r0,#2                 ;493
000022  d100              BNE      |L12.38|
000024  e7f5              B        |L12.18|
                  |L12.38|
000026  f894002c          LDRB     r0,[r4,#0x2c]         ;497
00002a  2805              CMP      r0,#5                 ;497
00002c  d101              BNE      |L12.50|
00002e  2001              MOVS     r0,#1                 ;499
000030  e7ef              B        |L12.18|
                  |L12.50|
000032  e004              B        |L12.62|
                  |L12.52|
000034  6828              LDR      r0,[r5,#0]            ;505
000036  6010              STR      r0,[r2,#0]            ;505
000038  1d12              ADDS     r2,r2,#4              ;506
00003a  1d2d              ADDS     r5,r5,#4              ;507
00003c  1e5b              SUBS     r3,r3,#1              ;503
                  |L12.62|
00003e  2b00              CMP      r3,#0                 ;503
000040  d1f8              BNE      |L12.52|
000042  bf00              NOP                            ;511
000044  2000              MOVS     r0,#0                 ;511
000046  f884002d          STRB     r0,[r4,#0x2d]         ;511
00004a  bf00              NOP                            ;511
00004c  bf00              NOP                            ;513
00004e  e7e0              B        |L12.18|
;;;515    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_8b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_8b PROC
;;;316      */
;;;317    HAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319      __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
000004  460d              MOV      r5,r1
;;;320      
;;;321      /* Process Locked */
;;;322      __HAL_LOCK(hsdram);
000006  bf00              NOP      
000008  f894002d          LDRB     r0,[r4,#0x2d]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L13.20|
000010  2002              MOVS     r0,#2
                  |L13.18|
;;;323      
;;;324      /* Check the SDRAM controller state */
;;;325      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
;;;326      {
;;;327        return HAL_BUSY;
;;;328      }
;;;329      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
;;;330      {
;;;331        return  HAL_ERROR; 
;;;332      }  
;;;333      
;;;334      /* Read data from source */
;;;335      for(; BufferSize != 0; BufferSize--)
;;;336      {
;;;337        *pDstBuffer = *(__IO uint8_t *)pSdramAddress;  
;;;338        pDstBuffer++;
;;;339        pSdramAddress++;
;;;340      }
;;;341      
;;;342      /* Process Unlocked */
;;;343      __HAL_UNLOCK(hsdram);
;;;344      
;;;345      return HAL_OK; 
;;;346    }
000012  bd30              POP      {r4,r5,pc}
                  |L13.20|
000014  2001              MOVS     r0,#1                 ;322
000016  f884002d          STRB     r0,[r4,#0x2d]         ;322
00001a  bf00              NOP                            ;322
00001c  f894002c          LDRB     r0,[r4,#0x2c]         ;325
000020  2802              CMP      r0,#2                 ;325
000022  d100              BNE      |L13.38|
000024  e7f5              B        |L13.18|
                  |L13.38|
000026  f894002c          LDRB     r0,[r4,#0x2c]         ;329
00002a  2805              CMP      r0,#5                 ;329
00002c  d101              BNE      |L13.50|
00002e  2001              MOVS     r0,#1                 ;331
000030  e7ef              B        |L13.18|
                  |L13.50|
000032  e004              B        |L13.62|
                  |L13.52|
000034  7828              LDRB     r0,[r5,#0]            ;337
000036  7010              STRB     r0,[r2,#0]            ;337
000038  1c52              ADDS     r2,r2,#1              ;338
00003a  1c6d              ADDS     r5,r5,#1              ;339
00003c  1e5b              SUBS     r3,r3,#1              ;335
                  |L13.62|
00003e  2b00              CMP      r3,#0                 ;335
000040  d1f8              BNE      |L13.52|
000042  bf00              NOP                            ;343
000044  2000              MOVS     r0,#0                 ;343
000046  f884002d          STRB     r0,[r4,#0x2d]         ;343
00004a  bf00              NOP                            ;343
00004c  bf00              NOP                            ;345
00004e  e7e0              B        |L13.18|
;;;347    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Read_DMA PROC
;;;567      */
;;;568    HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;569    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;570      uint32_t tmp = 0;
00000c  2500              MOVS     r5,#0
;;;571        
;;;572      /* Process Locked */
;;;573      __HAL_LOCK(hsdram);
00000e  bf00              NOP      
000010  f894002d          LDRB     r0,[r4,#0x2d]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L14.30|
000018  2002              MOVS     r0,#2
                  |L14.26|
;;;574      
;;;575      /* Check the SDRAM controller state */  
;;;576      tmp = hsdram->State;
;;;577      
;;;578      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;579      {
;;;580        return HAL_BUSY;
;;;581      }
;;;582      else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
;;;583      {
;;;584        return  HAL_ERROR; 
;;;585      }  
;;;586      
;;;587      /* Configure DMA user callbacks */
;;;588      hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
;;;589      hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
;;;590      
;;;591      /* Enable the DMA Stream */
;;;592      HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
;;;593      
;;;594      /* Process Unlocked */
;;;595      __HAL_UNLOCK(hsdram);  
;;;596      
;;;597      return HAL_OK; 
;;;598    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L14.30|
00001e  2001              MOVS     r0,#1                 ;573
000020  f884002d          STRB     r0,[r4,#0x2d]         ;573
000024  bf00              NOP                            ;573
000026  f894502c          LDRB     r5,[r4,#0x2c]         ;576
00002a  2d02              CMP      r5,#2                 ;578
00002c  d101              BNE      |L14.50|
00002e  2002              MOVS     r0,#2                 ;580
000030  e7f3              B        |L14.26|
                  |L14.50|
000032  2d05              CMP      r5,#5                 ;582
000034  d101              BNE      |L14.58|
000036  2001              MOVS     r0,#1                 ;584
000038  e7ef              B        |L14.26|
                  |L14.58|
00003a  4809              LDR      r0,|L14.96|
00003c  6b21              LDR      r1,[r4,#0x30]         ;588
00003e  63c8              STR      r0,[r1,#0x3c]         ;588
000040  4808              LDR      r0,|L14.100|
000042  6b21              LDR      r1,[r4,#0x30]         ;589
000044  64c8              STR      r0,[r1,#0x4c]         ;589
000046  4643              MOV      r3,r8                 ;592
000048  463a              MOV      r2,r7                 ;592
00004a  4631              MOV      r1,r6                 ;592
00004c  6b20              LDR      r0,[r4,#0x30]         ;592
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  bf00              NOP                            ;595
000054  2000              MOVS     r0,#0                 ;595
000056  f884002d          STRB     r0,[r4,#0x2d]         ;595
00005a  bf00              NOP                            ;595
00005c  bf00              NOP                            ;597
00005e  e7dc              B        |L14.26|
;;;599    
                          ENDP

                  |L14.96|
                          DCD      HAL_SDRAM_DMA_XferCpltCallback
                  |L14.100|
                          DCD      HAL_SDRAM_DMA_XferErrorCallback

                          AREA ||i.HAL_SDRAM_RefreshErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_RefreshErrorCallback PROC
;;;248      */
;;;249    __weak void HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;250    {
;;;251      /* Prevent unused argument(s) compilation warning */
;;;252      UNUSED(hsdram);
;;;253     
;;;254      /* NOTE: This function Should not be modified, when the callback is needed,
;;;255                the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
;;;256       */ 
;;;257    }
;;;258    
                          ENDP


                          AREA ||i.HAL_SDRAM_SendCommand||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_SendCommand PROC
;;;719      */  
;;;720    HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;721    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;722      /* Check the SDRAM controller state */
;;;723      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000008  f894002c          LDRB     r0,[r4,#0x2c]
00000c  2802              CMP      r0,#2
00000e  d100              BNE      |L16.18|
                  |L16.16|
;;;724      {
;;;725        return HAL_BUSY;
;;;726      }
;;;727      
;;;728      /* Update the SDRAM state */
;;;729      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;730      
;;;731      /* Send SDRAM command */
;;;732      FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
;;;733      
;;;734      /* Update the SDRAM controller state state */
;;;735      if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
;;;736      {
;;;737        hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
;;;738      }
;;;739      else
;;;740      {
;;;741        hsdram->State = HAL_SDRAM_STATE_READY;
;;;742      }
;;;743      
;;;744      return HAL_OK;  
;;;745    }
000010  bd70              POP      {r4-r6,pc}
                  |L16.18|
000012  2002              MOVS     r0,#2                 ;729
000014  f884002c          STRB     r0,[r4,#0x2c]         ;729
000018  4632              MOV      r2,r6                 ;732
00001a  4629              MOV      r1,r5                 ;732
00001c  6820              LDR      r0,[r4,#0]            ;732
00001e  f7fffffe          BL       FMC_SDRAM_SendCommand
000022  6828              LDR      r0,[r5,#0]            ;735
000024  2802              CMP      r0,#2                 ;735
000026  d103              BNE      |L16.48|
000028  2005              MOVS     r0,#5                 ;737
00002a  f884002c          STRB     r0,[r4,#0x2c]         ;737
00002e  e002              B        |L16.54|
                  |L16.48|
000030  2001              MOVS     r0,#1                 ;741
000032  f884002c          STRB     r0,[r4,#0x2c]         ;741
                  |L16.54|
000036  2000              MOVS     r0,#0                 ;744
000038  e7ea              B        |L16.16|
;;;746    
                          ENDP


                          AREA ||i.HAL_SDRAM_SetAutoRefreshNumber||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_SetAutoRefreshNumber PROC
;;;780      */
;;;781    HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
000000  b570              PUSH     {r4-r6,lr}
;;;782    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;783      /* Check the SDRAM controller state */
;;;784      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000006  f894002c          LDRB     r0,[r4,#0x2c]
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L17.16|
                  |L17.14|
;;;785      {
;;;786        return HAL_BUSY;
;;;787      } 
;;;788      
;;;789      /* Update the SDRAM state */
;;;790      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;791      
;;;792      /* Set the Auto-Refresh number */
;;;793      FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance ,AutoRefreshNumber);
;;;794      
;;;795      /* Update the SDRAM state */
;;;796      hsdram->State = HAL_SDRAM_STATE_READY;
;;;797      
;;;798      return HAL_OK;
;;;799    }
00000e  bd70              POP      {r4-r6,pc}
                  |L17.16|
000010  2002              MOVS     r0,#2                 ;790
000012  f884002c          STRB     r0,[r4,#0x2c]         ;790
000016  4629              MOV      r1,r5                 ;793
000018  6820              LDR      r0,[r4,#0]            ;793
00001a  f7fffffe          BL       FMC_SDRAM_SetAutoRefreshNumber
00001e  2001              MOVS     r0,#1                 ;796
000020  f884002c          STRB     r0,[r4,#0x2c]         ;796
000024  2000              MOVS     r0,#0                 ;798
000026  e7f2              B        |L17.14|
;;;800    
                          ENDP


                          AREA ||i.HAL_SDRAM_WriteProtection_Disable||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_WriteProtection_Disable PROC
;;;691      */
;;;692    HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;693    {
000002  4604              MOV      r4,r0
;;;694      /* Check the SDRAM controller state */
;;;695      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  f894002c          LDRB     r0,[r4,#0x2c]
000008  2802              CMP      r0,#2
00000a  d100              BNE      |L18.14|
                  |L18.12|
;;;696      {
;;;697        return HAL_BUSY;
;;;698      }
;;;699      
;;;700      /* Update the SDRAM state */
;;;701      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;702      
;;;703      /* Disable write protection */
;;;704      FMC_SDRAM_WriteProtection_Disable(hsdram->Instance, hsdram->Init.SDBank);
;;;705      
;;;706      /* Update the SDRAM state */
;;;707      hsdram->State = HAL_SDRAM_STATE_READY;
;;;708      
;;;709      return HAL_OK;
;;;710    }
00000c  bd10              POP      {r4,pc}
                  |L18.14|
00000e  2002              MOVS     r0,#2                 ;701
000010  f884002c          STRB     r0,[r4,#0x2c]         ;701
000014  e9d40100          LDRD     r0,r1,[r4,#0]         ;704
000018  f7fffffe          BL       FMC_SDRAM_WriteProtection_Disable
00001c  2001              MOVS     r0,#1                 ;707
00001e  f884002c          STRB     r0,[r4,#0x2c]         ;707
000022  2000              MOVS     r0,#0                 ;709
000024  e7f2              B        |L18.12|
;;;711    
                          ENDP


                          AREA ||i.HAL_SDRAM_WriteProtection_Enable||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_WriteProtection_Enable PROC
;;;665      */
;;;666    HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;667    { 
000002  4604              MOV      r4,r0
;;;668      /* Check the SDRAM controller state */ 
;;;669      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  f894002c          LDRB     r0,[r4,#0x2c]
000008  2802              CMP      r0,#2
00000a  d100              BNE      |L19.14|
                  |L19.12|
;;;670      {
;;;671        return HAL_BUSY;
;;;672      }
;;;673      
;;;674      /* Update the SDRAM state */
;;;675      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;676      
;;;677      /* Enable write protection */
;;;678      FMC_SDRAM_WriteProtection_Enable(hsdram->Instance, hsdram->Init.SDBank);
;;;679      
;;;680      /* Update the SDRAM state */
;;;681      hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
;;;682      
;;;683      return HAL_OK;  
;;;684    }
00000c  bd10              POP      {r4,pc}
                  |L19.14|
00000e  2002              MOVS     r0,#2                 ;675
000010  f884002c          STRB     r0,[r4,#0x2c]         ;675
000014  e9d40100          LDRD     r0,r1,[r4,#0]         ;678
000018  f7fffffe          BL       FMC_SDRAM_WriteProtection_Enable
00001c  2004              MOVS     r0,#4                 ;681
00001e  f884002c          STRB     r0,[r4,#0x2c]         ;681
000022  2000              MOVS     r0,#0                 ;683
000024  e7f2              B        |L19.12|
;;;685    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_16b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_16b PROC
;;;441      */
;;;442    HAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;444      __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
000006  462e              MOV      r6,r5
;;;445      uint32_t tmp = 0;
000008  2100              MOVS     r1,#0
;;;446      
;;;447      /* Process Locked */
;;;448      __HAL_LOCK(hsdram);
00000a  bf00              NOP      
00000c  f894002d          LDRB     r0,[r4,#0x2d]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L20.24|
000014  2002              MOVS     r0,#2
                  |L20.22|
;;;449      
;;;450      /* Check the SDRAM controller state */
;;;451      tmp = hsdram->State;
;;;452      
;;;453      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;454      {
;;;455        return HAL_BUSY;
;;;456      }
;;;457      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;458      {
;;;459        return  HAL_ERROR; 
;;;460      }
;;;461      
;;;462      /* Write data to memory */
;;;463      for(; BufferSize != 0; BufferSize--)
;;;464      {
;;;465        *(__IO uint16_t *)pSdramAddress = *pSrcBuffer;
;;;466        pSrcBuffer++;
;;;467        pSdramAddress++;            
;;;468      }
;;;469      
;;;470      /* Process Unlocked */
;;;471      __HAL_UNLOCK(hsdram);    
;;;472      
;;;473      return HAL_OK;   
;;;474    }
000016  bd70              POP      {r4-r6,pc}
                  |L20.24|
000018  2001              MOVS     r0,#1                 ;448
00001a  f884002d          STRB     r0,[r4,#0x2d]         ;448
00001e  bf00              NOP                            ;448
000020  f894102c          LDRB     r1,[r4,#0x2c]         ;451
000024  2902              CMP      r1,#2                 ;453
000026  d101              BNE      |L20.44|
000028  2002              MOVS     r0,#2                 ;455
00002a  e7f4              B        |L20.22|
                  |L20.44|
00002c  2905              CMP      r1,#5                 ;457
00002e  d001              BEQ      |L20.52|
000030  2904              CMP      r1,#4                 ;457
000032  d101              BNE      |L20.56|
                  |L20.52|
000034  2001              MOVS     r0,#1                 ;459
000036  e7ee              B        |L20.22|
                  |L20.56|
000038  e004              B        |L20.68|
                  |L20.58|
00003a  8810              LDRH     r0,[r2,#0]            ;465
00003c  8030              STRH     r0,[r6,#0]            ;465
00003e  1c92              ADDS     r2,r2,#2              ;466
000040  1cb6              ADDS     r6,r6,#2              ;467
000042  1e5b              SUBS     r3,r3,#1              ;463
                  |L20.68|
000044  2b00              CMP      r3,#0                 ;463
000046  d1f8              BNE      |L20.58|
000048  bf00              NOP                            ;471
00004a  2000              MOVS     r0,#0                 ;471
00004c  f884002d          STRB     r0,[r4,#0x2d]         ;471
000050  bf00              NOP                            ;471
000052  bf00              NOP                            ;473
000054  e7df              B        |L20.22|
;;;475    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_32b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_32b PROC
;;;524      */
;;;525    HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;526    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;527      __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
000006  462e              MOV      r6,r5
;;;528      uint32_t tmp = 0;
000008  2100              MOVS     r1,#0
;;;529      
;;;530      /* Process Locked */
;;;531      __HAL_LOCK(hsdram);
00000a  bf00              NOP      
00000c  f894002d          LDRB     r0,[r4,#0x2d]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L21.24|
000014  2002              MOVS     r0,#2
                  |L21.22|
;;;532      
;;;533      /* Check the SDRAM controller state */
;;;534      tmp = hsdram->State;
;;;535      
;;;536      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;537      {
;;;538        return HAL_BUSY;
;;;539      }
;;;540      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;541      {
;;;542        return  HAL_ERROR; 
;;;543      }
;;;544      
;;;545      /* Write data to memory */
;;;546      for(; BufferSize != 0; BufferSize--)
;;;547      {
;;;548        *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
;;;549        pSrcBuffer++;
;;;550        pSdramAddress++;          
;;;551      }
;;;552      
;;;553      /* Process Unlocked */
;;;554      __HAL_UNLOCK(hsdram);    
;;;555      
;;;556      return HAL_OK;  
;;;557    }
000016  bd70              POP      {r4-r6,pc}
                  |L21.24|
000018  2001              MOVS     r0,#1                 ;531
00001a  f884002d          STRB     r0,[r4,#0x2d]         ;531
00001e  bf00              NOP                            ;531
000020  f894102c          LDRB     r1,[r4,#0x2c]         ;534
000024  2902              CMP      r1,#2                 ;536
000026  d101              BNE      |L21.44|
000028  2002              MOVS     r0,#2                 ;538
00002a  e7f4              B        |L21.22|
                  |L21.44|
00002c  2905              CMP      r1,#5                 ;540
00002e  d001              BEQ      |L21.52|
000030  2904              CMP      r1,#4                 ;540
000032  d101              BNE      |L21.56|
                  |L21.52|
000034  2001              MOVS     r0,#1                 ;542
000036  e7ee              B        |L21.22|
                  |L21.56|
000038  e004              B        |L21.68|
                  |L21.58|
00003a  6810              LDR      r0,[r2,#0]            ;548
00003c  6030              STR      r0,[r6,#0]            ;548
00003e  1d12              ADDS     r2,r2,#4              ;549
000040  1d36              ADDS     r6,r6,#4              ;550
000042  1e5b              SUBS     r3,r3,#1              ;546
                  |L21.68|
000044  2b00              CMP      r3,#0                 ;546
000046  d1f8              BNE      |L21.58|
000048  bf00              NOP                            ;554
00004a  2000              MOVS     r0,#0                 ;554
00004c  f884002d          STRB     r0,[r4,#0x2d]         ;554
000050  bf00              NOP                            ;554
000052  bf00              NOP                            ;556
000054  e7df              B        |L21.22|
;;;558    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_8b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_8b PROC
;;;357      */
;;;358    HAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;359    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;360      __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
000006  462e              MOV      r6,r5
;;;361      uint32_t tmp = 0;
000008  2100              MOVS     r1,#0
;;;362      
;;;363      /* Process Locked */
;;;364      __HAL_LOCK(hsdram);
00000a  bf00              NOP      
00000c  f894002d          LDRB     r0,[r4,#0x2d]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L22.24|
000014  2002              MOVS     r0,#2
                  |L22.22|
;;;365      
;;;366      /* Check the SDRAM controller state */
;;;367      tmp = hsdram->State;
;;;368      
;;;369      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;370      {
;;;371        return HAL_BUSY;
;;;372      }
;;;373      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;374      {
;;;375        return  HAL_ERROR; 
;;;376      }
;;;377      
;;;378      /* Write data to memory */
;;;379      for(; BufferSize != 0; BufferSize--)
;;;380      {
;;;381        *(__IO uint8_t *)pSdramAddress = *pSrcBuffer;
;;;382        pSrcBuffer++;
;;;383        pSdramAddress++;
;;;384      }
;;;385      
;;;386      /* Process Unlocked */
;;;387      __HAL_UNLOCK(hsdram);    
;;;388      
;;;389      return HAL_OK;   
;;;390    }
000016  bd70              POP      {r4-r6,pc}
                  |L22.24|
000018  2001              MOVS     r0,#1                 ;364
00001a  f884002d          STRB     r0,[r4,#0x2d]         ;364
00001e  bf00              NOP                            ;364
000020  f894102c          LDRB     r1,[r4,#0x2c]         ;367
000024  2902              CMP      r1,#2                 ;369
000026  d101              BNE      |L22.44|
000028  2002              MOVS     r0,#2                 ;371
00002a  e7f4              B        |L22.22|
                  |L22.44|
00002c  2905              CMP      r1,#5                 ;373
00002e  d001              BEQ      |L22.52|
000030  2904              CMP      r1,#4                 ;373
000032  d101              BNE      |L22.56|
                  |L22.52|
000034  2001              MOVS     r0,#1                 ;375
000036  e7ee              B        |L22.22|
                  |L22.56|
000038  e004              B        |L22.68|
                  |L22.58|
00003a  7810              LDRB     r0,[r2,#0]            ;381
00003c  7030              STRB     r0,[r6,#0]            ;381
00003e  1c52              ADDS     r2,r2,#1              ;382
000040  1c76              ADDS     r6,r6,#1              ;383
000042  1e5b              SUBS     r3,r3,#1              ;379
                  |L22.68|
000044  2b00              CMP      r3,#0                 ;379
000046  d1f8              BNE      |L22.58|
000048  bf00              NOP                            ;387
00004a  2000              MOVS     r0,#0                 ;387
00004c  f884002d          STRB     r0,[r4,#0x2d]         ;387
000050  bf00              NOP                            ;387
000052  bf00              NOP                            ;389
000054  e7df              B        |L22.22|
;;;391    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Write_DMA PROC
;;;608      */
;;;609    HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;610    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;611      uint32_t tmp = 0;
00000c  2500              MOVS     r5,#0
;;;612      
;;;613      /* Process Locked */
;;;614      __HAL_LOCK(hsdram);
00000e  bf00              NOP      
000010  f894002d          LDRB     r0,[r4,#0x2d]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L23.30|
000018  2002              MOVS     r0,#2
                  |L23.26|
;;;615      
;;;616      /* Check the SDRAM controller state */  
;;;617      tmp = hsdram->State;
;;;618      
;;;619      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;620      {
;;;621        return HAL_BUSY;
;;;622      }
;;;623      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;624      {
;;;625        return  HAL_ERROR; 
;;;626      }  
;;;627      
;;;628      /* Configure DMA user callbacks */
;;;629      hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
;;;630      hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
;;;631      
;;;632      /* Enable the DMA Stream */
;;;633      HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
;;;634      
;;;635      /* Process Unlocked */
;;;636      __HAL_UNLOCK(hsdram);
;;;637      
;;;638      return HAL_OK;
;;;639    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L23.30|
00001e  2001              MOVS     r0,#1                 ;614
000020  f884002d          STRB     r0,[r4,#0x2d]         ;614
000024  bf00              NOP                            ;614
000026  f894502c          LDRB     r5,[r4,#0x2c]         ;617
00002a  2d02              CMP      r5,#2                 ;619
00002c  d101              BNE      |L23.50|
00002e  2002              MOVS     r0,#2                 ;621
000030  e7f3              B        |L23.26|
                  |L23.50|
000032  2d05              CMP      r5,#5                 ;623
000034  d001              BEQ      |L23.58|
000036  2d04              CMP      r5,#4                 ;623
000038  d101              BNE      |L23.62|
                  |L23.58|
00003a  2001              MOVS     r0,#1                 ;625
00003c  e7ed              B        |L23.26|
                  |L23.62|
00003e  4809              LDR      r0,|L23.100|
000040  6b21              LDR      r1,[r4,#0x30]         ;629
000042  63c8              STR      r0,[r1,#0x3c]         ;629
000044  4808              LDR      r0,|L23.104|
000046  6b21              LDR      r1,[r4,#0x30]         ;630
000048  64c8              STR      r0,[r1,#0x4c]         ;630
00004a  4643              MOV      r3,r8                 ;633
00004c  4632              MOV      r2,r6                 ;633
00004e  4639              MOV      r1,r7                 ;633
000050  6b20              LDR      r0,[r4,#0x30]         ;633
000052  f7fffffe          BL       HAL_DMA_Start_IT
000056  bf00              NOP                            ;636
000058  2000              MOVS     r0,#0                 ;636
00005a  f884002d          STRB     r0,[r4,#0x2d]         ;636
00005e  bf00              NOP                            ;636
000060  bf00              NOP                            ;638
000062  e7da              B        |L23.26|
;;;640    
                          ENDP

                  |L23.100|
                          DCD      HAL_SDRAM_DMA_XferCpltCallback
                  |L23.104|
                          DCD      HAL_SDRAM_DMA_XferErrorCallback

;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_sdram.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REVSH|
#line 402
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____RRX|
#line 587
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
