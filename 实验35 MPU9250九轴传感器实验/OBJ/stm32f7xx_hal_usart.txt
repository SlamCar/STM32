; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f7xx_hal_usart.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f7xx_hal_usart.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\stm32f7xx_hal_usart.crf ..\HALLIB\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_usart.c]
                          THUMB

                          AREA ||i.HAL_USART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAPause PROC
;;;1010     */
;;;1011   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1012   {
;;;1013     /* Process Locked */
;;;1014     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  f8910044          LDRB     r0,[r1,#0x44]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L1.16|
00000c  2002              MOVS     r0,#2
                  |L1.14|
;;;1015   
;;;1016     if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1017     {
;;;1018       /* Disable the USART DMA Tx request */
;;;1019       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1020     }
;;;1021     else if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1022     {
;;;1023       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1024       CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;1025       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1026       /* Disable the USART DMA Rx request */
;;;1027       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1028     }
;;;1029     else if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
;;;1030     {
;;;1031       /* Disable the USART DMA Tx request */
;;;1032       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1033       /* Disable the USART DMA Rx request */
;;;1034       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1035     }
;;;1036   
;;;1037     /* Process Unlocked */
;;;1038     __HAL_UNLOCK(husart);
;;;1039   
;;;1040     return HAL_OK;
;;;1041   }
00000e  4770              BX       lr
                  |L1.16|
000010  2001              MOVS     r0,#1                 ;1014
000012  f8810044          STRB     r0,[r1,#0x44]         ;1014
000016  bf00              NOP                            ;1014
000018  f8910045          LDRB     r0,[r1,#0x45]         ;1016
00001c  2812              CMP      r0,#0x12              ;1016
00001e  d106              BNE      |L1.46|
000020  6808              LDR      r0,[r1,#0]            ;1019
000022  6880              LDR      r0,[r0,#8]            ;1019
000024  f0200080          BIC      r0,r0,#0x80           ;1019
000028  680a              LDR      r2,[r1,#0]            ;1019
00002a  6090              STR      r0,[r2,#8]            ;1019
00002c  e026              B        |L1.124|
                  |L1.46|
00002e  f8910045          LDRB     r0,[r1,#0x45]         ;1021
000032  2822              CMP      r0,#0x22              ;1021
000034  d112              BNE      |L1.92|
000036  6808              LDR      r0,[r1,#0]            ;1024
000038  6800              LDR      r0,[r0,#0]            ;1024
00003a  f4207090          BIC      r0,r0,#0x120          ;1024
00003e  680a              LDR      r2,[r1,#0]            ;1024
000040  6010              STR      r0,[r2,#0]            ;1024
000042  6808              LDR      r0,[r1,#0]            ;1025
000044  6880              LDR      r0,[r0,#8]            ;1025
000046  f0200001          BIC      r0,r0,#1              ;1025
00004a  680a              LDR      r2,[r1,#0]            ;1025
00004c  6090              STR      r0,[r2,#8]            ;1025
00004e  6808              LDR      r0,[r1,#0]            ;1027
000050  6880              LDR      r0,[r0,#8]            ;1027
000052  f0200040          BIC      r0,r0,#0x40           ;1027
000056  680a              LDR      r2,[r1,#0]            ;1027
000058  6090              STR      r0,[r2,#8]            ;1027
00005a  e00f              B        |L1.124|
                  |L1.92|
00005c  f8910045          LDRB     r0,[r1,#0x45]         ;1029
000060  2832              CMP      r0,#0x32              ;1029
000062  d10b              BNE      |L1.124|
000064  6808              LDR      r0,[r1,#0]            ;1032
000066  6880              LDR      r0,[r0,#8]            ;1032
000068  f0200040          BIC      r0,r0,#0x40           ;1032
00006c  680a              LDR      r2,[r1,#0]            ;1032
00006e  6090              STR      r0,[r2,#8]            ;1032
000070  6808              LDR      r0,[r1,#0]            ;1034
000072  6880              LDR      r0,[r0,#8]            ;1034
000074  f0200080          BIC      r0,r0,#0x80           ;1034
000078  680a              LDR      r2,[r1,#0]            ;1034
00007a  6090              STR      r0,[r2,#8]            ;1034
                  |L1.124|
00007c  bf00              NOP                            ;1038
00007e  2000              MOVS     r0,#0                 ;1038
000080  f8810044          STRB     r0,[r1,#0x44]         ;1038
000084  bf00              NOP                            ;1038
000086  bf00              NOP                            ;1040
000088  e7c1              B        |L1.14|
;;;1042   
                          ENDP


                          AREA ||i.HAL_USART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAResume PROC
;;;1047     */
;;;1048   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1049   {
;;;1050     /* Process Locked */
;;;1051     __HAL_LOCK(husart);
000002  bf00              NOP      
000004  f8910044          LDRB     r0,[r1,#0x44]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L2.16|
00000c  2002              MOVS     r0,#2
                  |L2.14|
;;;1052   
;;;1053     if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1054     {
;;;1055       /* Enable the USART DMA Tx request */
;;;1056       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1057     }
;;;1058     else if(husart->State == HAL_USART_STATE_BUSY_RX)
;;;1059     {
;;;1060       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1061       __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
;;;1062       
;;;1063       /* Reenable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1064       SET_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;1065       SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;1066   
;;;1067       /* Enable the USART DMA Rx request */
;;;1068       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1069     }
;;;1070     else if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
;;;1071     {
;;;1072       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1073       __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
;;;1074   
;;;1075       /* Enable the USART DMA Rx request  before the DMA Tx request */
;;;1076       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1077   
;;;1078       /* Enable the USART DMA Tx request */
;;;1079       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1080     }
;;;1081   
;;;1082     /* Process Unlocked */
;;;1083     __HAL_UNLOCK(husart);
;;;1084   
;;;1085     return HAL_OK;
;;;1086   }
00000e  4770              BX       lr
                  |L2.16|
000010  2001              MOVS     r0,#1                 ;1051
000012  f8810044          STRB     r0,[r1,#0x44]         ;1051
000016  bf00              NOP                            ;1051
000018  f8910045          LDRB     r0,[r1,#0x45]         ;1053
00001c  2812              CMP      r0,#0x12              ;1053
00001e  d106              BNE      |L2.46|
000020  6808              LDR      r0,[r1,#0]            ;1056
000022  6880              LDR      r0,[r0,#8]            ;1056
000024  f0400080          ORR      r0,r0,#0x80           ;1056
000028  680a              LDR      r2,[r1,#0]            ;1056
00002a  6090              STR      r0,[r2,#8]            ;1056
00002c  e02c              B        |L2.136|
                  |L2.46|
00002e  f8910045          LDRB     r0,[r1,#0x45]         ;1058
000032  2822              CMP      r0,#0x22              ;1058
000034  d115              BNE      |L2.98|
000036  2008              MOVS     r0,#8                 ;1061
000038  680a              LDR      r2,[r1,#0]            ;1061
00003a  6210              STR      r0,[r2,#0x20]         ;1061
00003c  6808              LDR      r0,[r1,#0]            ;1064
00003e  6800              LDR      r0,[r0,#0]            ;1064
000040  f4407090          ORR      r0,r0,#0x120          ;1064
000044  680a              LDR      r2,[r1,#0]            ;1064
000046  6010              STR      r0,[r2,#0]            ;1064
000048  6808              LDR      r0,[r1,#0]            ;1065
00004a  6880              LDR      r0,[r0,#8]            ;1065
00004c  f0400001          ORR      r0,r0,#1              ;1065
000050  680a              LDR      r2,[r1,#0]            ;1065
000052  6090              STR      r0,[r2,#8]            ;1065
000054  6808              LDR      r0,[r1,#0]            ;1068
000056  6880              LDR      r0,[r0,#8]            ;1068
000058  f0400040          ORR      r0,r0,#0x40           ;1068
00005c  680a              LDR      r2,[r1,#0]            ;1068
00005e  6090              STR      r0,[r2,#8]            ;1068
000060  e012              B        |L2.136|
                  |L2.98|
000062  f8910045          LDRB     r0,[r1,#0x45]         ;1070
000066  2832              CMP      r0,#0x32              ;1070
000068  d10e              BNE      |L2.136|
00006a  2008              MOVS     r0,#8                 ;1073
00006c  680a              LDR      r2,[r1,#0]            ;1073
00006e  6210              STR      r0,[r2,#0x20]         ;1073
000070  6808              LDR      r0,[r1,#0]            ;1076
000072  6880              LDR      r0,[r0,#8]            ;1076
000074  f0400040          ORR      r0,r0,#0x40           ;1076
000078  680a              LDR      r2,[r1,#0]            ;1076
00007a  6090              STR      r0,[r2,#8]            ;1076
00007c  6808              LDR      r0,[r1,#0]            ;1079
00007e  6880              LDR      r0,[r0,#8]            ;1079
000080  f0400080          ORR      r0,r0,#0x80           ;1079
000084  680a              LDR      r2,[r1,#0]            ;1079
000086  6090              STR      r0,[r2,#8]            ;1079
                  |L2.136|
000088  bf00              NOP                            ;1083
00008a  2000              MOVS     r0,#0                 ;1083
00008c  f8810044          STRB     r0,[r1,#0x44]         ;1083
000090  bf00              NOP                            ;1083
000092  bf00              NOP                            ;1085
000094  e7bb              B        |L2.14|
;;;1087   
                          ENDP


                          AREA ||i.HAL_USART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_USART_DMAStop PROC
;;;1092     */
;;;1093   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1094   {
000002  4604              MOV      r4,r0
;;;1095     /* The Lock is not implemented on this API to allow the user application
;;;1096        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback() /
;;;1097        HAL_USART_TxHalfCpltCallback / HAL_USART_RxHalfCpltCallback: 
;;;1098        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete  
;;;1099        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of 
;;;1100        the stream and the corresponding call back is executed. */
;;;1101   
;;;1102     /* Stop USART DMA Tx request if ongoing */
;;;1103     if ((husart->State == HAL_USART_STATE_BUSY_TX) &&
000004  f8940045          LDRB     r0,[r4,#0x45]
000008  2812              CMP      r0,#0x12
00000a  d112              BNE      |L3.50|
;;;1104         (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)))
00000c  6820              LDR      r0,[r4,#0]
00000e  6880              LDR      r0,[r0,#8]
000010  f0000080          AND      r0,r0,#0x80
000014  b168              CBZ      r0,|L3.50|
;;;1105     {
;;;1106       USART_EndTxTransfer(husart);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USART_EndTxTransfer
;;;1107       
;;;1108       /* Abort the USART DMA Tx channel */
;;;1109       if(husart->hdmatx != NULL)
00001c  6be0              LDR      r0,[r4,#0x3c]
00001e  b110              CBZ      r0,|L3.38|
;;;1110       {
;;;1111         HAL_DMA_Abort(husart->hdmatx);
000020  6be0              LDR      r0,[r4,#0x3c]
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L3.38|
;;;1112       }
;;;1113       
;;;1114       /* Disable the USART Tx DMA request */
;;;1115       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000026  6820              LDR      r0,[r4,#0]
000028  6880              LDR      r0,[r0,#8]
00002a  f0200080          BIC      r0,r0,#0x80
00002e  6821              LDR      r1,[r4,#0]
000030  6088              STR      r0,[r1,#8]
                  |L3.50|
;;;1116     }
;;;1117     
;;;1118     /* Stop USART DMA Rx request if ongoing */
;;;1119     if ((husart->State == HAL_USART_STATE_BUSY_RX) &&
000032  f8940045          LDRB     r0,[r4,#0x45]
000036  2822              CMP      r0,#0x22
000038  d112              BNE      |L3.96|
;;;1120         (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)))
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  f0000040          AND      r0,r0,#0x40
000042  b168              CBZ      r0,|L3.96|
;;;1121     {
;;;1122       USART_EndRxTransfer(husart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       USART_EndRxTransfer
;;;1123       
;;;1124       /* Abort the USART DMA Rx channel */
;;;1125       if(husart->hdmarx != NULL)
00004a  6c20              LDR      r0,[r4,#0x40]
00004c  b110              CBZ      r0,|L3.84|
;;;1126       {
;;;1127         HAL_DMA_Abort(husart->hdmarx);
00004e  6c20              LDR      r0,[r4,#0x40]
000050  f7fffffe          BL       HAL_DMA_Abort
                  |L3.84|
;;;1128       }
;;;1129       
;;;1130       /* Disable the USART Rx DMA request */
;;;1131       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000054  6820              LDR      r0,[r4,#0]
000056  6880              LDR      r0,[r0,#8]
000058  f0200040          BIC      r0,r0,#0x40
00005c  6821              LDR      r1,[r4,#0]
00005e  6088              STR      r0,[r1,#8]
                  |L3.96|
;;;1132     }
;;;1133     
;;;1134     return HAL_OK;
000060  2000              MOVS     r0,#0
;;;1135   }
000062  bd10              POP      {r4,pc}
;;;1136   
                          ENDP


                          AREA ||i.HAL_USART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_DeInit PROC
;;;238      */
;;;239    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;240    {
000002  4604              MOV      r4,r0
;;;241       /* Check the USART handle allocation */
;;;242      if(husart == NULL)
000004  b90c              CBNZ     r4,|L4.10|
;;;243      {
;;;244        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L4.8|
;;;245      }
;;;246    
;;;247      /* Check the parameters */
;;;248      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;249    
;;;250      husart->State = HAL_USART_STATE_BUSY;
;;;251    
;;;252      husart->Instance->CR1 = 0x0U;
;;;253      husart->Instance->CR2 = 0x0U;
;;;254      husart->Instance->CR3 = 0x0U;
;;;255    
;;;256      /* DeInit the low level hardware */
;;;257      HAL_USART_MspDeInit(husart);
;;;258    
;;;259      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;260      husart->State = HAL_USART_STATE_RESET;
;;;261    
;;;262      /* Process Unlock */
;;;263      __HAL_UNLOCK(husart);
;;;264    
;;;265      return HAL_OK;
;;;266    }
000008  bd10              POP      {r4,pc}
                  |L4.10|
00000a  2002              MOVS     r0,#2                 ;250
00000c  f8840045          STRB     r0,[r4,#0x45]         ;250
000010  2000              MOVS     r0,#0                 ;252
000012  6821              LDR      r1,[r4,#0]            ;252
000014  6008              STR      r0,[r1,#0]            ;252
000016  6821              LDR      r1,[r4,#0]            ;253
000018  6048              STR      r0,[r1,#4]            ;253
00001a  6821              LDR      r1,[r4,#0]            ;254
00001c  6088              STR      r0,[r1,#8]            ;254
00001e  4620              MOV      r0,r4                 ;257
000020  f7fffffe          BL       HAL_USART_MspDeInit
000024  2000              MOVS     r0,#0                 ;259
000026  64a0              STR      r0,[r4,#0x48]         ;259
000028  f8840045          STRB     r0,[r4,#0x45]         ;260
00002c  bf00              NOP                            ;263
00002e  f8840044          STRB     r0,[r4,#0x44]         ;263
000032  bf00              NOP                            ;263
000034  bf00              NOP                            ;265
000036  e7e7              B        |L4.8|
;;;267    
                          ENDP


                          AREA ||i.HAL_USART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_ErrorCallback PROC
;;;1362     */
;;;1363   __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1364   {
;;;1365     /* Prevent unused argument(s) compilation warning */
;;;1366     UNUSED(husart);
;;;1367    
;;;1368     /* NOTE : This function should not be modified, when the callback is needed,
;;;1369               the HAL_USART_ErrorCallback can be implemented in the user file
;;;1370      */ 
;;;1371   }
;;;1372   
                          ENDP


                          AREA ||i.HAL_USART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetError PROC
;;;1411     */
;;;1412   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1413   {
;;;1414     return husart->ErrorCode;
000002  6c88              LDR      r0,[r1,#0x48]
;;;1415   }
000004  4770              BX       lr
;;;1416   
                          ENDP


                          AREA ||i.HAL_USART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_USART_GetState PROC
;;;1400     */
;;;1401   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1402   {
;;;1403     return husart->State;
000002  f8910045          LDRB     r0,[r1,#0x45]
;;;1404   }
000006  4770              BX       lr
;;;1405   
                          ENDP


                          AREA ||i.HAL_USART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_USART_IRQHandler PROC
;;;1141     */
;;;1142   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1143   {
000004  4604              MOV      r4,r0
;;;1144     uint32_t isrflags = READ_REG(husart->Instance->ISR);
000006  6820              LDR      r0,[r4,#0]
000008  69c5              LDR      r5,[r0,#0x1c]
;;;1145     uint32_t cr1its   = READ_REG(husart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  6806              LDR      r6,[r0,#0]
;;;1146     uint32_t cr3its   = READ_REG(husart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6887              LDR      r7,[r0,#8]
;;;1147     uint32_t errorflags;
;;;1148     
;;;1149     /* If no error occurs */
;;;1150     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
000012  f005080f          AND      r8,r5,#0xf
;;;1151     if (errorflags == RESET)
000016  f1b80f00          CMP      r8,#0
00001a  d110              BNE      |L8.62|
;;;1152     {
;;;1153       /* USART in mode Receiver --------------------------------------------------*/
;;;1154       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00001c  f0050020          AND      r0,r5,#0x20
000020  b168              CBZ      r0,|L8.62|
000022  f0060020          AND      r0,r6,#0x20
000026  b150              CBZ      r0,|L8.62|
;;;1155       {
;;;1156         if(husart->State == HAL_USART_STATE_BUSY_RX)
000028  f8940045          LDRB     r0,[r4,#0x45]
00002c  2822              CMP      r0,#0x22
00002e  d103              BNE      |L8.56|
;;;1157         {
;;;1158           USART_Receive_IT(husart);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USART_Receive_IT
000036  e002              B        |L8.62|
                  |L8.56|
;;;1159         }
;;;1160         else
;;;1161         {
;;;1162           USART_TransmitReceive_IT(husart);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USART_TransmitReceive_IT
                  |L8.62|
;;;1163         }
;;;1164       }
;;;1165     }
;;;1166     
;;;1167     /* If some errors occur */
;;;1168     if((errorflags != RESET) && ((cr3its & (USART_CR3_EIE | USART_CR1_PEIE)) != RESET))
00003e  f1b80f00          CMP      r8,#0
000042  d077              BEQ      |L8.308|
000044  f2401001          MOV      r0,#0x101
000048  4038              ANDS     r0,r0,r7
00004a  2800              CMP      r0,#0
00004c  d072              BEQ      |L8.308|
;;;1169     {
;;;1170       
;;;1171       /* USART parity error interrupt occurred ------------------------------------*/
;;;1172       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
00004e  f0050001          AND      r0,r5,#1
000052  b148              CBZ      r0,|L8.104|
000054  f4067080          AND      r0,r6,#0x100
000058  b130              CBZ      r0,|L8.104|
;;;1173       {
;;;1174         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_PEF);
00005a  2001              MOVS     r0,#1
00005c  6821              LDR      r1,[r4,#0]
00005e  6208              STR      r0,[r1,#0x20]
;;;1175         husart->ErrorCode |= HAL_USART_ERROR_PE;
000060  6ca0              LDR      r0,[r4,#0x48]
000062  f0400001          ORR      r0,r0,#1
000066  64a0              STR      r0,[r4,#0x48]
                  |L8.104|
;;;1176       }
;;;1177       
;;;1178       /* USART frame error interrupt occurred -------------------------------------*/
;;;1179       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000068  f0050002          AND      r0,r5,#2
00006c  b148              CBZ      r0,|L8.130|
00006e  f0070001          AND      r0,r7,#1
000072  b130              CBZ      r0,|L8.130|
;;;1180       {
;;;1181         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_FEF);
000074  2002              MOVS     r0,#2
000076  6821              LDR      r1,[r4,#0]
000078  6208              STR      r0,[r1,#0x20]
;;;1182         husart->ErrorCode |= HAL_USART_ERROR_FE;
00007a  6ca0              LDR      r0,[r4,#0x48]
00007c  f0400004          ORR      r0,r0,#4
000080  64a0              STR      r0,[r4,#0x48]
                  |L8.130|
;;;1183       }
;;;1184       
;;;1185       /* USART noise error interrupt occurred -------------------------------------*/
;;;1186       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000082  f0050004          AND      r0,r5,#4
000086  b148              CBZ      r0,|L8.156|
000088  f0070001          AND      r0,r7,#1
00008c  b130              CBZ      r0,|L8.156|
;;;1187       {
;;;1188         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_NEF);
00008e  2004              MOVS     r0,#4
000090  6821              LDR      r1,[r4,#0]
000092  6208              STR      r0,[r1,#0x20]
;;;1189         husart->ErrorCode |= HAL_USART_ERROR_NE;
000094  6ca0              LDR      r0,[r4,#0x48]
000096  f0400002          ORR      r0,r0,#2
00009a  64a0              STR      r0,[r4,#0x48]
                  |L8.156|
;;;1190       }
;;;1191       
;;;1192       /* USART Over-Run interrupt occurred ----------------------------------------*/
;;;1193       if(((isrflags & USART_ISR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00009c  f0050008          AND      r0,r5,#8
0000a0  b148              CBZ      r0,|L8.182|
0000a2  f0070001          AND      r0,r7,#1
0000a6  b130              CBZ      r0,|L8.182|
;;;1194       {
;;;1195         __HAL_USART_CLEAR_IT(husart, USART_CLEAR_OREF);
0000a8  2008              MOVS     r0,#8
0000aa  6821              LDR      r1,[r4,#0]
0000ac  6208              STR      r0,[r1,#0x20]
;;;1196         husart->ErrorCode |= HAL_USART_ERROR_ORE;
0000ae  6ca0              LDR      r0,[r4,#0x48]
0000b0  f0400008          ORR      r0,r0,#8
0000b4  64a0              STR      r0,[r4,#0x48]
                  |L8.182|
;;;1197       }
;;;1198       
;;;1199       /* Call USART Error Call back function if need be --------------------------*/
;;;1200       if(husart->ErrorCode != HAL_USART_ERROR_NONE)
0000b6  6ca0              LDR      r0,[r4,#0x48]
0000b8  b358              CBZ      r0,|L8.274|
;;;1201       {
;;;1202         /* USART in mode Receiver ---------------------------------------------------*/
;;;1203         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
0000ba  f0050020          AND      r0,r5,#0x20
0000be  b128              CBZ      r0,|L8.204|
0000c0  f0060020          AND      r0,r6,#0x20
0000c4  b110              CBZ      r0,|L8.204|
;;;1204         {
;;;1205           USART_Receive_IT(husart);
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       USART_Receive_IT
                  |L8.204|
;;;1206         }
;;;1207         
;;;1208         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1209         consider error as blocking */
;;;1210         if (((husart->ErrorCode & HAL_USART_ERROR_ORE) != RESET) ||
0000cc  6ca0              LDR      r0,[r4,#0x48]
0000ce  f0000008          AND      r0,r0,#8
0000d2  b920              CBNZ     r0,|L8.222|
;;;1211             (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)))
0000d4  6820              LDR      r0,[r4,#0]
0000d6  6880              LDR      r0,[r0,#8]
0000d8  f0000040          AND      r0,r0,#0x40
0000dc  b318              CBZ      r0,|L8.294|
                  |L8.222|
;;;1212         {  
;;;1213           /* Blocking error : transfer is aborted
;;;1214           Set the USART state ready to be able to start again the process,
;;;1215           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1216           USART_EndRxTransfer(husart);
0000de  4620              MOV      r0,r4
0000e0  f7fffffe          BL       USART_EndRxTransfer
;;;1217           
;;;1218           /* Disable the USART DMA Rx request if enabled */
;;;1219           if (HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR))
0000e4  6820              LDR      r0,[r4,#0]
0000e6  6880              LDR      r0,[r0,#8]
0000e8  f0000040          AND      r0,r0,#0x40
0000ec  b1b0              CBZ      r0,|L8.284|
;;;1220           {
;;;1221             CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
0000ee  6820              LDR      r0,[r4,#0]
0000f0  6880              LDR      r0,[r0,#8]
0000f2  f0200040          BIC      r0,r0,#0x40
0000f6  6821              LDR      r1,[r4,#0]
0000f8  6088              STR      r0,[r1,#8]
;;;1222             
;;;1223             /* Abort the USART DMA Rx channel */
;;;1224             if(husart->hdmarx != NULL)
0000fa  6c20              LDR      r0,[r4,#0x40]
0000fc  b150              CBZ      r0,|L8.276|
;;;1225             {            
;;;1226               /* Set the USART DMA Abort callback : 
;;;1227               will lead to call HAL_USART_ErrorCallback() at end of DMA abort procedure */
;;;1228               husart->hdmarx->XferAbortCallback = USART_DMAAbortOnError;
0000fe  481c              LDR      r0,|L8.368|
000100  6c21              LDR      r1,[r4,#0x40]
000102  6508              STR      r0,[r1,#0x50]
;;;1229               
;;;1230               /* Abort DMA RX */
;;;1231               if(HAL_DMA_Abort_IT(husart->hdmarx) != HAL_OK)
000104  6c20              LDR      r0,[r4,#0x40]
000106  f7fffffe          BL       HAL_DMA_Abort_IT
00010a  b110              CBZ      r0,|L8.274|
;;;1232               {
;;;1233                 /* Call Directly husart->hdmarx->XferAbortCallback function in case of error */
;;;1234                 husart->hdmarx->XferAbortCallback(husart->hdmarx);
00010c  6c20              LDR      r0,[r4,#0x40]
00010e  6d01              LDR      r1,[r0,#0x50]
000110  4788              BLX      r1
                  |L8.274|
000112  e00d              B        |L8.304|
                  |L8.276|
;;;1235               }
;;;1236             }
;;;1237             else
;;;1238             {
;;;1239               /* Call user error callback */
;;;1240               HAL_USART_ErrorCallback(husart);
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       HAL_USART_ErrorCallback
00011a  e009              B        |L8.304|
                  |L8.284|
;;;1241             }
;;;1242           }
;;;1243           else
;;;1244           {
;;;1245             /* Call user error callback */
;;;1246             HAL_USART_ErrorCallback(husart);
00011c  4620              MOV      r0,r4
00011e  f7fffffe          BL       HAL_USART_ErrorCallback
000122  e005              B        |L8.304|
000124  e006              B        |L8.308|
                  |L8.294|
;;;1247           }
;;;1248         }
;;;1249         else
;;;1250         {
;;;1251           /* Non Blocking error : transfer could go on. 
;;;1252           Error is notified to user through user error callback */
;;;1253           HAL_USART_ErrorCallback(husart);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1254           husart->ErrorCode = HAL_USART_ERROR_NONE;
00012c  2000              MOVS     r0,#0
00012e  64a0              STR      r0,[r4,#0x48]
                  |L8.304|
;;;1255         }
;;;1256       }
;;;1257       return;
;;;1258       
;;;1259     } /* End if some error occurs */
;;;1260     
;;;1261     /* USART in mode Transmitter -----------------------------------------------*/
;;;1262     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1263     {
;;;1264       if(husart->State == HAL_USART_STATE_BUSY_TX)
;;;1265       {
;;;1266         USART_Transmit_IT(husart);
;;;1267       }
;;;1268       else
;;;1269       {
;;;1270         USART_TransmitReceive_IT(husart);
;;;1271       }
;;;1272       return;
;;;1273     }
;;;1274     
;;;1275     /* USART in mode Transmitter (transmission end) -----------------------------*/
;;;1276     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1277     {
;;;1278       USART_EndTransmit_IT(husart);
;;;1279       return;
;;;1280     }
;;;1281   }
000130  e8bd81f0          POP      {r4-r8,pc}
                  |L8.308|
000134  f0050080          AND      r0,r5,#0x80           ;1262
000138  b170              CBZ      r0,|L8.344|
00013a  f0060080          AND      r0,r6,#0x80           ;1262
00013e  b158              CBZ      r0,|L8.344|
000140  f8940045          LDRB     r0,[r4,#0x45]         ;1264
000144  2812              CMP      r0,#0x12              ;1264
000146  d103              BNE      |L8.336|
000148  4620              MOV      r0,r4                 ;1266
00014a  f7fffffe          BL       USART_Transmit_IT
00014e  e002              B        |L8.342|
                  |L8.336|
000150  4620              MOV      r0,r4                 ;1270
000152  f7fffffe          BL       USART_TransmitReceive_IT
                  |L8.342|
000156  e7eb              B        |L8.304|
                  |L8.344|
000158  f0050040          AND      r0,r5,#0x40           ;1276
00015c  b130              CBZ      r0,|L8.364|
00015e  f0060040          AND      r0,r6,#0x40           ;1276
000162  b118              CBZ      r0,|L8.364|
000164  4620              MOV      r0,r4                 ;1278
000166  f7fffffe          BL       USART_EndTransmit_IT
00016a  e7e1              B        |L8.304|
                  |L8.364|
00016c  bf00              NOP      
00016e  e7df              B        |L8.304|
;;;1282   
                          ENDP

                  |L8.368|
                          DCD      USART_DMAAbortOnError

                          AREA ||i.HAL_USART_Init||, CODE, READONLY, ALIGN=1

                  HAL_USART_Init PROC
;;;190      */
;;;191    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;192    {
000002  4604              MOV      r4,r0
;;;193      /* Check the USART handle allocation */
;;;194      if(husart == NULL)
000004  b90c              CBNZ     r4,|L9.10|
;;;195      {
;;;196        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L9.8|
;;;197      }
;;;198    
;;;199      /* Check the parameters */
;;;200      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;201    
;;;202      if(husart->State == HAL_USART_STATE_RESET)
;;;203      {
;;;204        /* Allocate lock resource and initialize it */
;;;205        husart->Lock = HAL_UNLOCKED;
;;;206        /* Init the low level hardware : GPIO, CLOCK */
;;;207        HAL_USART_MspInit(husart);
;;;208      }
;;;209    
;;;210      husart->State = HAL_USART_STATE_BUSY;
;;;211    
;;;212      /* Disable the Peripheral */
;;;213      __HAL_USART_DISABLE(husart);
;;;214    
;;;215      /* Set the Usart Communication parameters */
;;;216      if (USART_SetConfig(husart) == HAL_ERROR)
;;;217      {
;;;218        return HAL_ERROR;
;;;219      }
;;;220    
;;;221      /* In Synchronous mode, the following bits must be kept cleared:
;;;222      - LINEN bit in the USART_CR2 register
;;;223      - HDSEL, SCEN and IREN bits in the USART_CR3 register.*/
;;;224      CLEAR_BIT(husart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;225      CLEAR_BIT(husart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;226    
;;;227      /* Enable the Peripheral */
;;;228      __HAL_USART_ENABLE(husart);
;;;229    
;;;230      /* TEACK and/or REACK to check before moving husart->State to Ready */
;;;231      return (USART_CheckIdleState(husart));
;;;232    }
000008  bd10              POP      {r4,pc}
                  |L9.10|
00000a  f8940045          LDRB     r0,[r4,#0x45]         ;202
00000e  b928              CBNZ     r0,|L9.28|
000010  2000              MOVS     r0,#0                 ;205
000012  f8840044          STRB     r0,[r4,#0x44]         ;205
000016  4620              MOV      r0,r4                 ;207
000018  f7fffffe          BL       HAL_USART_MspInit
                  |L9.28|
00001c  2002              MOVS     r0,#2                 ;210
00001e  f8840045          STRB     r0,[r4,#0x45]         ;210
000022  6820              LDR      r0,[r4,#0]            ;213
000024  6800              LDR      r0,[r0,#0]            ;213
000026  f0200001          BIC      r0,r0,#1              ;213
00002a  6821              LDR      r1,[r4,#0]            ;213
00002c  6008              STR      r0,[r1,#0]            ;213
00002e  4620              MOV      r0,r4                 ;216
000030  f7fffffe          BL       USART_SetConfig
000034  2801              CMP      r0,#1                 ;216
000036  d100              BNE      |L9.58|
000038  e7e6              B        |L9.8|
                  |L9.58|
00003a  6820              LDR      r0,[r4,#0]            ;224
00003c  6840              LDR      r0,[r0,#4]            ;224
00003e  f4204090          BIC      r0,r0,#0x4800         ;224
000042  6821              LDR      r1,[r4,#0]            ;224
000044  6048              STR      r0,[r1,#4]            ;224
000046  6820              LDR      r0,[r4,#0]            ;225
000048  6880              LDR      r0,[r0,#8]            ;225
00004a  f020002a          BIC      r0,r0,#0x2a           ;225
00004e  6821              LDR      r1,[r4,#0]            ;225
000050  6088              STR      r0,[r1,#8]            ;225
000052  6820              LDR      r0,[r4,#0]            ;228
000054  6800              LDR      r0,[r0,#0]            ;228
000056  f0400001          ORR      r0,r0,#1              ;228
00005a  6821              LDR      r1,[r4,#0]            ;228
00005c  6008              STR      r0,[r1,#0]            ;228
00005e  4620              MOV      r0,r4                 ;231
000060  f7fffffe          BL       USART_CheckIdleState
000064  e7d0              B        |L9.8|
;;;233    
                          ENDP


                          AREA ||i.HAL_USART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspDeInit PROC
;;;287      */
;;;288     __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;289    {
;;;290      /* Prevent unused argument(s) compilation warning */
;;;291      UNUSED(husart);
;;;292     
;;;293      /* NOTE : This function should not be modified, when the callback is needed,
;;;294                the HAL_USART_MspDeInit can be implemented in the user file
;;;295       */
;;;296    }
;;;297    
                          ENDP


                          AREA ||i.HAL_USART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_USART_MspInit PROC
;;;272      */
;;;273     __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(husart);
;;;277     
;;;278      /* NOTE : This function should not be modified, when the callback is needed,
;;;279                the HAL_USART_MspInit can be implemented in the user file
;;;280       */
;;;281    }
;;;282    
                          ENDP


                          AREA ||i.HAL_USART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive PROC
;;;437      */
;;;438    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;439    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;440      uint16_t* tmp;
;;;441      uint16_t uhMask;
;;;442      uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;443    
;;;444      if(husart->State == HAL_USART_STATE_READY)
000010  f8940045          LDRB     r0,[r4,#0x45]
000014  2801              CMP      r0,#1
000016  d17d              BNE      |L12.276|
;;;445      {
;;;446        if((pRxData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L12.28|
00001a  b916              CBNZ     r6,|L12.34|
                  |L12.28|
;;;447        {
;;;448          return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L12.30|
;;;449        }
;;;450        /* Process Locked */
;;;451        __HAL_LOCK(husart);
;;;452    
;;;453        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;454        husart->State = HAL_USART_STATE_BUSY_RX;
;;;455    	
;;;456    	/* Init tickstart for timeout managment*/
;;;457        tickstart = HAL_GetTick();
;;;458    
;;;459        husart->RxXferSize = Size;
;;;460        husart->RxXferCount = Size;
;;;461    
;;;462        /* Computation of USART mask to apply to RDR register */
;;;463        __HAL_USART_MASK_COMPUTATION(husart);
;;;464        uhMask = husart->Mask;
;;;465    
;;;466        /* as long as data have to be received */
;;;467        while(husart->RxXferCount > 0U)
;;;468        {
;;;469          husart->RxXferCount--;
;;;470    
;;;471          /* Wait until TC flag is set to send dummy byte in order to generate the
;;;472          * clock for the slave to send data.
;;;473           * Whatever the frame length (7, 8 or 9-bit long), the same dummy value
;;;474           * can be written for all the cases. */
;;;475          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;476          {
;;;477            return HAL_TIMEOUT;
;;;478          }
;;;479          husart->Instance->TDR = (DUMMY_DATA & (uint16_t)0x0FFU);
;;;480    
;;;481          /* Wait for RXNE Flag */
;;;482          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;483          {
;;;484            return HAL_TIMEOUT;
;;;485          }
;;;486    
;;;487          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;488          {
;;;489            tmp = (uint16_t*) pRxData ;
;;;490            *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
;;;491            pRxData +=2;
;;;492          }
;;;493          else
;;;494          {
;;;495            *pRxData++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;496          }
;;;497        }
;;;498    
;;;499        husart->State = HAL_USART_STATE_READY;
;;;500    
;;;501        /* Process Unlocked */
;;;502        __HAL_UNLOCK(husart);
;;;503    
;;;504        return HAL_OK;
;;;505      }
;;;506      else
;;;507      {
;;;508        return HAL_BUSY;
;;;509      }
;;;510    }
00001e  e8bd8ff8          POP      {r3-r11,pc}
                  |L12.34|
000022  bf00              NOP                            ;451
000024  f8940044          LDRB     r0,[r4,#0x44]         ;451
000028  2801              CMP      r0,#1                 ;451
00002a  d101              BNE      |L12.48|
00002c  2002              MOVS     r0,#2                 ;451
00002e  e7f6              B        |L12.30|
                  |L12.48|
000030  2001              MOVS     r0,#1                 ;451
000032  f8840044          STRB     r0,[r4,#0x44]         ;451
000036  bf00              NOP                            ;451
000038  2000              MOVS     r0,#0                 ;453
00003a  64a0              STR      r0,[r4,#0x48]         ;453
00003c  2022              MOVS     r0,#0x22              ;454
00003e  f8840045          STRB     r0,[r4,#0x45]         ;454
000042  f7fffffe          BL       HAL_GetTick
000046  4682              MOV      r10,r0                ;457
000048  86a6              STRH     r6,[r4,#0x34]         ;459
00004a  86e6              STRH     r6,[r4,#0x36]         ;460
00004c  bf00              NOP                            ;463
00004e  68a0              LDR      r0,[r4,#8]            ;463
000050  f5b05f80          CMP      r0,#0x1000            ;463
000054  d108              BNE      |L12.104|
000056  6920              LDR      r0,[r4,#0x10]         ;463
000058  b918              CBNZ     r0,|L12.98|
00005a  f24010ff          MOV      r0,#0x1ff             ;463
00005e  8720              STRH     r0,[r4,#0x38]         ;463
000060  e017              B        |L12.146|
                  |L12.98|
000062  20ff              MOVS     r0,#0xff              ;463
000064  8720              STRH     r0,[r4,#0x38]         ;463
000066  e014              B        |L12.146|
                  |L12.104|
000068  68a0              LDR      r0,[r4,#8]            ;463
00006a  b938              CBNZ     r0,|L12.124|
00006c  6920              LDR      r0,[r4,#0x10]         ;463
00006e  b910              CBNZ     r0,|L12.118|
000070  20ff              MOVS     r0,#0xff              ;463
000072  8720              STRH     r0,[r4,#0x38]         ;463
000074  e00d              B        |L12.146|
                  |L12.118|
000076  207f              MOVS     r0,#0x7f              ;463
000078  8720              STRH     r0,[r4,#0x38]         ;463
00007a  e00a              B        |L12.146|
                  |L12.124|
00007c  68a0              LDR      r0,[r4,#8]            ;463
00007e  f1b05f80          CMP      r0,#0x10000000        ;463
000082  d106              BNE      |L12.146|
000084  6920              LDR      r0,[r4,#0x10]         ;463
000086  b910              CBNZ     r0,|L12.142|
000088  207f              MOVS     r0,#0x7f              ;463
00008a  8720              STRH     r0,[r4,#0x38]         ;463
00008c  e001              B        |L12.146|
                  |L12.142|
00008e  203f              MOVS     r0,#0x3f              ;463
000090  8720              STRH     r0,[r4,#0x38]         ;463
                  |L12.146|
000092  bf00              NOP                            ;463
000094  f8b49038          LDRH     r9,[r4,#0x38]         ;464
000098  e02f              B        |L12.250|
                  |L12.154|
00009a  8ee0              LDRH     r0,[r4,#0x36]         ;469
00009c  1e40              SUBS     r0,r0,#1              ;469
00009e  86e0              STRH     r0,[r4,#0x36]         ;469
0000a0  4653              MOV      r3,r10                ;475
0000a2  2200              MOVS     r2,#0                 ;475
0000a4  2140              MOVS     r1,#0x40              ;475
0000a6  4620              MOV      r0,r4                 ;475
0000a8  9700              STR      r7,[sp,#0]            ;475
0000aa  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000ae  b108              CBZ      r0,|L12.180|
0000b0  2003              MOVS     r0,#3                 ;477
0000b2  e7b4              B        |L12.30|
                  |L12.180|
0000b4  20ff              MOVS     r0,#0xff              ;479
0000b6  6821              LDR      r1,[r4,#0]            ;479
0000b8  6288              STR      r0,[r1,#0x28]         ;479
0000ba  4653              MOV      r3,r10                ;482
0000bc  2200              MOVS     r2,#0                 ;482
0000be  2120              MOVS     r1,#0x20              ;482
0000c0  4620              MOV      r0,r4                 ;482
0000c2  9700              STR      r7,[sp,#0]            ;482
0000c4  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000c8  b108              CBZ      r0,|L12.206|
0000ca  2003              MOVS     r0,#3                 ;484
0000cc  e7a7              B        |L12.30|
                  |L12.206|
0000ce  68a0              LDR      r0,[r4,#8]            ;487
0000d0  f5b05f80          CMP      r0,#0x1000            ;487
0000d4  d10a              BNE      |L12.236|
0000d6  6920              LDR      r0,[r4,#0x10]         ;487
0000d8  b940              CBNZ     r0,|L12.236|
0000da  46a8              MOV      r8,r5                 ;489
0000dc  6820              LDR      r0,[r4,#0]            ;490
0000de  6a40              LDR      r0,[r0,#0x24]         ;490
0000e0  ea000009          AND      r0,r0,r9              ;490
0000e4  f8a80000          STRH     r0,[r8,#0]            ;490
0000e8  1cad              ADDS     r5,r5,#2              ;491
0000ea  e006              B        |L12.250|
                  |L12.236|
0000ec  6820              LDR      r0,[r4,#0]            ;495
0000ee  6a40              LDR      r0,[r0,#0x24]         ;495
0000f0  f00901ff          AND      r1,r9,#0xff           ;495
0000f4  4008              ANDS     r0,r0,r1              ;495
0000f6  f8050b01          STRB     r0,[r5],#1            ;495
                  |L12.250|
0000fa  8ee0              LDRH     r0,[r4,#0x36]         ;467
0000fc  2800              CMP      r0,#0                 ;467
0000fe  d1cc              BNE      |L12.154|
000100  2001              MOVS     r0,#1                 ;499
000102  f8840045          STRB     r0,[r4,#0x45]         ;499
000106  bf00              NOP                            ;502
000108  2000              MOVS     r0,#0                 ;502
00010a  f8840044          STRB     r0,[r4,#0x44]         ;502
00010e  bf00              NOP                            ;502
000110  e785              B        |L12.30|
000112  e7ff              B        |L12.276|
                  |L12.276|
000114  2002              MOVS     r0,#2                 ;508
000116  e782              B        |L12.30|
;;;511    
                          ENDP


                          AREA ||i.HAL_USART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Receive_DMA PROC
;;;836      */
;;;837    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;838    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;839      uint32_t *tmp;
;;;840    
;;;841      if(husart->State == HAL_USART_STATE_READY)
000006  f8940045          LDRB     r0,[r4,#0x45]
00000a  2801              CMP      r0,#1
00000c  d169              BNE      |L13.226|
;;;842      {
;;;843        if((pRxData == NULL ) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L13.20|
000012  b90d              CBNZ     r5,|L13.24|
                  |L13.20|
;;;844        {
;;;845          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L13.22|
;;;846        }
;;;847    
;;;848        /* Process Locked */
;;;849        __HAL_LOCK(husart);
;;;850    
;;;851        husart->pRxBuffPtr = pRxData;
;;;852        husart->RxXferSize = Size;
;;;853        husart->pTxBuffPtr = pRxData;
;;;854        husart->TxXferSize = Size;
;;;855    
;;;856        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;857        husart->State = HAL_USART_STATE_BUSY_RX;
;;;858    
;;;859        /* Set the USART DMA Rx transfer complete callback */
;;;860        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;861    
;;;862        /* Set the USART DMA Half transfer complete callback */
;;;863        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;864    
;;;865        /* Set the USART DMA Rx transfer error callback */
;;;866        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;867        
;;;868        /* Set the DMA abort callback */
;;;869        husart->hdmatx->XferAbortCallback = NULL;
;;;870    	
;;;871    	/* Set the USART Tx DMA transfer complete callback as NULL because the communication closing
;;;872        is performed in DMA reception complete callback  */
;;;873        husart->hdmatx->XferHalfCpltCallback = NULL;
;;;874        husart->hdmatx->XferCpltCallback = NULL;
;;;875        
;;;876        /* Set the DMA error callback */
;;;877        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;878    
;;;879        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;880        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;881        SET_BIT(husart->Instance->ISR, (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE | USART_ISR_ORE));
;;;882    
;;;883        /* Enable the USART receive DMA channel */
;;;884        tmp = (uint32_t*)&pRxData;
;;;885        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;886    
;;;887        /* Enable the USART transmit DMA channel: the transmit stream is used in order
;;;888           to generate in the non-blocking mode the clock to the slave device,
;;;889           this mode isn't a simplex receive mode but a full-duplex receive mode */
;;;890        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;891        
;;;892        /* Process Unlocked */
;;;893        __HAL_UNLOCK(husart);
;;;894        
;;;895        /* Enable the USART Parity Error Interrupt */
;;;896        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;897        
;;;898        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;899        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;900    
;;;901        /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;902           in the USART CR3 register */
;;;903        SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;904    
;;;905        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;906           in the USART CR3 register */
;;;907        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;908    
;;;909    
;;;910        return HAL_OK;
;;;911      }
;;;912      else
;;;913      {
;;;914        return HAL_BUSY;
;;;915      }
;;;916    }
000016  bdfe              POP      {r1-r7,pc}
                  |L13.24|
000018  bf00              NOP                            ;849
00001a  f8940044          LDRB     r0,[r4,#0x44]         ;849
00001e  2801              CMP      r0,#1                 ;849
000020  d101              BNE      |L13.38|
000022  2002              MOVS     r0,#2                 ;849
000024  e7f7              B        |L13.22|
                  |L13.38|
000026  2001              MOVS     r0,#1                 ;849
000028  f8840044          STRB     r0,[r4,#0x44]         ;849
00002c  bf00              NOP                            ;849
00002e  9801              LDR      r0,[sp,#4]            ;851
000030  6320              STR      r0,[r4,#0x30]         ;851
000032  86a5              STRH     r5,[r4,#0x34]         ;852
000034  9801              LDR      r0,[sp,#4]            ;853
000036  62a0              STR      r0,[r4,#0x28]         ;853
000038  85a5              STRH     r5,[r4,#0x2c]         ;854
00003a  2000              MOVS     r0,#0                 ;856
00003c  64a0              STR      r0,[r4,#0x48]         ;856
00003e  2022              MOVS     r0,#0x22              ;857
000040  f8840045          STRB     r0,[r4,#0x45]         ;857
000044  4828              LDR      r0,|L13.232|
000046  6c21              LDR      r1,[r4,#0x40]         ;860
000048  63c8              STR      r0,[r1,#0x3c]         ;860
00004a  4828              LDR      r0,|L13.236|
00004c  6c21              LDR      r1,[r4,#0x40]         ;863
00004e  6408              STR      r0,[r1,#0x40]         ;863
000050  4827              LDR      r0,|L13.240|
000052  6c21              LDR      r1,[r4,#0x40]         ;866
000054  64c8              STR      r0,[r1,#0x4c]         ;866
000056  2000              MOVS     r0,#0                 ;869
000058  6be1              LDR      r1,[r4,#0x3c]         ;869
00005a  6508              STR      r0,[r1,#0x50]         ;869
00005c  6be1              LDR      r1,[r4,#0x3c]         ;873
00005e  6408              STR      r0,[r1,#0x40]         ;873
000060  6be1              LDR      r1,[r4,#0x3c]         ;874
000062  63c8              STR      r0,[r1,#0x3c]         ;874
000064  4822              LDR      r0,|L13.240|
000066  6be1              LDR      r1,[r4,#0x3c]         ;877
000068  64c8              STR      r0,[r1,#0x4c]         ;877
00006a  6820              LDR      r0,[r4,#0]            ;880
00006c  6880              LDR      r0,[r0,#8]            ;880
00006e  f0400001          ORR      r0,r0,#1              ;880
000072  6821              LDR      r1,[r4,#0]            ;880
000074  6088              STR      r0,[r1,#8]            ;880
000076  6820              LDR      r0,[r4,#0]            ;881
000078  69c0              LDR      r0,[r0,#0x1c]         ;881
00007a  f040000f          ORR      r0,r0,#0xf            ;881
00007e  6821              LDR      r1,[r4,#0]            ;881
000080  61c8              STR      r0,[r1,#0x1c]         ;881
000082  ae01              ADD      r6,sp,#4              ;884
000084  6832              LDR      r2,[r6,#0]            ;885
000086  6823              LDR      r3,[r4,#0]            ;885
000088  f1030124          ADD      r1,r3,#0x24           ;885
00008c  462b              MOV      r3,r5                 ;885
00008e  6c20              LDR      r0,[r4,#0x40]         ;885
000090  f7fffffe          BL       HAL_DMA_Start_IT
000094  6823              LDR      r3,[r4,#0]            ;890
000096  f1030228          ADD      r2,r3,#0x28           ;890
00009a  6831              LDR      r1,[r6,#0]            ;890
00009c  462b              MOV      r3,r5                 ;890
00009e  6be0              LDR      r0,[r4,#0x3c]         ;890
0000a0  f7fffffe          BL       HAL_DMA_Start_IT
0000a4  bf00              NOP                            ;893
0000a6  2000              MOVS     r0,#0                 ;893
0000a8  f8840044          STRB     r0,[r4,#0x44]         ;893
0000ac  bf00              NOP                            ;893
0000ae  6820              LDR      r0,[r4,#0]            ;896
0000b0  6800              LDR      r0,[r0,#0]            ;896
0000b2  f4407080          ORR      r0,r0,#0x100          ;896
0000b6  6821              LDR      r1,[r4,#0]            ;896
0000b8  6008              STR      r0,[r1,#0]            ;896
0000ba  6820              LDR      r0,[r4,#0]            ;899
0000bc  6880              LDR      r0,[r0,#8]            ;899
0000be  f0400001          ORR      r0,r0,#1              ;899
0000c2  6821              LDR      r1,[r4,#0]            ;899
0000c4  6088              STR      r0,[r1,#8]            ;899
0000c6  6820              LDR      r0,[r4,#0]            ;903
0000c8  6880              LDR      r0,[r0,#8]            ;903
0000ca  f0400040          ORR      r0,r0,#0x40           ;903
0000ce  6821              LDR      r1,[r4,#0]            ;903
0000d0  6088              STR      r0,[r1,#8]            ;903
0000d2  6820              LDR      r0,[r4,#0]            ;907
0000d4  6880              LDR      r0,[r0,#8]            ;907
0000d6  f0400080          ORR      r0,r0,#0x80           ;907
0000da  6821              LDR      r1,[r4,#0]            ;907
0000dc  6088              STR      r0,[r1,#8]            ;907
0000de  2000              MOVS     r0,#0                 ;910
0000e0  e799              B        |L13.22|
                  |L13.226|
0000e2  2002              MOVS     r0,#2                 ;914
0000e4  e797              B        |L13.22|
;;;917    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L13.232|
                          DCD      USART_DMAReceiveCplt
                  |L13.236|
                          DCD      USART_DMARxHalfCplt
                  |L13.240|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Receive_IT PROC
;;;657      */
;;;658    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;659    {
000002  4603              MOV      r3,r0
;;;660      if(husart->State == HAL_USART_STATE_READY)
000004  f8930045          LDRB     r0,[r3,#0x45]
000008  2801              CMP      r0,#1
00000a  d15f              BNE      |L14.204|
;;;661      {
;;;662        if((pRxData == NULL ) || (Size == 0U))
00000c  b101              CBZ      r1,|L14.16|
00000e  b90a              CBNZ     r2,|L14.20|
                  |L14.16|
;;;663        {
;;;664          return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L14.18|
;;;665        }
;;;666        /* Process Locked */
;;;667        __HAL_LOCK(husart);
;;;668    
;;;669        husart->pRxBuffPtr = pRxData;
;;;670        husart->RxXferSize = Size;
;;;671        husart->RxXferCount = Size;
;;;672    
;;;673        __HAL_USART_MASK_COMPUTATION(husart);
;;;674    
;;;675        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;676        husart->State = HAL_USART_STATE_BUSY_RX;
;;;677    
;;;678        /* Enable the USART Parity Error Interrupt */
;;;679        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;680    
;;;681        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;682        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;683    
;;;684        /* Enable the USART Data Register not empty Interrupt */
;;;685        SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;686    
;;;687        /* Process Unlocked */
;;;688        __HAL_UNLOCK(husart);
;;;689    
;;;690    
;;;691        /* Send dummy byte in order to generate the clock for the Slave to send the next data */
;;;692        if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;693        {
;;;694          husart->Instance->TDR = (DUMMY_DATA & (uint16_t)0x01FFU);
;;;695        }
;;;696        else
;;;697        {
;;;698          husart->Instance->TDR = (DUMMY_DATA & (uint16_t)0x00FFU);
;;;699        }
;;;700    
;;;701        return HAL_OK;
;;;702      }
;;;703      else
;;;704      {
;;;705        return HAL_BUSY;
;;;706      }
;;;707    }
000012  bd10              POP      {r4,pc}
                  |L14.20|
000014  bf00              NOP                            ;667
000016  f8930044          LDRB     r0,[r3,#0x44]         ;667
00001a  2801              CMP      r0,#1                 ;667
00001c  d101              BNE      |L14.34|
00001e  2002              MOVS     r0,#2                 ;667
000020  e7f7              B        |L14.18|
                  |L14.34|
000022  2001              MOVS     r0,#1                 ;667
000024  f8830044          STRB     r0,[r3,#0x44]         ;667
000028  bf00              NOP                            ;667
00002a  6319              STR      r1,[r3,#0x30]         ;669
00002c  869a              STRH     r2,[r3,#0x34]         ;670
00002e  86da              STRH     r2,[r3,#0x36]         ;671
000030  bf00              NOP                            ;673
000032  6898              LDR      r0,[r3,#8]            ;673
000034  f5b05f80          CMP      r0,#0x1000            ;673
000038  d108              BNE      |L14.76|
00003a  6918              LDR      r0,[r3,#0x10]         ;673
00003c  b918              CBNZ     r0,|L14.70|
00003e  f24010ff          MOV      r0,#0x1ff             ;673
000042  8718              STRH     r0,[r3,#0x38]         ;673
000044  e017              B        |L14.118|
                  |L14.70|
000046  20ff              MOVS     r0,#0xff              ;673
000048  8718              STRH     r0,[r3,#0x38]         ;673
00004a  e014              B        |L14.118|
                  |L14.76|
00004c  6898              LDR      r0,[r3,#8]            ;673
00004e  b938              CBNZ     r0,|L14.96|
000050  6918              LDR      r0,[r3,#0x10]         ;673
000052  b910              CBNZ     r0,|L14.90|
000054  20ff              MOVS     r0,#0xff              ;673
000056  8718              STRH     r0,[r3,#0x38]         ;673
000058  e00d              B        |L14.118|
                  |L14.90|
00005a  207f              MOVS     r0,#0x7f              ;673
00005c  8718              STRH     r0,[r3,#0x38]         ;673
00005e  e00a              B        |L14.118|
                  |L14.96|
000060  6898              LDR      r0,[r3,#8]            ;673
000062  f1b05f80          CMP      r0,#0x10000000        ;673
000066  d106              BNE      |L14.118|
000068  6918              LDR      r0,[r3,#0x10]         ;673
00006a  b910              CBNZ     r0,|L14.114|
00006c  207f              MOVS     r0,#0x7f              ;673
00006e  8718              STRH     r0,[r3,#0x38]         ;673
000070  e001              B        |L14.118|
                  |L14.114|
000072  203f              MOVS     r0,#0x3f              ;673
000074  8718              STRH     r0,[r3,#0x38]         ;673
                  |L14.118|
000076  bf00              NOP                            ;673
000078  2000              MOVS     r0,#0                 ;675
00007a  6498              STR      r0,[r3,#0x48]         ;675
00007c  2022              MOVS     r0,#0x22              ;676
00007e  f8830045          STRB     r0,[r3,#0x45]         ;676
000082  6818              LDR      r0,[r3,#0]            ;679
000084  6800              LDR      r0,[r0,#0]            ;679
000086  f4407080          ORR      r0,r0,#0x100          ;679
00008a  681c              LDR      r4,[r3,#0]            ;679
00008c  6020              STR      r0,[r4,#0]            ;679
00008e  6818              LDR      r0,[r3,#0]            ;682
000090  6880              LDR      r0,[r0,#8]            ;682
000092  f0400001          ORR      r0,r0,#1              ;682
000096  681c              LDR      r4,[r3,#0]            ;682
000098  60a0              STR      r0,[r4,#8]            ;682
00009a  6818              LDR      r0,[r3,#0]            ;685
00009c  6800              LDR      r0,[r0,#0]            ;685
00009e  f0400020          ORR      r0,r0,#0x20           ;685
0000a2  681c              LDR      r4,[r3,#0]            ;685
0000a4  6020              STR      r0,[r4,#0]            ;685
0000a6  bf00              NOP                            ;688
0000a8  2000              MOVS     r0,#0                 ;688
0000aa  f8830044          STRB     r0,[r3,#0x44]         ;688
0000ae  bf00              NOP                            ;688
0000b0  6898              LDR      r0,[r3,#8]            ;692
0000b2  f5b05f80          CMP      r0,#0x1000            ;692
0000b6  d104              BNE      |L14.194|
0000b8  f24010ff          MOV      r0,#0x1ff             ;694
0000bc  681c              LDR      r4,[r3,#0]            ;694
0000be  62a0              STR      r0,[r4,#0x28]         ;694
0000c0  e002              B        |L14.200|
                  |L14.194|
0000c2  20ff              MOVS     r0,#0xff              ;698
0000c4  681c              LDR      r4,[r3,#0]            ;698
0000c6  62a0              STR      r0,[r4,#0x28]         ;698
                  |L14.200|
0000c8  2000              MOVS     r0,#0                 ;701
0000ca  e7a2              B        |L14.18|
                  |L14.204|
0000cc  2002              MOVS     r0,#2                 ;705
0000ce  e7a0              B        |L14.18|
;;;708    
                          ENDP


                          AREA ||i.HAL_USART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxCpltCallback PROC
;;;1317     */
;;;1318   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1319   {
;;;1320     /* Prevent unused argument(s) compilation warning */
;;;1321     UNUSED(husart);
;;;1322    
;;;1323     /* NOTE: This function should not be modified, when the callback is needed,
;;;1324              the HAL_USART_RxCpltCallback can be implemented in the user file
;;;1325      */
;;;1326   }
;;;1327   
                          ENDP


                          AREA ||i.HAL_USART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_RxHalfCpltCallback PROC
;;;1332     */
;;;1333   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1334   {
;;;1335     /* Prevent unused argument(s) compilation warning */
;;;1336     UNUSED(husart);
;;;1337    
;;;1338     /* NOTE : This function should not be modified, when the callback is needed,
;;;1339               the HAL_USART_RxHalfCpltCallback can be implemented in the user file
;;;1340      */
;;;1341   }
;;;1342   
                          ENDP


                          AREA ||i.HAL_USART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit PROC
;;;366      */
;;;367    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;368    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;369      uint16_t* tmp;
;;;370      uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;371    
;;;372      if(husart->State == HAL_USART_STATE_READY)
000010  f8940045          LDRB     r0,[r4,#0x45]
000014  2801              CMP      r0,#1
000016  d150              BNE      |L17.186|
;;;373      {
;;;374        if((pTxData == NULL) || (Size == 0U))
000018  b105              CBZ      r5,|L17.28|
00001a  b916              CBNZ     r6,|L17.34|
                  |L17.28|
;;;375        {
;;;376          return  HAL_ERROR;
00001c  2001              MOVS     r0,#1
                  |L17.30|
;;;377        }
;;;378    
;;;379        /* Process Locked */
;;;380        __HAL_LOCK(husart);
;;;381    
;;;382        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;383        husart->State = HAL_USART_STATE_BUSY_TX;
;;;384        
;;;385        /* Init tickstart for timeout managment*/
;;;386        tickstart = HAL_GetTick();
;;;387    
;;;388        husart->TxXferSize = Size;
;;;389        husart->TxXferCount = Size;
;;;390    
;;;391        /* Check the remaining data to be sent */
;;;392        while(husart->TxXferCount > 0U)
;;;393        {
;;;394          husart->TxXferCount--;
;;;395          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;396            {
;;;397              return HAL_TIMEOUT;
;;;398            }
;;;399          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;400          {
;;;401            tmp = (uint16_t*) pTxData;
;;;402            husart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;403            pTxData += 2;
;;;404          }
;;;405          else
;;;406          {
;;;407            husart->Instance->TDR = (*pTxData++ & (uint8_t)0xFFU);
;;;408          }
;;;409        }
;;;410    
;;;411        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;412        {
;;;413          return HAL_TIMEOUT;
;;;414        }
;;;415    
;;;416        husart->State = HAL_USART_STATE_READY;
;;;417    
;;;418        /* Process Unlocked */
;;;419        __HAL_UNLOCK(husart);
;;;420    
;;;421        return HAL_OK;
;;;422      }
;;;423      else
;;;424      {
;;;425        return HAL_BUSY;
;;;426      }
;;;427    }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L17.34|
000022  bf00              NOP                            ;380
000024  f8940044          LDRB     r0,[r4,#0x44]         ;380
000028  2801              CMP      r0,#1                 ;380
00002a  d101              BNE      |L17.48|
00002c  2002              MOVS     r0,#2                 ;380
00002e  e7f6              B        |L17.30|
                  |L17.48|
000030  2001              MOVS     r0,#1                 ;380
000032  f8840044          STRB     r0,[r4,#0x44]         ;380
000036  bf00              NOP                            ;380
000038  2000              MOVS     r0,#0                 ;382
00003a  64a0              STR      r0,[r4,#0x48]         ;382
00003c  2012              MOVS     r0,#0x12              ;383
00003e  f8840045          STRB     r0,[r4,#0x45]         ;383
000042  f7fffffe          BL       HAL_GetTick
000046  4681              MOV      r9,r0                 ;386
000048  85a6              STRH     r6,[r4,#0x2c]         ;388
00004a  85e6              STRH     r6,[r4,#0x2e]         ;389
00004c  e01f              B        |L17.142|
                  |L17.78|
00004e  8de0              LDRH     r0,[r4,#0x2e]         ;394
000050  1e40              SUBS     r0,r0,#1              ;394
000052  85e0              STRH     r0,[r4,#0x2e]         ;394
000054  464b              MOV      r3,r9                 ;395
000056  2200              MOVS     r2,#0                 ;395
000058  2140              MOVS     r1,#0x40              ;395
00005a  4620              MOV      r0,r4                 ;395
00005c  9700              STR      r7,[sp,#0]            ;395
00005e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000062  b108              CBZ      r0,|L17.104|
000064  2003              MOVS     r0,#3                 ;397
000066  e7da              B        |L17.30|
                  |L17.104|
000068  68a0              LDR      r0,[r4,#8]            ;399
00006a  f5b05f80          CMP      r0,#0x1000            ;399
00006e  d10a              BNE      |L17.134|
000070  6920              LDR      r0,[r4,#0x10]         ;399
000072  b940              CBNZ     r0,|L17.134|
000074  46a8              MOV      r8,r5                 ;401
000076  f8b80000          LDRH     r0,[r8,#0]            ;402
00007a  f3c00008          UBFX     r0,r0,#0,#9           ;402
00007e  6821              LDR      r1,[r4,#0]            ;402
000080  6288              STR      r0,[r1,#0x28]         ;402
000082  1cad              ADDS     r5,r5,#2              ;403
000084  e003              B        |L17.142|
                  |L17.134|
000086  f8150b01          LDRB     r0,[r5],#1            ;407
00008a  6821              LDR      r1,[r4,#0]            ;407
00008c  6288              STR      r0,[r1,#0x28]         ;407
                  |L17.142|
00008e  8de0              LDRH     r0,[r4,#0x2e]         ;392
000090  2800              CMP      r0,#0                 ;392
000092  d1dc              BNE      |L17.78|
000094  464b              MOV      r3,r9                 ;411
000096  2200              MOVS     r2,#0                 ;411
000098  2140              MOVS     r1,#0x40              ;411
00009a  4620              MOV      r0,r4                 ;411
00009c  9700              STR      r7,[sp,#0]            ;411
00009e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000a2  b108              CBZ      r0,|L17.168|
0000a4  2003              MOVS     r0,#3                 ;413
0000a6  e7ba              B        |L17.30|
                  |L17.168|
0000a8  2001              MOVS     r0,#1                 ;416
0000aa  f8840045          STRB     r0,[r4,#0x45]         ;416
0000ae  bf00              NOP                            ;419
0000b0  2000              MOVS     r0,#0                 ;419
0000b2  f8840044          STRB     r0,[r4,#0x44]         ;419
0000b6  bf00              NOP                            ;419
0000b8  e7b1              B        |L17.30|
                  |L17.186|
0000ba  2002              MOVS     r0,#2                 ;425
0000bc  e7af              B        |L17.30|
;;;428    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive PROC
;;;520      */
;;;521    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;522    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dda028          LDR      r10,[sp,#0x28]
;;;523      uint16_t* tmp;
;;;524      uint16_t uhMask;
;;;525      uint32_t tickstart = 0U;
000010  f04f0b00          MOV      r11,#0
;;;526    
;;;527      if(husart->State == HAL_USART_STATE_READY)
000014  f8940045          LDRB     r0,[r4,#0x45]
000018  2801              CMP      r0,#1
00001a  d174              BNE      |L18.262|
;;;528      {
;;;529        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00001c  b10d              CBZ      r5,|L18.34|
00001e  b106              CBZ      r6,|L18.34|
000020  b917              CBNZ     r7,|L18.40|
                  |L18.34|
;;;530        {
;;;531          return  HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L18.36|
;;;532        }
;;;533        /* Process Locked */
;;;534        __HAL_LOCK(husart);
;;;535    
;;;536        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;537        husart->State = HAL_USART_STATE_BUSY_RX;
;;;538    	
;;;539    	/* Init tickstart for timeout managment*/
;;;540        tickstart = HAL_GetTick();
;;;541    
;;;542        husart->RxXferSize = Size;
;;;543        husart->TxXferSize = Size;
;;;544        husart->TxXferCount = Size;
;;;545        husart->RxXferCount = Size;
;;;546    
;;;547        /* Computation of USART mask to apply to RDR register */
;;;548        __HAL_USART_MASK_COMPUTATION(husart);
;;;549        uhMask = husart->Mask;
;;;550    
;;;551        /* Check the remain data to be sent */
;;;552        while(husart->TxXferCount > 0)
;;;553        {
;;;554          husart->TxXferCount--;
;;;555          husart->RxXferCount--;
;;;556    
;;;557          /* Wait until TC flag is set to send data */
;;;558          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;559          {
;;;560            return HAL_TIMEOUT;
;;;561          }
;;;562          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;563          {
;;;564            tmp = (uint16_t*) pTxData;
;;;565            husart->Instance->TDR = (*tmp & uhMask);
;;;566            pTxData += 2;
;;;567          }
;;;568          else
;;;569          {
;;;570            husart->Instance->TDR = (*pTxData++ & (uint8_t)uhMask);
;;;571          }
;;;572    
;;;573          /* Wait for RXNE Flag */
;;;574          if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;575          {
;;;576            return HAL_TIMEOUT;
;;;577          }
;;;578    
;;;579          if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;580          {
;;;581            tmp = (uint16_t*) pRxData ;
;;;582            *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
;;;583            pRxData +=2U;
;;;584          }
;;;585          else
;;;586          {
;;;587            *pRxData++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
;;;588          }
;;;589        }
;;;590    
;;;591        husart->State = HAL_USART_STATE_READY;
;;;592    
;;;593        /* Process Unlocked */
;;;594        __HAL_UNLOCK(husart);
;;;595    
;;;596        return HAL_OK;
;;;597      }
;;;598      else
;;;599      {
;;;600        return HAL_BUSY;
;;;601      }
;;;602    }
000024  e8bd8ff8          POP      {r3-r11,pc}
                  |L18.40|
000028  bf00              NOP                            ;534
00002a  f8940044          LDRB     r0,[r4,#0x44]         ;534
00002e  2801              CMP      r0,#1                 ;534
000030  d101              BNE      |L18.54|
000032  2002              MOVS     r0,#2                 ;534
000034  e7f6              B        |L18.36|
                  |L18.54|
000036  2001              MOVS     r0,#1                 ;534
000038  f8840044          STRB     r0,[r4,#0x44]         ;534
00003c  bf00              NOP                            ;534
00003e  2000              MOVS     r0,#0                 ;536
000040  64a0              STR      r0,[r4,#0x48]         ;536
000042  2022              MOVS     r0,#0x22              ;537
000044  f8840045          STRB     r0,[r4,#0x45]         ;537
000048  f7fffffe          BL       HAL_GetTick
00004c  4683              MOV      r11,r0                ;540
00004e  86a7              STRH     r7,[r4,#0x34]         ;542
000050  85a7              STRH     r7,[r4,#0x2c]         ;543
000052  85e7              STRH     r7,[r4,#0x2e]         ;544
000054  86e7              STRH     r7,[r4,#0x36]         ;545
000056  bf00              NOP                            ;548
000058  68a0              LDR      r0,[r4,#8]            ;548
00005a  f5b05f80          CMP      r0,#0x1000            ;548
00005e  d108              BNE      |L18.114|
000060  6920              LDR      r0,[r4,#0x10]         ;548
000062  b918              CBNZ     r0,|L18.108|
000064  f24010ff          MOV      r0,#0x1ff             ;548
000068  8720              STRH     r0,[r4,#0x38]         ;548
00006a  e017              B        |L18.156|
                  |L18.108|
00006c  20ff              MOVS     r0,#0xff              ;548
00006e  8720              STRH     r0,[r4,#0x38]         ;548
000070  e014              B        |L18.156|
                  |L18.114|
000072  68a0              LDR      r0,[r4,#8]            ;548
000074  b938              CBNZ     r0,|L18.134|
000076  6920              LDR      r0,[r4,#0x10]         ;548
000078  b910              CBNZ     r0,|L18.128|
00007a  20ff              MOVS     r0,#0xff              ;548
00007c  8720              STRH     r0,[r4,#0x38]         ;548
00007e  e00d              B        |L18.156|
                  |L18.128|
000080  207f              MOVS     r0,#0x7f              ;548
000082  8720              STRH     r0,[r4,#0x38]         ;548
000084  e00a              B        |L18.156|
                  |L18.134|
000086  68a0              LDR      r0,[r4,#8]            ;548
000088  f1b05f80          CMP      r0,#0x10000000        ;548
00008c  d106              BNE      |L18.156|
00008e  6920              LDR      r0,[r4,#0x10]         ;548
000090  b910              CBNZ     r0,|L18.152|
000092  207f              MOVS     r0,#0x7f              ;548
000094  8720              STRH     r0,[r4,#0x38]         ;548
000096  e001              B        |L18.156|
                  |L18.152|
000098  203f              MOVS     r0,#0x3f              ;548
00009a  8720              STRH     r0,[r4,#0x38]         ;548
                  |L18.156|
00009c  bf00              NOP                            ;548
00009e  f8b48038          LDRH     r8,[r4,#0x38]         ;549
0000a2  e047              B        |L18.308|
                  |L18.164|
0000a4  8de0              LDRH     r0,[r4,#0x2e]         ;554
0000a6  1e40              SUBS     r0,r0,#1              ;554
0000a8  85e0              STRH     r0,[r4,#0x2e]         ;554
0000aa  8ee0              LDRH     r0,[r4,#0x36]         ;555
0000ac  1e40              SUBS     r0,r0,#1              ;555
0000ae  86e0              STRH     r0,[r4,#0x36]         ;555
0000b0  465b              MOV      r3,r11                ;558
0000b2  2200              MOVS     r2,#0                 ;558
0000b4  2140              MOVS     r1,#0x40              ;558
0000b6  4620              MOV      r0,r4                 ;558
0000b8  f8cda000          STR      r10,[sp,#0]           ;558
0000bc  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0000c0  b108              CBZ      r0,|L18.198|
0000c2  2003              MOVS     r0,#3                 ;560
0000c4  e7ae              B        |L18.36|
                  |L18.198|
0000c6  68a0              LDR      r0,[r4,#8]            ;562
0000c8  f5b05f80          CMP      r0,#0x1000            ;562
0000cc  d10a              BNE      |L18.228|
0000ce  6920              LDR      r0,[r4,#0x10]         ;562
0000d0  b940              CBNZ     r0,|L18.228|
0000d2  46a9              MOV      r9,r5                 ;564
0000d4  f8b90000          LDRH     r0,[r9,#0]            ;565
0000d8  ea000008          AND      r0,r0,r8              ;565
0000dc  6821              LDR      r1,[r4,#0]            ;565
0000de  6288              STR      r0,[r1,#0x28]         ;565
0000e0  1cad              ADDS     r5,r5,#2              ;566
0000e2  e005              B        |L18.240|
                  |L18.228|
0000e4  f8150b01          LDRB     r0,[r5],#1            ;570
0000e8  ea000008          AND      r0,r0,r8              ;570
0000ec  6821              LDR      r1,[r4,#0]            ;570
0000ee  6288              STR      r0,[r1,#0x28]         ;570
                  |L18.240|
0000f0  465b              MOV      r3,r11                ;574
0000f2  2200              MOVS     r2,#0                 ;574
0000f4  2120              MOVS     r1,#0x20              ;574
0000f6  4620              MOV      r0,r4                 ;574
0000f8  f8cda000          STR      r10,[sp,#0]           ;574
0000fc  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000100  b110              CBZ      r0,|L18.264|
000102  2003              MOVS     r0,#3                 ;576
000104  e78e              B        |L18.36|
                  |L18.262|
000106  e021              B        |L18.332|
                  |L18.264|
000108  68a0              LDR      r0,[r4,#8]            ;579
00010a  f5b05f80          CMP      r0,#0x1000            ;579
00010e  d10a              BNE      |L18.294|
000110  6920              LDR      r0,[r4,#0x10]         ;579
000112  b940              CBNZ     r0,|L18.294|
000114  46b1              MOV      r9,r6                 ;581
000116  6820              LDR      r0,[r4,#0]            ;582
000118  6a40              LDR      r0,[r0,#0x24]         ;582
00011a  ea000008          AND      r0,r0,r8              ;582
00011e  f8a90000          STRH     r0,[r9,#0]            ;582
000122  1cb6              ADDS     r6,r6,#2              ;583
000124  e006              B        |L18.308|
                  |L18.294|
000126  6820              LDR      r0,[r4,#0]            ;587
000128  6a40              LDR      r0,[r0,#0x24]         ;587
00012a  f00801ff          AND      r1,r8,#0xff           ;587
00012e  4008              ANDS     r0,r0,r1              ;587
000130  f8060b01          STRB     r0,[r6],#1            ;587
                  |L18.308|
000134  8de0              LDRH     r0,[r4,#0x2e]         ;552
000136  2800              CMP      r0,#0                 ;552
000138  dcb4              BGT      |L18.164|
00013a  2001              MOVS     r0,#1                 ;591
00013c  f8840045          STRB     r0,[r4,#0x45]         ;591
000140  bf00              NOP                            ;594
000142  2000              MOVS     r0,#0                 ;594
000144  f8840044          STRB     r0,[r4,#0x44]         ;594
000148  bf00              NOP                            ;594
00014a  e76b              B        |L18.36|
                  |L18.332|
00014c  2002              MOVS     r0,#2                 ;600
00014e  e769              B        |L18.36|
;;;603    
                          ENDP


                          AREA ||i.HAL_USART_TransmitReceive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_TransmitReceive_DMA PROC
;;;926      */
;;;927    HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000000  b57f              PUSH     {r0-r6,lr}
;;;928    {
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;929      uint32_t *tmp;
;;;930    
;;;931      if(husart->State == HAL_USART_STATE_READY)
000006  f8940045          LDRB     r0,[r4,#0x45]
00000a  2801              CMP      r0,#1
00000c  d16e              BNE      |L19.236|
;;;932      {
;;;933        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b110              CBZ      r0,|L19.24|
000012  9802              LDR      r0,[sp,#8]
000014  b100              CBZ      r0,|L19.24|
000016  b915              CBNZ     r5,|L19.30|
                  |L19.24|
;;;934        {
;;;935          return HAL_ERROR;
000018  2001              MOVS     r0,#1
                  |L19.26|
;;;936        }
;;;937        /* Process Locked */
;;;938        __HAL_LOCK(husart);
;;;939    
;;;940        husart->pRxBuffPtr = pRxData;
;;;941        husart->RxXferSize = Size;
;;;942        husart->pTxBuffPtr = pTxData;
;;;943        husart->TxXferSize = Size;
;;;944    
;;;945        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;946        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;947    
;;;948        /* Set the USART DMA Rx transfer complete callback */
;;;949        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;950    
;;;951        /* Set the USART DMA Half transfer complete callback */
;;;952        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;953    
;;;954        /* Set the USART DMA Tx transfer complete callback */
;;;955        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;956    
;;;957        /* Set the USART DMA Half transfer complete callback */
;;;958        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;959    
;;;960        /* Set the USART DMA Tx transfer error callback */
;;;961        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;962    
;;;963        /* Set the USART DMA Rx transfer error callback */
;;;964        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;965    
;;;966        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;967        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;968        SET_BIT(husart->Instance->ISR, (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE | USART_ISR_ORE));
;;;969    
;;;970        /* Enable the USART receive DMA channel */
;;;971        tmp = (uint32_t*)&pRxData;
;;;972        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;973    
;;;974        /* Enable the USART transmit DMA channel */
;;;975        tmp = (uint32_t*)&pTxData;
;;;976        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;977    
;;;978        /* Clear the TC flag in the SR register by writing 0 to it */
;;;979        __HAL_USART_CLEAR_IT(husart, USART_FLAG_TC);
;;;980        
;;;981        /* Process Unlocked */
;;;982        __HAL_UNLOCK(husart);
;;;983        
;;;984        /* Enable the USART Parity Error Interrupt */
;;;985        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;986        
;;;987        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;988        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;989    
;;;990        /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;991           in the USART CR3 register */
;;;992        SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;993    
;;;994        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;995           in the USART CR3 register */
;;;996        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;997    
;;;998        return HAL_OK;
;;;999      }
;;;1000     else
;;;1001     {
;;;1002       return HAL_BUSY;
;;;1003     }
;;;1004   }
00001a  b004              ADD      sp,sp,#0x10
00001c  bd70              POP      {r4-r6,pc}
                  |L19.30|
00001e  bf00              NOP                            ;938
000020  f8940044          LDRB     r0,[r4,#0x44]         ;938
000024  2801              CMP      r0,#1                 ;938
000026  d101              BNE      |L19.44|
000028  2002              MOVS     r0,#2                 ;938
00002a  e7f6              B        |L19.26|
                  |L19.44|
00002c  2001              MOVS     r0,#1                 ;938
00002e  f8840044          STRB     r0,[r4,#0x44]         ;938
000032  bf00              NOP                            ;938
000034  9802              LDR      r0,[sp,#8]            ;940
000036  6320              STR      r0,[r4,#0x30]         ;940
000038  86a5              STRH     r5,[r4,#0x34]         ;941
00003a  9801              LDR      r0,[sp,#4]            ;942
00003c  62a0              STR      r0,[r4,#0x28]         ;942
00003e  85a5              STRH     r5,[r4,#0x2c]         ;943
000040  2000              MOVS     r0,#0                 ;945
000042  64a0              STR      r0,[r4,#0x48]         ;945
000044  2032              MOVS     r0,#0x32              ;946
000046  f8840045          STRB     r0,[r4,#0x45]         ;946
00004a  4829              LDR      r0,|L19.240|
00004c  6c21              LDR      r1,[r4,#0x40]         ;949
00004e  63c8              STR      r0,[r1,#0x3c]         ;949
000050  4828              LDR      r0,|L19.244|
000052  6c21              LDR      r1,[r4,#0x40]         ;952
000054  6408              STR      r0,[r1,#0x40]         ;952
000056  4828              LDR      r0,|L19.248|
000058  6be1              LDR      r1,[r4,#0x3c]         ;955
00005a  63c8              STR      r0,[r1,#0x3c]         ;955
00005c  4827              LDR      r0,|L19.252|
00005e  6be1              LDR      r1,[r4,#0x3c]         ;958
000060  6408              STR      r0,[r1,#0x40]         ;958
000062  4827              LDR      r0,|L19.256|
000064  6be1              LDR      r1,[r4,#0x3c]         ;961
000066  64c8              STR      r0,[r1,#0x4c]         ;961
000068  6c21              LDR      r1,[r4,#0x40]         ;964
00006a  64c8              STR      r0,[r1,#0x4c]         ;964
00006c  6820              LDR      r0,[r4,#0]            ;967
00006e  6880              LDR      r0,[r0,#8]            ;967
000070  f0400001          ORR      r0,r0,#1              ;967
000074  6821              LDR      r1,[r4,#0]            ;967
000076  6088              STR      r0,[r1,#8]            ;967
000078  6820              LDR      r0,[r4,#0]            ;968
00007a  69c0              LDR      r0,[r0,#0x1c]         ;968
00007c  f040000f          ORR      r0,r0,#0xf            ;968
000080  6821              LDR      r1,[r4,#0]            ;968
000082  61c8              STR      r0,[r1,#0x1c]         ;968
000084  ae02              ADD      r6,sp,#8              ;971
000086  6832              LDR      r2,[r6,#0]            ;972
000088  6823              LDR      r3,[r4,#0]            ;972
00008a  f1030124          ADD      r1,r3,#0x24           ;972
00008e  462b              MOV      r3,r5                 ;972
000090  6c20              LDR      r0,[r4,#0x40]         ;972
000092  f7fffffe          BL       HAL_DMA_Start_IT
000096  ae01              ADD      r6,sp,#4              ;975
000098  6823              LDR      r3,[r4,#0]            ;976
00009a  f1030228          ADD      r2,r3,#0x28           ;976
00009e  6831              LDR      r1,[r6,#0]            ;976
0000a0  462b              MOV      r3,r5                 ;976
0000a2  6be0              LDR      r0,[r4,#0x3c]         ;976
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  2040              MOVS     r0,#0x40              ;979
0000aa  6821              LDR      r1,[r4,#0]            ;979
0000ac  6208              STR      r0,[r1,#0x20]         ;979
0000ae  bf00              NOP                            ;982
0000b0  2000              MOVS     r0,#0                 ;982
0000b2  f8840044          STRB     r0,[r4,#0x44]         ;982
0000b6  bf00              NOP                            ;982
0000b8  6820              LDR      r0,[r4,#0]            ;985
0000ba  6800              LDR      r0,[r0,#0]            ;985
0000bc  f4407080          ORR      r0,r0,#0x100          ;985
0000c0  6821              LDR      r1,[r4,#0]            ;985
0000c2  6008              STR      r0,[r1,#0]            ;985
0000c4  6820              LDR      r0,[r4,#0]            ;988
0000c6  6880              LDR      r0,[r0,#8]            ;988
0000c8  f0400001          ORR      r0,r0,#1              ;988
0000cc  6821              LDR      r1,[r4,#0]            ;988
0000ce  6088              STR      r0,[r1,#8]            ;988
0000d0  6820              LDR      r0,[r4,#0]            ;992
0000d2  6880              LDR      r0,[r0,#8]            ;992
0000d4  f0400040          ORR      r0,r0,#0x40           ;992
0000d8  6821              LDR      r1,[r4,#0]            ;992
0000da  6088              STR      r0,[r1,#8]            ;992
0000dc  6820              LDR      r0,[r4,#0]            ;996
0000de  6880              LDR      r0,[r0,#8]            ;996
0000e0  f0400080          ORR      r0,r0,#0x80           ;996
0000e4  6821              LDR      r1,[r4,#0]            ;996
0000e6  6088              STR      r0,[r1,#8]            ;996
0000e8  2000              MOVS     r0,#0                 ;998
0000ea  e796              B        |L19.26|
                  |L19.236|
0000ec  2002              MOVS     r0,#2                 ;1002
0000ee  e794              B        |L19.26|
;;;1005   
                          ENDP

                  |L19.240|
                          DCD      USART_DMAReceiveCplt
                  |L19.244|
                          DCD      USART_DMARxHalfCplt
                  |L19.248|
                          DCD      USART_DMATransmitCplt
                  |L19.252|
                          DCD      USART_DMATxHalfCplt
                  |L19.256|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_TransmitReceive_IT PROC
;;;716      */
;;;717    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
000000  b530              PUSH     {r4,r5,lr}
;;;718    {
000002  4604              MOV      r4,r0
;;;719    
;;;720      if(husart->State == HAL_USART_STATE_READY)
000004  f8940045          LDRB     r0,[r4,#0x45]
000008  2801              CMP      r0,#1
00000a  d15d              BNE      |L20.200|
;;;721      {
;;;722        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
00000c  b109              CBZ      r1,|L20.18|
00000e  b102              CBZ      r2,|L20.18|
000010  b90b              CBNZ     r3,|L20.22|
                  |L20.18|
;;;723        {
;;;724          return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L20.20|
;;;725        }
;;;726        /* Process Locked */
;;;727        __HAL_LOCK(husart);
;;;728    
;;;729        husart->pRxBuffPtr = pRxData;
;;;730        husart->RxXferSize = Size;
;;;731        husart->RxXferCount = Size;
;;;732        husart->pTxBuffPtr = pTxData;
;;;733        husart->TxXferSize = Size;
;;;734        husart->TxXferCount = Size;
;;;735    
;;;736        /* Computation of USART mask to apply to RDR register */
;;;737        __HAL_USART_MASK_COMPUTATION(husart);
;;;738    
;;;739        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;740        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;741    
;;;742        /* Enable the USART Data Register not empty Interrupt */
;;;743        SET_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
;;;744    
;;;745        /* Enable the USART Parity Error Interrupt */
;;;746        SET_BIT(husart->Instance->CR1, USART_CR1_PEIE);
;;;747    
;;;748        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;749        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;750    
;;;751        /* Process Unlocked */
;;;752        __HAL_UNLOCK(husart);
;;;753    
;;;754        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;755        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;756    
;;;757        return HAL_OK;
;;;758      }
;;;759      else
;;;760      {
;;;761        return HAL_BUSY;
;;;762      }
;;;763    }
000014  bd30              POP      {r4,r5,pc}
                  |L20.22|
000016  bf00              NOP                            ;727
000018  f8940044          LDRB     r0,[r4,#0x44]         ;727
00001c  2801              CMP      r0,#1                 ;727
00001e  d101              BNE      |L20.36|
000020  2002              MOVS     r0,#2                 ;727
000022  e7f7              B        |L20.20|
                  |L20.36|
000024  2001              MOVS     r0,#1                 ;727
000026  f8840044          STRB     r0,[r4,#0x44]         ;727
00002a  bf00              NOP                            ;727
00002c  6322              STR      r2,[r4,#0x30]         ;729
00002e  86a3              STRH     r3,[r4,#0x34]         ;730
000030  86e3              STRH     r3,[r4,#0x36]         ;731
000032  62a1              STR      r1,[r4,#0x28]         ;732
000034  85a3              STRH     r3,[r4,#0x2c]         ;733
000036  85e3              STRH     r3,[r4,#0x2e]         ;734
000038  bf00              NOP                            ;737
00003a  68a0              LDR      r0,[r4,#8]            ;737
00003c  f5b05f80          CMP      r0,#0x1000            ;737
000040  d108              BNE      |L20.84|
000042  6920              LDR      r0,[r4,#0x10]         ;737
000044  b918              CBNZ     r0,|L20.78|
000046  f24010ff          MOV      r0,#0x1ff             ;737
00004a  8720              STRH     r0,[r4,#0x38]         ;737
00004c  e017              B        |L20.126|
                  |L20.78|
00004e  20ff              MOVS     r0,#0xff              ;737
000050  8720              STRH     r0,[r4,#0x38]         ;737
000052  e014              B        |L20.126|
                  |L20.84|
000054  68a0              LDR      r0,[r4,#8]            ;737
000056  b938              CBNZ     r0,|L20.104|
000058  6920              LDR      r0,[r4,#0x10]         ;737
00005a  b910              CBNZ     r0,|L20.98|
00005c  20ff              MOVS     r0,#0xff              ;737
00005e  8720              STRH     r0,[r4,#0x38]         ;737
000060  e00d              B        |L20.126|
                  |L20.98|
000062  207f              MOVS     r0,#0x7f              ;737
000064  8720              STRH     r0,[r4,#0x38]         ;737
000066  e00a              B        |L20.126|
                  |L20.104|
000068  68a0              LDR      r0,[r4,#8]            ;737
00006a  f1b05f80          CMP      r0,#0x10000000        ;737
00006e  d106              BNE      |L20.126|
000070  6920              LDR      r0,[r4,#0x10]         ;737
000072  b910              CBNZ     r0,|L20.122|
000074  207f              MOVS     r0,#0x7f              ;737
000076  8720              STRH     r0,[r4,#0x38]         ;737
000078  e001              B        |L20.126|
                  |L20.122|
00007a  203f              MOVS     r0,#0x3f              ;737
00007c  8720              STRH     r0,[r4,#0x38]         ;737
                  |L20.126|
00007e  bf00              NOP                            ;737
000080  2000              MOVS     r0,#0                 ;739
000082  64a0              STR      r0,[r4,#0x48]         ;739
000084  2032              MOVS     r0,#0x32              ;740
000086  f8840045          STRB     r0,[r4,#0x45]         ;740
00008a  6820              LDR      r0,[r4,#0]            ;743
00008c  6800              LDR      r0,[r0,#0]            ;743
00008e  f0400020          ORR      r0,r0,#0x20           ;743
000092  6825              LDR      r5,[r4,#0]            ;743
000094  6028              STR      r0,[r5,#0]            ;743
000096  6820              LDR      r0,[r4,#0]            ;746
000098  6800              LDR      r0,[r0,#0]            ;746
00009a  f4407080          ORR      r0,r0,#0x100          ;746
00009e  6825              LDR      r5,[r4,#0]            ;746
0000a0  6028              STR      r0,[r5,#0]            ;746
0000a2  6820              LDR      r0,[r4,#0]            ;749
0000a4  6880              LDR      r0,[r0,#8]            ;749
0000a6  f0400001          ORR      r0,r0,#1              ;749
0000aa  6825              LDR      r5,[r4,#0]            ;749
0000ac  60a8              STR      r0,[r5,#8]            ;749
0000ae  bf00              NOP                            ;752
0000b0  2000              MOVS     r0,#0                 ;752
0000b2  f8840044          STRB     r0,[r4,#0x44]         ;752
0000b6  bf00              NOP                            ;752
0000b8  6820              LDR      r0,[r4,#0]            ;755
0000ba  6800              LDR      r0,[r0,#0]            ;755
0000bc  f0400080          ORR      r0,r0,#0x80           ;755
0000c0  6825              LDR      r5,[r4,#0]            ;755
0000c2  6028              STR      r0,[r5,#0]            ;755
0000c4  2000              MOVS     r0,#0                 ;757
0000c6  e7a5              B        |L20.20|
                  |L20.200|
0000c8  2002              MOVS     r0,#2                 ;761
0000ca  e7a3              B        |L20.20|
;;;764    
                          ENDP


                          AREA ||i.HAL_USART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_USART_Transmit_DMA PROC
;;;771      */
;;;772    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;773    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;774      uint32_t *tmp;
;;;775    
;;;776      if(husart->State == HAL_USART_STATE_READY)
000006  f8940045          LDRB     r0,[r4,#0x45]
00000a  2801              CMP      r0,#1
00000c  d146              BNE      |L21.156|
;;;777      {
;;;778        if((pTxData == NULL ) || (Size == 0U))
00000e  9801              LDR      r0,[sp,#4]
000010  b100              CBZ      r0,|L21.20|
000012  b90d              CBNZ     r5,|L21.24|
                  |L21.20|
;;;779        {
;;;780          return HAL_ERROR;
000014  2001              MOVS     r0,#1
                  |L21.22|
;;;781        }
;;;782        /* Process Locked */
;;;783        __HAL_LOCK(husart);
;;;784    
;;;785        husart->pTxBuffPtr = pTxData;
;;;786        husart->TxXferSize = Size;
;;;787        husart->TxXferCount = Size;
;;;788    
;;;789        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;790        husart->State = HAL_USART_STATE_BUSY_TX;
;;;791    
;;;792        /* Set the USART DMA transfer complete callback */
;;;793        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;794    
;;;795        /* Set the USART DMA Half transfer complete callback */
;;;796        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;797    
;;;798        /* Set the DMA error callback */
;;;799        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;800    
;;;801        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;802        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;803        SET_BIT(husart->Instance->ISR, (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE | USART_ISR_ORE));
;;;804      
;;;805        /* Enable the USART transmit DMA channel */
;;;806        tmp = (uint32_t*)&pTxData;
;;;807        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->TDR, Size);
;;;808    
;;;809        /* Clear the TC flag in the SR register by writing 0 to it */
;;;810        __HAL_USART_CLEAR_IT(husart, USART_FLAG_TC);
;;;811        
;;;812        /* Process Unlocked */
;;;813        __HAL_UNLOCK(husart);
;;;814    
;;;815        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;816           in the USART CR3 register */
;;;817        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;818    
;;;819        return HAL_OK;
;;;820      }
;;;821      else
;;;822      {
;;;823        return HAL_BUSY;
;;;824      }
;;;825    }
000016  bdfe              POP      {r1-r7,pc}
                  |L21.24|
000018  bf00              NOP                            ;783
00001a  f8940044          LDRB     r0,[r4,#0x44]         ;783
00001e  2801              CMP      r0,#1                 ;783
000020  d101              BNE      |L21.38|
000022  2002              MOVS     r0,#2                 ;783
000024  e7f7              B        |L21.22|
                  |L21.38|
000026  2001              MOVS     r0,#1                 ;783
000028  f8840044          STRB     r0,[r4,#0x44]         ;783
00002c  bf00              NOP                            ;783
00002e  9801              LDR      r0,[sp,#4]            ;785
000030  62a0              STR      r0,[r4,#0x28]         ;785
000032  85a5              STRH     r5,[r4,#0x2c]         ;786
000034  85e5              STRH     r5,[r4,#0x2e]         ;787
000036  2000              MOVS     r0,#0                 ;789
000038  64a0              STR      r0,[r4,#0x48]         ;789
00003a  2012              MOVS     r0,#0x12              ;790
00003c  f8840045          STRB     r0,[r4,#0x45]         ;790
000040  4817              LDR      r0,|L21.160|
000042  6be1              LDR      r1,[r4,#0x3c]         ;793
000044  63c8              STR      r0,[r1,#0x3c]         ;793
000046  4817              LDR      r0,|L21.164|
000048  6be1              LDR      r1,[r4,#0x3c]         ;796
00004a  6408              STR      r0,[r1,#0x40]         ;796
00004c  4816              LDR      r0,|L21.168|
00004e  6be1              LDR      r1,[r4,#0x3c]         ;799
000050  64c8              STR      r0,[r1,#0x4c]         ;799
000052  6820              LDR      r0,[r4,#0]            ;802
000054  6880              LDR      r0,[r0,#8]            ;802
000056  f0400001          ORR      r0,r0,#1              ;802
00005a  6821              LDR      r1,[r4,#0]            ;802
00005c  6088              STR      r0,[r1,#8]            ;802
00005e  6820              LDR      r0,[r4,#0]            ;803
000060  69c0              LDR      r0,[r0,#0x1c]         ;803
000062  f040000f          ORR      r0,r0,#0xf            ;803
000066  6821              LDR      r1,[r4,#0]            ;803
000068  61c8              STR      r0,[r1,#0x1c]         ;803
00006a  ae01              ADD      r6,sp,#4              ;806
00006c  6823              LDR      r3,[r4,#0]            ;807
00006e  f1030228          ADD      r2,r3,#0x28           ;807
000072  6831              LDR      r1,[r6,#0]            ;807
000074  462b              MOV      r3,r5                 ;807
000076  6be0              LDR      r0,[r4,#0x3c]         ;807
000078  f7fffffe          BL       HAL_DMA_Start_IT
00007c  2040              MOVS     r0,#0x40              ;810
00007e  6821              LDR      r1,[r4,#0]            ;810
000080  6208              STR      r0,[r1,#0x20]         ;810
000082  bf00              NOP                            ;813
000084  2000              MOVS     r0,#0                 ;813
000086  f8840044          STRB     r0,[r4,#0x44]         ;813
00008a  bf00              NOP                            ;813
00008c  6820              LDR      r0,[r4,#0]            ;817
00008e  6880              LDR      r0,[r0,#8]            ;817
000090  f0400080          ORR      r0,r0,#0x80           ;817
000094  6821              LDR      r1,[r4,#0]            ;817
000096  6088              STR      r0,[r1,#8]            ;817
000098  2000              MOVS     r0,#0                 ;819
00009a  e7bc              B        |L21.22|
                  |L21.156|
00009c  2002              MOVS     r0,#2                 ;823
00009e  e7ba              B        |L21.22|
;;;826    
                          ENDP

                  |L21.160|
                          DCD      USART_DMATransmitCplt
                  |L21.164|
                          DCD      USART_DMATxHalfCplt
                  |L21.168|
                          DCD      USART_DMAError

                          AREA ||i.HAL_USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_USART_Transmit_IT PROC
;;;610      */
;;;611    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;612    {
000002  4603              MOV      r3,r0
;;;613      if(husart->State == HAL_USART_STATE_READY)
000004  f8930045          LDRB     r0,[r3,#0x45]
000008  2801              CMP      r0,#1
00000a  d123              BNE      |L22.84|
;;;614      {
;;;615        if((pTxData == NULL ) || (Size == 0U))
00000c  b101              CBZ      r1,|L22.16|
00000e  b90a              CBNZ     r2,|L22.20|
                  |L22.16|
;;;616        {
;;;617          return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L22.18|
;;;618        }
;;;619    
;;;620        /* Process Locked */
;;;621        __HAL_LOCK(husart);
;;;622    
;;;623        husart->pTxBuffPtr = pTxData;
;;;624        husart->TxXferSize = Size;
;;;625        husart->TxXferCount = Size;
;;;626    
;;;627        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;628        husart->State = HAL_USART_STATE_BUSY_TX;
;;;629    
;;;630        /* The USART Error Interrupts: (Frame error, noise error, overrun error)
;;;631        are not managed by the USART Transmit Process to avoid the overrun interrupt
;;;632        when the usart mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;633        to benefit for the frame error and noise interrupts the usart mode should be
;;;634        configured only for transmit "USART_MODE_TX" */
;;;635    
;;;636        /* Process Unlocked */
;;;637        __HAL_UNLOCK(husart);
;;;638    
;;;639        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;640        SET_BIT(husart->Instance->CR3, USART_CR3_EIE);
;;;641    
;;;642        return HAL_OK;
;;;643      }
;;;644      else
;;;645      {
;;;646        return HAL_BUSY;
;;;647      }
;;;648    }
000012  bd10              POP      {r4,pc}
                  |L22.20|
000014  bf00              NOP                            ;621
000016  f8930044          LDRB     r0,[r3,#0x44]         ;621
00001a  2801              CMP      r0,#1                 ;621
00001c  d101              BNE      |L22.34|
00001e  2002              MOVS     r0,#2                 ;621
000020  e7f7              B        |L22.18|
                  |L22.34|
000022  2001              MOVS     r0,#1                 ;621
000024  f8830044          STRB     r0,[r3,#0x44]         ;621
000028  bf00              NOP                            ;621
00002a  6299              STR      r1,[r3,#0x28]         ;623
00002c  859a              STRH     r2,[r3,#0x2c]         ;624
00002e  85da              STRH     r2,[r3,#0x2e]         ;625
000030  2000              MOVS     r0,#0                 ;627
000032  6498              STR      r0,[r3,#0x48]         ;627
000034  2012              MOVS     r0,#0x12              ;628
000036  f8830045          STRB     r0,[r3,#0x45]         ;628
00003a  bf00              NOP                            ;637
00003c  2000              MOVS     r0,#0                 ;637
00003e  f8830044          STRB     r0,[r3,#0x44]         ;637
000042  bf00              NOP                            ;637
000044  6818              LDR      r0,[r3,#0]            ;640
000046  6880              LDR      r0,[r0,#8]            ;640
000048  f0400001          ORR      r0,r0,#1              ;640
00004c  681c              LDR      r4,[r3,#0]            ;640
00004e  60a0              STR      r0,[r4,#8]            ;640
000050  2000              MOVS     r0,#0                 ;642
000052  e7de              B        |L22.18|
                  |L22.84|
000054  2002              MOVS     r0,#2                 ;646
000056  e7dc              B        |L22.18|
;;;649    
                          ENDP


                          AREA ||i.HAL_USART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxCpltCallback PROC
;;;1287     */
;;;1288   __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1289   {
;;;1290     /* Prevent unused argument(s) compilation warning */
;;;1291     UNUSED(husart);
;;;1292    
;;;1293     /* NOTE : This function should not be modified, when the callback is needed,
;;;1294               the HAL_USART_TxCpltCallback can be implemented in the user file
;;;1295      */ 
;;;1296   }
;;;1297   
                          ENDP


                          AREA ||i.HAL_USART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxHalfCpltCallback PROC
;;;1302     */
;;;1303    __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1304   {
;;;1305     /* Prevent unused argument(s) compilation warning */
;;;1306     UNUSED(husart);
;;;1307    
;;;1308     /* NOTE: This function should not be modified, when the callback is needed,
;;;1309              the HAL_USART_TxHalfCpltCallback can be implemented in the user file
;;;1310      */
;;;1311   }
;;;1312   
                          ENDP


                          AREA ||i.HAL_USART_TxRxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_USART_TxRxCpltCallback PROC
;;;1347     */
;;;1348   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000000  4770              BX       lr
;;;1349   {
;;;1350     /* Prevent unused argument(s) compilation warning */
;;;1351     UNUSED(husart);
;;;1352    
;;;1353     /* NOTE : This function should not be modified, when the callback is needed,
;;;1354               the HAL_USART_TxRxCpltCallback can be implemented in the user file
;;;1355      */
;;;1356   }
;;;1357   
                          ENDP


                          AREA ||i.USART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  USART_CheckIdleState PROC
;;;1943     */
;;;1944   static HAL_StatusTypeDef USART_CheckIdleState(USART_HandleTypeDef *husart)
000000  b538              PUSH     {r3-r5,lr}
;;;1945   {
000002  4604              MOV      r4,r0
;;;1946     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;1947   	
;;;1948      /* Initialize the USART ErrorCode */
;;;1949     husart->ErrorCode = HAL_USART_ERROR_NONE;
000006  2000              MOVS     r0,#0
000008  64a0              STR      r0,[r4,#0x48]
;;;1950     
;;;1951     /* Init tickstart for timeout managment*/
;;;1952     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4605              MOV      r5,r0
;;;1953     
;;;1954     /* Check if the Transmitter is enabled */
;;;1955     if((husart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0000008          AND      r0,r0,#8
000018  2808              CMP      r0,#8
00001a  d10e              BNE      |L26.58|
;;;1956     {
;;;1957       /* Wait until TEACK flag is set */
;;;1958       if(USART_WaitOnFlagUntilTimeout(husart, USART_ISR_TEACK, RESET, tickstart, TEACK_REACK_TIMEOUT) != HAL_OK)  
00001c  f44f707a          MOV      r0,#0x3e8
000020  462b              MOV      r3,r5
000022  2200              MOVS     r2,#0
000024  f44f1100          MOV      r1,#0x200000
000028  9000              STR      r0,[sp,#0]
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000030  b118              CBZ      r0,|L26.58|
;;;1959       { 
;;;1960         husart->State= HAL_USART_STATE_TIMEOUT;      
000032  2003              MOVS     r0,#3
000034  f8840045          STRB     r0,[r4,#0x45]
                  |L26.56|
;;;1961         return HAL_TIMEOUT;
;;;1962       } 
;;;1963     }
;;;1964     /* Check if the Receiver is enabled */
;;;1965     if((husart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
;;;1966     {
;;;1967       /* Wait until REACK flag is set */
;;;1968       if(USART_WaitOnFlagUntilTimeout(husart, USART_ISR_REACK, RESET, tickstart, TEACK_REACK_TIMEOUT) != HAL_OK)  
;;;1969       { 
;;;1970         husart->State= HAL_USART_STATE_TIMEOUT;       
;;;1971         return HAL_TIMEOUT;
;;;1972       }
;;;1973     }
;;;1974     
;;;1975     /* Initialize the USART state*/
;;;1976     husart->State= HAL_USART_STATE_READY;
;;;1977     
;;;1978     /* Process Unlocked */
;;;1979     __HAL_UNLOCK(husart);
;;;1980     
;;;1981     return HAL_OK;  
;;;1982   }
000038  bd38              POP      {r3-r5,pc}
                  |L26.58|
00003a  6820              LDR      r0,[r4,#0]            ;1965
00003c  6800              LDR      r0,[r0,#0]            ;1965
00003e  f0000004          AND      r0,r0,#4              ;1965
000042  2804              CMP      r0,#4                 ;1965
000044  d10e              BNE      |L26.100|
000046  f44f707a          MOV      r0,#0x3e8             ;1968
00004a  462b              MOV      r3,r5                 ;1968
00004c  2200              MOVS     r2,#0                 ;1968
00004e  f44f0180          MOV      r1,#0x400000          ;1968
000052  9000              STR      r0,[sp,#0]            ;1968
000054  4620              MOV      r0,r4                 ;1968
000056  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00005a  b118              CBZ      r0,|L26.100|
00005c  2003              MOVS     r0,#3                 ;1970
00005e  f8840045          STRB     r0,[r4,#0x45]         ;1970
000062  e7e9              B        |L26.56|
                  |L26.100|
000064  2001              MOVS     r0,#1                 ;1976
000066  f8840045          STRB     r0,[r4,#0x45]         ;1976
00006a  bf00              NOP                            ;1979
00006c  2000              MOVS     r0,#0                 ;1979
00006e  f8840044          STRB     r0,[r4,#0x44]         ;1979
000072  bf00              NOP                            ;1979
000074  bf00              NOP                            ;1981
000076  e7df              B        |L26.56|
;;;1983   
                          ENDP


                          AREA ||i.USART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  USART_DMAAbortOnError PROC
;;;1818     */
;;;1819   static void USART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1820   {
000002  4605              MOV      r5,r0
;;;1821     USART_HandleTypeDef* husart = (USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1822     husart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  86e0              STRH     r0,[r4,#0x36]
;;;1823     husart->TxXferCount = 0U;
00000a  85e0              STRH     r0,[r4,#0x2e]
;;;1824     
;;;1825     HAL_USART_ErrorCallback(husart);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1826   }
000012  bd70              POP      {r4-r6,pc}
;;;1827   
                          ENDP


                          AREA ||i.USART_DMAError||, CODE, READONLY, ALIGN=1

                  USART_DMAError PROC
;;;1785     */
;;;1786   static void USART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1787   {
000002  4605              MOV      r5,r0
;;;1788     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1789   
;;;1790     husart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  86e0              STRH     r0,[r4,#0x36]
;;;1791     husart->TxXferCount = 0U;
00000a  85e0              STRH     r0,[r4,#0x2e]
;;;1792     
;;;1793     /* Stop USART DMA Tx request if ongoing */
;;;1794     if((husart->State == HAL_USART_STATE_BUSY_TX)
00000c  f8940045          LDRB     r0,[r4,#0x45]
000010  2812              CMP      r0,#0x12
000012  d107              BNE      |L28.36|
;;;1795        &&(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAT)))
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  f0000080          AND      r0,r0,#0x80
00001c  b110              CBZ      r0,|L28.36|
;;;1796     {
;;;1797       USART_EndTxTransfer(husart);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       USART_EndTxTransfer
                  |L28.36|
;;;1798     }
;;;1799     
;;;1800     /* Stop USART DMA Rx request if ongoing */
;;;1801     if((husart->State == HAL_USART_STATE_BUSY_RX)
000024  f8940045          LDRB     r0,[r4,#0x45]
000028  2822              CMP      r0,#0x22
00002a  d107              BNE      |L28.60|
;;;1802        &&(HAL_IS_BIT_SET(husart->Instance->CR3, USART_CR3_DMAR)))
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0000040          AND      r0,r0,#0x40
000034  b110              CBZ      r0,|L28.60|
;;;1803     {
;;;1804       USART_EndRxTransfer(husart);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       USART_EndRxTransfer
                  |L28.60|
;;;1805     }
;;;1806     
;;;1807     husart->ErrorCode |= HAL_USART_ERROR_DMA;
00003c  6ca0              LDR      r0,[r4,#0x48]
00003e  f0400010          ORR      r0,r0,#0x10
000042  64a0              STR      r0,[r4,#0x48]
;;;1808     husart->State= HAL_USART_STATE_READY;
000044  2001              MOVS     r0,#1
000046  f8840045          STRB     r0,[r4,#0x45]
;;;1809   
;;;1810     HAL_USART_ErrorCallback(husart);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1811   }
000050  bd70              POP      {r4-r6,pc}
;;;1812   
                          ENDP


                          AREA ||i.USART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  USART_DMAReceiveCplt PROC
;;;1722     */
;;;1723   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1724   {
000002  4605              MOV      r5,r0
;;;1725     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1726   
;;;1727     /* DMA Normal mode */
;;;1728     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  bb40              CBNZ     r0,|L29.98|
;;;1729     { 
;;;1730       husart->RxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  86e0              STRH     r0,[r4,#0x36]
;;;1731       
;;;1732       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1733       CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000014  6820              LDR      r0,[r4,#0]
000016  6800              LDR      r0,[r0,#0]
000018  f4207090          BIC      r0,r0,#0x120
00001c  6821              LDR      r1,[r4,#0]
00001e  6008              STR      r0,[r1,#0]
;;;1734       CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000020  6820              LDR      r0,[r4,#0]
000022  6880              LDR      r0,[r0,#8]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6088              STR      r0,[r1,#8]
;;;1735   
;;;1736       /* Disable the DMA RX transfer for the receiver request by resetting the DMAR bit
;;;1737       in USART CR3 register */
;;;1738       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0200040          BIC      r0,r0,#0x40
000034  6821              LDR      r1,[r4,#0]
000036  6088              STR      r0,[r1,#8]
;;;1739       /* similarly, disable the DMA TX transfer that was started to provide the
;;;1740          clock to the slave device */
;;;1741       CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000038  6820              LDR      r0,[r4,#0]
00003a  6880              LDR      r0,[r0,#8]
00003c  f0200080          BIC      r0,r0,#0x80
000040  6821              LDR      r1,[r4,#0]
000042  6088              STR      r0,[r1,#8]
;;;1742   
;;;1743         if(husart->State == HAL_USART_STATE_BUSY_RX)
000044  f8940045          LDRB     r0,[r4,#0x45]
000048  2822              CMP      r0,#0x22
00004a  d103              BNE      |L29.84|
;;;1744         {
;;;1745           HAL_USART_RxCpltCallback(husart);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       HAL_USART_RxCpltCallback
000052  e002              B        |L29.90|
                  |L29.84|
;;;1746         }
;;;1747         /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1748         else
;;;1749         {
;;;1750           HAL_USART_TxRxCpltCallback(husart);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L29.90|
;;;1751         }
;;;1752       husart->State= HAL_USART_STATE_READY;
00005a  2001              MOVS     r0,#1
00005c  f8840045          STRB     r0,[r4,#0x45]
000060  e00a              B        |L29.120|
                  |L29.98|
;;;1753     }
;;;1754     /* DMA circular mode */
;;;1755     else
;;;1756     {
;;;1757       if(husart->State == HAL_USART_STATE_BUSY_RX)
000062  f8940045          LDRB     r0,[r4,#0x45]
000066  2822              CMP      r0,#0x22
000068  d103              BNE      |L29.114|
;;;1758       {
;;;1759         HAL_USART_RxCpltCallback(husart);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       HAL_USART_RxCpltCallback
000070  e002              B        |L29.120|
                  |L29.114|
;;;1760       }
;;;1761       /* The USART state is HAL_USART_STATE_BUSY_TX_RX */
;;;1762       else
;;;1763       {
;;;1764         HAL_USART_TxRxCpltCallback(husart);
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L29.120|
;;;1765       }
;;;1766     }
;;;1767   }
000078  bd70              POP      {r4-r6,pc}
;;;1768   
                          ENDP


                          AREA ||i.USART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMARxHalfCplt PROC
;;;1773     */
;;;1774   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1775   {
000002  4604              MOV      r4,r0
;;;1776     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1777   
;;;1778     HAL_USART_RxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1779   }
00000c  bd70              POP      {r4-r6,pc}
;;;1780   
                          ENDP


                          AREA ||i.USART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATransmitCplt PROC
;;;1675     */
;;;1676   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1677   {
000002  4605              MOV      r5,r0
;;;1678     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bac              LDR      r4,[r5,#0x38]
;;;1679   
;;;1680     /* DMA Normal mode */
;;;1681     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b990              CBNZ     r0,|L31.54|
;;;1682     { 
;;;1683       husart->TxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  85e0              STRH     r0,[r4,#0x2e]
;;;1684   
;;;1685       if(husart->State == HAL_USART_STATE_BUSY_TX)
000014  f8940045          LDRB     r0,[r4,#0x45]
000018  2812              CMP      r0,#0x12
00001a  d113              BNE      |L31.68|
;;;1686       {
;;;1687         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1688            in the USART CR3 register */
;;;1689         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
00001c  6820              LDR      r0,[r4,#0]
00001e  6880              LDR      r0,[r0,#8]
000020  f0200080          BIC      r0,r0,#0x80
000024  6821              LDR      r1,[r4,#0]
000026  6088              STR      r0,[r1,#8]
;;;1690   
;;;1691         /* Enable the USART Transmit Complete Interrupt */
;;;1692         SET_BIT(husart->Instance->CR1, USART_CR1_TCIE);
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
000034  e006              B        |L31.68|
                  |L31.54|
;;;1693       }
;;;1694     }
;;;1695     /* DMA Circular mode */
;;;1696     else
;;;1697     {
;;;1698       if(husart->State == HAL_USART_STATE_BUSY_TX)
000036  f8940045          LDRB     r0,[r4,#0x45]
00003a  2812              CMP      r0,#0x12
00003c  d102              BNE      |L31.68|
;;;1699       {
;;;1700       HAL_USART_TxCpltCallback(husart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_USART_TxCpltCallback
                  |L31.68|
;;;1701      }
;;;1702    }
;;;1703   }
000044  bd70              POP      {r4-r6,pc}
;;;1704   
                          ENDP


                          AREA ||i.USART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  USART_DMATxHalfCplt PROC
;;;1710     */
;;;1711   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1712   {
000002  4604              MOV      r4,r0
;;;1713     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6ba5              LDR      r5,[r4,#0x38]
;;;1714   
;;;1715     HAL_USART_TxHalfCpltCallback(husart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1716   }
00000c  bd70              POP      {r4-r6,pc}
;;;1717   
                          ENDP


                          AREA ||i.USART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  USART_EndRxTransfer PROC
;;;1846     */
;;;1847   static void USART_EndRxTransfer(USART_HandleTypeDef *husart)
000000  2101              MOVS     r1,#1
;;;1848   {
;;;1849     /* At end of Rx process, restore husart->RxState to Ready */
;;;1850     husart->State = HAL_USART_STATE_READY;
000002  f8801045          STRB     r1,[r0,#0x45]
;;;1851     
;;;1852     /* Disable RXNE, PE and ERR interrupts */
;;;1853     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000006  6801              LDR      r1,[r0,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f4217190          BIC      r1,r1,#0x120
00000e  6802              LDR      r2,[r0,#0]
000010  6011              STR      r1,[r2,#0]
;;;1854     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000012  6801              LDR      r1,[r0,#0]
000014  6889              LDR      r1,[r1,#8]
000016  f0210101          BIC      r1,r1,#1
00001a  6802              LDR      r2,[r0,#0]
00001c  6091              STR      r1,[r2,#8]
;;;1855   }
00001e  4770              BX       lr
;;;1856   
                          ENDP


                          AREA ||i.USART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  USART_EndTransmit_IT PROC
;;;1476     */
;;;1477   static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart)
000000  b510              PUSH     {r4,lr}
;;;1478   {
000002  4604              MOV      r4,r0
;;;1479     /* Disable the USART Transmit Complete Interrupt */
;;;1480     CLEAR_BIT(husart->Instance->CR1, USART_CR1_TCIE);
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;1481   
;;;1482     /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1483     CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;1484   
;;;1485     husart->State = HAL_USART_STATE_READY;
00001c  2001              MOVS     r0,#1
00001e  f8840045          STRB     r0,[r4,#0x45]
;;;1486   
;;;1487     HAL_USART_TxCpltCallback(husart);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_USART_TxCpltCallback
;;;1488   
;;;1489     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1490   }
00002a  bd10              POP      {r4,pc}
;;;1491   
                          ENDP


                          AREA ||i.USART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  USART_EndTxTransfer PROC
;;;1832     */
;;;1833   static void USART_EndTxTransfer(USART_HandleTypeDef *husart)
000000  2101              MOVS     r1,#1
;;;1834   {
;;;1835     /* At end of Tx process, restore husart->State to Ready */
;;;1836     husart->State = HAL_USART_STATE_READY;
000002  f8801045          STRB     r1,[r0,#0x45]
;;;1837     
;;;1838     /* Disable TXEIE and TCIE interrupts */
;;;1839     CLEAR_BIT(husart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6801              LDR      r1,[r0,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f02101c0          BIC      r1,r1,#0xc0
00000e  6802              LDR      r2,[r0,#0]
000010  6011              STR      r1,[r2,#0]
;;;1840   }
000012  4770              BX       lr
;;;1841   
                          ENDP


                          AREA ||i.USART_Receive_IT||, CODE, READONLY, ALIGN=1

                  USART_Receive_IT PROC
;;;1498     */
;;;1499   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1500   {
000002  4604              MOV      r4,r0
;;;1501     uint16_t* tmp;
;;;1502     uint16_t uhMask = husart->Mask;
000004  8f26              LDRH     r6,[r4,#0x38]
;;;1503   
;;;1504     if(husart->State == HAL_USART_STATE_BUSY_RX)
000006  f8940045          LDRB     r0,[r4,#0x45]
00000a  2822              CMP      r0,#0x22
00000c  d13a              BNE      |L36.132|
;;;1505     {
;;;1506   
;;;1507       if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00000e  68a0              LDR      r0,[r4,#8]
000010  f5b05f80          CMP      r0,#0x1000
000014  d10a              BNE      |L36.44|
000016  6920              LDR      r0,[r4,#0x10]
000018  b940              CBNZ     r0,|L36.44|
;;;1508       {
;;;1509         tmp = (uint16_t*) husart->pRxBuffPtr;
00001a  6b25              LDR      r5,[r4,#0x30]
;;;1510         *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
00001c  6820              LDR      r0,[r4,#0]
00001e  6a40              LDR      r0,[r0,#0x24]
000020  4030              ANDS     r0,r0,r6
000022  8028              STRH     r0,[r5,#0]
;;;1511         husart->pRxBuffPtr += 2U;
000024  6b20              LDR      r0,[r4,#0x30]
000026  1c80              ADDS     r0,r0,#2
000028  6320              STR      r0,[r4,#0x30]
00002a  e007              B        |L36.60|
                  |L36.44|
;;;1512       }
;;;1513       else
;;;1514       {
;;;1515         *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
00002c  6820              LDR      r0,[r4,#0]
00002e  6a40              LDR      r0,[r0,#0x24]
000030  b2f1              UXTB     r1,r6
000032  4008              ANDS     r0,r0,r1
000034  6b22              LDR      r2,[r4,#0x30]
000036  1c51              ADDS     r1,r2,#1
000038  6321              STR      r1,[r4,#0x30]
00003a  7010              STRB     r0,[r2,#0]
                  |L36.60|
;;;1516       }
;;;1517         /* Send dummy byte in order to generate the clock for the Slave to Send the next data */
;;;1518         husart->Instance->TDR = (DUMMY_DATA & (uint16_t)0x00FFU);
00003c  20ff              MOVS     r0,#0xff
00003e  6821              LDR      r1,[r4,#0]
000040  6288              STR      r0,[r1,#0x28]
;;;1519   
;;;1520       if(--husart->RxXferCount == 0U)
000042  8ee0              LDRH     r0,[r4,#0x36]
000044  1e40              SUBS     r0,r0,#1
000046  b280              UXTH     r0,r0
000048  86e0              STRH     r0,[r4,#0x36]
00004a  b9c8              CBNZ     r0,|L36.128|
;;;1521       {
;;;1522         CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
00004c  6820              LDR      r0,[r4,#0]
00004e  6800              LDR      r0,[r0,#0]
000050  f0200020          BIC      r0,r0,#0x20
000054  6821              LDR      r1,[r4,#0]
000056  6008              STR      r0,[r1,#0]
;;;1523   
;;;1524         /* Disable the USART Parity Error Interrupt */
;;;1525         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
000058  6820              LDR      r0,[r4,#0]
00005a  6800              LDR      r0,[r0,#0]
00005c  f4207080          BIC      r0,r0,#0x100
000060  6821              LDR      r1,[r4,#0]
000062  6008              STR      r0,[r1,#0]
;;;1526   
;;;1527         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1528         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000064  6820              LDR      r0,[r4,#0]
000066  6880              LDR      r0,[r0,#8]
000068  f0200001          BIC      r0,r0,#1
00006c  6821              LDR      r1,[r4,#0]
00006e  6088              STR      r0,[r1,#8]
;;;1529   
;;;1530         husart->State = HAL_USART_STATE_READY;
000070  2001              MOVS     r0,#1
000072  f8840045          STRB     r0,[r4,#0x45]
;;;1531   
;;;1532         HAL_USART_RxCpltCallback(husart);
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       HAL_USART_RxCpltCallback
;;;1533   
;;;1534         return HAL_OK;
00007c  2000              MOVS     r0,#0
                  |L36.126|
;;;1535       }
;;;1536   
;;;1537       return HAL_OK;
;;;1538     }
;;;1539     else
;;;1540     {
;;;1541       return HAL_BUSY;
;;;1542     }
;;;1543   }
00007e  bd70              POP      {r4-r6,pc}
                  |L36.128|
000080  2000              MOVS     r0,#0                 ;1537
000082  e7fc              B        |L36.126|
                  |L36.132|
000084  2002              MOVS     r0,#2                 ;1541
000086  e7fa              B        |L36.126|
;;;1544   
                          ENDP


                          AREA ||i.USART_SetConfig||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;1861     */
;;;1862   static HAL_StatusTypeDef USART_SetConfig(USART_HandleTypeDef *husart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1863   {
000004  4604              MOV      r4,r0
;;;1864     uint32_t tmpreg      = 0x0U;
000006  2500              MOVS     r5,#0
;;;1865     USART_ClockSourceTypeDef clocksource = USART_CLOCKSOURCE_UNDEFINED;
000008  f04f0810          MOV      r8,#0x10
;;;1866     HAL_StatusTypeDef ret                = HAL_OK;
00000c  46a9              MOV      r9,r5
;;;1867     uint16_t brrtemp                     = 0x0000U;
00000e  2600              MOVS     r6,#0
;;;1868     uint16_t usartdiv                    = 0x0000U;
000010  2700              MOVS     r7,#0
;;;1869     
;;;1870     /* Check the parameters */
;;;1871     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;1872     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;1873     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;1874     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));  
;;;1875     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;1876     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;1877     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;1878     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;1879     assert_param(IS_USART_OVERSAMPLING(husart->Init.OverSampling));   
;;;1880   
;;;1881   
;;;1882     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1883      /* Clear M, PCE, PS, TE and RE bits and configure       
;;;1884      *  the USART Word Length, Parity, Mode and OverSampling: 
;;;1885      *  set the M bits according to husart->Init.WordLength value 
;;;1886      *  set PCE and PS bits according to husart->Init.Parity value
;;;1887      *  set TE and RE bits according to husart->Init.Mode value
;;;1888      *  force OVER8 to 1 to allow to reach the maximum speed (Fclock/8) */
;;;1889     tmpreg = (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode | USART_CR1_OVER8;
000012  6921              LDR      r1,[r4,#0x10]
000014  68a0              LDR      r0,[r4,#8]
000016  4308              ORRS     r0,r0,r1
000018  6961              LDR      r1,[r4,#0x14]
00001a  4308              ORRS     r0,r0,r1
00001c  f4404500          ORR      r5,r0,#0x8000
;;;1890     MODIFY_REG(husart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  4974              LDR      r1,|L37.504|
000026  4008              ANDS     r0,r0,r1
000028  4328              ORRS     r0,r0,r5
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;1891     
;;;1892     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;1893     /* Clear and configure the USART Clock, CPOL, CPHA, LBCL and STOP bits:
;;;1894      * set CPOL bit according to husart->Init.CLKPolarity value
;;;1895      * set CPHA bit according to husart->Init.CLKPhase value
;;;1896      * set LBCL bit according to husart->Init.CLKLastBit value
;;;1897      * set STOP[13:12] bits according to husart->Init.StopBits value */
;;;1898     tmpreg = (uint32_t)(USART_CLOCK_ENABLE); 
00002e  f44f6500          MOV      r5,#0x800
;;;1899     tmpreg |= ((uint32_t)husart->Init.CLKPolarity | (uint32_t)husart->Init.CLKPhase);
000032  e9d40107          LDRD     r0,r1,[r4,#0x1c]
000036  4308              ORRS     r0,r0,r1
000038  4305              ORRS     r5,r5,r0
;;;1900     tmpreg |= ((uint32_t)husart->Init.CLKLastBit | (uint32_t)husart->Init.StopBits);
00003a  68e1              LDR      r1,[r4,#0xc]
00003c  6a60              LDR      r0,[r4,#0x24]
00003e  4308              ORRS     r0,r0,r1
000040  4305              ORRS     r5,r5,r0
;;;1901     MODIFY_REG(husart->Instance->CR2, USART_CR2_FIELDS, tmpreg);
000042  6820              LDR      r0,[r4,#0]
000044  6840              LDR      r0,[r0,#4]
000046  f420507c          BIC      r0,r0,#0x3f00
00004a  4328              ORRS     r0,r0,r5
00004c  6821              LDR      r1,[r4,#0]
00004e  6048              STR      r0,[r1,#4]
;;;1902   
;;;1903     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;1904     /* no CR3 register configuration                                            */
;;;1905   
;;;1906     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1907     /* BRR is filled-up according to OVER8 bit setting which is forced to 1     */
;;;1908     USART_GETCLOCKSOURCE(husart, clocksource);
000050  bf00              NOP      
000052  496a              LDR      r1,|L37.508|
000054  6820              LDR      r0,[r4,#0]
000056  4288              CMP      r0,r1
000058  d119              BNE      |L37.142|
00005a  4869              LDR      r0,|L37.512|
00005c  6800              LDR      r0,[r0,#0]
00005e  f0000003          AND      r0,r0,#3
000062  b130              CBZ      r0,|L37.114|
000064  2801              CMP      r0,#1
000066  d00a              BEQ      |L37.126|
000068  2802              CMP      r0,#2
00006a  d005              BEQ      |L37.120|
00006c  2803              CMP      r0,#3
00006e  d10c              BNE      |L37.138|
000070  e008              B        |L37.132|
                  |L37.114|
000072  f04f0801          MOV      r8,#1
000076  e009              B        |L37.140|
                  |L37.120|
000078  f04f0802          MOV      r8,#2
00007c  e006              B        |L37.140|
                  |L37.126|
00007e  f04f0804          MOV      r8,#4
000082  e003              B        |L37.140|
                  |L37.132|
000084  f04f0808          MOV      r8,#8
000088  e000              B        |L37.140|
                  |L37.138|
00008a  bf00              NOP      
                  |L37.140|
00008c  e05c              B        |L37.328|
                  |L37.142|
00008e  495d              LDR      r1,|L37.516|
000090  6820              LDR      r0,[r4,#0]
000092  4288              CMP      r0,r1
000094  d119              BNE      |L37.202|
000096  485a              LDR      r0,|L37.512|
000098  6800              LDR      r0,[r0,#0]
00009a  f000000c          AND      r0,r0,#0xc
00009e  b130              CBZ      r0,|L37.174|
0000a0  2804              CMP      r0,#4
0000a2  d00a              BEQ      |L37.186|
0000a4  2808              CMP      r0,#8
0000a6  d005              BEQ      |L37.180|
0000a8  280c              CMP      r0,#0xc
0000aa  d10c              BNE      |L37.198|
0000ac  e008              B        |L37.192|
                  |L37.174|
0000ae  f04f0800          MOV      r8,#0
0000b2  e009              B        |L37.200|
                  |L37.180|
0000b4  f04f0802          MOV      r8,#2
0000b8  e006              B        |L37.200|
                  |L37.186|
0000ba  f04f0804          MOV      r8,#4
0000be  e003              B        |L37.200|
                  |L37.192|
0000c0  f04f0808          MOV      r8,#8
0000c4  e000              B        |L37.200|
                  |L37.198|
0000c6  bf00              NOP      
                  |L37.200|
0000c8  e03e              B        |L37.328|
                  |L37.202|
0000ca  494f              LDR      r1,|L37.520|
0000cc  6820              LDR      r0,[r4,#0]
0000ce  4288              CMP      r0,r1
0000d0  d119              BNE      |L37.262|
0000d2  484b              LDR      r0,|L37.512|
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f0000030          AND      r0,r0,#0x30
0000da  b130              CBZ      r0,|L37.234|
0000dc  2810              CMP      r0,#0x10
0000de  d00a              BEQ      |L37.246|
0000e0  2820              CMP      r0,#0x20
0000e2  d005              BEQ      |L37.240|
0000e4  2830              CMP      r0,#0x30
0000e6  d10c              BNE      |L37.258|
0000e8  e008              B        |L37.252|
                  |L37.234|
0000ea  f04f0800          MOV      r8,#0
0000ee  e009              B        |L37.260|
                  |L37.240|
0000f0  f04f0802          MOV      r8,#2
0000f4  e006              B        |L37.260|
                  |L37.246|
0000f6  f04f0804          MOV      r8,#4
0000fa  e003              B        |L37.260|
                  |L37.252|
0000fc  f04f0808          MOV      r8,#8
000100  e000              B        |L37.260|
                  |L37.258|
000102  bf00              NOP      
                  |L37.260|
000104  e020              B        |L37.328|
                  |L37.262|
000106  4941              LDR      r1,|L37.524|
000108  6820              LDR      r0,[r4,#0]
00010a  4288              CMP      r0,r1
00010c  d11c              BNE      |L37.328|
00010e  483c              LDR      r0,|L37.512|
000110  6800              LDR      r0,[r0,#0]
000112  f4006040          AND      r0,r0,#0xc00
000116  b148              CBZ      r0,|L37.300|
000118  f5b06f80          CMP      r0,#0x400
00011c  d00c              BEQ      |L37.312|
00011e  f5b06f00          CMP      r0,#0x800
000122  d006              BEQ      |L37.306|
000124  f5b06f40          CMP      r0,#0xc00
000128  d10c              BNE      |L37.324|
00012a  e008              B        |L37.318|
                  |L37.300|
00012c  f04f0801          MOV      r8,#1
000130  e009              B        |L37.326|
                  |L37.306|
000132  f04f0802          MOV      r8,#2
000136  e006              B        |L37.326|
                  |L37.312|
000138  f04f0804          MOV      r8,#4
00013c  e003              B        |L37.326|
                  |L37.318|
00013e  f04f0808          MOV      r8,#8
000142  e000              B        |L37.326|
                  |L37.324|
000144  bf00              NOP      
                  |L37.326|
000146  bf00              NOP      
                  |L37.328|
000148  bf00              NOP      
;;;1909     switch (clocksource)
00014a  f1b80f04          CMP      r8,#4
00014e  d02e              BEQ      |L37.430|
000150  dc09              BGT      |L37.358|
000152  f1b80f00          CMP      r8,#0
000156  d00d              BEQ      |L37.372|
000158  f1b80f01          CMP      r8,#1
00015c  d014              BEQ      |L37.392|
00015e  f1b80f02          CMP      r8,#2
000162  d138              BNE      |L37.470|
000164  e01a              B        |L37.412|
                  |L37.358|
000166  f1b80f08          CMP      r8,#8
00016a  d02a              BEQ      |L37.450|
00016c  f1b80f10          CMP      r8,#0x10
000170  d131              BNE      |L37.470|
000172  e031              B        |L37.472|
                  |L37.372|
;;;1910     {
;;;1911       case USART_CLOCKSOURCE_PCLK1:
;;;1912         usartdiv = (uint16_t)(((2*HAL_RCC_GetPCLK1Freq()) + (husart->Init.BaudRate/2))/ husart->Init.BaudRate);
000174  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000178  0040              LSLS     r0,r0,#1
00017a  6861              LDR      r1,[r4,#4]
00017c  eb000051          ADD      r0,r0,r1,LSR #1
000180  fbb0f0f1          UDIV     r0,r0,r1
000184  b287              UXTH     r7,r0
;;;1913         break;
000186  e02a              B        |L37.478|
                  |L37.392|
;;;1914       case USART_CLOCKSOURCE_PCLK2:
;;;1915         usartdiv = (uint16_t)(((2*HAL_RCC_GetPCLK2Freq()) + (husart->Init.BaudRate/2))/ husart->Init.BaudRate);
000188  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00018c  0040              LSLS     r0,r0,#1
00018e  6861              LDR      r1,[r4,#4]
000190  eb000051          ADD      r0,r0,r1,LSR #1
000194  fbb0f0f1          UDIV     r0,r0,r1
000198  b287              UXTH     r7,r0
;;;1916         break;
00019a  e020              B        |L37.478|
                  |L37.412|
;;;1917       case USART_CLOCKSOURCE_HSI:
;;;1918         usartdiv = (uint16_t)(((2*HSI_VALUE) + (husart->Init.BaudRate/2))/ husart->Init.BaudRate);
00019c  491c              LDR      r1,|L37.528|
00019e  6860              LDR      r0,[r4,#4]
0001a0  eb010050          ADD      r0,r1,r0,LSR #1
0001a4  6861              LDR      r1,[r4,#4]
0001a6  fbb0f0f1          UDIV     r0,r0,r1
0001aa  b287              UXTH     r7,r0
;;;1919         break;
0001ac  e017              B        |L37.478|
                  |L37.430|
;;;1920       case USART_CLOCKSOURCE_SYSCLK:
;;;1921         usartdiv = (uint16_t)(((2*HAL_RCC_GetSysClockFreq()) + (husart->Init.BaudRate/2))/ husart->Init.BaudRate);
0001ae  f7fffffe          BL       HAL_RCC_GetSysClockFreq
0001b2  0040              LSLS     r0,r0,#1
0001b4  6861              LDR      r1,[r4,#4]
0001b6  eb000051          ADD      r0,r0,r1,LSR #1
0001ba  fbb0f0f1          UDIV     r0,r0,r1
0001be  b287              UXTH     r7,r0
;;;1922         break;
0001c0  e00d              B        |L37.478|
                  |L37.450|
;;;1923       case USART_CLOCKSOURCE_LSE:
;;;1924         usartdiv = (uint16_t)(((2*LSE_VALUE) + (husart->Init.BaudRate/2))/ husart->Init.BaudRate);
0001c2  f44f3180          MOV      r1,#0x10000
0001c6  6860              LDR      r0,[r4,#4]
0001c8  eb010050          ADD      r0,r1,r0,LSR #1
0001cc  6861              LDR      r1,[r4,#4]
0001ce  fbb0f0f1          UDIV     r0,r0,r1
0001d2  b287              UXTH     r7,r0
;;;1925         break;
0001d4  e003              B        |L37.478|
                  |L37.470|
;;;1926       case USART_CLOCKSOURCE_UNDEFINED:
0001d6  bf00              NOP      
                  |L37.472|
;;;1927       default:
;;;1928         ret = HAL_ERROR;
0001d8  f04f0901          MOV      r9,#1
;;;1929         break;
0001dc  bf00              NOP      
                  |L37.478|
0001de  bf00              NOP                            ;1913
;;;1930     } 
;;;1931     
;;;1932     brrtemp = usartdiv & 0xFFF0U;
0001e0  f64f70f0          MOV      r0,#0xfff0
0001e4  ea070600          AND      r6,r7,r0
;;;1933     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
0001e8  f3c70042          UBFX     r0,r7,#1,#3
0001ec  4306              ORRS     r6,r6,r0
;;;1934     husart->Instance->BRR = brrtemp;
0001ee  6820              LDR      r0,[r4,#0]
0001f0  60c6              STR      r6,[r0,#0xc]
;;;1935     
;;;1936     return ret; 
0001f2  4648              MOV      r0,r9
;;;1937   }
0001f4  e8bd87f0          POP      {r4-r10,pc}
;;;1938   
                          ENDP

                  |L37.504|
                          DCD      0xefff69f3
                  |L37.508|
                          DCD      0x40011000
                  |L37.512|
                          DCD      0x40023890
                  |L37.516|
                          DCD      0x40004400
                  |L37.520|
                          DCD      0x40004800
                  |L37.524|
                          DCD      0x40011400
                  |L37.528|
                          DCD      0x01e84800

                          AREA ||i.USART_TransmitReceive_IT||, CODE, READONLY, ALIGN=1

                  USART_TransmitReceive_IT PROC
;;;1551     */
;;;1552   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1553   {
000002  4604              MOV      r4,r0
;;;1554     uint16_t* tmp;
;;;1555     uint16_t uhMask = husart->Mask;
000004  8f25              LDRH     r5,[r4,#0x38]
;;;1556   
;;;1557     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000006  f8940045          LDRB     r0,[r4,#0x45]
00000a  2832              CMP      r0,#0x32
00000c  d166              BNE      |L38.220|
;;;1558     {
;;;1559       if(husart->TxXferCount != 0x00U)
00000e  8de0              LDRH     r0,[r4,#0x2e]
000010  b328              CBZ      r0,|L38.94|
;;;1560       {
;;;1561         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
000012  6820              LDR      r0,[r4,#0]
000014  69c0              LDR      r0,[r0,#0x1c]
000016  f3c010c0          UBFX     r0,r0,#7,#1
00001a  b300              CBZ      r0,|L38.94|
;;;1562         {
;;;1563           if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00001c  68a0              LDR      r0,[r4,#8]
00001e  f5b05f80          CMP      r0,#0x1000
000022  d10a              BNE      |L38.58|
000024  6920              LDR      r0,[r4,#0x10]
000026  b940              CBNZ     r0,|L38.58|
;;;1564           {
;;;1565             tmp = (uint16_t*) husart->pTxBuffPtr;
000028  6aa6              LDR      r6,[r4,#0x28]
;;;1566             husart->Instance->TDR = (uint16_t)(*tmp & uhMask);
00002a  8830              LDRH     r0,[r6,#0]
00002c  4028              ANDS     r0,r0,r5
00002e  6821              LDR      r1,[r4,#0]
000030  6288              STR      r0,[r1,#0x28]
;;;1567             husart->pTxBuffPtr += 2U;
000032  6aa0              LDR      r0,[r4,#0x28]
000034  1c80              ADDS     r0,r0,#2
000036  62a0              STR      r0,[r4,#0x28]
000038  e006              B        |L38.72|
                  |L38.58|
;;;1568           }
;;;1569           else
;;;1570           {
;;;1571             husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)uhMask);
00003a  6aa1              LDR      r1,[r4,#0x28]
00003c  1c48              ADDS     r0,r1,#1
00003e  62a0              STR      r0,[r4,#0x28]
000040  7808              LDRB     r0,[r1,#0]
000042  4028              ANDS     r0,r0,r5
000044  6821              LDR      r1,[r4,#0]
000046  6288              STR      r0,[r1,#0x28]
                  |L38.72|
;;;1572           }
;;;1573           husart->TxXferCount--;
000048  8de0              LDRH     r0,[r4,#0x2e]
00004a  1e40              SUBS     r0,r0,#1
00004c  85e0              STRH     r0,[r4,#0x2e]
;;;1574   
;;;1575           /* Check the latest data transmitted */
;;;1576           if(husart->TxXferCount == 0U)
00004e  8de0              LDRH     r0,[r4,#0x2e]
000050  b928              CBNZ     r0,|L38.94|
;;;1577           {
;;;1578              CLEAR_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
000052  6820              LDR      r0,[r4,#0]
000054  6800              LDR      r0,[r0,#0]
000056  f0200080          BIC      r0,r0,#0x80
00005a  6821              LDR      r1,[r4,#0]
00005c  6008              STR      r0,[r1,#0]
                  |L38.94|
;;;1579           }
;;;1580         }
;;;1581       }
;;;1582   
;;;1583       if(husart->RxXferCount != 0x00U)
00005e  8ee0              LDRH     r0,[r4,#0x36]
000060  b1f0              CBZ      r0,|L38.160|
;;;1584       {
;;;1585         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
000062  6820              LDR      r0,[r4,#0]
000064  69c0              LDR      r0,[r0,#0x1c]
000066  f3c01040          UBFX     r0,r0,#5,#1
00006a  b1c8              CBZ      r0,|L38.160|
;;;1586         {
;;;1587           if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
00006c  68a0              LDR      r0,[r4,#8]
00006e  f5b05f80          CMP      r0,#0x1000
000072  d10a              BNE      |L38.138|
000074  6920              LDR      r0,[r4,#0x10]
000076  b940              CBNZ     r0,|L38.138|
;;;1588           {
;;;1589             tmp = (uint16_t*) husart->pRxBuffPtr;
000078  6b26              LDR      r6,[r4,#0x30]
;;;1590             *tmp = (uint16_t)(husart->Instance->RDR & uhMask);
00007a  6820              LDR      r0,[r4,#0]
00007c  6a40              LDR      r0,[r0,#0x24]
00007e  4028              ANDS     r0,r0,r5
000080  8030              STRH     r0,[r6,#0]
;;;1591             husart->pRxBuffPtr += 2U;
000082  6b20              LDR      r0,[r4,#0x30]
000084  1c80              ADDS     r0,r0,#2
000086  6320              STR      r0,[r4,#0x30]
000088  e007              B        |L38.154|
                  |L38.138|
;;;1592           }
;;;1593           else
;;;1594           {
;;;1595             *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->RDR & (uint8_t)uhMask);
00008a  6820              LDR      r0,[r4,#0]
00008c  6a40              LDR      r0,[r0,#0x24]
00008e  b2e9              UXTB     r1,r5
000090  4008              ANDS     r0,r0,r1
000092  6b22              LDR      r2,[r4,#0x30]
000094  1c51              ADDS     r1,r2,#1
000096  6321              STR      r1,[r4,#0x30]
000098  7010              STRB     r0,[r2,#0]
                  |L38.154|
;;;1596           }
;;;1597           husart->RxXferCount--;
00009a  8ee0              LDRH     r0,[r4,#0x36]
00009c  1e40              SUBS     r0,r0,#1
00009e  86e0              STRH     r0,[r4,#0x36]
                  |L38.160|
;;;1598         }
;;;1599       }
;;;1600   
;;;1601       /* Check the latest data received */
;;;1602       if(husart->RxXferCount == 0U)
0000a0  8ee0              LDRH     r0,[r4,#0x36]
0000a2  b9c8              CBNZ     r0,|L38.216|
;;;1603       {
;;;1604         CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6800              LDR      r0,[r0,#0]
0000a8  f0200020          BIC      r0,r0,#0x20
0000ac  6821              LDR      r1,[r4,#0]
0000ae  6008              STR      r0,[r1,#0]
;;;1605   
;;;1606         /* Disable the USART Parity Error Interrupt */
;;;1607         CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6800              LDR      r0,[r0,#0]
0000b4  f4207080          BIC      r0,r0,#0x100
0000b8  6821              LDR      r1,[r4,#0]
0000ba  6008              STR      r0,[r1,#0]
;;;1608   
;;;1609         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1610         CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
0000bc  6820              LDR      r0,[r4,#0]
0000be  6880              LDR      r0,[r0,#8]
0000c0  f0200001          BIC      r0,r0,#1
0000c4  6821              LDR      r1,[r4,#0]
0000c6  6088              STR      r0,[r1,#8]
;;;1611   
;;;1612         husart->State = HAL_USART_STATE_READY;
0000c8  2001              MOVS     r0,#1
0000ca  f8840045          STRB     r0,[r4,#0x45]
;;;1613   
;;;1614         HAL_USART_TxRxCpltCallback(husart);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;1615   
;;;1616         return HAL_OK;
0000d4  2000              MOVS     r0,#0
                  |L38.214|
;;;1617       }
;;;1618   
;;;1619       return HAL_OK;
;;;1620     }
;;;1621     else
;;;1622     {
;;;1623       return HAL_BUSY;
;;;1624     }
;;;1625   }
0000d6  bd70              POP      {r4-r6,pc}
                  |L38.216|
0000d8  2000              MOVS     r0,#0                 ;1619
0000da  e7fc              B        |L38.214|
                  |L38.220|
0000dc  2002              MOVS     r0,#2                 ;1623
0000de  e7fa              B        |L38.214|
;;;1626   
                          ENDP


                          AREA ||i.USART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  USART_Transmit_IT PROC
;;;1429     */
;;;1430   static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
000000  4601              MOV      r1,r0
;;;1431   {
;;;1432     uint16_t* tmp;
;;;1433   
;;;1434     if(husart->State == HAL_USART_STATE_BUSY_TX)
000002  f8910045          LDRB     r0,[r1,#0x45]
000006  2812              CMP      r0,#0x12
000008  d12a              BNE      |L39.96|
;;;1435     {
;;;1436   
;;;1437       if(husart->TxXferCount == 0U)
00000a  8dc8              LDRH     r0,[r1,#0x2e]
00000c  b968              CBNZ     r0,|L39.42|
;;;1438       {
;;;1439         /* Disable the USART Transmit data register empty interrupt */
;;;1440         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0200080          BIC      r0,r0,#0x80
000016  680b              LDR      r3,[r1,#0]
000018  6018              STR      r0,[r3,#0]
;;;1441   
;;;1442         /* Enable the USART Transmit Complete Interrupt */
;;;1443         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400040          ORR      r0,r0,#0x40
000022  680b              LDR      r3,[r1,#0]
000024  6018              STR      r0,[r3,#0]
;;;1444   
;;;1445         return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L39.40|
;;;1446       }
;;;1447       else
;;;1448       {
;;;1449         if((husart->Init.WordLength == USART_WORDLENGTH_9B) && (husart->Init.Parity == USART_PARITY_NONE))
;;;1450         {
;;;1451           tmp = (uint16_t*) husart->pTxBuffPtr;
;;;1452           husart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;1453           husart->pTxBuffPtr += 2U;
;;;1454         }
;;;1455         else
;;;1456         {
;;;1457           husart->Instance->TDR = (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0xFF);       
;;;1458         }
;;;1459   
;;;1460         husart->TxXferCount--;
;;;1461   
;;;1462         return HAL_OK;
;;;1463       }
;;;1464     }
;;;1465     else
;;;1466     {
;;;1467       return HAL_BUSY;
;;;1468     }
;;;1469   }
000028  4770              BX       lr
                  |L39.42|
00002a  6888              LDR      r0,[r1,#8]            ;1449
00002c  f5b05f80          CMP      r0,#0x1000            ;1449
000030  d10b              BNE      |L39.74|
000032  6908              LDR      r0,[r1,#0x10]         ;1449
000034  b948              CBNZ     r0,|L39.74|
000036  6a8a              LDR      r2,[r1,#0x28]         ;1451
000038  8810              LDRH     r0,[r2,#0]            ;1452
00003a  f3c00008          UBFX     r0,r0,#0,#9           ;1452
00003e  680b              LDR      r3,[r1,#0]            ;1452
000040  6298              STR      r0,[r3,#0x28]         ;1452
000042  6a88              LDR      r0,[r1,#0x28]         ;1453
000044  1c80              ADDS     r0,r0,#2              ;1453
000046  6288              STR      r0,[r1,#0x28]         ;1453
000048  e005              B        |L39.86|
                  |L39.74|
00004a  6a8b              LDR      r3,[r1,#0x28]         ;1457
00004c  1c58              ADDS     r0,r3,#1              ;1457
00004e  6288              STR      r0,[r1,#0x28]         ;1457
000050  7818              LDRB     r0,[r3,#0]            ;1457
000052  680b              LDR      r3,[r1,#0]            ;1457
000054  6298              STR      r0,[r3,#0x28]         ;1457
                  |L39.86|
000056  8dc8              LDRH     r0,[r1,#0x2e]         ;1460
000058  1e40              SUBS     r0,r0,#1              ;1460
00005a  85c8              STRH     r0,[r1,#0x2e]         ;1460
00005c  2000              MOVS     r0,#0                 ;1462
00005e  e7e3              B        |L39.40|
                  |L39.96|
000060  2002              MOVS     r0,#2                 ;1467
000062  e7e1              B        |L39.40|
;;;1470   
                          ENDP


                          AREA ||i.USART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  USART_WaitOnFlagUntilTimeout PROC
;;;1635     */
;;;1636   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1637   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;1638     /* Wait until flag is set */
;;;1639     while((__HAL_USART_GET_FLAG(husart, Flag) ? SET : RESET) == Status)
00000e  e02b              B        |L40.104|
                  |L40.16|
;;;1640     {
;;;1641       /* Check for the Timeout */
;;;1642       if(Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b348              CBZ      r0,|L40.104|
;;;1643       {
;;;1644         if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
000014  b12e              CBZ      r6,|L40.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d322              BCC      |L40.104|
                  |L40.34|
;;;1645         {
;;;1646           /* Disable the USART Transmit Complete Interrupt */
;;;1647           CLEAR_BIT(husart->Instance->CR1, USART_CR1_TXEIE);
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0200080          BIC      r0,r0,#0x80
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;1648           
;;;1649           /* Disable the USART RXNE Interrupt */
;;;1650           CLEAR_BIT(husart->Instance->CR1, USART_CR1_RXNEIE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200020          BIC      r0,r0,#0x20
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;1651           
;;;1652           /* Disable the USART Parity Error Interrupt */
;;;1653           CLEAR_BIT(husart->Instance->CR1, USART_CR1_PEIE);
00003a  6820              LDR      r0,[r4,#0]
00003c  6800              LDR      r0,[r0,#0]
00003e  f4207080          BIC      r0,r0,#0x100
000042  6821              LDR      r1,[r4,#0]
000044  6008              STR      r0,[r1,#0]
;;;1654           
;;;1655           /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1656           CLEAR_BIT(husart->Instance->CR3, USART_CR3_EIE);
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  f0200001          BIC      r0,r0,#1
00004e  6821              LDR      r1,[r4,#0]
000050  6088              STR      r0,[r1,#8]
;;;1657           
;;;1658           husart->State= HAL_USART_STATE_READY;
000052  2001              MOVS     r0,#1
000054  f8840045          STRB     r0,[r4,#0x45]
;;;1659           
;;;1660           /* Process Unlocked */
;;;1661           __HAL_UNLOCK(husart);
000058  bf00              NOP      
00005a  2000              MOVS     r0,#0
00005c  f8840044          STRB     r0,[r4,#0x44]
000060  bf00              NOP      
;;;1662           
;;;1663           return HAL_TIMEOUT;
000062  2003              MOVS     r0,#3
                  |L40.100|
;;;1664         }
;;;1665       }
;;;1666     }
;;;1667     return HAL_OK;
;;;1668   }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L40.104|
000068  6820              LDR      r0,[r4,#0]            ;1639
00006a  69c0              LDR      r0,[r0,#0x1c]         ;1639
00006c  4028              ANDS     r0,r0,r5              ;1639
00006e  42a8              CMP      r0,r5                 ;1639
000070  d101              BNE      |L40.118|
000072  2001              MOVS     r0,#1                 ;1639
000074  e000              B        |L40.120|
                  |L40.118|
000076  2000              MOVS     r0,#0                 ;1639
                  |L40.120|
000078  42b8              CMP      r0,r7                 ;1639
00007a  d0c9              BEQ      |L40.16|
00007c  2000              MOVS     r0,#0                 ;1667
00007e  e7f1              B        |L40.100|
;;;1669   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___21_stm32f7xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32f7xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_usart_c_32ae8742____RRX|
#line 587
|__asm___21_stm32f7xx_hal_usart_c_32ae8742____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
