; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\stm32f7xx_ll_fmc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f7xx_ll_fmc.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\stm32f7xx_ll_fmc.crf ..\HALLIB\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_fmc.c]
                          THUMB

                          AREA ||i.FMC_NAND_AttributeSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NAND_AttributeSpace_Timing_Init PROC
;;;556      */
;;;557    HAL_StatusTypeDef FMC_NAND_AttributeSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;558    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;559      uint32_t tmpr = 0;  
000006  2200              MOVS     r2,#0
;;;560      
;;;561      /* Check the parameters */ 
;;;562      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;563      assert_param(IS_FMC_SETUP_TIME(Timing->SetupTime));
;;;564      assert_param(IS_FMC_WAIT_TIME(Timing->WaitSetupTime));
;;;565      assert_param(IS_FMC_HOLD_TIME(Timing->HoldSetupTime));
;;;566      assert_param(IS_FMC_HIZ_TIME(Timing->HiZSetupTime));
;;;567      assert_param(IS_FMC_NAND_BANK(Bank));
;;;568      
;;;569      /* Get the NAND bank 3 register value */
;;;570      tmpr = Device->PATT;
000008  68da              LDR      r2,[r3,#0xc]
;;;571    
;;;572      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;573      tmpr &= ((uint32_t)~(FMC_PATT_ATTSET3  | FMC_PATT_ATTWAIT3 | FMC_PATT_ATTHOLD3 | \
00000a  2200              MOVS     r2,#0
;;;574                           FMC_PATT_ATTHIZ3));
;;;575      /* Set FMC_NAND device timing parameters */
;;;576      tmpr |= (uint32_t)(Timing->SetupTime                  |\
00000c  e9d10500          LDRD     r0,r5,[r1,#0]
000010  ea402005          ORR      r0,r0,r5,LSL #8
000014  890d              LDRH     r5,[r1,#8]
000016  ea404005          ORR      r0,r0,r5,LSL #16
00001a  7b0d              LDRB     r5,[r1,#0xc]
00001c  ea406005          ORR      r0,r0,r5,LSL #24
000020  4302              ORRS     r2,r2,r0
;;;577                       ((Timing->WaitSetupTime) << 8)     |\
;;;578                       ((Timing->HoldSetupTime) << 16)    |\
;;;579                       ((Timing->HiZSetupTime) << 24));
;;;580                           
;;;581        /* NAND bank 3 registers configuration */
;;;582        Device->PATT = tmpr;
000022  60da              STR      r2,[r3,#0xc]
;;;583      
;;;584      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;585    }
000026  bd30              POP      {r4,r5,pc}
;;;586    
                          ENDP


                          AREA ||i.FMC_NAND_CommonSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NAND_CommonSpace_Timing_Init PROC
;;;517      */
;;;518    HAL_StatusTypeDef FMC_NAND_CommonSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;519    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;520      uint32_t tmpr = 0;  
000006  2200              MOVS     r2,#0
;;;521      
;;;522      /* Check the parameters */
;;;523      assert_param(IS_FMC_NAND_DEVICE(Device));
;;;524      assert_param(IS_FMC_SETUP_TIME(Timing->SetupTime));
;;;525      assert_param(IS_FMC_WAIT_TIME(Timing->WaitSetupTime));
;;;526      assert_param(IS_FMC_HOLD_TIME(Timing->HoldSetupTime));
;;;527      assert_param(IS_FMC_HIZ_TIME(Timing->HiZSetupTime));
;;;528      assert_param(IS_FMC_NAND_BANK(Bank));
;;;529      
;;;530      /* Get the NAND bank 3 register value */
;;;531      tmpr = Device->PMEM;
000008  689a              LDR      r2,[r3,#8]
;;;532    
;;;533      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;534      tmpr &= ((uint32_t)~(FMC_PMEM_MEMSET3  | FMC_PMEM_MEMWAIT3 | FMC_PMEM_MEMHOLD3 | \
00000a  2200              MOVS     r2,#0
;;;535                           FMC_PMEM_MEMHIZ3)); 
;;;536      /* Set FMC_NAND device timing parameters */
;;;537      tmpr |= (uint32_t)(Timing->SetupTime                  |\
00000c  e9d10500          LDRD     r0,r5,[r1,#0]
000010  ea402005          ORR      r0,r0,r5,LSL #8
000014  890d              LDRH     r5,[r1,#8]
000016  ea404005          ORR      r0,r0,r5,LSL #16
00001a  7b0d              LDRB     r5,[r1,#0xc]
00001c  ea406005          ORR      r0,r0,r5,LSL #24
000020  4302              ORRS     r2,r2,r0
;;;538                           ((Timing->WaitSetupTime) << 8)     |\
;;;539                           ((Timing->HoldSetupTime) << 16)    |\
;;;540                           ((Timing->HiZSetupTime) << 24)
;;;541                           );
;;;542                                
;;;543        /* NAND bank 3 registers configuration */
;;;544        Device->PMEM = tmpr;
000022  609a              STR      r2,[r3,#8]
;;;545      
;;;546      return HAL_OK;  
000024  2000              MOVS     r0,#0
;;;547    }
000026  bd30              POP      {r4,r5,pc}
;;;548    
                          ENDP


                          AREA ||i.FMC_NAND_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_NAND_DeInit PROC
;;;592      */
;;;593    HAL_StatusTypeDef FMC_NAND_DeInit(FMC_NAND_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;594    {
;;;595      /* Check the parameters */ 
;;;596      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;597      assert_param(IS_FMC_NAND_BANK(Bank));
;;;598          
;;;599      /* Disable the NAND Bank */
;;;600      __FMC_NAND_DISABLE(Device);
000002  6810              LDR      r0,[r2,#0]
000004  f0200004          BIC      r0,r0,#4
000008  6010              STR      r0,[r2,#0]
;;;601     
;;;602        /* Set the FMC_NAND_BANK3 registers to their reset values */
;;;603        Device->PCR  = 0x00000018U;
00000a  2018              MOVS     r0,#0x18
00000c  6010              STR      r0,[r2,#0]
;;;604        Device->SR   = 0x00000040U;
00000e  2040              MOVS     r0,#0x40
000010  6050              STR      r0,[r2,#4]
;;;605        Device->PMEM = 0xFCFCFCFCU;
000012  f04f30fc          MOV      r0,#0xfcfcfcfc
000016  6090              STR      r0,[r2,#8]
;;;606        Device->PATT = 0xFCFCFCFCU; 
000018  60d0              STR      r0,[r2,#0xc]
;;;607      
;;;608      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;609    }
00001c  4770              BX       lr
;;;610    
                          ENDP


                          AREA ||i.FMC_NAND_ECC_Disable||, CODE, READONLY, ALIGN=1

                  FMC_NAND_ECC_Disable PROC
;;;655      */  
;;;656    HAL_StatusTypeDef FMC_NAND_ECC_Disable(FMC_NAND_TypeDef *Device, uint32_t Bank)  
000000  4602              MOV      r2,r0
;;;657    {  
;;;658      /* Check the parameters */ 
;;;659      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;660      assert_param(IS_FMC_NAND_BANK(Bank));
;;;661        
;;;662      /* Disable ECC feature */
;;;663        Device->PCR &= ~FMC_PCR_ECCEN;
000002  6810              LDR      r0,[r2,#0]
000004  f0200040          BIC      r0,r0,#0x40
000008  6010              STR      r0,[r2,#0]
;;;664    
;;;665      return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;666    }
00000c  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.FMC_NAND_ECC_Enable||, CODE, READONLY, ALIGN=1

                  FMC_NAND_ECC_Enable PROC
;;;636      */    
;;;637    HAL_StatusTypeDef FMC_NAND_ECC_Enable(FMC_NAND_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;638    {
;;;639      /* Check the parameters */ 
;;;640      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;641      assert_param(IS_FMC_NAND_BANK(Bank));
;;;642        
;;;643      /* Enable ECC feature */
;;;644        Device->PCR |= FMC_PCR_ECCEN;
000002  6810              LDR      r0,[r2,#0]
000004  f0400040          ORR      r0,r0,#0x40
000008  6010              STR      r0,[r2,#0]
;;;645      
;;;646      return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;647    }
00000c  4770              BX       lr
;;;648    
                          ENDP


                          AREA ||i.FMC_NAND_GetECC||, CODE, READONLY, ALIGN=1

                  FMC_NAND_GetECC PROC
;;;675      */
;;;676    HAL_StatusTypeDef FMC_NAND_GetECC(FMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;677    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;678      uint32_t tickstart = 0;
00000c  2700              MOVS     r7,#0
;;;679    
;;;680      /* Check the parameters */ 
;;;681      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;682      assert_param(IS_FMC_NAND_BANK(Bank));
;;;683    
;;;684      /* Get tick */ 
;;;685      tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4607              MOV      r7,r0
;;;686    
;;;687      /* Wait until FIFO is empty */
;;;688      while(__FMC_NAND_GET_FLAG(Device, Bank, FMC_FLAG_FEMPT) == RESET)
000014  e00a              B        |L6.44|
                  |L6.22|
;;;689      {
;;;690        /* Check for the Timeout */
;;;691        if(Timeout != HAL_MAX_DELAY)
000016  1c60              ADDS     r0,r4,#1
000018  b140              CBZ      r0,|L6.44|
;;;692        {
;;;693          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
00001a  b124              CBZ      r4,|L6.38|
00001c  f7fffffe          BL       HAL_GetTick
000020  1bc0              SUBS     r0,r0,r7
000022  42a0              CMP      r0,r4
000024  d902              BLS      |L6.44|
                  |L6.38|
;;;694          {
;;;695            return HAL_TIMEOUT;
000026  2003              MOVS     r0,#3
                  |L6.40|
;;;696          }
;;;697        }  
;;;698      }
;;;699     
;;;700      /* Get the ECCR register value */
;;;701      *ECCval = (uint32_t)Device->ECCR;
;;;702    
;;;703      return HAL_OK;  
;;;704    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L6.44|
00002c  6868              LDR      r0,[r5,#4]            ;688
00002e  f3c01080          UBFX     r0,r0,#6,#1           ;688
000032  2800              CMP      r0,#0                 ;688
000034  d0ef              BEQ      |L6.22|
000036  6968              LDR      r0,[r5,#0x14]         ;701
000038  6030              STR      r0,[r6,#0]            ;701
00003a  2000              MOVS     r0,#0                 ;703
00003c  e7f4              B        |L6.40|
;;;705    
                          ENDP


                          AREA ||i.FMC_NAND_Init||, CODE, READONLY, ALIGN=2

                  FMC_NAND_Init PROC
;;;472      */
;;;473    HAL_StatusTypeDef FMC_NAND_Init(FMC_NAND_TypeDef *Device, FMC_NAND_InitTypeDef *Init)
000000  b510              PUSH     {r4,lr}
;;;474    {
000002  4602              MOV      r2,r0
;;;475      uint32_t tmpr  = 0; 
000004  2300              MOVS     r3,#0
;;;476        
;;;477      /* Check the parameters */
;;;478      assert_param(IS_FMC_NAND_DEVICE(Device));
;;;479      assert_param(IS_FMC_NAND_BANK(Init->NandBank));
;;;480      assert_param(IS_FMC_WAIT_FEATURE(Init->Waitfeature));
;;;481      assert_param(IS_FMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;482      assert_param(IS_FMC_ECC_STATE(Init->EccComputation));
;;;483      assert_param(IS_FMC_ECCPAGE_SIZE(Init->ECCPageSize));
;;;484      assert_param(IS_FMC_TCLR_TIME(Init->TCLRSetupTime));
;;;485      assert_param(IS_FMC_TAR_TIME(Init->TARSetupTime));   
;;;486    
;;;487      /* Get the NAND bank 3 register value */
;;;488      tmpr = Device->PCR;
000006  6813              LDR      r3,[r2,#0]
;;;489    
;;;490      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;491      tmpr &= ((uint32_t)~(FMC_PCR_PWAITEN  | FMC_PCR_PBKEN | FMC_PCR_PTYP | \
000008  480a              LDR      r0,|L7.52|
00000a  4003              ANDS     r3,r3,r0
;;;492                           FMC_PCR_PWID | FMC_PCR_ECCEN | FMC_PCR_TCLR | \
;;;493                           FMC_PCR_TAR | FMC_PCR_ECCPS));  
;;;494      /* Set NAND device control parameters */
;;;495      tmpr |= (uint32_t)(Init->Waitfeature                |\
00000c  6848              LDR      r0,[r1,#4]
00000e  f0400008          ORR      r0,r0,#8
000012  688c              LDR      r4,[r1,#8]
000014  4320              ORRS     r0,r0,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4320              ORRS     r0,r0,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4320              ORRS     r0,r0,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  ea402044          ORR      r0,r0,r4,LSL #9
000024  698c              LDR      r4,[r1,#0x18]
000026  ea403044          ORR      r0,r0,r4,LSL #13
00002a  4303              ORRS     r3,r3,r0
;;;496                          FMC_PCR_MEMORY_TYPE_NAND         |\
;;;497                          Init->MemoryDataWidth            |\
;;;498                          Init->EccComputation             |\
;;;499                          Init->ECCPageSize                |\
;;;500                          ((Init->TCLRSetupTime) << 9)     |\
;;;501                          ((Init->TARSetupTime) << 13));   
;;;502      
;;;503        /* NAND bank 3 registers configuration */
;;;504        Device->PCR  = tmpr;
00002c  6013              STR      r3,[r2,#0]
;;;505      
;;;506      return HAL_OK;
00002e  2000              MOVS     r0,#0
;;;507    
;;;508    }
000030  bd10              POP      {r4,pc}
;;;509    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0xfff00181

                          AREA ||i.FMC_NORSRAM_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_DeInit PROC
;;;226      */
;;;227    HAL_StatusTypeDef FMC_NORSRAM_DeInit(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
000000  b510              PUSH     {r4,lr}
;;;228    {
000002  4603              MOV      r3,r0
;;;229      /* Check the parameters */
;;;230      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;231      assert_param(IS_FMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
;;;232      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;233      
;;;234      /* Disable the FMC_NORSRAM device */
;;;235      __FMC_NORSRAM_DISABLE(Device, Bank);
000004  f8530022          LDR      r0,[r3,r2,LSL #2]
000008  f0200001          BIC      r0,r0,#1
00000c  f8430022          STR      r0,[r3,r2,LSL #2]
;;;236      
;;;237      /* De-initialize the FMC_NORSRAM device */
;;;238      /* FMC_NORSRAM_BANK1 */
;;;239      if(Bank == FMC_NORSRAM_BANK1)
000010  b922              CBNZ     r2,|L8.28|
;;;240      {
;;;241        Device->BTCR[Bank] = 0x000030DB;    
000012  f24300db          MOV      r0,#0x30db
000016  f8430022          STR      r0,[r3,r2,LSL #2]
00001a  e003              B        |L8.36|
                  |L8.28|
;;;242      }
;;;243      /* FMC_NORSRAM_BANK2, FMC_NORSRAM_BANK3 or FMC_NORSRAM_BANK4 */
;;;244      else
;;;245      {   
;;;246        Device->BTCR[Bank] = 0x000030D2; 
00001c  f24300d2          MOV      r0,#0x30d2
000020  f8430022          STR      r0,[r3,r2,LSL #2]
                  |L8.36|
;;;247      }
;;;248      
;;;249      Device->BTCR[Bank + 1] = 0x0FFFFFFF;
000024  f06f4470          MVN      r4,#0xf0000000
000028  1c50              ADDS     r0,r2,#1
00002a  f8434020          STR      r4,[r3,r0,LSL #2]
;;;250      ExDevice->BWTR[Bank]   = 0x0FFFFFFF;
00002e  4620              MOV      r0,r4
000030  f8410022          STR      r0,[r1,r2,LSL #2]
;;;251       
;;;252      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;253    }
000036  bd10              POP      {r4,pc}
;;;254    
                          ENDP


                          AREA ||i.FMC_NORSRAM_Extended_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Extended_Timing_Init PROC
;;;317      */
;;;318    HAL_StatusTypeDef  FMC_NORSRAM_Extended_Timing_Init(FMC_NORSRAM_EXTENDED_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
000000  b570              PUSH     {r4-r6,lr}
;;;319    {  
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;320      uint32_t tmpr = 0;
000006  2300              MOVS     r3,#0
;;;321     
;;;322      /* Check the parameters */
;;;323      assert_param(IS_FMC_EXTENDED_MODE(ExtendedMode));
;;;324      
;;;325      /* Set NORSRAM device timing register for write configuration, if extended mode is used */
;;;326      if(ExtendedMode == FMC_EXTENDED_MODE_ENABLE)
000008  f5b54f80          CMP      r5,#0x4000
00000c  d113              BNE      |L9.54|
;;;327      {
;;;328        /* Check the parameters */
;;;329        assert_param(IS_FMC_NORSRAM_EXTENDED_DEVICE(Device));  
;;;330        assert_param(IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;331        assert_param(IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;332        assert_param(IS_FMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;333        assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;334        assert_param(IS_FMC_CLK_DIV(Timing->CLKDivision));
;;;335        assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
;;;336        assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
;;;337        assert_param(IS_FMC_NORSRAM_BANK(Bank));  
;;;338        
;;;339        /* Get the BWTR register value */
;;;340        tmpr = Device->BWTR[Bank];
00000e  f8543022          LDR      r3,[r4,r2,LSL #2]
;;;341    
;;;342        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;343        tmpr &= ((uint32_t)~(FMC_BWTR1_ADDSET  | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | \
000012  480c              LDR      r0,|L9.68|
000014  4003              ANDS     r3,r3,r0
;;;344                             FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD));
;;;345        
;;;346        tmpr |= (uint32_t)(Timing->AddressSetupTime                 |\
000016  e9d10600          LDRD     r0,r6,[r1,#0]
00001a  ea401006          ORR      r0,r0,r6,LSL #4
00001e  688e              LDR      r6,[r1,#8]
000020  ea402006          ORR      r0,r0,r6,LSL #8
000024  898e              LDRH     r6,[r1,#0xc]
000026  ea404006          ORR      r0,r0,r6,LSL #16
00002a  698e              LDR      r6,[r1,#0x18]
00002c  4330              ORRS     r0,r0,r6
00002e  4303              ORRS     r3,r3,r0
;;;347                          ((Timing->AddressHoldTime) << 4)          |\
;;;348                          ((Timing->DataSetupTime) << 8)            |\
;;;349                          ((Timing->BusTurnAroundDuration) << 16)   |\
;;;350                          (Timing->AccessMode));
;;;351    
;;;352        Device->BWTR[Bank] = tmpr;
000030  f8443022          STR      r3,[r4,r2,LSL #2]
000034  e003              B        |L9.62|
                  |L9.54|
;;;353      }
;;;354      else
;;;355      {
;;;356        Device->BWTR[Bank] = 0x0FFFFFFF;
000036  f06f4070          MVN      r0,#0xf0000000
00003a  f8440022          STR      r0,[r4,r2,LSL #2]
                  |L9.62|
;;;357      }   
;;;358      
;;;359      return HAL_OK;  
00003e  2000              MOVS     r0,#0
;;;360    }
000040  bd70              POP      {r4-r6,pc}
;;;361    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L9.68|
                          DCD      0xcff00000

                          AREA ||i.FMC_NORSRAM_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Init PROC
;;;149      */
;;;150    HAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_InitTypeDef* Init)
000000  b510              PUSH     {r4,lr}
;;;151    { 
000002  4602              MOV      r2,r0
;;;152      uint32_t tmpr = 0;
000004  2300              MOVS     r3,#0
;;;153        
;;;154      /* Check the parameters */
;;;155      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;156      assert_param(IS_FMC_NORSRAM_BANK(Init->NSBank));
;;;157      assert_param(IS_FMC_MUX(Init->DataAddressMux));
;;;158      assert_param(IS_FMC_MEMORY(Init->MemoryType));
;;;159      assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;160      assert_param(IS_FMC_BURSTMODE(Init->BurstAccessMode));
;;;161      assert_param(IS_FMC_WAIT_POLARITY(Init->WaitSignalPolarity));
;;;162      assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
;;;163      assert_param(IS_FMC_WRITE_OPERATION(Init->WriteOperation));
;;;164      assert_param(IS_FMC_WAITE_SIGNAL(Init->WaitSignal));
;;;165      assert_param(IS_FMC_EXTENDED_MODE(Init->ExtendedMode));
;;;166      assert_param(IS_FMC_ASYNWAIT(Init->AsynchronousWait));
;;;167      assert_param(IS_FMC_WRITE_BURST(Init->WriteBurst));
;;;168      assert_param(IS_FMC_CONTINOUS_CLOCK(Init->ContinuousClock)); 
;;;169      assert_param(IS_FMC_WRITE_FIFO(Init->WriteFifo));
;;;170      assert_param(IS_FMC_PAGESIZE(Init->PageSize));
;;;171    
;;;172      /* Get the BTCR register value */
;;;173      tmpr = Device->BTCR[Init->NSBank];
000006  6808              LDR      r0,[r1,#0]
000008  f8523020          LDR      r3,[r2,r0,LSL #2]
;;;174      
;;;175      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WAITCFG, WREN,
;;;176               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;177      tmpr &= ((uint32_t)~(FMC_BCR1_MBKEN     | FMC_BCR1_MUXEN    | FMC_BCR1_MTYP     | \
00000c  481b              LDR      r0,|L10.124|
00000e  4003              ANDS     r3,r3,r0
;;;178                           FMC_BCR1_MWID      | FMC_BCR1_FACCEN   | FMC_BCR1_BURSTEN  | \
;;;179                           FMC_BCR1_WAITPOL   | FMC_BCR1_CPSIZE    | FMC_BCR1_WAITCFG  | \
;;;180                           FMC_BCR1_WREN      | FMC_BCR1_WAITEN   | FMC_BCR1_EXTMOD   | \
;;;181                           FMC_BCR1_ASYNCWAIT | FMC_BCR1_CBURSTRW | FMC_BCR1_CCLKEN | FMC_BCR1_WFDIS));
;;;182      
;;;183      /* Set NORSRAM device control parameters */
;;;184      tmpr |= (uint32_t)(Init->DataAddressMux       |\
000010  e9d10401          LDRD     r0,r4,[r1,#4]
000014  4320              ORRS     r0,r0,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4320              ORRS     r0,r0,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4320              ORRS     r0,r0,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  4320              ORRS     r0,r0,r4
000022  698c              LDR      r4,[r1,#0x18]
000024  4320              ORRS     r0,r0,r4
000026  69cc              LDR      r4,[r1,#0x1c]
000028  4320              ORRS     r0,r0,r4
00002a  6a0c              LDR      r4,[r1,#0x20]
00002c  4320              ORRS     r0,r0,r4
00002e  6a4c              LDR      r4,[r1,#0x24]
000030  4320              ORRS     r0,r0,r4
000032  6a8c              LDR      r4,[r1,#0x28]
000034  4320              ORRS     r0,r0,r4
000036  6acc              LDR      r4,[r1,#0x2c]
000038  4320              ORRS     r0,r0,r4
00003a  6b0c              LDR      r4,[r1,#0x30]
00003c  4320              ORRS     r0,r0,r4
00003e  6b8c              LDR      r4,[r1,#0x38]
000040  4320              ORRS     r0,r0,r4
000042  6b4c              LDR      r4,[r1,#0x34]
000044  4320              ORRS     r0,r0,r4
000046  4303              ORRS     r3,r3,r0
;;;185                        Init->MemoryType           |\
;;;186                        Init->MemoryDataWidth      |\
;;;187                        Init->BurstAccessMode      |\
;;;188                        Init->WaitSignalPolarity   |\
;;;189                        Init->WaitSignalActive     |\
;;;190                        Init->WriteOperation       |\
;;;191                        Init->WaitSignal           |\
;;;192                        Init->ExtendedMode         |\
;;;193                        Init->AsynchronousWait     |\
;;;194                        Init->WriteBurst           |\
;;;195                        Init->ContinuousClock      |\
;;;196                        Init->PageSize             |\
;;;197                        Init->WriteFifo);
;;;198                        
;;;199      if(Init->MemoryType == FMC_MEMORY_TYPE_NOR)
000048  6888              LDR      r0,[r1,#8]
00004a  2808              CMP      r0,#8
00004c  d101              BNE      |L10.82|
;;;200      {
;;;201        tmpr |= (uint32_t)FMC_NORSRAM_FLASH_ACCESS_ENABLE;
00004e  f0430340          ORR      r3,r3,#0x40
                  |L10.82|
;;;202      }
;;;203      
;;;204      Device->BTCR[Init->NSBank] = tmpr;
000052  6808              LDR      r0,[r1,#0]
000054  f8423020          STR      r3,[r2,r0,LSL #2]
;;;205    
;;;206      /* Configure synchronous mode when Continuous clock is enabled for bank2..4 */
;;;207      if((Init->ContinuousClock == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC) && (Init->NSBank != FMC_NORSRAM_BANK1))
000058  6b08              LDR      r0,[r1,#0x30]
00005a  f5b01f80          CMP      r0,#0x100000
00005e  d105              BNE      |L10.108|
000060  6808              LDR      r0,[r1,#0]
000062  b118              CBZ      r0,|L10.108|
;;;208      { 
;;;209        Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->ContinuousClock);
000064  6810              LDR      r0,[r2,#0]
000066  6b0c              LDR      r4,[r1,#0x30]
000068  4320              ORRS     r0,r0,r4
00006a  6010              STR      r0,[r2,#0]
                  |L10.108|
;;;210      }
;;;211      if(Init->NSBank != FMC_NORSRAM_BANK1)
00006c  6808              LDR      r0,[r1,#0]
00006e  b118              CBZ      r0,|L10.120|
;;;212      {
;;;213        Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->WriteFifo);              
000070  6810              LDR      r0,[r2,#0]
000072  6b4c              LDR      r4,[r1,#0x34]
000074  4320              ORRS     r0,r0,r4
000076  6010              STR      r0,[r2,#0]
                  |L10.120|
;;;214      }
;;;215      
;;;216      return HAL_OK;
000078  2000              MOVS     r0,#0
;;;217    }
00007a  bd10              POP      {r4,pc}
;;;218    
                          ENDP

                  |L10.124|
                          DCD      0xffc00480

                          AREA ||i.FMC_NORSRAM_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_Timing_Init PROC
;;;263      */
;;;264    HAL_StatusTypeDef FMC_NORSRAM_Timing_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;265    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;266      uint32_t tmpr = 0;
000006  2200              MOVS     r2,#0
;;;267      
;;;268      /* Check the parameters */
;;;269      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;270      assert_param(IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;271      assert_param(IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;272      assert_param(IS_FMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;273      assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;274      assert_param(IS_FMC_CLK_DIV(Timing->CLKDivision));
;;;275      assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
;;;276      assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
;;;277      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;278      
;;;279      /* Get the BTCR register value */
;;;280      tmpr = Device->BTCR[Bank + 1];
000008  1c60              ADDS     r0,r4,#1
00000a  f8532020          LDR      r2,[r3,r0,LSL #2]
;;;281    
;;;282      /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;283      tmpr &= ((uint32_t)~(FMC_BTR1_ADDSET  | FMC_BTR1_ADDHLD | FMC_BTR1_DATAST | \
00000e  f0024240          AND      r2,r2,#0xc0000000
;;;284                           FMC_BTR1_BUSTURN | FMC_BTR1_CLKDIV | FMC_BTR1_DATLAT | \
;;;285                           FMC_BTR1_ACCMOD));
;;;286      
;;;287      /* Set FMC_NORSRAM device timing parameters */  
;;;288      tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
000012  e9d10500          LDRD     r0,r5,[r1,#0]
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  688d              LDR      r5,[r1,#8]
00001c  ea402005          ORR      r0,r0,r5,LSL #8
000020  898d              LDRH     r5,[r1,#0xc]
000022  ea404505          ORR      r5,r0,r5,LSL #16
000026  8a08              LDRH     r0,[r1,#0x10]
000028  1e40              SUBS     r0,r0,#1
00002a  ea455500          ORR      r5,r5,r0,LSL #20
00002e  7d08              LDRB     r0,[r1,#0x14]
000030  1e80              SUBS     r0,r0,#2
000032  ea456000          ORR      r0,r5,r0,LSL #24
000036  698d              LDR      r5,[r1,#0x18]
000038  4328              ORRS     r0,r0,r5
00003a  4302              ORRS     r2,r2,r0
;;;289                       ((Timing->AddressHoldTime) << 4)          |\
;;;290                       ((Timing->DataSetupTime) << 8)            |\
;;;291                       ((Timing->BusTurnAroundDuration) << 16)   |\
;;;292                       (((Timing->CLKDivision)-1) << 20)         |\
;;;293                       (((Timing->DataLatency)-2) << 24)         |\
;;;294                        (Timing->AccessMode)
;;;295                        );
;;;296      
;;;297      Device->BTCR[Bank + 1] = tmpr;
00003c  1c60              ADDS     r0,r4,#1
00003e  f8432020          STR      r2,[r3,r0,LSL #2]
;;;298      
;;;299      /* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled */
;;;300      if(HAL_IS_BIT_SET(Device->BTCR[FMC_NORSRAM_BANK1], FMC_BCR1_CCLKEN))
000042  6818              LDR      r0,[r3,#0]
000044  f4001080          AND      r0,r0,#0x100000
000048  b138              CBZ      r0,|L11.90|
;;;301      {
;;;302        tmpr = (uint32_t)(Device->BTCR[FMC_NORSRAM_BANK1 + 1] & ~(((uint32_t)0x0F) << 20)); 
00004a  6858              LDR      r0,[r3,#4]
00004c  f4200270          BIC      r2,r0,#0xf00000
;;;303        tmpr |= (uint32_t)(((Timing->CLKDivision)-1) << 20);
000050  8a08              LDRH     r0,[r1,#0x10]
000052  1e40              SUBS     r0,r0,#1
000054  ea425200          ORR      r2,r2,r0,LSL #20
;;;304        Device->BTCR[FMC_NORSRAM_BANK1 + 1] = tmpr;
000058  605a              STR      r2,[r3,#4]
                  |L11.90|
;;;305      }  
;;;306      
;;;307      return HAL_OK;   
00005a  2000              MOVS     r0,#0
;;;308    }
00005c  bd30              POP      {r4,r5,pc}
;;;309    
                          ENDP


                          AREA ||i.FMC_NORSRAM_WriteOperation_Disable||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_WriteOperation_Disable PROC
;;;403      */
;;;404    HAL_StatusTypeDef FMC_NORSRAM_WriteOperation_Disable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;405    { 
;;;406      /* Check the parameters */
;;;407      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;408      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;409        
;;;410      /* Disable write operation */
;;;411      Device->BTCR[Bank] &= ~FMC_WRITE_OPERATION_ENABLE; 
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4205080          BIC      r0,r0,#0x1000
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;412    
;;;413      return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;414    }
000010  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.FMC_NORSRAM_WriteOperation_Enable||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_WriteOperation_Enable PROC
;;;385      */
;;;386    HAL_StatusTypeDef FMC_NORSRAM_WriteOperation_Enable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;387    {
;;;388      /* Check the parameters */
;;;389      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;390      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;391      
;;;392      /* Enable write operation */
;;;393      Device->BTCR[Bank] |= FMC_WRITE_OPERATION_ENABLE; 
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4405080          ORR      r0,r0,#0x1000
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;394    
;;;395      return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;396    }
000010  4770              BX       lr
;;;397    
                          ENDP


                          AREA ||i.FMC_SDRAM_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_DeInit PROC
;;;910      */
;;;911    HAL_StatusTypeDef FMC_SDRAM_DeInit(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;912    {
;;;913      /* Check the parameters */
;;;914      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;915      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;916      
;;;917      /* De-initialize the SDRAM device */
;;;918      Device->SDCR[Bank] = 0x000002D0;
000002  f44f7034          MOV      r0,#0x2d0
000006  f8420021          STR      r0,[r2,r1,LSL #2]
;;;919      Device->SDTR[Bank] = 0x0FFFFFFF;    
00000a  f06f4370          MVN      r3,#0xf0000000
00000e  f1020008          ADD      r0,r2,#8
000012  f8403021          STR      r3,[r0,r1,LSL #2]
;;;920      Device->SDCMR      = 0x00000000;
000016  2000              MOVS     r0,#0
000018  6110              STR      r0,[r2,#0x10]
;;;921      Device->SDRTR      = 0x00000000;
00001a  6150              STR      r0,[r2,#0x14]
;;;922      Device->SDSR       = 0x00000000;
00001c  6190              STR      r0,[r2,#0x18]
;;;923    
;;;924      return HAL_OK;
;;;925    }
00001e  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.FMC_SDRAM_GetModeStatus||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_GetModeStatus PROC
;;;1073     */
;;;1074   uint32_t FMC_SDRAM_GetModeStatus(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;1075   {
;;;1076     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1077     
;;;1078     /* Check the parameters */
;;;1079     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1080     assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;1081   
;;;1082     /* Get the corresponding bank mode */
;;;1083     if(Bank == FMC_SDRAM_BANK1)
000004  b919              CBNZ     r1,|L15.14|
;;;1084     {
;;;1085       tmpreg = (uint32_t)(Device->SDSR & FMC_SDSR_MODES1); 
000006  6993              LDR      r3,[r2,#0x18]
000008  f0030006          AND      r0,r3,#6
00000c  e003              B        |L15.22|
                  |L15.14|
;;;1086     }
;;;1087     else
;;;1088     {
;;;1089       tmpreg = ((uint32_t)(Device->SDSR & FMC_SDSR_MODES2) >> 2);
00000e  6993              LDR      r3,[r2,#0x18]
000010  f0030318          AND      r3,r3,#0x18
000014  0898              LSRS     r0,r3,#2
                  |L15.22|
;;;1090     }
;;;1091     
;;;1092     /* Return the mode status */
;;;1093     return tmpreg;
;;;1094   }
000016  4770              BX       lr
;;;1095   
                          ENDP


                          AREA ||i.FMC_SDRAM_Init||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_Init PROC
;;;759      */
;;;760    HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
000000  b530              PUSH     {r4,r5,lr}
;;;761    {
000002  4602              MOV      r2,r0
;;;762      uint32_t tmpr1 = 0;
000004  2300              MOVS     r3,#0
;;;763      uint32_t tmpr2 = 0;
000006  2400              MOVS     r4,#0
;;;764        
;;;765      /* Check the parameters */
;;;766      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;767      assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
;;;768      assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
;;;769      assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
;;;770      assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
;;;771      assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
;;;772      assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
;;;773      assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
;;;774      assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
;;;775      assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
;;;776      assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   
;;;777    
;;;778      /* Set SDRAM bank configuration parameters */
;;;779      if (Init->SDBank != FMC_SDRAM_BANK2) 
000008  6808              LDR      r0,[r1,#0]
00000a  2801              CMP      r0,#1
00000c  d016              BEQ      |L16.60|
;;;780      {
;;;781        tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
00000e  6813              LDR      r3,[r2,#0]
;;;782        
;;;783        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;784        tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
000010  f36f030e          BFC      r3,#0,#15
;;;785                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
;;;786                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;787    
;;;788        tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
000014  e9d10501          LDRD     r0,r5,[r1,#4]
000018  4328              ORRS     r0,r0,r5
00001a  68cd              LDR      r5,[r1,#0xc]
00001c  4328              ORRS     r0,r0,r5
00001e  690d              LDR      r5,[r1,#0x10]
000020  4328              ORRS     r0,r0,r5
000022  694d              LDR      r5,[r1,#0x14]
000024  4328              ORRS     r0,r0,r5
000026  698d              LDR      r5,[r1,#0x18]
000028  4328              ORRS     r0,r0,r5
00002a  69cd              LDR      r5,[r1,#0x1c]
00002c  4328              ORRS     r0,r0,r5
00002e  6a0d              LDR      r5,[r1,#0x20]
000030  4328              ORRS     r0,r0,r5
000032  6a4d              LDR      r5,[r1,#0x24]
000034  4328              ORRS     r0,r0,r5
000036  4303              ORRS     r3,r3,r0
;;;789                            Init->RowBitsNumber      |\
;;;790                            Init->MemoryDataWidth    |\
;;;791                            Init->InternalBankNumber |\
;;;792                            Init->CASLatency         |\
;;;793                            Init->WriteProtection    |\
;;;794                            Init->SDClockPeriod      |\
;;;795                            Init->ReadBurst          |\
;;;796                            Init->ReadPipeDelay
;;;797                            );                                      
;;;798        Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
000038  6013              STR      r3,[r2,#0]
00003a  e019              B        |L16.112|
                  |L16.60|
;;;799      }
;;;800      else /* FMC_Bank2_SDRAM */                      
;;;801      {
;;;802        tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
00003c  6813              LDR      r3,[r2,#0]
;;;803        
;;;804        /* Clear SDCLK, RBURST, and RPIPE bits */
;;;805        tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
00003e  f42343f8          BIC      r3,r3,#0x7c00
;;;806        
;;;807        tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
000042  e9d10507          LDRD     r0,r5,[r1,#0x1c]
000046  4328              ORRS     r0,r0,r5
000048  6a4d              LDR      r5,[r1,#0x24]
00004a  4328              ORRS     r0,r0,r5
00004c  4303              ORRS     r3,r3,r0
;;;808                            Init->ReadBurst          |\
;;;809                            Init->ReadPipeDelay);
;;;810        
;;;811        tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
00004e  6854              LDR      r4,[r2,#4]
;;;812        
;;;813        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;814        tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
000050  f36f040e          BFC      r4,#0,#15
;;;815                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
;;;816                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;817    
;;;818        tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
000054  e9d10501          LDRD     r0,r5,[r1,#4]
000058  4328              ORRS     r0,r0,r5
00005a  68cd              LDR      r5,[r1,#0xc]
00005c  4328              ORRS     r0,r0,r5
00005e  690d              LDR      r5,[r1,#0x10]
000060  4328              ORRS     r0,r0,r5
000062  694d              LDR      r5,[r1,#0x14]
000064  4328              ORRS     r0,r0,r5
000066  698d              LDR      r5,[r1,#0x18]
000068  4328              ORRS     r0,r0,r5
00006a  4304              ORRS     r4,r4,r0
;;;819                           Init->RowBitsNumber       |\
;;;820                           Init->MemoryDataWidth     |\
;;;821                           Init->InternalBankNumber  |\
;;;822                           Init->CASLatency          |\
;;;823                           Init->WriteProtection);
;;;824    
;;;825        Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
00006c  6013              STR      r3,[r2,#0]
;;;826        Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
00006e  6054              STR      r4,[r2,#4]
                  |L16.112|
;;;827      }
;;;828      
;;;829      return HAL_OK;
000070  2000              MOVS     r0,#0
;;;830    }
000072  bd30              POP      {r4,r5,pc}
;;;831    
                          ENDP


                          AREA ||i.FMC_SDRAM_ProgramRefreshRate||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_ProgramRefreshRate PROC
;;;1034     */
;;;1035   HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
000000  4602              MOV      r2,r0
;;;1036   {
;;;1037     /* Check the parameters */
;;;1038     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1039     assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
;;;1040     
;;;1041     /* Set the refresh rate in command register */
;;;1042     Device->SDRTR |= (RefreshRate<<1);
000002  6950              LDR      r0,[r2,#0x14]
000004  ea400041          ORR      r0,r0,r1,LSL #1
000008  6150              STR      r0,[r2,#0x14]
;;;1043     
;;;1044     return HAL_OK;   
00000a  2000              MOVS     r0,#0
;;;1045   }
00000c  4770              BX       lr
;;;1046   
                          ENDP


                          AREA ||i.FMC_SDRAM_SendCommand||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_SendCommand PROC
;;;988      */  
;;;989    HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
000000  b5f8              PUSH     {r3-r7,lr}
;;;990    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;991      __IO uint32_t tmpr = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;992      uint32_t tickstart = 0;
00000c  2700              MOVS     r7,#0
;;;993      
;;;994      /* Check the parameters */
;;;995      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;996      assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
;;;997      assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
;;;998      assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
;;;999      assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  
;;;1000   
;;;1001     /* Set command register */
;;;1002     tmpr = (uint32_t)((Command->CommandMode)                  |\
00000e  e9d40100          LDRD     r0,r1,[r4,#0]
000012  4308              ORRS     r0,r0,r1
000014  68a1              LDR      r1,[r4,#8]
000016  1e49              SUBS     r1,r1,#1
000018  ea401041          ORR      r0,r0,r1,LSL #5
00001c  68e1              LDR      r1,[r4,#0xc]
00001e  ea402041          ORR      r0,r0,r1,LSL #9
000022  9000              STR      r0,[sp,#0]
;;;1003                       (Command->CommandTarget)                |\
;;;1004                       (((Command->AutoRefreshNumber)-1) << 5) |\
;;;1005                       ((Command->ModeRegisterDefinition) << 9)
;;;1006                       );
;;;1007       
;;;1008     Device->SDCMR = tmpr;
000024  9800              LDR      r0,[sp,#0]
000026  6130              STR      r0,[r6,#0x10]
;;;1009   
;;;1010     /* Get tick */ 
;;;1011     tickstart = HAL_GetTick();
000028  f7fffffe          BL       HAL_GetTick
00002c  4607              MOV      r7,r0
;;;1012   
;;;1013     /* wait until command is send */
;;;1014     while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
00002e  e009              B        |L18.68|
                  |L18.48|
;;;1015     {
;;;1016       /* Check for the Timeout */
;;;1017       if(Timeout != HAL_MAX_DELAY)
000030  1c68              ADDS     r0,r5,#1
000032  b138              CBZ      r0,|L18.68|
;;;1018       {
;;;1019         if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000034  b125              CBZ      r5,|L18.64|
000036  f7fffffe          BL       HAL_GetTick
00003a  1bc0              SUBS     r0,r0,r7
00003c  42a8              CMP      r0,r5
00003e  d901              BLS      |L18.68|
                  |L18.64|
;;;1020         {
;;;1021           return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L18.66|
;;;1022         }
;;;1023       }     
;;;1024     }
;;;1025     
;;;1026     return HAL_OK;  
;;;1027   }
000042  bdf8              POP      {r3-r7,pc}
                  |L18.68|
000044  69b0              LDR      r0,[r6,#0x18]         ;1014
000046  f0000020          AND      r0,r0,#0x20           ;1014
00004a  2800              CMP      r0,#0                 ;1014
00004c  d1f0              BNE      |L18.48|
00004e  bf00              NOP                            ;1026
000050  e7f7              B        |L18.66|
;;;1028   
                          ENDP


                          AREA ||i.FMC_SDRAM_SetAutoRefreshNumber||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_SetAutoRefreshNumber PROC
;;;1052     */
;;;1053   HAL_StatusTypeDef FMC_SDRAM_SetAutoRefreshNumber(FMC_SDRAM_TypeDef *Device, uint32_t AutoRefreshNumber)
000000  4602              MOV      r2,r0
;;;1054   {
;;;1055     /* Check the parameters */
;;;1056     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1057     assert_param(IS_FMC_AUTOREFRESH_NUMBER(AutoRefreshNumber));
;;;1058     
;;;1059     /* Set the Auto-refresh number in command register */
;;;1060     Device->SDCMR |= (AutoRefreshNumber << 5); 
000002  6910              LDR      r0,[r2,#0x10]
000004  ea401041          ORR      r0,r0,r1,LSL #5
000008  6110              STR      r0,[r2,#0x10]
;;;1061   
;;;1062     return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;1063   }
00000c  4770              BX       lr
;;;1064   
                          ENDP


                          AREA ||i.FMC_SDRAM_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_SDRAM_Timing_Init PROC
;;;840      */
;;;841    HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  b570              PUSH     {r4-r6,lr}
;;;842    {
000002  4603              MOV      r3,r0
000004  4615              MOV      r5,r2
;;;843      uint32_t tmpr1 = 0;
000006  2200              MOVS     r2,#0
;;;844      uint32_t tmpr2 = 0;
000008  2400              MOVS     r4,#0
;;;845        
;;;846      /* Check the parameters */
;;;847      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;848      assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
;;;849      assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
;;;850      assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
;;;851      assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
;;;852      assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
;;;853      assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
;;;854      assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
;;;855      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;856      
;;;857      /* Set SDRAM device timing parameters */ 
;;;858      if (Bank != FMC_SDRAM_BANK2) 
00000a  2d01              CMP      r5,#1
00000c  d01f              BEQ      |L20.78|
;;;859      {
;;;860        tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
00000e  689a              LDR      r2,[r3,#8]
;;;861        
;;;862        /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;863        tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
000010  f0024270          AND      r2,r2,#0xf0000000
;;;864                              FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;865                              FMC_SDTR1_TRCD));
;;;866        
;;;867        tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
000014  6808              LDR      r0,[r1,#0]
000016  1e40              SUBS     r0,r0,#1
000018  684e              LDR      r6,[r1,#4]
00001a  1e76              SUBS     r6,r6,#1
00001c  ea401606          ORR      r6,r0,r6,LSL #4
000020  6888              LDR      r0,[r1,#8]
000022  1e40              SUBS     r0,r0,#1
000024  ea462600          ORR      r6,r6,r0,LSL #8
000028  68c8              LDR      r0,[r1,#0xc]
00002a  1e40              SUBS     r0,r0,#1
00002c  ea463600          ORR      r6,r6,r0,LSL #12
000030  8a08              LDRH     r0,[r1,#0x10]
000032  1e40              SUBS     r0,r0,#1
000034  ea464600          ORR      r6,r6,r0,LSL #16
000038  8a88              LDRH     r0,[r1,#0x14]
00003a  1e40              SUBS     r0,r0,#1
00003c  ea465600          ORR      r6,r6,r0,LSL #20
000040  7e08              LDRB     r0,[r1,#0x18]
000042  1e40              SUBS     r0,r0,#1
000044  ea466000          ORR      r0,r6,r0,LSL #24
000048  4302              ORRS     r2,r2,r0
;;;868                           (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
;;;869                           (((Timing->SelfRefreshTime)-1) << 8)      |\
;;;870                           (((Timing->RowCycleDelay)-1) << 12)       |\
;;;871                           (((Timing->WriteRecoveryTime)-1) <<16)    |\
;;;872                           (((Timing->RPDelay)-1) << 20)             |\
;;;873                           (((Timing->RCDDelay)-1) << 24));
;;;874        Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
00004a  609a              STR      r2,[r3,#8]
00004c  e022              B        |L20.148|
                  |L20.78|
;;;875      }
;;;876      else /* FMC_Bank2_SDRAM */
;;;877      {
;;;878        tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
00004e  689a              LDR      r2,[r3,#8]
;;;879        
;;;880        /* Clear TRC and TRP bits */
;;;881        tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
000050  4811              LDR      r0,|L20.152|
000052  4002              ANDS     r2,r2,r0
;;;882        
;;;883        tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
000054  68c8              LDR      r0,[r1,#0xc]
000056  1e40              SUBS     r0,r0,#1
000058  0306              LSLS     r6,r0,#12
00005a  8a88              LDRH     r0,[r1,#0x14]
00005c  1e40              SUBS     r0,r0,#1
00005e  ea465000          ORR      r0,r6,r0,LSL #20
000062  4302              ORRS     r2,r2,r0
;;;884                            (((Timing->RPDelay)-1) << 20)); 
;;;885        
;;;886        tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
000064  68dc              LDR      r4,[r3,#0xc]
;;;887        
;;;888        /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;889        tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
000066  f0044470          AND      r4,r4,#0xf0000000
;;;890                              FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;891                              FMC_SDTR1_TRCD));
;;;892        
;;;893        tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
00006a  6808              LDR      r0,[r1,#0]
00006c  1e40              SUBS     r0,r0,#1
00006e  684e              LDR      r6,[r1,#4]
000070  1e76              SUBS     r6,r6,#1
000072  ea401606          ORR      r6,r0,r6,LSL #4
000076  6888              LDR      r0,[r1,#8]
000078  1e40              SUBS     r0,r0,#1
00007a  ea462600          ORR      r6,r6,r0,LSL #8
00007e  8a08              LDRH     r0,[r1,#0x10]
000080  1e40              SUBS     r0,r0,#1
000082  ea464600          ORR      r6,r6,r0,LSL #16
000086  7e08              LDRB     r0,[r1,#0x18]
000088  1e40              SUBS     r0,r0,#1
00008a  ea466000          ORR      r0,r6,r0,LSL #24
00008e  4304              ORRS     r4,r4,r0
;;;894                           (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
;;;895                           (((Timing->SelfRefreshTime)-1) << 8)       |\
;;;896                           (((Timing->WriteRecoveryTime)-1) <<16)     |\
;;;897                           (((Timing->RCDDelay)-1) << 24));   
;;;898    
;;;899        Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
000090  609a              STR      r2,[r3,#8]
;;;900        Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
000092  60dc              STR      r4,[r3,#0xc]
                  |L20.148|
;;;901      }
;;;902      
;;;903      return HAL_OK;
000094  2000              MOVS     r0,#0
;;;904    }
000096  bd70              POP      {r4-r6,pc}
;;;905    
                          ENDP

                  |L20.152|
                          DCD      0xff0f0fff

                          AREA ||i.FMC_SDRAM_WriteProtection_Disable||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_WriteProtection_Disable PROC
;;;968      */
;;;969    HAL_StatusTypeDef FMC_SDRAM_WriteProtection_Disable(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;970    {
;;;971      /* Check the parameters */
;;;972      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;973      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;974      
;;;975      /* Disable write protection */
;;;976      Device->SDCR[Bank] &= ~FMC_SDRAM_WRITE_PROTECTION_ENABLE;
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4207000          BIC      r0,r0,#0x200
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;977      
;;;978      return HAL_OK;
00000e  2000              MOVS     r0,#0
;;;979    }
000010  4770              BX       lr
;;;980      
                          ENDP


                          AREA ||i.FMC_SDRAM_WriteProtection_Enable||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_WriteProtection_Enable PROC
;;;951      */
;;;952    HAL_StatusTypeDef FMC_SDRAM_WriteProtection_Enable(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;953    { 
;;;954      /* Check the parameters */
;;;955      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;956      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;957      
;;;958      /* Enable write protection */
;;;959      Device->SDCR[Bank] |= FMC_SDRAM_WRITE_PROTECTION_ENABLE;
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4407000          ORR      r0,r0,#0x200
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;960      
;;;961      return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;962    }
000010  4770              BX       lr
;;;963    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\HALLIB\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_ll_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REVSH|
#line 402
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____RRX|
#line 587
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
