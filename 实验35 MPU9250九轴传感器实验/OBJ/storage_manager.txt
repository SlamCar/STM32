; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\storage_manager.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\storage_manager.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\storage_manager.crf ..\DMP\mllite\storage_manager.c]
                          THUMB

                          AREA ||i.inv_find_entry||, CODE, READONLY, ALIGN=2

                  inv_find_entry PROC
;;;104     */
;;;105    static int inv_find_entry(unsigned int key)
000000  4602              MOV      r2,r0
;;;106    {
;;;107        int kk;
;;;108        for (kk=0; kk<ds.num; ++kk) {
000002  2100              MOVS     r1,#0
000004  e00a              B        |L1.28|
                  |L1.6|
;;;109            if (key == ds.hd[kk].key) {
000006  eb010341          ADD      r3,r1,r1,LSL #1
00000a  4808              LDR      r0,|L1.44|
00000c  eb000083          ADD      r0,r0,r3,LSL #2
000010  6880              LDR      r0,[r0,#8]
000012  4290              CMP      r0,r2
000014  d101              BNE      |L1.26|
;;;110                return kk;
000016  4608              MOV      r0,r1
                  |L1.24|
;;;111            }
;;;112        }
;;;113        return -1;
;;;114    }
000018  4770              BX       lr
                  |L1.26|
00001a  1c49              ADDS     r1,r1,#1              ;108
                  |L1.28|
00001c  4803              LDR      r0,|L1.44|
00001e  38a8              SUBS     r0,r0,#0xa8           ;108
000020  6800              LDR      r0,[r0,#0]            ;108  ; ds
000022  4288              CMP      r0,r1                 ;108
000024  dcef              BGT      |L1.6|
000026  f04f30ff          MOV      r0,#0xffffffff        ;113
00002a  e7f5              B        |L1.24|
;;;115    
                          ENDP

                  |L1.44|
                          DCD      ||ds||+0xa8

                          AREA ||i.inv_get_mpl_state_size||, CODE, READONLY, ALIGN=2

                  inv_get_mpl_state_size PROC
;;;94     */
;;;95     inv_error_t inv_get_mpl_state_size(size_t *size)
000000  4601              MOV      r1,r0
;;;96     {
;;;97         *size = ds.total_size;
000002  4802              LDR      r0,|L2.12|
000004  6840              LDR      r0,[r0,#4]  ; ds
000006  6008              STR      r0,[r1,#0]
;;;98         return INV_SUCCESS;
000008  2000              MOVS     r0,#0
;;;99     }
00000a  4770              BX       lr
;;;100    
                          ENDP

                  |L2.12|
                          DCD      ||ds||

                          AREA ||i.inv_init_storage_manager||, CODE, READONLY, ALIGN=2

                  inv_init_storage_manager PROC
;;;49     * called first by inv_init_mpl().*/
;;;50     void inv_init_storage_manager()
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52         memset(&ds, 0, sizeof(ds));
000002  f44f71cc          MOV      r1,#0x198
000006  4803              LDR      r0,|L3.20|
000008  f7fffffe          BL       __aeabi_memclr4
;;;53         ds.total_size = sizeof(struct data_header_t);
00000c  200c              MOVS     r0,#0xc
00000e  4901              LDR      r1,|L3.20|
000010  6048              STR      r0,[r1,#4]  ; ds
;;;54     }
000012  bd10              POP      {r4,pc}
;;;55     
                          ENDP

                  |L3.20|
                          DCD      ||ds||

                          AREA ||i.inv_load_mpl_states||, CODE, READONLY, ALIGN=2

                  inv_load_mpl_states PROC
;;;121    */
;;;122    inv_error_t inv_load_mpl_states(const unsigned char *data, size_t length)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;123    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
;;;124        struct data_header_t *hd;
;;;125        int entry;
;;;126        uint32_t checksum;
;;;127        long len;
;;;128    
;;;129        len = length; // Important so we get negative numbers
000008  464d              MOV      r5,r9
;;;130        if (len < sizeof(struct data_header_t))
00000a  2d0c              CMP      r5,#0xc
00000c  d202              BCS      |L4.20|
;;;131            return INV_ERROR_CALIBRATION_LOAD;	// No data
00000e  206b              MOVS     r0,#0x6b
                  |L4.16|
;;;132        hd = (struct data_header_t *)data;
;;;133        if (hd->key != DEFAULT_KEY)
;;;134            return INV_ERROR_CALIBRATION_LOAD;	// Key changed or data corruption
;;;135        len = MIN(hd->size, len);
;;;136        len = hd->size;
;;;137        len -= sizeof(struct data_header_t);
;;;138        data += sizeof(struct data_header_t);
;;;139        checksum = inv_checksum(data, len);
;;;140        if (checksum != hd->checksum)
;;;141            return INV_ERROR_CALIBRATION_LOAD;	// Data corruption
;;;142    
;;;143        while (len > (long)sizeof(struct data_header_t)) {
;;;144            hd = (struct data_header_t *)data;
;;;145            entry = inv_find_entry(hd->key);
;;;146            data += sizeof(struct data_header_t);
;;;147            len -= sizeof(struct data_header_t);
;;;148            if (entry >= 0 && len >= hd->size) {
;;;149                if (hd->size == ds.hd[entry].size) {
;;;150                    checksum = inv_checksum(data, hd->size);
;;;151                    if (checksum == hd->checksum) {
;;;152                        ds.load[entry](data);
;;;153                    } else {
;;;154                        return INV_ERROR_CALIBRATION_LOAD;
;;;155                    }
;;;156                }
;;;157            }
;;;158            len -= hd->size;
;;;159            if (len >= 0)
;;;160                data = data + hd->size;
;;;161        }
;;;162    
;;;163        return INV_SUCCESS;
;;;164    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L4.20|
000014  4634              MOV      r4,r6                 ;132
000016  f24731f1          MOV      r1,#0x73f1            ;133
00001a  68a0              LDR      r0,[r4,#8]            ;133
00001c  4288              CMP      r0,r1                 ;133
00001e  d001              BEQ      |L4.36|
000020  206b              MOVS     r0,#0x6b              ;134
000022  e7f5              B        |L4.16|
                  |L4.36|
000024  6820              LDR      r0,[r4,#0]            ;135
000026  42a8              CMP      r0,r5                 ;135
000028  da01              BGE      |L4.46|
00002a  6820              LDR      r0,[r4,#0]            ;135
00002c  e000              B        |L4.48|
                  |L4.46|
00002e  4628              MOV      r0,r5                 ;135
                  |L4.48|
000030  4605              MOV      r5,r0                 ;135
000032  6825              LDR      r5,[r4,#0]            ;136
000034  3d0c              SUBS     r5,r5,#0xc            ;137
000036  360c              ADDS     r6,r6,#0xc            ;138
000038  4629              MOV      r1,r5                 ;139
00003a  4630              MOV      r0,r6                 ;139
00003c  f7fffffe          BL       inv_checksum
000040  4680              MOV      r8,r0                 ;139
000042  6861              LDR      r1,[r4,#4]            ;140
000044  4541              CMP      r1,r8                 ;140
000046  d001              BEQ      |L4.76|
000048  206b              MOVS     r0,#0x6b              ;141
00004a  e7e1              B        |L4.16|
                  |L4.76|
00004c  e02a              B        |L4.164|
                  |L4.78|
00004e  4634              MOV      r4,r6                 ;144
000050  68a0              LDR      r0,[r4,#8]            ;145
000052  f7fffffe          BL       inv_find_entry
000056  4607              MOV      r7,r0                 ;145
000058  360c              ADDS     r6,r6,#0xc            ;146
00005a  3d0c              SUBS     r5,r5,#0xc            ;147
00005c  2f00              CMP      r7,#0                 ;148
00005e  db1b              BLT      |L4.152|
000060  6820              LDR      r0,[r4,#0]            ;148
000062  42a8              CMP      r0,r5                 ;148
000064  dc18              BGT      |L4.152|
000066  eb070247          ADD      r2,r7,r7,LSL #1       ;149
00006a  4810              LDR      r0,|L4.172|
00006c  f8500022          LDR      r0,[r0,r2,LSL #2]     ;149
000070  6821              LDR      r1,[r4,#0]            ;149
000072  4281              CMP      r1,r0                 ;149
000074  d110              BNE      |L4.152|
000076  4630              MOV      r0,r6                 ;150
000078  6821              LDR      r1,[r4,#0]            ;150
00007a  f7fffffe          BL       inv_checksum
00007e  4680              MOV      r8,r0                 ;150
000080  6860              LDR      r0,[r4,#4]            ;151
000082  4540              CMP      r0,r8                 ;151
000084  d106              BNE      |L4.148|
000086  4809              LDR      r0,|L4.172|
000088  38a0              SUBS     r0,r0,#0xa0           ;152
00008a  f8501027          LDR      r1,[r0,r7,LSL #2]     ;152
00008e  4630              MOV      r0,r6                 ;152
000090  4788              BLX      r1                    ;152
000092  e001              B        |L4.152|
                  |L4.148|
000094  206b              MOVS     r0,#0x6b              ;154
000096  e7bb              B        |L4.16|
                  |L4.152|
000098  6820              LDR      r0,[r4,#0]            ;158
00009a  1a2d              SUBS     r5,r5,r0              ;158
00009c  2d00              CMP      r5,#0                 ;159
00009e  db01              BLT      |L4.164|
0000a0  6820              LDR      r0,[r4,#0]            ;160
0000a2  4406              ADD      r6,r6,r0              ;160
                  |L4.164|
0000a4  2d0c              CMP      r5,#0xc               ;143
0000a6  dcd2              BGT      |L4.78|
0000a8  2000              MOVS     r0,#0                 ;163
0000aa  e7b1              B        |L4.16|
;;;165    
                          ENDP

                  |L4.172|
                          DCD      ||ds||+0xa8

                          AREA ||i.inv_register_load_store||, CODE, READONLY, ALIGN=2

                  inv_register_load_store PROC
;;;65     */
;;;66     inv_error_t inv_register_load_store(inv_error_t (*load_func)(const unsigned char *data),
000000  b570              PUSH     {r4-r6,lr}
;;;67                                         inv_error_t (*save_func)(unsigned char *data), size_t size, unsigned int key)
;;;68     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;69         int kk;
;;;70         // Check if this has been registered already
;;;71         for (kk=0; kk<ds.num; ++kk) {
000006  2100              MOVS     r1,#0
000008  e00a              B        |L5.32|
                  |L5.10|
;;;72             if (key == ds.hd[kk].key) {
00000a  eb010641          ADD      r6,r1,r1,LSL #1
00000e  481f              LDR      r0,|L5.140|
000010  eb000086          ADD      r0,r0,r6,LSL #2
000014  6880              LDR      r0,[r0,#8]
000016  4298              CMP      r0,r3
000018  d101              BNE      |L5.30|
;;;73                 return INV_ERROR_INVALID_PARAMETER;
00001a  2005              MOVS     r0,#5
                  |L5.28|
;;;74             }
;;;75         }
;;;76         // Make sure there is room
;;;77         if (ds.num >= NUM_STORAGE_BOXES) {
;;;78             return INV_ERROR_INVALID_PARAMETER;
;;;79         }
;;;80         // Add to list
;;;81         ds.hd[ds.num].key = key;
;;;82         ds.hd[ds.num].size = size;
;;;83         ds.load[ds.num] = load_func;
;;;84         ds.save[ds.num] = save_func;
;;;85         ds.total_size += size + sizeof(struct data_header_t);
;;;86         ds.num++;
;;;87     
;;;88         return INV_SUCCESS;
;;;89     }
00001c  bd70              POP      {r4-r6,pc}
                  |L5.30|
00001e  1c49              ADDS     r1,r1,#1              ;71
                  |L5.32|
000020  481a              LDR      r0,|L5.140|
000022  38a8              SUBS     r0,r0,#0xa8           ;71
000024  6800              LDR      r0,[r0,#0]            ;71  ; ds
000026  4288              CMP      r0,r1                 ;71
000028  dcef              BGT      |L5.10|
00002a  4818              LDR      r0,|L5.140|
00002c  38a8              SUBS     r0,r0,#0xa8           ;77
00002e  6800              LDR      r0,[r0,#0]            ;77  ; ds
000030  2814              CMP      r0,#0x14              ;77
000032  db01              BLT      |L5.56|
000034  2005              MOVS     r0,#5                 ;78
000036  e7f1              B        |L5.28|
                  |L5.56|
000038  4814              LDR      r0,|L5.140|
00003a  38a8              SUBS     r0,r0,#0xa8           ;81
00003c  6800              LDR      r0,[r0,#0]            ;81  ; ds
00003e  eb000640          ADD      r6,r0,r0,LSL #1       ;81
000042  4812              LDR      r0,|L5.140|
000044  eb000086          ADD      r0,r0,r6,LSL #2       ;81
000048  6083              STR      r3,[r0,#8]            ;81
00004a  4810              LDR      r0,|L5.140|
00004c  38a8              SUBS     r0,r0,#0xa8           ;82
00004e  6800              LDR      r0,[r0,#0]            ;82  ; ds
000050  eb000640          ADD      r6,r0,r0,LSL #1       ;82
000054  480d              LDR      r0,|L5.140|
000056  f8402026          STR      r2,[r0,r6,LSL #2]     ;82
00005a  38a8              SUBS     r0,r0,#0xa8           ;83
00005c  6806              LDR      r6,[r0,#0]            ;83  ; ds
00005e  3008              ADDS     r0,r0,#8              ;83
000060  f8404026          STR      r4,[r0,r6,LSL #2]     ;83
000064  3808              SUBS     r0,r0,#8              ;84
000066  6806              LDR      r6,[r0,#0]            ;84  ; ds
000068  3058              ADDS     r0,r0,#0x58           ;84
00006a  f8405026          STR      r5,[r0,r6,LSL #2]     ;84
00006e  3858              SUBS     r0,r0,#0x58           ;85
000070  6846              LDR      r6,[r0,#4]            ;85  ; ds
000072  f102000c          ADD      r0,r2,#0xc            ;85
000076  4430              ADD      r0,r0,r6              ;85
000078  4e04              LDR      r6,|L5.140|
00007a  3ea8              SUBS     r6,r6,#0xa8           ;85
00007c  6070              STR      r0,[r6,#4]            ;85  ; ds
00007e  4630              MOV      r0,r6                 ;86
000080  6800              LDR      r0,[r0,#0]            ;86  ; ds
000082  1c40              ADDS     r0,r0,#1              ;86
000084  6030              STR      r0,[r6,#0]            ;86  ; ds
000086  2000              MOVS     r0,#0                 ;88
000088  e7c8              B        |L5.28|
;;;90     
                          ENDP

00008a  0000              DCW      0x0000
                  |L5.140|
                          DCD      ||ds||+0xa8

                          AREA ||i.inv_save_mpl_states||, CODE, READONLY, ALIGN=2

                  inv_save_mpl_states PROC
;;;171    */
;;;172    inv_error_t inv_save_mpl_states(unsigned char *data, size_t sz)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;173    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;174        unsigned char *cur;
;;;175        int kk;
;;;176        struct data_header_t *hd;
;;;177    
;;;178        if (sz >= ds.total_size) {
000008  4825              LDR      r0,|L6.160|
00000a  6840              LDR      r0,[r0,#4]  ; ds
00000c  4540              CMP      r0,r8
00000e  d831              BHI      |L6.116|
;;;179            cur = data + sizeof(struct data_header_t);
000010  f106070c          ADD      r7,r6,#0xc
;;;180            for (kk = 0; kk < ds.num; ++kk) {
000014  2500              MOVS     r5,#0
000016  e028              B        |L6.106|
                  |L6.24|
;;;181                hd = (struct data_header_t *)cur;
000018  463c              MOV      r4,r7
;;;182                cur += sizeof(struct data_header_t);
00001a  370c              ADDS     r7,r7,#0xc
;;;183                ds.save[kk](cur);
00001c  4820              LDR      r0,|L6.160|
00001e  3058              ADDS     r0,r0,#0x58
000020  f8501025          LDR      r1,[r0,r5,LSL #2]
000024  4638              MOV      r0,r7
000026  4788              BLX      r1
;;;184                hd->checksum = inv_checksum(cur, ds.hd[kk].size);
000028  eb050245          ADD      r2,r5,r5,LSL #1
00002c  481c              LDR      r0,|L6.160|
00002e  30a8              ADDS     r0,r0,#0xa8
000030  f8501022          LDR      r1,[r0,r2,LSL #2]
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       inv_checksum
00003a  6060              STR      r0,[r4,#4]
;;;185                hd->size = ds.hd[kk].size;
00003c  eb050145          ADD      r1,r5,r5,LSL #1
000040  4817              LDR      r0,|L6.160|
000042  30a8              ADDS     r0,r0,#0xa8
000044  f8500021          LDR      r0,[r0,r1,LSL #2]
000048  6020              STR      r0,[r4,#0]
;;;186                hd->key = ds.hd[kk].key;
00004a  eb050145          ADD      r1,r5,r5,LSL #1
00004e  4814              LDR      r0,|L6.160|
000050  30a8              ADDS     r0,r0,#0xa8
000052  eb000081          ADD      r0,r0,r1,LSL #2
000056  6880              LDR      r0,[r0,#8]
000058  60a0              STR      r0,[r4,#8]
;;;187                cur += ds.hd[kk].size;
00005a  eb050145          ADD      r1,r5,r5,LSL #1
00005e  4810              LDR      r0,|L6.160|
000060  30a8              ADDS     r0,r0,#0xa8
000062  f8500021          LDR      r0,[r0,r1,LSL #2]
000066  4407              ADD      r7,r7,r0
000068  1c6d              ADDS     r5,r5,#1              ;180
                  |L6.106|
00006a  480d              LDR      r0,|L6.160|
00006c  6800              LDR      r0,[r0,#0]            ;180  ; ds
00006e  42a8              CMP      r0,r5                 ;180
000070  dcd2              BGT      |L6.24|
000072  e002              B        |L6.122|
                  |L6.116|
;;;188            }
;;;189        } else {
;;;190            return INV_ERROR_CALIBRATION_LOAD;
000074  206b              MOVS     r0,#0x6b
                  |L6.118|
;;;191        }
;;;192    
;;;193        hd = (struct data_header_t *)data;
;;;194        hd->checksum = inv_checksum(data + sizeof(struct data_header_t),
;;;195                                    ds.total_size - sizeof(struct data_header_t));
;;;196        hd->key = DEFAULT_KEY;
;;;197        hd->size = ds.total_size;
;;;198    
;;;199        return INV_SUCCESS;
;;;200    }
000076  e8bd81f0          POP      {r4-r8,pc}
                  |L6.122|
00007a  4634              MOV      r4,r6                 ;193
00007c  4808              LDR      r0,|L6.160|
00007e  6840              LDR      r0,[r0,#4]            ;194  ; ds
000080  f1a0010c          SUB      r1,r0,#0xc            ;194
000084  f106000c          ADD      r0,r6,#0xc            ;194
000088  f7fffffe          BL       inv_checksum
00008c  6060              STR      r0,[r4,#4]            ;194
00008e  f24730f1          MOV      r0,#0x73f1            ;196
000092  60a0              STR      r0,[r4,#8]            ;196
000094  4802              LDR      r0,|L6.160|
000096  6840              LDR      r0,[r0,#4]            ;197  ; ds
000098  6020              STR      r0,[r4,#0]            ;197
00009a  2000              MOVS     r0,#0                 ;199
00009c  e7eb              B        |L6.118|
;;;201    
                          ENDP

00009e  0000              DCW      0x0000
                  |L6.160|
                          DCD      ||ds||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||ds||
                          %        408
