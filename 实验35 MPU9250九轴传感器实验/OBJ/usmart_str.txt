; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\usmart_str.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\usmart_str.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O0 --diag_suppress=9931 -I..\CORE -I..\OBJ -I..\USER -I..\HALLIB\STM32F7xx_HAL_Driver\Inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\SDRAM -I..\HARDWARE\IIC -I..\HARDWARE\24CXX -I..\HARDWARE\MPU9250 -I..\HARDWARE\DHT11 -I..\HARDWARE\MPU -I..\USMART -I..\DMP\driver\eMPL -I..\DMP\driver\include -I..\DMP\driver\stm32L -I..\DMP\eMPL-hal -I..\DMP\mllite -I..\DMP\mpl -I..\UCOSIII -I..\UCOSIII\UCOS-BSP -I..\UCOSIII\UCOS-CONFIG -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\uC-CPU\ARM-Cortex-M4\RealView -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M4\RealView -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M4\Generic\RealView -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-CPU -I..\HARDWARE\MY_FUNCTION -I..\USER -I..\HARDWARE\CRC -I..\HARDWARE\DMA -I..\HARDWARE\HEART_BEAT -I..\HARDWARE\RECEIVE_ANALYZE -I..\HARDWARE\FEED_BACK -I..\HARDWARE\DATA -I"D:\1111111\32F4\Slam car\实验35 MPU9250九轴传感器实验\USER\RTE" -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0 -IF:\Keil_v5\ARM\CMSIS\Include -IF:\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.7.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__UVISION_VERSION=514 -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DMPL_LOG_NDEBUG=1 -DEMPL -DMPU9250 -DEMPL_TARGET_STM32F4 --omf_browse=..\obj\usmart_str.crf ..\USMART\usmart_str.c]
                          THUMB

                          AREA ||i.usmart_get_aparm||, CODE, READONLY, ALIGN=1

                  usmart_get_aparm PROC
;;;314    //返回值:0,已经无参数了;其他,下一个参数的偏移量.
;;;315    u8 usmart_get_aparm(u8 *str,u8 *fparm,u8 *ptype)
000000  b5f0              PUSH     {r4-r7,lr}
;;;316    {
000002  4603              MOV      r3,r0
000004  4615              MOV      r5,r2
;;;317    	u8 i=0;
000006  2000              MOVS     r0,#0
;;;318    	u8 enout=0;
000008  2200              MOVS     r2,#0
;;;319    	u8 type=0;//默认是数字
00000a  2600              MOVS     r6,#0
;;;320    	u8 string=0; //标记str是否正在读
00000c  2400              MOVS     r4,#0
;;;321    	while(1)
00000e  e05b              B        |L1.200|
                  |L1.16|
;;;322    	{		    
;;;323    		if(*str==','&& string==0)enout=1;			//暂缓立即退出,目的是寻找下一个参数的起始地址
000010  781f              LDRB     r7,[r3,#0]
000012  2f2c              CMP      r7,#0x2c
000014  d101              BNE      |L1.26|
000016  b904              CBNZ     r4,|L1.26|
000018  2201              MOVS     r2,#1
                  |L1.26|
;;;324    		if((*str==')'||*str=='\0')&&string==0)break;//立即退出标识符
00001a  781f              LDRB     r7,[r3,#0]
00001c  2f29              CMP      r7,#0x29
00001e  d001              BEQ      |L1.36|
000020  781f              LDRB     r7,[r3,#0]
000022  b90f              CBNZ     r7,|L1.40|
                  |L1.36|
000024  b904              CBNZ     r4,|L1.40|
000026  e050              B        |L1.202|
                  |L1.40|
;;;325    		if(type==0)//默认是数字的
000028  2e00              CMP      r6,#0
00002a  d13a              BNE      |L1.162|
;;;326    		{
;;;327    			if((*str>='0' && *str<='9')||*str=='-'||*str=='+'||(*str>='a' && *str<='f')||(*str>='A' && *str<='F')||*str=='X'||*str=='x')//数字串检测
00002c  781f              LDRB     r7,[r3,#0]
00002e  2f30              CMP      r7,#0x30
000030  db02              BLT      |L1.56|
000032  781f              LDRB     r7,[r3,#0]
000034  2f39              CMP      r7,#0x39
000036  dd17              BLE      |L1.104|
                  |L1.56|
000038  781f              LDRB     r7,[r3,#0]
00003a  2f2d              CMP      r7,#0x2d
00003c  d014              BEQ      |L1.104|
00003e  781f              LDRB     r7,[r3,#0]
000040  2f2b              CMP      r7,#0x2b
000042  d011              BEQ      |L1.104|
000044  781f              LDRB     r7,[r3,#0]
000046  2f61              CMP      r7,#0x61
000048  db02              BLT      |L1.80|
00004a  781f              LDRB     r7,[r3,#0]
00004c  2f66              CMP      r7,#0x66
00004e  dd0b              BLE      |L1.104|
                  |L1.80|
000050  781f              LDRB     r7,[r3,#0]
000052  2f41              CMP      r7,#0x41
000054  db02              BLT      |L1.92|
000056  781f              LDRB     r7,[r3,#0]
000058  2f46              CMP      r7,#0x46
00005a  dd05              BLE      |L1.104|
                  |L1.92|
00005c  781f              LDRB     r7,[r3,#0]
00005e  2f58              CMP      r7,#0x58
000060  d002              BEQ      |L1.104|
000062  781f              LDRB     r7,[r3,#0]
000064  2f78              CMP      r7,#0x78
000066  d10c              BNE      |L1.130|
                  |L1.104|
;;;328    			{
;;;329    				if(enout)break;					//找到了下一个参数,直接退出.
000068  b102              CBZ      r2,|L1.108|
00006a  e02e              B        |L1.202|
                  |L1.108|
;;;330    				if(*str>='a')*fparm=*str-0X20;	//小写转换为大写
00006c  781f              LDRB     r7,[r3,#0]
00006e  2f61              CMP      r7,#0x61
000070  db03              BLT      |L1.122|
000072  781f              LDRB     r7,[r3,#0]
000074  3f20              SUBS     r7,r7,#0x20
000076  700f              STRB     r7,[r1,#0]
000078  e001              B        |L1.126|
                  |L1.122|
;;;331    				else *fparm=*str;		   		//小写或者数字保持不变
00007a  781f              LDRB     r7,[r3,#0]
00007c  700f              STRB     r7,[r1,#0]
                  |L1.126|
;;;332    				fparm++;
00007e  1c49              ADDS     r1,r1,#1
000080  e01f              B        |L1.194|
                  |L1.130|
;;;333    			}else if(*str=='"')//找到字符串的开始标志
000082  781f              LDRB     r7,[r3,#0]
000084  2f22              CMP      r7,#0x22
000086  d104              BNE      |L1.146|
;;;334    			{
;;;335    				if(enout)break;//找到,后才找到",认为结束了.
000088  b102              CBZ      r2,|L1.140|
00008a  e01e              B        |L1.202|
                  |L1.140|
;;;336    				type=1;
00008c  2601              MOVS     r6,#1
;;;337    				string=1;//登记STRING 正在读了
00008e  2401              MOVS     r4,#1
000090  e017              B        |L1.194|
                  |L1.146|
;;;338    			}else if(*str!=' '&&*str!=',')//发现非法字符,参数错误
000092  781f              LDRB     r7,[r3,#0]
000094  2f20              CMP      r7,#0x20
000096  d014              BEQ      |L1.194|
000098  781f              LDRB     r7,[r3,#0]
00009a  2f2c              CMP      r7,#0x2c
00009c  d011              BEQ      |L1.194|
;;;339    			{
;;;340    				type=0XFF;
00009e  26ff              MOVS     r6,#0xff
;;;341    				break;
0000a0  e013              B        |L1.202|
                  |L1.162|
;;;342    			}
;;;343    		}else//string类
;;;344    		{ 
;;;345    			if(*str=='"')string=0;
0000a2  781f              LDRB     r7,[r3,#0]
0000a4  2f22              CMP      r7,#0x22
0000a6  d100              BNE      |L1.170|
0000a8  2400              MOVS     r4,#0
                  |L1.170|
;;;346    			if(enout)break;			//找到了下一个参数,直接退出.
0000aa  b102              CBZ      r2,|L1.174|
0000ac  e00d              B        |L1.202|
                  |L1.174|
;;;347    			if(string)				//字符串正在读
0000ae  b144              CBZ      r4,|L1.194|
;;;348    			{	
;;;349    				if(*str=='\\')		//遇到转义符(不复制转义符)
0000b0  781f              LDRB     r7,[r3,#0]
0000b2  2f5c              CMP      r7,#0x5c
0000b4  d102              BNE      |L1.188|
;;;350    				{ 
;;;351    					str++;			//偏移到转义符后面的字符,不管什么字符,直接COPY
0000b6  1c5b              ADDS     r3,r3,#1
;;;352    					i++;
0000b8  1c47              ADDS     r7,r0,#1
0000ba  b2f8              UXTB     r0,r7
                  |L1.188|
;;;353    				}					
;;;354    				*fparm=*str;		//小写或者数字保持不变
0000bc  781f              LDRB     r7,[r3,#0]
0000be  700f              STRB     r7,[r1,#0]
;;;355    				fparm++;
0000c0  1c49              ADDS     r1,r1,#1
                  |L1.194|
;;;356    			}	
;;;357    		}
;;;358    		i++;//偏移量增加
0000c2  1c47              ADDS     r7,r0,#1
0000c4  b2f8              UXTB     r0,r7
;;;359    		str++;
0000c6  1c5b              ADDS     r3,r3,#1
                  |L1.200|
0000c8  e7a2              B        |L1.16|
                  |L1.202|
0000ca  bf00              NOP                            ;324
;;;360    	}
;;;361    	*fparm='\0';	//加入结束符
0000cc  2700              MOVS     r7,#0
0000ce  700f              STRB     r7,[r1,#0]
;;;362    	*ptype=type;	//返回参数类型
0000d0  702e              STRB     r6,[r5,#0]
;;;363    	return i;		//返回参数长度
;;;364    }
0000d2  bdf0              POP      {r4-r7,pc}
;;;365    //得到指定参数的起始地址
                          ENDP


                          AREA ||i.usmart_get_cmdname||, CODE, READONLY, ALIGN=1

                  usmart_get_cmdname PROC
;;;177    //返回值:0,成功;其他,失败.	  
;;;178    u8 usmart_get_cmdname(u8*str,u8*cmdname,u8 *nlen,u8 maxlen)
000000  b510              PUSH     {r4,lr}
;;;179    {
000002  4604              MOV      r4,r0
;;;180    	*nlen=0;
000004  2000              MOVS     r0,#0
000006  7010              STRB     r0,[r2,#0]
;;;181     	while(*str!=' '&&*str!='\0') //找到空格或者结束符则认为结束了
000008  e00b              B        |L2.34|
                  |L2.10|
;;;182    	{
;;;183    		*cmdname=*str;
00000a  7820              LDRB     r0,[r4,#0]
00000c  7008              STRB     r0,[r1,#0]
;;;184    		str++;
00000e  1c64              ADDS     r4,r4,#1
;;;185    		cmdname++;
000010  1c49              ADDS     r1,r1,#1
;;;186    		(*nlen)++;//统计命令长度
000012  7810              LDRB     r0,[r2,#0]
000014  1c40              ADDS     r0,r0,#1
000016  7010              STRB     r0,[r2,#0]
;;;187    		if(*nlen>=maxlen)return 1;//错误的指令
000018  7810              LDRB     r0,[r2,#0]
00001a  4298              CMP      r0,r3
00001c  db01              BLT      |L2.34|
00001e  2001              MOVS     r0,#1
                  |L2.32|
;;;188    	}
;;;189    	*cmdname='\0';//加入结束符
;;;190    	return 0;//正常返回
;;;191    }
000020  bd10              POP      {r4,pc}
                  |L2.34|
000022  7820              LDRB     r0,[r4,#0]            ;181
000024  2820              CMP      r0,#0x20              ;181
000026  d002              BEQ      |L2.46|
000028  7820              LDRB     r0,[r4,#0]            ;181
00002a  2800              CMP      r0,#0                 ;181
00002c  d1ed              BNE      |L2.10|
                  |L2.46|
00002e  2000              MOVS     r0,#0                 ;189
000030  7008              STRB     r0,[r1,#0]            ;189
000032  bf00              NOP                            ;190
000034  e7f4              B        |L2.32|
;;;192    //获取下一个字符（当中间有很多空格的时候，此函数直接忽略空格，找到空格之后的第一个字符）
                          ENDP


                          AREA ||i.usmart_get_fname||, CODE, READONLY, ALIGN=2

                  usmart_get_fname PROC
;;;206    //返回值:0,成功;其他,错误代码.
;;;207    u8 usmart_get_fname(u8*str,u8*fname,u8 *pnum,u8 *rval)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;208    {
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
;;;209    	u8 res;
;;;210    	u8 fover=0;	  //括号深度
00000a  2700              MOVS     r7,#0
;;;211    	u8 *strtemp;
;;;212    	u8 offset=0;  
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
;;;213    	u8 parmnum=0;
000010  9003              STR      r0,[sp,#0xc]
;;;214    	u8 temp=1;
000012  2001              MOVS     r0,#1
000014  9002              STR      r0,[sp,#8]
;;;215    	u8 fpname[6];//void+X+'/0'
;;;216    	u8 fplcnt=0; //第一个参数的长度计数器
000016  f04f0b00          MOV      r11,#0
;;;217    	u8 pcnt=0;	 //参数计数器
00001a  2500              MOVS     r5,#0
;;;218    	u8 nchar;
;;;219    	//判断函数是否有返回值
;;;220    	strtemp=str;
00001c  4644              MOV      r4,r8
;;;221    	while(*strtemp!='\0')//没有结束
00001e  e01d              B        |L3.92|
                  |L3.32|
;;;222    	{
;;;223    		if(*strtemp!=' '&&(pcnt&0X7F)<5)//最多记录5个字符
000020  7820              LDRB     r0,[r4,#0]
000022  2820              CMP      r0,#0x20
000024  d016              BEQ      |L3.84|
000026  f005007f          AND      r0,r5,#0x7f
00002a  2805              CMP      r0,#5
00002c  da12              BGE      |L3.84|
;;;224    		{	
;;;225    			if(pcnt==0)pcnt|=0X80;//置位最高位,标记开始接收返回值类型
00002e  b90d              CBNZ     r5,|L3.52|
000030  f0450580          ORR      r5,r5,#0x80
                  |L3.52|
;;;226    			if(((pcnt&0x7f)==4)&&(*strtemp!='*'))break;//最后一个字符,必须是*
000034  f005007f          AND      r0,r5,#0x7f
000038  2804              CMP      r0,#4
00003a  d103              BNE      |L3.68|
00003c  7820              LDRB     r0,[r4,#0]
00003e  282a              CMP      r0,#0x2a
000040  d000              BEQ      |L3.68|
000042  e00e              B        |L3.98|
                  |L3.68|
;;;227    			fpname[pcnt&0x7f]=*strtemp;//记录函数的返回值类型
000044  7820              LDRB     r0,[r4,#0]
000046  f005017f          AND      r1,r5,#0x7f
00004a  f80d0001          STRB     r0,[sp,r1]
;;;228    			pcnt++;
00004e  1c68              ADDS     r0,r5,#1
000050  b2c5              UXTB     r5,r0
000052  e002              B        |L3.90|
                  |L3.84|
;;;229    		}else if(pcnt==0X85)break;
000054  2d85              CMP      r5,#0x85
000056  d100              BNE      |L3.90|
000058  e003              B        |L3.98|
                  |L3.90|
;;;230    		strtemp++; 
00005a  1c64              ADDS     r4,r4,#1
                  |L3.92|
00005c  7820              LDRB     r0,[r4,#0]            ;221
00005e  2800              CMP      r0,#0                 ;221
000060  d1de              BNE      |L3.32|
                  |L3.98|
000062  bf00              NOP                            ;226
;;;231    	} 
;;;232    	if(pcnt)//接收完了
000064  b18d              CBZ      r5,|L3.138|
;;;233    	{
;;;234    		fpname[pcnt&0x7f]='\0';//加入结束符
000066  2000              MOVS     r0,#0
000068  f005017f          AND      r1,r5,#0x7f
00006c  f80d0001          STRB     r0,[sp,r1]
;;;235    		if(usmart_strcmp(fpname,"void")==0)*rval=0;//不需要返回值
000070  a151              ADR      r1,|L3.440|
000072  4668              MOV      r0,sp
000074  f7fffffe          BL       usmart_strcmp
000078  b918              CBNZ     r0,|L3.130|
00007a  2100              MOVS     r1,#0
00007c  9808              LDR      r0,[sp,#0x20]
00007e  7001              STRB     r1,[r0,#0]
000080  e002              B        |L3.136|
                  |L3.130|
;;;236    		else *rval=1;							   //需要返回值
000082  2101              MOVS     r1,#1
000084  9808              LDR      r0,[sp,#0x20]
000086  7001              STRB     r1,[r0,#0]
                  |L3.136|
;;;237    		pcnt=0;
000088  2500              MOVS     r5,#0
                  |L3.138|
;;;238    	} 
;;;239    	res=0;
00008a  f04f0a00          MOV      r10,#0
;;;240    	strtemp=str;
00008e  4644              MOV      r4,r8
;;;241    	while(*strtemp!='('&&*strtemp!='\0') //此代码找到函数名的真正起始位置
000090  e014              B        |L3.188|
                  |L3.146|
;;;242    	{  
;;;243    		strtemp++;
000092  1c64              ADDS     r4,r4,#1
;;;244    		res++;
000094  f10a0001          ADD      r0,r10,#1
000098  f0000aff          AND      r10,r0,#0xff
;;;245    		if(*strtemp==' '||*strtemp=='*')
00009c  7820              LDRB     r0,[r4,#0]
00009e  2820              CMP      r0,#0x20
0000a0  d002              BEQ      |L3.168|
0000a2  7820              LDRB     r0,[r4,#0]
0000a4  282a              CMP      r0,#0x2a
0000a6  d109              BNE      |L3.188|
                  |L3.168|
;;;246    		{
;;;247    			nchar=usmart_search_nextc(strtemp);		//获取下一个字符
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       usmart_search_nextc
0000ae  4606              MOV      r6,r0
;;;248    			if(nchar!='('&&nchar!='*')offset=res;	//跳过空格和*号
0000b0  2e28              CMP      r6,#0x28
0000b2  d003              BEQ      |L3.188|
0000b4  2e2a              CMP      r6,#0x2a
0000b6  d001              BEQ      |L3.188|
0000b8  f8cda010          STR      r10,[sp,#0x10]
                  |L3.188|
0000bc  7820              LDRB     r0,[r4,#0]            ;241
0000be  2828              CMP      r0,#0x28              ;241
0000c0  d002              BEQ      |L3.200|
0000c2  7820              LDRB     r0,[r4,#0]            ;241
0000c4  2800              CMP      r0,#0                 ;241
0000c6  d1e4              BNE      |L3.146|
                  |L3.200|
;;;249    		}
;;;250    	}	 
;;;251    	strtemp=str;
0000c8  4644              MOV      r4,r8
;;;252    	if(offset)strtemp+=offset+1;//跳到函数名开始的地方	   
0000ca  9804              LDR      r0,[sp,#0x10]
0000cc  b110              CBZ      r0,|L3.212|
0000ce  9804              LDR      r0,[sp,#0x10]
0000d0  1c40              ADDS     r0,r0,#1
0000d2  4404              ADD      r4,r4,r0
                  |L3.212|
;;;253    	res=0;
0000d4  f04f0a00          MOV      r10,#0
;;;254    	nchar=0;//是否正在字符串里面的标志,0，不在字符串;1，在字符串;
0000d8  2600              MOVS     r6,#0
;;;255    	while(1)
0000da  e054              B        |L3.390|
                  |L3.220|
;;;256    	{
;;;257    		if(*strtemp==0)
0000dc  7820              LDRB     r0,[r4,#0]
0000de  b910              CBNZ     r0,|L3.230|
;;;258    		{
;;;259    			res=USMART_FUNCERR;//函数错误
0000e0  f04f0a01          MOV      r10,#1
;;;260    			break;
0000e4  e050              B        |L3.392|
                  |L3.230|
;;;261    		}else if(*strtemp=='('&&nchar==0)fover++;//括号深度增加一级	 
0000e6  7820              LDRB     r0,[r4,#0]
0000e8  2828              CMP      r0,#0x28
0000ea  d103              BNE      |L3.244|
0000ec  b916              CBNZ     r6,|L3.244|
0000ee  1c78              ADDS     r0,r7,#1
0000f0  b2c7              UXTB     r7,r0
0000f2  e013              B        |L3.284|
                  |L3.244|
;;;262    		else if(*strtemp==')'&&nchar==0)
0000f4  7820              LDRB     r0,[r4,#0]
0000f6  2829              CMP      r0,#0x29
0000f8  d108              BNE      |L3.268|
0000fa  b93e              CBNZ     r6,|L3.268|
;;;263    		{
;;;264    			if(fover)fover--;
0000fc  b117              CBZ      r7,|L3.260|
0000fe  1e78              SUBS     r0,r7,#1
000100  b2c7              UXTB     r7,r0
000102  e001              B        |L3.264|
                  |L3.260|
;;;265    			else res=USMART_FUNCERR;//错误结束,没收到'('
000104  f04f0a01          MOV      r10,#1
                  |L3.264|
;;;266    			if(fover==0)break;//到末尾了,退出	    
000108  b947              CBNZ     r7,|L3.284|
00010a  e03d              B        |L3.392|
                  |L3.268|
;;;267    		}else if(*strtemp=='"')nchar=!nchar;
00010c  7820              LDRB     r0,[r4,#0]
00010e  2822              CMP      r0,#0x22
000110  d104              BNE      |L3.284|
000112  b90e              CBNZ     r6,|L3.280|
000114  2001              MOVS     r0,#1
000116  e000              B        |L3.282|
                  |L3.280|
000118  2000              MOVS     r0,#0
                  |L3.282|
00011a  4606              MOV      r6,r0
                  |L3.284|
;;;268    
;;;269    		if(fover==0)//函数名还没接收完
00011c  b947              CBNZ     r7,|L3.304|
;;;270    		{
;;;271    			if(*strtemp!=' ')//空格不属于函数名
00011e  7820              LDRB     r0,[r4,#0]
000120  2820              CMP      r0,#0x20
000122  d02f              BEQ      |L3.388|
;;;272    			{
;;;273    				*fname=*strtemp;//得到函数名
000124  7820              LDRB     r0,[r4,#0]
000126  f8890000          STRB     r0,[r9,#0]
;;;274    				fname++;
00012a  f1090901          ADD      r9,r9,#1
00012e  e029              B        |L3.388|
                  |L3.304|
;;;275    			}
;;;276    		}else //已经接受完了函数名了.
;;;277    		{
;;;278    			if(*strtemp==',')
000130  7820              LDRB     r0,[r4,#0]
000132  282c              CMP      r0,#0x2c
000134  d104              BNE      |L3.320|
;;;279    			{
;;;280    				temp=1;		//使能增加一个参数
000136  2001              MOVS     r0,#1
000138  9002              STR      r0,[sp,#8]
;;;281    				pcnt++;	
00013a  1c68              ADDS     r0,r5,#1
00013c  b2c5              UXTB     r5,r0
00013e  e014              B        |L3.362|
                  |L3.320|
;;;282    			}else if(*strtemp!=' '&&*strtemp!='(')
000140  7820              LDRB     r0,[r4,#0]
000142  2820              CMP      r0,#0x20
000144  d011              BEQ      |L3.362|
000146  7820              LDRB     r0,[r4,#0]
000148  2828              CMP      r0,#0x28
00014a  d00e              BEQ      |L3.362|
;;;283    			{
;;;284    				if(pcnt==0&&fplcnt<5)		//当第一个参数来时,为了避免统计void类型的参数,必须做判断.
00014c  b94d              CBNZ     r5,|L3.354|
00014e  f1bb0f05          CMP      r11,#5
000152  da06              BGE      |L3.354|
;;;285    				{
;;;286    					fpname[fplcnt]=*strtemp;//记录参数特征.
000154  7820              LDRB     r0,[r4,#0]
000156  f80d000b          STRB     r0,[sp,r11]
;;;287    					fplcnt++;
00015a  f10b0001          ADD      r0,r11,#1
00015e  f0000bff          AND      r11,r0,#0xff
                  |L3.354|
;;;288    				}
;;;289    				temp++;	//得到有效参数(非空格)
000162  9802              LDR      r0,[sp,#8]
000164  1c40              ADDS     r0,r0,#1
000166  b2c0              UXTB     r0,r0
000168  9002              STR      r0,[sp,#8]
                  |L3.362|
;;;290    			}
;;;291    			if(fover==1&&temp==2)
00016a  2f01              CMP      r7,#1
00016c  d10a              BNE      |L3.388|
00016e  9802              LDR      r0,[sp,#8]
000170  2802              CMP      r0,#2
000172  d107              BNE      |L3.388|
;;;292    			{
;;;293    				temp++;		//防止重复增加
000174  9802              LDR      r0,[sp,#8]
000176  1c40              ADDS     r0,r0,#1
000178  b2c0              UXTB     r0,r0
00017a  9002              STR      r0,[sp,#8]
;;;294    				parmnum++; 	//参数增加一个
00017c  9803              LDR      r0,[sp,#0xc]
00017e  1c40              ADDS     r0,r0,#1
000180  b2c0              UXTB     r0,r0
000182  9003              STR      r0,[sp,#0xc]
                  |L3.388|
;;;295    			}
;;;296    		}
;;;297    		strtemp++; 			
000184  1c64              ADDS     r4,r4,#1
                  |L3.390|
000186  e7a9              B        |L3.220|
                  |L3.392|
000188  bf00              NOP                            ;260
;;;298    	}   
;;;299    	if(parmnum==1)//只有1个参数.
00018a  9803              LDR      r0,[sp,#0xc]
00018c  2801              CMP      r0,#1
00018e  d109              BNE      |L3.420|
;;;300    	{
;;;301    		fpname[fplcnt]='\0';//加入结束符
000190  2000              MOVS     r0,#0
000192  f80d000b          STRB     r0,[sp,r11]
;;;302    		if(usmart_strcmp(fpname,"void")==0)parmnum=0;//参数为void,表示没有参数.
000196  a108              ADR      r1,|L3.440|
000198  4668              MOV      r0,sp
00019a  f7fffffe          BL       usmart_strcmp
00019e  b908              CBNZ     r0,|L3.420|
0001a0  2000              MOVS     r0,#0
0001a2  9003              STR      r0,[sp,#0xc]
                  |L3.420|
;;;303    	}
;;;304    	*pnum=parmnum;	//记录参数个数
0001a4  9907              LDR      r1,[sp,#0x1c]
0001a6  9803              LDR      r0,[sp,#0xc]
0001a8  7008              STRB     r0,[r1,#0]
;;;305    	*fname='\0';	//加入结束符
0001aa  2000              MOVS     r0,#0
0001ac  f8890000          STRB     r0,[r9,#0]
;;;306    	return res;		//返回执行结果
0001b0  4650              MOV      r0,r10
;;;307    }
0001b2  b009              ADD      sp,sp,#0x24
0001b4  e8bd8ff0          POP      {r4-r11,pc}
;;;308    
                          ENDP

                  |L3.440|
0001b8  766f6964          DCB      "void",0
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0

                          AREA ||i.usmart_get_fparam||, CODE, READONLY, ALIGN=2

                  usmart_get_fparam PROC
;;;378    //返回值:0,成功;其他,错误代码.
;;;379    u8 usmart_get_fparam(u8*str,u8 *parn)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;380    {	
000004  b0b5              SUB      sp,sp,#0xd4
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;381    	u8 i,type;  
;;;382    	u32 res;
;;;383    	u8 n=0;
00000a  2400              MOVS     r4,#0
;;;384    	u8 len;
;;;385    	u8 tstr[PARM_LEN+1];//字节长度的缓存,最多可以存放PARM_LEN个字符的字符串
;;;386    	for(i=0;i<MAX_PARM;i++)usmart_dev.plentbl[i]=0;//清空参数长度表
00000c  2600              MOVS     r6,#0
00000e  e004              B        |L4.26|
                  |L4.16|
000010  2100              MOVS     r1,#0
000012  483d              LDR      r0,|L4.264|
000014  5581              STRB     r1,[r0,r6]
000016  1c70              ADDS     r0,r6,#1
000018  b2c6              UXTB     r6,r0
                  |L4.26|
00001a  2e0a              CMP      r6,#0xa
00001c  dbf8              BLT      |L4.16|
;;;387    	while(*str!='(')//偏移到参数开始的地方
00001e  e006              B        |L4.46|
                  |L4.32|
;;;388    	{
;;;389    		str++;											    
000020  1c6d              ADDS     r5,r5,#1
;;;390    		if(*str=='\0')return USMART_FUNCERR;//遇到结束符了
000022  7828              LDRB     r0,[r5,#0]
000024  b918              CBNZ     r0,|L4.46|
000026  2001              MOVS     r0,#1
                  |L4.40|
;;;391    	}
;;;392    	str++;//偏移到"("之后的第一个字节
;;;393    	while(1)
;;;394    	{
;;;395    		i=usmart_get_aparm(str,tstr,&type);	//得到第一个参数  
;;;396    		str+=i;								//偏移
;;;397    		switch(type)
;;;398    		{
;;;399    			case 0:	//数字
;;;400    				if(tstr[0]!='\0')				//接收到的参数有效
;;;401    				{					    
;;;402    					i=usmart_str2num(tstr,&res);	//记录该参数	 
;;;403    					if(i)return USMART_PARMERR;		//参数错误.
;;;404    					*(u32*)(usmart_dev.parm+usmart_get_parmpos(n))=res;//记录转换成功的结果.
;;;405    					usmart_dev.parmtype&=~(1<<n);	//标记数字
;;;406    					usmart_dev.plentbl[n]=4;		//该参数的长度为4  
;;;407    					n++;							//参数增加  
;;;408    					if(n>MAX_PARM)return USMART_PARMOVER;//参数太多
;;;409    				}
;;;410    				break;
;;;411    			case 1://字符串	 	
;;;412    				len=usmart_strlen(tstr)+1;	//包含了结束符'\0'
;;;413    				usmart_strcopy(tstr,&usmart_dev.parm[usmart_get_parmpos(n)]);//拷贝tstr数据到usmart_dev.parm[n]
;;;414    				usmart_dev.parmtype|=1<<n;	//标记字符串 
;;;415    				usmart_dev.plentbl[n]=len;	//该参数的长度为len  
;;;416    				n++;
;;;417    				if(n>MAX_PARM)return USMART_PARMOVER;//参数太多
;;;418    				break;
;;;419    			case 0XFF://错误
;;;420    				return USMART_PARMERR;//参数错误	  
;;;421    		}
;;;422    		if(*str==')'||*str=='\0')break;//查到结束标志了.
;;;423    	}
;;;424    	*parn=n;	//记录参数的个数
;;;425    	return USMART_OK;//正确得到了参数
;;;426    }
000028  b035              ADD      sp,sp,#0xd4
00002a  e8bd83f0          POP      {r4-r9,pc}
                  |L4.46|
00002e  7828              LDRB     r0,[r5,#0]            ;387
000030  2828              CMP      r0,#0x28              ;387
000032  d1f5              BNE      |L4.32|
000034  1c6d              ADDS     r5,r5,#1              ;392
000036  e061              B        |L4.252|
                  |L4.56|
000038  aa34              ADD      r2,sp,#0xd0           ;395
00003a  4669              MOV      r1,sp                 ;395
00003c  4628              MOV      r0,r5                 ;395
00003e  f7fffffe          BL       usmart_get_aparm
000042  4606              MOV      r6,r0                 ;395
000044  4435              ADD      r5,r5,r6              ;396
000046  f89d00d0          LDRB     r0,[sp,#0xd0]         ;397
00004a  b120              CBZ      r0,|L4.86|
00004c  2801              CMP      r0,#1                 ;397
00004e  d027              BEQ      |L4.160|
000050  28ff              CMP      r0,#0xff              ;397
000052  d14c              BNE      |L4.238|
000054  e049              B        |L4.234|
                  |L4.86|
000056  f89d0000          LDRB     r0,[sp,#0]            ;400
00005a  b300              CBZ      r0,|L4.158|
00005c  a933              ADD      r1,sp,#0xcc           ;402
00005e  4668              MOV      r0,sp                 ;402
000060  f7fffffe          BL       usmart_str2num
000064  4606              MOV      r6,r0                 ;402
000066  b10e              CBZ      r6,|L4.108|
000068  2002              MOVS     r0,#2                 ;403
00006a  e7dd              B        |L4.40|
                  |L4.108|
00006c  4620              MOV      r0,r4                 ;404
00006e  f7fffffe          BL       usmart_get_parmpos
000072  4925              LDR      r1,|L4.264|
000074  310a              ADDS     r1,r1,#0xa            ;404
000076  9a33              LDR      r2,[sp,#0xcc]         ;404
000078  500a              STR      r2,[r1,r0]            ;404
00007a  f1a10024          SUB      r0,r1,#0x24           ;405
00007e  8b00              LDRH     r0,[r0,#0x18]         ;405  ; usmart_dev
000080  2101              MOVS     r1,#1                 ;405
000082  40a1              LSLS     r1,r1,r4              ;405
000084  4388              BICS     r0,r0,r1              ;405
000086  4920              LDR      r1,|L4.264|
000088  391a              SUBS     r1,r1,#0x1a           ;405
00008a  8308              STRH     r0,[r1,#0x18]         ;405
00008c  2104              MOVS     r1,#4                 ;406
00008e  481e              LDR      r0,|L4.264|
000090  5501              STRB     r1,[r0,r4]            ;406
000092  1c60              ADDS     r0,r4,#1              ;407
000094  b2c4              UXTB     r4,r0                 ;407
000096  2c0a              CMP      r4,#0xa               ;408
000098  dd01              BLE      |L4.158|
00009a  2003              MOVS     r0,#3                 ;408
00009c  e7c4              B        |L4.40|
                  |L4.158|
00009e  e026              B        |L4.238|
                  |L4.160|
0000a0  4668              MOV      r0,sp                 ;412
0000a2  f7fffffe          BL       usmart_strlen
0000a6  1c40              ADDS     r0,r0,#1              ;412
0000a8  f00008ff          AND      r8,r0,#0xff           ;412
0000ac  4620              MOV      r0,r4                 ;413
0000ae  f7fffffe          BL       usmart_get_parmpos
0000b2  4915              LDR      r1,|L4.264|
0000b4  310a              ADDS     r1,r1,#0xa            ;413
0000b6  eb000901          ADD      r9,r0,r1              ;413
0000ba  4649              MOV      r1,r9                 ;413
0000bc  4668              MOV      r0,sp                 ;413
0000be  f7fffffe          BL       usmart_strcopy
0000c2  4811              LDR      r0,|L4.264|
0000c4  381a              SUBS     r0,r0,#0x1a           ;414
0000c6  8b01              LDRH     r1,[r0,#0x18]         ;414  ; usmart_dev
0000c8  2001              MOVS     r0,#1                 ;414
0000ca  40a0              LSLS     r0,r0,r4              ;414
0000cc  4301              ORRS     r1,r1,r0              ;414
0000ce  b288              UXTH     r0,r1                 ;414
0000d0  490d              LDR      r1,|L4.264|
0000d2  391a              SUBS     r1,r1,#0x1a           ;414
0000d4  8308              STRH     r0,[r1,#0x18]         ;414
0000d6  480c              LDR      r0,|L4.264|
0000d8  f8008004          STRB     r8,[r0,r4]            ;415
0000dc  1c60              ADDS     r0,r4,#1              ;416
0000de  b2c4              UXTB     r4,r0                 ;416
0000e0  2c0a              CMP      r4,#0xa               ;417
0000e2  dd01              BLE      |L4.232|
0000e4  2003              MOVS     r0,#3                 ;417
0000e6  e79f              B        |L4.40|
                  |L4.232|
0000e8  e001              B        |L4.238|
                  |L4.234|
0000ea  2002              MOVS     r0,#2                 ;420
0000ec  e79c              B        |L4.40|
                  |L4.238|
0000ee  bf00              NOP                            ;410
0000f0  7828              LDRB     r0,[r5,#0]            ;422
0000f2  2829              CMP      r0,#0x29              ;422
0000f4  d001              BEQ      |L4.250|
0000f6  7828              LDRB     r0,[r5,#0]            ;422
0000f8  b900              CBNZ     r0,|L4.252|
                  |L4.250|
0000fa  e000              B        |L4.254|
                  |L4.252|
0000fc  e79c              B        |L4.56|
                  |L4.254|
0000fe  bf00              NOP                            ;422
000100  703c              STRB     r4,[r7,#0]            ;424
000102  2000              MOVS     r0,#0                 ;425
000104  e790              B        |L4.40|
;;;427    
                          ENDP

000106  0000              DCW      0x0000
                  |L4.264|
                          DCD      usmart_dev+0x1a

                          AREA ||i.usmart_get_parmpos||, CODE, READONLY, ALIGN=2

                  usmart_get_parmpos PROC
;;;367    //返回值:该参数的起始地址
;;;368    u8 usmart_get_parmpos(u8 num)
000000  4602              MOV      r2,r0
;;;369    {
;;;370    	u8 temp=0;
000002  2000              MOVS     r0,#0
;;;371    	u8 i;
;;;372    	for(i=0;i<num;i++)temp+=usmart_dev.plentbl[i];
000004  2100              MOVS     r1,#0
000006  e005              B        |L5.20|
                  |L5.8|
000008  4b04              LDR      r3,|L5.28|
00000a  5c5b              LDRB     r3,[r3,r1]
00000c  4403              ADD      r3,r3,r0
00000e  b2d8              UXTB     r0,r3
000010  1c4b              ADDS     r3,r1,#1
000012  b2d9              UXTB     r1,r3
                  |L5.20|
000014  4291              CMP      r1,r2
000016  dbf7              BLT      |L5.8|
;;;373    	return temp;
;;;374    }
000018  4770              BX       lr
;;;375    //从str中得到函数参数
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      usmart_dev+0x1a

                          AREA ||i.usmart_pow||, CODE, READONLY, ALIGN=1

                  usmart_pow PROC
;;;110    //返回值:m^n次方
;;;111    u32 usmart_pow(u8 m,u8 n)
000000  b510              PUSH     {r4,lr}
;;;112    {
000002  4602              MOV      r2,r0
;;;113    	u32 result=1;	 
000004  2001              MOVS     r0,#1
;;;114    	while(n--)result*=m;    
000006  e000              B        |L6.10|
                  |L6.8|
000008  4350              MULS     r0,r2,r0
                  |L6.10|
00000a  000b              MOVS     r3,r1
00000c  f1a10401          SUB      r4,r1,#1
000010  b2e1              UXTB     r1,r4
000012  d1f9              BNE      |L6.8|
;;;115    	return result;
;;;116    }	    
000014  bd10              POP      {r4,pc}
;;;117    //把字符串转为数字
                          ENDP


                          AREA ||i.usmart_search_nextc||, CODE, READONLY, ALIGN=1

                  usmart_search_nextc PROC
;;;194    //返回值:下一个字符
;;;195    u8 usmart_search_nextc(u8* str)
000000  4601              MOV      r1,r0
;;;196    {		   	 	
;;;197    	str++;
000002  1c49              ADDS     r1,r1,#1
;;;198    	while(*str==' '&&str!='\0')str++;
000004  e000              B        |L7.8|
                  |L7.6|
000006  1c49              ADDS     r1,r1,#1
                  |L7.8|
000008  7808              LDRB     r0,[r1,#0]
00000a  2820              CMP      r0,#0x20
00000c  d101              BNE      |L7.18|
00000e  2900              CMP      r1,#0
000010  d1f9              BNE      |L7.6|
                  |L7.18|
;;;199    	return *str;
000012  7808              LDRB     r0,[r1,#0]
;;;200    } 
000014  4770              BX       lr
;;;201    //从str中得到函数名
                          ENDP


                          AREA ||i.usmart_str2num||, CODE, READONLY, ALIGN=1

                  usmart_str2num PROC
;;;123    //1,数据格式错误.2,16进制位数为0.3,起始格式错误.4,十进制位数为0.
;;;124    u8 usmart_str2num(u8*str,u32 *res)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;125    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;126    	u32 t;
;;;127    	int tnum;
;;;128    	u8 bnum=0;		//数字的位数
000008  2600              MOVS     r6,#0
;;;129    	u8 *p;		  
;;;130    	u8 hexdec=10;	//默认为十进制数据
00000a  f04f090a          MOV      r9,#0xa
;;;131    	u8 flag=0;		//0,没有符号标记;1,表示正数;2,表示负数.
00000e  46b3              MOV      r11,r6
;;;132    	p=str;
000010  462c              MOV      r4,r5
;;;133    	*res=0;//清零.
000012  2000              MOVS     r0,#0
000014  6038              STR      r0,[r7,#0]
;;;134    	while(1)
000016  e034              B        |L8.130|
                  |L8.24|
;;;135    	{
;;;136    		if((*p<='9'&&*p>='0')||((*str=='-'||*str=='+')&&bnum==0)||(*p<='F'&&*p>='A')||(*p=='X'&&bnum==1))//参数合法
000018  7820              LDRB     r0,[r4,#0]
00001a  2839              CMP      r0,#0x39
00001c  dc02              BGT      |L8.36|
00001e  7820              LDRB     r0,[r4,#0]
000020  2830              CMP      r0,#0x30
000022  da11              BGE      |L8.72|
                  |L8.36|
000024  7828              LDRB     r0,[r5,#0]
000026  282d              CMP      r0,#0x2d
000028  d002              BEQ      |L8.48|
00002a  7828              LDRB     r0,[r5,#0]
00002c  282b              CMP      r0,#0x2b
00002e  d100              BNE      |L8.50|
                  |L8.48|
000030  b156              CBZ      r6,|L8.72|
                  |L8.50|
000032  7820              LDRB     r0,[r4,#0]
000034  2846              CMP      r0,#0x46
000036  dc02              BGT      |L8.62|
000038  7820              LDRB     r0,[r4,#0]
00003a  2841              CMP      r0,#0x41
00003c  da04              BGE      |L8.72|
                  |L8.62|
00003e  7820              LDRB     r0,[r4,#0]
000040  2858              CMP      r0,#0x58
000042  d117              BNE      |L8.116|
000044  2e01              CMP      r6,#1
000046  d115              BNE      |L8.116|
                  |L8.72|
;;;137    		{
;;;138    			if(*p>='A')hexdec=16;	//字符串中存在字母,为16进制格式.
000048  7820              LDRB     r0,[r4,#0]
00004a  2841              CMP      r0,#0x41
00004c  db01              BLT      |L8.82|
00004e  f04f0910          MOV      r9,#0x10
                  |L8.82|
;;;139    			if(*str=='-'){flag=2;str+=1;}//偏移掉符号
000052  7828              LDRB     r0,[r5,#0]
000054  282d              CMP      r0,#0x2d
000056  d103              BNE      |L8.96|
000058  f04f0b02          MOV      r11,#2
00005c  1c6d              ADDS     r5,r5,#1
00005e  e00f              B        |L8.128|
                  |L8.96|
;;;140    			else if(*str=='+'){flag=1;str+=1;}//偏移掉符号
000060  7828              LDRB     r0,[r5,#0]
000062  282b              CMP      r0,#0x2b
000064  d103              BNE      |L8.110|
000066  f04f0b01          MOV      r11,#1
00006a  1c6d              ADDS     r5,r5,#1
00006c  e008              B        |L8.128|
                  |L8.110|
;;;141    			else bnum++;			//位数增加.
00006e  1c70              ADDS     r0,r6,#1
000070  b2c6              UXTB     r6,r0
000072  e005              B        |L8.128|
                  |L8.116|
;;;142    		}else if(*p=='\0')break;	//碰到结束符,退出.
000074  7820              LDRB     r0,[r4,#0]
000076  b900              CBNZ     r0,|L8.122|
000078  e004              B        |L8.132|
                  |L8.122|
;;;143    		else return 1;				//不全是十进制或者16进制数据.
00007a  2001              MOVS     r0,#1
                  |L8.124|
;;;144    		p++; 
;;;145    	} 
;;;146    	p=str;			    //重新定位到字符串开始的地址.
;;;147    	if(hexdec==16)		//16进制数据
;;;148    	{
;;;149    		if(bnum<3)return 2;			//位数小于3，直接退出.因为0X就占了2个,如果0X后面不跟数据,则该数据非法.
;;;150    		if(*p=='0' && (*(p+1)=='X'))//必须以'0X'开头.
;;;151    		{
;;;152    			p+=2;	//偏移到数据起始地址.
;;;153    			bnum-=2;//减去偏移量	 
;;;154    		}else return 3;//起始头的格式不对
;;;155    	}else if(bnum==0)return 4;//位数为0，直接退出.	  
;;;156    	while(1)
;;;157    	{
;;;158    		if(bnum)bnum--;
;;;159    		if(*p<='9'&&*p>='0')t=*p-'0';	//得到数字的值
;;;160    		else t=*p-'A'+10;				//得到A~F对应的值	    
;;;161    		*res+=t*usmart_pow(hexdec,bnum);		   
;;;162    		p++;
;;;163    		if(*p=='\0')break;//数据都查完了.	
;;;164    	}
;;;165    	if(flag==2)//是负数?
;;;166    	{	
;;;167    		tnum=-*res; 
;;;168    		*res=tnum;
;;;169    	}
;;;170    	return 0;//成功转换
;;;171    }
00007c  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.128|
000080  1c64              ADDS     r4,r4,#1              ;144
                  |L8.130|
000082  e7c9              B        |L8.24|
                  |L8.132|
000084  bf00              NOP                            ;142
000086  462c              MOV      r4,r5                 ;146
000088  f1b90f10          CMP      r9,#0x10              ;147
00008c  d10f              BNE      |L8.174|
00008e  2e03              CMP      r6,#3                 ;149
000090  da01              BGE      |L8.150|
000092  2002              MOVS     r0,#2                 ;149
000094  e7f2              B        |L8.124|
                  |L8.150|
000096  7820              LDRB     r0,[r4,#0]            ;150
000098  2830              CMP      r0,#0x30              ;150
00009a  d106              BNE      |L8.170|
00009c  7860              LDRB     r0,[r4,#1]            ;150
00009e  2858              CMP      r0,#0x58              ;150
0000a0  d103              BNE      |L8.170|
0000a2  1ca4              ADDS     r4,r4,#2              ;152
0000a4  1eb0              SUBS     r0,r6,#2              ;153
0000a6  b2c6              UXTB     r6,r0                 ;153
0000a8  e004              B        |L8.180|
                  |L8.170|
0000aa  2003              MOVS     r0,#3                 ;154
0000ac  e7e6              B        |L8.124|
                  |L8.174|
0000ae  b90e              CBNZ     r6,|L8.180|
0000b0  2004              MOVS     r0,#4                 ;155
0000b2  e7e3              B        |L8.124|
                  |L8.180|
0000b4  e01b              B        |L8.238|
                  |L8.182|
0000b6  b10e              CBZ      r6,|L8.188|
0000b8  1e70              SUBS     r0,r6,#1              ;158
0000ba  b2c6              UXTB     r6,r0                 ;158
                  |L8.188|
0000bc  7820              LDRB     r0,[r4,#0]            ;159
0000be  2839              CMP      r0,#0x39              ;159
0000c0  dc06              BGT      |L8.208|
0000c2  7820              LDRB     r0,[r4,#0]            ;159
0000c4  2830              CMP      r0,#0x30              ;159
0000c6  db03              BLT      |L8.208|
0000c8  7820              LDRB     r0,[r4,#0]            ;159
0000ca  f1a00a30          SUB      r10,r0,#0x30          ;159
0000ce  e002              B        |L8.214|
                  |L8.208|
0000d0  7820              LDRB     r0,[r4,#0]            ;160
0000d2  f1a00a37          SUB      r10,r0,#0x37          ;160
                  |L8.214|
0000d6  4631              MOV      r1,r6                 ;161
0000d8  4648              MOV      r0,r9                 ;161
0000da  f7fffffe          BL       usmart_pow
0000de  6839              LDR      r1,[r7,#0]            ;161
0000e0  fb0a1000          MLA      r0,r10,r0,r1          ;161
0000e4  6038              STR      r0,[r7,#0]            ;161
0000e6  1c64              ADDS     r4,r4,#1              ;162
0000e8  7820              LDRB     r0,[r4,#0]            ;163
0000ea  b900              CBNZ     r0,|L8.238|
0000ec  e000              B        |L8.240|
                  |L8.238|
0000ee  e7e2              B        |L8.182|
                  |L8.240|
0000f0  bf00              NOP                            ;163
0000f2  f1bb0f02          CMP      r11,#2                ;165
0000f6  d104              BNE      |L8.258|
0000f8  6838              LDR      r0,[r7,#0]            ;167
0000fa  f1c00800          RSB      r8,r0,#0              ;167
0000fe  f8c78000          STR      r8,[r7,#0]            ;168
                  |L8.258|
000102  2000              MOVS     r0,#0                 ;170
000104  e7ba              B        |L8.124|
;;;172    //得到指令名
                          ENDP


                          AREA ||i.usmart_strcmp||, CODE, READONLY, ALIGN=1

                  usmart_strcmp PROC
;;;70     //返回值:0，相等;1，不相等;
;;;71     u8 usmart_strcmp(u8 *str1,u8 *str2)
000000  4602              MOV      r2,r0
;;;72     {
;;;73     	while(1)
000002  e00a              B        |L9.26|
                  |L9.4|
;;;74     	{
;;;75     		if(*str1!=*str2)return 1;//不相等
000004  7810              LDRB     r0,[r2,#0]
000006  780b              LDRB     r3,[r1,#0]
000008  4298              CMP      r0,r3
00000a  d001              BEQ      |L9.16|
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;76     		if(*str1=='\0')break;//对比完成了.
;;;77     		str1++;
;;;78     		str2++;
;;;79     	}
;;;80     	return 0;//两个字符串相等
;;;81     }
00000e  4770              BX       lr
                  |L9.16|
000010  7810              LDRB     r0,[r2,#0]            ;76
000012  b900              CBNZ     r0,|L9.22|
000014  e002              B        |L9.28|
                  |L9.22|
000016  1c52              ADDS     r2,r2,#1              ;77
000018  1c49              ADDS     r1,r1,#1              ;78
                  |L9.26|
00001a  e7f3              B        |L9.4|
                  |L9.28|
00001c  bf00              NOP                            ;76
00001e  2000              MOVS     r0,#0                 ;80
000020  e7f5              B        |L9.14|
;;;82     //把str1的内容copy到str2
                          ENDP


                          AREA ||i.usmart_strcopy||, CODE, READONLY, ALIGN=1

                  usmart_strcopy PROC
;;;84     //*str2:字符串2指针			   
;;;85     void usmart_strcopy(u8*str1,u8 *str2)
000000  e006              B        |L10.16|
                  |L10.2|
;;;86     {
;;;87     	while(1)
;;;88     	{										   
;;;89     		*str2=*str1;	//拷贝
000002  7802              LDRB     r2,[r0,#0]
000004  700a              STRB     r2,[r1,#0]
;;;90     		if(*str1=='\0')break;//拷贝完成了.
000006  7802              LDRB     r2,[r0,#0]
000008  b902              CBNZ     r2,|L10.12|
00000a  e002              B        |L10.18|
                  |L10.12|
;;;91     		str1++;
00000c  1c40              ADDS     r0,r0,#1
;;;92     		str2++;
00000e  1c49              ADDS     r1,r1,#1
                  |L10.16|
000010  e7f7              B        |L10.2|
                  |L10.18|
000012  bf00              NOP                            ;90
;;;93     	}
;;;94     }
000014  4770              BX       lr
;;;95     //得到字符串的长度(字节)
                          ENDP


                          AREA ||i.usmart_strlen||, CODE, READONLY, ALIGN=1

                  usmart_strlen PROC
;;;97     //返回值:字符串的长度		   
;;;98     u8 usmart_strlen(u8*str)
000000  4601              MOV      r1,r0
;;;99     {
;;;100    	u8 len=0;
000002  2000              MOVS     r0,#0
;;;101    	while(1)
000004  e005              B        |L11.18|
                  |L11.6|
;;;102    	{							 
;;;103    		if(*str=='\0')break;//拷贝完成了.
000006  780a              LDRB     r2,[r1,#0]
000008  b902              CBNZ     r2,|L11.12|
00000a  e003              B        |L11.20|
                  |L11.12|
;;;104    		len++;
00000c  1c42              ADDS     r2,r0,#1
00000e  b2d0              UXTB     r0,r2
;;;105    		str++;
000010  1c49              ADDS     r1,r1,#1
                  |L11.18|
000012  e7f8              B        |L11.6|
                  |L11.20|
000014  bf00              NOP                            ;103
;;;106    	}
;;;107    	return len;
;;;108    }
000016  4770              BX       lr
;;;109    //m^n函数
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\USMART\\usmart_str.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_usmart_str_c_f7d9c3df____REV16|
#line 388 "..\\CORE\\cmsis_armcc.h"
|__asm___12_usmart_str_c_f7d9c3df____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_usmart_str_c_f7d9c3df____REVSH|
#line 402
|__asm___12_usmart_str_c_f7d9c3df____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_usmart_str_c_f7d9c3df____RRX|
#line 587
|__asm___12_usmart_str_c_f7d9c3df____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
